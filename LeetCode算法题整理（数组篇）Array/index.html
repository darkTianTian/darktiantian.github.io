<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="LeetCode,Python,Algorithm,Array," />








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.2" />






<meta name="description" content="26. Remove Duplicates from Sorted Array删除排序数组中重复的元素, 在原数组上操作，返回一个长度，标识前n个元素为目标数组。原题">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode算法题整理（数组篇）Array">
<meta property="og:url" content="http://darktiantian.github.io.git/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%95%B0%E7%BB%84%E7%AF%87%EF%BC%89Array/index.html">
<meta property="og:site_name" content="Xiaoliji&#39;s Blog">
<meta property="og:description" content="26. Remove Duplicates from Sorted Array删除排序数组中重复的元素, 在原数组上操作，返回一个长度，标识前n个元素为目标数组。原题">
<meta property="og:image" content="http://darktiantian.github.io.git/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%95%B0%E7%BB%84%E7%AF%87%EF%BC%89Array/interval1.png">
<meta property="og:image" content="http://darktiantian.github.io.git/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%95%B0%E7%BB%84%E7%AF%87%EF%BC%89Array/rotate_img.png">
<meta property="og:image" content="http://darktiantian.github.io.git/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%95%B0%E7%BB%84%E7%AF%87%EF%BC%89Array/rainwatertrap.png">
<meta property="article:published_time" content="2018-08-12T09:22:00.000Z">
<meta property="article:modified_time" content="2020-10-29T17:25:01.102Z">
<meta property="article:author" content="xiaoliji">
<meta property="article:tag" content="LeetCode">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="Algorithm">
<meta property="article:tag" content="Array">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://darktiantian.github.io.git/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%95%B0%E7%BB%84%E7%AF%87%EF%BC%89Array/interval1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://darktiantian.github.io.git/LeetCode算法题整理（数组篇）Array/"/>





  <title>LeetCode算法题整理（数组篇）Array | Xiaoliji's Blog</title>
  














<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <a href="https://github.com/darkTianTian" target="_blank" rel="noopener" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Xiaoliji's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">小里脊的个人博客</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://darktiantian.github.io.git/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%95%B0%E7%BB%84%E7%AF%87%EF%BC%89Array/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaoliji">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xiaoliji's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">LeetCode算法题整理（数组篇）Array</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-12T17:22:00+08:00">
                2018-08-12
              </time>
            

            
              <span class="post-updated">
                &nbsp; | &nbsp; Updated on
                <time itemprop="dateUpdated" datetime="2020-10-30T01:25:01+08:00" content="2020-10-30">
                  2020-10-30
                </time>
              </span>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%95%B0%E7%BB%84%E7%AF%87%EF%BC%89Array/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="LeetCode算法题整理（数组篇）Array/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%95%B0%E7%BB%84%E7%AF%87%EF%BC%89Array/" class="leancloud_visitors" data-flag-title="LeetCode算法题整理（数组篇）Array">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="26-Remove-Duplicates-from-Sorted-Array"><a href="#26-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="26. Remove Duplicates from Sorted Array"></a>26. Remove Duplicates from Sorted Array</h3><h4 id="删除排序数组中重复的元素-在原数组上操作，返回一个长度，标识前n个元素为目标数组。原题"><a href="#删除排序数组中重复的元素-在原数组上操作，返回一个长度，标识前n个元素为目标数组。原题" class="headerlink" title="删除排序数组中重复的元素, 在原数组上操作，返回一个长度，标识前n个元素为目标数组。原题"></a>删除排序数组中重复的元素, 在原数组上操作，返回一个长度，标识前n个元素为目标数组。<a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/" target="_blank" rel="noopener">原题</a></h4><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given nums &#x3D; [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">Your function should return length &#x3D; 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&#39;t matter what values are set beyond the returned length.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_duplicates</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    index = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> nums[i] != nums[i+<span class="number">1</span>]:</span><br><span class="line">            nums[index] = nums[i+<span class="number">1</span>]</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> index</span><br></pre></td></tr></table></figure>
<h3 id="80-Remove-Duplicates-from-Sorted-Array-II"><a href="#80-Remove-Duplicates-from-Sorted-Array-II" class="headerlink" title="80. Remove Duplicates from Sorted Array II"></a>80. Remove Duplicates from Sorted Array II</h3><h4 id="和上题一样，但是可以允许重复两次。原题"><a href="#和上题一样，但是可以允许重复两次。原题" class="headerlink" title="和上题一样，但是可以允许重复两次。原题"></a>和上题一样，但是可以允许重复两次。<a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/" target="_blank" rel="noopener">原题</a></h4><p>方法一：双指针调了半天。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    left = right = cnt = <span class="number">0</span></span><br><span class="line">    last_left = <span class="literal">None</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">while</span> right &lt; n:</span><br><span class="line">        <span class="keyword">while</span> right&lt;n <span class="keyword">and</span> nums[right]==last_left <span class="keyword">and</span> cnt:</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> right &gt;= n: <span class="keyword">break</span></span><br><span class="line">        nums[left] = nums[right]</span><br><span class="line">        cnt = last_left==nums[left]</span><br><span class="line">        last_left = nums[left]</span><br><span class="line">        left += <span class="number">1</span></span><br><span class="line">        right += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：stefan的方法原来这么简单。i作为待插入的索引位置，用n和他前两位比较，如果一样的话，保持插入位置不动，而nums[i-2]是不变的，一直可以用来作比较。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> i&lt;<span class="number">2</span> <span class="keyword">or</span> n&gt;nums[i<span class="number">-2</span>]:</span><br><span class="line">            nums[i] = n</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>
<h3 id="66-Plus-One"><a href="#66-Plus-One" class="headerlink" title="66. Plus One"></a>66. Plus One</h3><h4 id="给数组加一，元素为非负整数，不以0开头，每个元素只有一个数字。原题"><a href="#给数组加一，元素为非负整数，不以0开头，每个元素只有一个数字。原题" class="headerlink" title="给数组加一，元素为非负整数，不以0开头，每个元素只有一个数字。原题"></a>给数组加一，元素为非负整数，不以0开头，每个元素只有一个数字。<a href="https://leetcode.com/problems/plus-one/description/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,3,2,1]</span><br><span class="line">Output: [4,3,2,2]</span><br><span class="line">Explanation: The array represents the integer 4321.</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法一：转成字符串再转成数字</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plusOne</span><span class="params">(self, digits: <span class="string">'List[int]'</span>)</span> -&gt; 'List[int]':</span></span><br><span class="line">    num = int(<span class="string">''</span>.join(map(str, digits)))</span><br><span class="line">    <span class="keyword">return</span> [int(d) <span class="keyword">for</span> d <span class="keyword">in</span> str(num + <span class="number">1</span>)]</span><br></pre></td></tr></table></figure>
<p>方法二：Math 进位</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plus_one</span><span class="params">(digits)</span>:</span></span><br><span class="line">    d = digits[:]  </span><br><span class="line">    plused = []</span><br><span class="line">    carry = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> d <span class="keyword">or</span> carry:</span><br><span class="line">        <span class="keyword">if</span> d:</span><br><span class="line">            v = d.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            v = <span class="number">0</span></span><br><span class="line">        carry, val = divmod(carry+v, <span class="number">10</span>)</span><br><span class="line">        plused.append(val)</span><br><span class="line">    <span class="keyword">return</span> plused[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法三：数组进位。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plusOne</span><span class="params">(self, digits: <span class="string">'List[int]'</span>)</span> -&gt; 'List[int]':</span></span><br><span class="line">    d = digits[:]</span><br><span class="line">    d[<span class="number">-1</span>] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(d)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        carry, d[i] = divmod(d[i], <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">if</span> i: d[i<span class="number">-1</span>] += carry</span><br><span class="line">    <span class="keyword">if</span> carry:</span><br><span class="line">        d.insert(<span class="number">0</span>, carry)</span><br><span class="line">    <span class="keyword">return</span> d</span><br></pre></td></tr></table></figure>
<h3 id="989-Add-to-Array-Form-of-Integer"><a href="#989-Add-to-Array-Form-of-Integer" class="headerlink" title="989. Add to Array-Form of Integer"></a>989. Add to Array-Form of Integer</h3><h4 id="和66题很相似。不同的是这个K会大于10，以至于余数也会大于10。原题"><a href="#和66题很相似。不同的是这个K会大于10，以至于余数也会大于10。原题" class="headerlink" title="和66题很相似。不同的是这个K会大于10，以至于余数也会大于10。原题"></a>和66题很相似。不同的是这个K会大于10，以至于余数也会大于10。<a href="https://leetcode.com/contest/weekly-contest-123/problems/add-to-array-form-of-integer/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A &#x3D; [2,7,4], K &#x3D; 181</span><br><span class="line">Output: [4,5,5]</span><br><span class="line">Explanation: 274 + 181 &#x3D; 455</span><br></pre></td></tr></table></figure>
<p>方法一：竞赛写法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addToArrayForm</span><span class="params">(self, A: <span class="string">'List[int]'</span>, K: <span class="string">'int'</span>)</span> -&gt; 'List[int]':</span></span><br><span class="line">    a = int(<span class="string">''</span>.join(map(str, A)))</span><br><span class="line">    <span class="keyword">return</span> [int(c) <span class="keyword">for</span> c <span class="keyword">in</span> str(a + K)]</span><br></pre></td></tr></table></figure>
<p>方法二：原理实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addToArrayForm</span><span class="params">(self, A: <span class="string">'List[int]'</span>, K: <span class="string">'int'</span>)</span> -&gt; 'List[int]':</span></span><br><span class="line">    A[<span class="number">-1</span>] += K</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        carry, A[i] = divmod(A[i], <span class="number">10</span>) </span><br><span class="line">        <span class="keyword">if</span> i: A[i<span class="number">-1</span>] += carry</span><br><span class="line">    <span class="keyword">if</span> carry:</span><br><span class="line">        A = list(map(int, str(carry))) + A</span><br><span class="line">    <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure>
<h3 id="88-Merge-Sorted-Array"><a href="#88-Merge-Sorted-Array" class="headerlink" title="88. Merge Sorted Array"></a>88. Merge Sorted Array</h3><h4 id="合并两个有序数组，在nums1上修改。原题"><a href="#合并两个有序数组，在nums1上修改。原题" class="headerlink" title="合并两个有序数组，在nums1上修改。原题"></a>合并两个有序数组，在nums1上修改。<a href="https://leetcode.com/problems/merge-sorted-array/description/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3</span><br><span class="line">nums2 &#x3D; [2,5,6],       n &#x3D; 3</span><br><span class="line"></span><br><span class="line">Output: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1, m, nums2, n)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> m&gt;<span class="number">0</span> <span class="keyword">and</span> n&gt;<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> nums1[m<span class="number">-1</span>] &gt; nums2[n<span class="number">-1</span>]:</span><br><span class="line">            nums1[n+m<span class="number">-1</span>] = nums1[m<span class="number">-1</span>]</span><br><span class="line">            m -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            nums1[n+m<span class="number">-1</span>] = nums2[n<span class="number">-1</span>]</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        nums1[:n] = nums2[:n]</span><br></pre></td></tr></table></figure>
<h3 id="118-Pascal’s-Triangle"><a href="#118-Pascal’s-Triangle" class="headerlink" title="118. Pascal’s Triangle"></a>118. Pascal’s Triangle</h3><h4 id="杨辉三角。原题"><a href="#杨辉三角。原题" class="headerlink" title="杨辉三角。原题"></a>杨辉三角。<a href="https://leetcode.com/problems/pascals-triangle/description/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">    [1,1],</span><br><span class="line">   [1,2,1],</span><br><span class="line">  [1,3,3,1],</span><br><span class="line"> [1,4,6,4,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法一: 错位相加。这里也可以使用zip，值得注意的是，res需要➕一个二维数组，而不是一维。结尾的切片是为了0的情况。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self, numRows: <span class="string">'int'</span>)</span> -&gt; 'List[List[int]]':</span></span><br><span class="line">    ans = [[<span class="number">1</span>]]</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(numRows<span class="number">-1</span>):</span><br><span class="line">        ans += [[a+b <span class="keyword">for</span> a, b <span class="keyword">in</span> zip([<span class="number">0</span>]+ans[<span class="number">-1</span>], ans[<span class="number">-1</span>]+[<span class="number">0</span>])]]</span><br><span class="line">        <span class="comment"># ans.append(list(map(lambda x, y: x + y, [0]+ans[-1], ans[-1]+[0])))</span></span><br><span class="line">    <span class="keyword">return</span> ans[:numRows]</span><br></pre></td></tr></table></figure>
<p>方法二</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(num)</span>:</span></span><br><span class="line">    triangle = []</span><br><span class="line">    inner = [<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(num):</span><br><span class="line">        triangle.append(list(inner))</span><br><span class="line">        inner.append(<span class="number">0</span>)</span><br><span class="line">        right = [inner[i]+inner[i+<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(inner)<span class="number">-1</span>)]</span><br><span class="line">        inner = [<span class="number">1</span>] + right</span><br><span class="line">    <span class="keyword">return</span> triangle</span><br></pre></td></tr></table></figure>
<h3 id="119-Pascal’s-Triangle-II"><a href="#119-Pascal’s-Triangle-II" class="headerlink" title="119.Pascal’s Triangle II"></a>119.Pascal’s Triangle II</h3><h4 id="杨辉三角，只打印一层。原题"><a href="#杨辉三角，只打印一层。原题" class="headerlink" title="杨辉三角，只打印一层。原题"></a>杨辉三角，只打印一层。<a href="https://leetcode.com/problems/pascals-triangle-ii/description/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getRow</span><span class="params">(self, rowIndex: <span class="string">'int'</span>)</span> -&gt; 'List[int]':</span></span><br><span class="line">    ans = [<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(rowIndex):</span><br><span class="line">        ans = [a+b <span class="keyword">for</span> a, b <span class="keyword">in</span> zip([<span class="number">0</span>]+ans, ans+[<span class="number">0</span>])]</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="169-Majority-Element"><a href="#169-Majority-Element" class="headerlink" title="169. Majority Element"></a>169. Majority Element</h3><h4 id="找出数组中出现次数超过一半的元素。原题"><a href="#找出数组中出现次数超过一半的元素。原题" class="headerlink" title="找出数组中出现次数超过一半的元素。原题"></a>找出数组中出现次数超过一半的元素。<a href="https://leetcode.com/problems/majority-element/description/" target="_blank" rel="noopener">原题</a></h4><p>方法一：排序. Time-O(nlogn), Space-O(n)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majority_element</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sorted(nums)[len(nums)//<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p>方法二：Counter Time-O(n), Space-O(n)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majority_element</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">    c = Counter(nums)</span><br><span class="line">    <span class="comment"># return max(c.keys(), key=c.get)</span></span><br><span class="line">    <span class="keyword">return</span> c.most_common(<span class="number">1</span>)[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法三：Boyer-Moore Voting Algorithm. 书中的算法说的就是这个，这里附上自己的见解。</font>

<a href="/%E6%B3%A2%E4%B9%89%E5%B0%94%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95%EF%BC%88Boyer-Moore-Voting-Algorithm%EF%BC%89/" title="波义尔摩尔投票算法">波义尔摩尔投票算法</a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    candidate = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">            candidate = num</span><br><span class="line">        count += (<span class="number">1</span> <span class="keyword">if</span> num == candidate <span class="keyword">else</span> <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> candidate</span><br></pre></td></tr></table></figure>
<h3 id="229-Majority-Element-II"><a href="#229-Majority-Element-II" class="headerlink" title="229. Majority Element II"></a>229. Majority Element II</h3><h4 id="找到数组中出现超过n-3次的元素。原题"><a href="#找到数组中出现超过n-3次的元素。原题" class="headerlink" title="找到数组中出现超过n/3次的元素。原题"></a>找到数组中出现超过n/3次的元素。<a href="https://leetcode.com/problems/majority-element-ii/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,1,3,3,2,2,2]</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure>
<p>方法一：波义尔摩尔投票法同样可用，但是我一开始想一次遍历求，发现好像不可以，最后都要遍历一次判断是否满足条件。循环中是elif，两个候选人开始设为不同的值以用来区分。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    count1, count2, candidate1, candidate2 = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> n == candidate1:</span><br><span class="line">            count1 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> n == candidate2:</span><br><span class="line">            count2 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> count1 == <span class="number">0</span>:</span><br><span class="line">            candidate1, count1 = n, <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> count2 == <span class="number">0</span>:</span><br><span class="line">            candidate2, count2 = n, <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count1, count2 = count1 - <span class="number">1</span>, count2 - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> [n <span class="keyword">for</span> n <span class="keyword">in</span> (candidate1, candidate2)</span><br><span class="line">            <span class="keyword">if</span> nums.count(n) &gt; len(nums) // <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>方法二：Counter. by Stefan.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    ctr = Counter()</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">        ctr[n] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> len(ctr)==<span class="number">3</span>:</span><br><span class="line">            ctr -= Counter(set(ctr))  <span class="comment"># 均-1</span></span><br><span class="line">    <span class="keyword">return</span> [n <span class="keyword">for</span> n <span class="keyword">in</span> ctr <span class="keyword">if</span> nums.count(n) &gt; len(nums)//<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<h3 id="189-Rotate-Array"><a href="#189-Rotate-Array" class="headerlink" title="189. Rotate Array"></a>189. Rotate Array</h3><h4 id="旋转数组。进阶：使用O-1-空间实现。原题"><a href="#旋转数组。进阶：使用O-1-空间实现。原题" class="headerlink" title="旋转数组。进阶：使用O(1)空间实现。原题"></a>旋转数组。进阶：使用O(1)空间实现。<a href="https://leetcode.com/problems/rotate-array/description/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5,6,7] and k &#x3D; 3</span><br><span class="line">Output: [5,6,7,1,2,3,4]</span><br><span class="line">Explanation:</span><br><span class="line">rotate 1 steps to the right: [7,1,2,3,4,5,6]</span><br><span class="line">rotate 2 steps to the right: [6,7,1,2,3,4,5]</span><br><span class="line">rotate 3 steps to the right: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="4">方法一：slicing。使用生成器而不是单纯的切片可以使复杂度降到常数。这里也是抱着试试看的态度，发现可以直接将chain的生成器对象赋值给nums。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    k = k % n</span><br><span class="line">    nums[:] = chain(islice(nums, n-k, n), islice(nums, n-k))</span><br></pre></td></tr></table></figure>
<p>方法二：reverse的方法很新颖，不过要遍历两次数组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(ary, lo, hi)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi: </span><br><span class="line">            ary[lo], ary[hi] = ary[hi], ary[lo]</span><br><span class="line">            lo += <span class="number">1</span></span><br><span class="line">            hi -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    N = len(nums)</span><br><span class="line">    k = k % N</span><br><span class="line">    reverse(nums, <span class="number">0</span>, N<span class="number">-1</span>)</span><br><span class="line">    reverse(nums, <span class="number">0</span>, k<span class="number">-1</span>)</span><br><span class="line">    reverse(nums, k, N<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="4">方法三: 想这种要求常数空间复杂度的并且允许修改原数组的，可以使用这种思想，<strong>把每个数放到应该放到的位置。</strong></font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    N = len(nums)</span><br><span class="line">    k %= N</span><br><span class="line"></span><br><span class="line">    start = count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> count &lt; N:</span><br><span class="line">        cur, prev = start, nums[start]</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            cur = (cur + k) % N</span><br><span class="line">            nums[cur], prev = prev, nums[cur]</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cur == start: <span class="keyword">break</span></span><br><span class="line">        start += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="217-Contains-Duplicate"><a href="#217-Contains-Duplicate" class="headerlink" title="217. Contains Duplicate"></a>217. Contains Duplicate</h3><h4 id="数组中是否包含重复元素。原题"><a href="#数组中是否包含重复元素。原题" class="headerlink" title="数组中是否包含重复元素。原题"></a>数组中是否包含重复元素。<a href="https://leetcode.com/problems/contains-duplicate/description/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,1]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p>方法一：set</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">contains_duplicate</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> len(set(nums)) &lt; len(nums)</span><br></pre></td></tr></table></figure>
<p>方法二：hash</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span><span class="params">(self, nums: <span class="string">'List[int]'</span>)</span> -&gt; 'bool':</span></span><br><span class="line">    seen = set()</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> num <span class="keyword">in</span> seen:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            seen.add(num)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="219-Contains-Duplicate-II"><a href="#219-Contains-Duplicate-II" class="headerlink" title="219. Contains Duplicate II"></a>219. Contains Duplicate II</h3><h4 id="数组中是否包含重复元素，且元素下标差小于等于k。原题"><a href="#数组中是否包含重复元素，且元素下标差小于等于k。原题" class="headerlink" title="数组中是否包含重复元素，且元素下标差小于等于k。原题"></a>数组中是否包含重复元素，且元素下标差小于等于k。<a href="https://leetcode.com/problems/contains-duplicate-ii/description/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,1], k &#x3D; 3</span><br><span class="line">Output: true</span><br><span class="line">Input: nums &#x3D; [1,0,1,1], k &#x3D; 1</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p>思路：开始想用set作切片来判断，同上题方法一，但是效率太低。故使用字典。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    seen = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">        <span class="keyword">if</span> num <span class="keyword">in</span> seen:</span><br><span class="line">            <span class="keyword">if</span> i-seen[num] &lt;= k:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        seen[num] = i</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="220-Contains-Duplicate-III"><a href="#220-Contains-Duplicate-III" class="headerlink" title="220. Contains Duplicate III"></a>220. Contains Duplicate III</h3><h4 id="是否存在索引差k范围内的绝对值不大于t的两个值。原题"><a href="#是否存在索引差k范围内的绝对值不大于t的两个值。原题" class="headerlink" title="是否存在索引差k范围内的绝对值不大于t的两个值。原题"></a>是否存在索引差k范围内的绝对值不大于t的两个值。<a href="https://leetcode.com/problems/contains-duplicate-iii/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,1], k &#x3D; 3, t &#x3D; 0</span><br><span class="line">Output: true</span><br><span class="line">Input: nums &#x3D; [1,5,9,1,5,9], k &#x3D; 2, t &#x3D; 3</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p>方法一：实际上是桶排序的原理，每个桶的size为t。两个差值为t的的数，只可能出现在同一个桶或者两边的桶中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(self, nums: List[int], k: int, t: int)</span> -&gt; bool:</span></span><br><span class="line">    <span class="keyword">if</span> k &lt; <span class="number">1</span> <span class="keyword">or</span> t &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    dic = collections.OrderedDict()</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">        key = n <span class="keyword">if</span> <span class="keyword">not</span> t <span class="keyword">else</span> n // t</span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> (dic.get(key - <span class="number">1</span>), dic.get(key), dic.get(key + <span class="number">1</span>)):</span><br><span class="line">            <span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> abs(n - m) &lt;= t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> len(dic) == k:</span><br><span class="line">            dic.popitem(<span class="literal">False</span>)</span><br><span class="line">        dic[key] = n</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="283-Move-Zeroes"><a href="#283-Move-Zeroes" class="headerlink" title="283. Move Zeroes"></a>283. Move Zeroes</h3><h4 id="将数组0元素移动到末尾，保证其他元素顺序。原题"><a href="#将数组0元素移动到末尾，保证其他元素顺序。原题" class="headerlink" title="将数组0元素移动到末尾，保证其他元素顺序。原题"></a>将数组0元素移动到末尾，保证其他元素顺序。<a href="https://leetcode.com/problems/move-zeroes/description/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,0,3,12]</span><br><span class="line">Output: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>
<p>方法一：two pointers</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move_zero</span><span class="params">(nums)</span>:</span></span><br><span class="line">    l, r = <span class="number">0</span>, len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        <span class="keyword">if</span> nums[l] == <span class="number">0</span>:</span><br><span class="line">            nums[:] = nums[:l] + nums[l+<span class="number">1</span>:] + [<span class="number">0</span>]</span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>方法二： slicing</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move_zero</span><span class="params">(nums)</span>:</span></span><br><span class="line">    nums[:] = [x <span class="keyword">for</span> x <span class="keyword">in</span> nums <span class="keyword">if</span> x != <span class="number">0</span>] + [x <span class="keyword">for</span> x <span class="keyword">in</span> nums <span class="keyword">if</span> x == <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法三：最后0的位置，感觉像冒泡。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">moveZeroes</span><span class="params">(self, nums: <span class="string">'List[int]'</span>)</span> -&gt; '<span class="keyword">None</span>':</span></span><br><span class="line">    p = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">        <span class="keyword">if</span> num != <span class="number">0</span>:</span><br><span class="line">            nums[p], nums[i] = nums[i], nums[p]</span><br><span class="line">            p += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>方法四：排序。时间复杂度略高。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">moveZeroes</span><span class="params">(self, nums: <span class="string">'List[int]'</span>)</span> -&gt; '<span class="keyword">None</span>':</span></span><br><span class="line">    nums.sort(key=<span class="keyword">lambda</span> x: <span class="number">1</span> <span class="keyword">if</span> x==<span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="54-Spiral-Matrix"><a href="#54-Spiral-Matrix" class="headerlink" title="54. Spiral Matrix"></a>54. Spiral Matrix</h3><h4 id="螺旋矩阵，顺时针打印矩阵。原题"><a href="#螺旋矩阵，顺时针打印矩阵。原题" class="headerlink" title="螺旋矩阵，顺时针打印矩阵。原题"></a>螺旋矩阵，顺时针打印矩阵。<a href="https://leetcode.com/problems/spiral-matrix/description/" target="_blank" rel="noopener">原题</a></h4><p>这里注意一点<code>matrix.pop(0)</code>需要转成list，因为zip函数中的每个元素是一个tuple，如果不转变成了一个<code>tuple+list</code>，会抛出异常。</p>
<p>ps: 此题解法为LeetCode一位大神，经常能看到此人的答案，不过这个是我认为最pythonic的一个，没有为了强行one-line而one-line。brilliant!</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeError: can only concatenate tuple (not &quot;list&quot;) to tuple</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> matrix <span class="keyword">and</span> list(matrix.pop(<span class="number">0</span>))+self.spiralOrder(list(zip(*matrix))[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
<p>方法二：迭代写法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> matrix: <span class="keyword">return</span> []</span><br><span class="line">    M, N = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">    ans = []</span><br><span class="line">    seen = [[<span class="literal">False</span>]*N <span class="keyword">for</span> _ <span class="keyword">in</span> range(M)]</span><br><span class="line">    x, y, di, dj = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> len(ans) &lt; M*N:</span><br><span class="line">        seen[x][y] = <span class="literal">True</span></span><br><span class="line">        ans.append(matrix[x][y])        </span><br><span class="line">        nx, ny = x+di, y+dj</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0</span>&lt;=nx&lt;M <span class="keyword">and</span> <span class="number">0</span>&lt;=ny&lt;N <span class="keyword">and</span> <span class="keyword">not</span> seen[nx][ny]):</span><br><span class="line">            di, dj = dj, -di</span><br><span class="line">        x, y = x+di, y+dj</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>此题有个变形，如果逆时针该如何打印。这样的话情况稍微复杂一些。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">anti_clock_wise</span><span class="params">(self, matrix)</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="title">not</span> <span class="title">matrix</span>:</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    clock_wise = list(zip(*(matrix[::<span class="number">-1</span>])))</span><br><span class="line">    a = list(clock_wise.pop(<span class="number">0</span>))[::<span class="number">-1</span>]</span><br><span class="line">    b = self.anti_clock_wise(clock_wise)</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure>
<h3 id="59-Spiral-Matrix-II"><a href="#59-Spiral-Matrix-II" class="headerlink" title="59. Spiral Matrix II"></a>59. Spiral Matrix II</h3><h4 id="按照顺时针的顺序生成一个矩阵。原题"><a href="#按照顺时针的顺序生成一个矩阵。原题" class="headerlink" title="按照顺时针的顺序生成一个矩阵。原题"></a>按照顺时针的顺序生成一个矩阵。<a href="https://leetcode.com/problems/spiral-matrix-ii/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 8, 9, 4 ],</span><br><span class="line"> [ 7, 6, 5 ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>方法一：自己的方法。使用了一个控制方向，如果超范围或者有值就换方向。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateMatrix</span><span class="params">(self, n: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">    ans = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    op = itertools.cycle([(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">-1</span>), (<span class="number">-1</span>, <span class="number">0</span>)])</span><br><span class="line">    d = next(op)</span><br><span class="line">    x, y = (<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, n**<span class="number">2</span>+<span class="number">1</span>):</span><br><span class="line">        ans[x][y] = k</span><br><span class="line">        i, j = x+d[<span class="number">0</span>], y+d[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span>&lt;=i&lt;n <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">0</span>&lt;=j&lt;n <span class="keyword">or</span> ans[i][j]:</span><br><span class="line">            d = next(op)</span><br><span class="line">            x, y = x+d[<span class="number">0</span>], y+d[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x, y = i, j</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><br>方法二：stefan的旋转法，我往这边想了，zip也想到了，没想到的是，从里往外遍历，还有一点是根据A的长度确定起始点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">||  &#x3D;&gt;  |9|  &#x3D;&gt;  |8|      |6 7|      |4 5|      |1 2 3|</span><br><span class="line">                 |9|  &#x3D;&gt;  |9 8|  &#x3D;&gt;  |9 6|  &#x3D;&gt;  |8 9 4|</span><br><span class="line">                                     |8 7|      |7 6 5|</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateMatrix</span><span class="params">(self, n: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">    A, lo = [], n**<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> lo &gt; <span class="number">1</span>:</span><br><span class="line">        lo, hi = lo - len(A), lo</span><br><span class="line">        A = [range(lo, hi)] + list(zip(*A[::<span class="number">-1</span>]))</span><br><span class="line">    <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure>
<h3 id="885-Spiral-Matrix-III"><a href="#885-Spiral-Matrix-III" class="headerlink" title="885. Spiral Matrix III"></a>885. Spiral Matrix III</h3><h4 id="从二维数组中的某一个点开始顺时针旋转输出所有的坐标。原题"><a href="#从二维数组中的某一个点开始顺时针旋转输出所有的坐标。原题" class="headerlink" title="从二维数组中的某一个点开始顺时针旋转输出所有的坐标。原题"></a>从二维数组中的某一个点开始顺时针旋转输出所有的坐标。<a href="https://leetcode.com/problems/spiral-matrix-iii/" target="_blank" rel="noopener">原题</a></h4><font color="#32CD32" size="3">方法一：还是通过生成器控制方向，当处于水平位置时步数增加1。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spiralMatrixIII</span><span class="params">(self, R: int, C: int, r0: int, c0: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">    direction = itertools.cycle([(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">-1</span>), (<span class="number">-1</span>, <span class="number">0</span>)])</span><br><span class="line">    ans = [(r0, c0)]</span><br><span class="line">    step = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> len(ans) &lt; R*C:</span><br><span class="line">        di, dj = next(direction)        </span><br><span class="line">        <span class="keyword">if</span> di==<span class="number">0</span>:</span><br><span class="line">            step += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(step):</span><br><span class="line">            r0 += di</span><br><span class="line">            c0 += dj</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span>&lt;=r0&lt;R <span class="keyword">and</span> <span class="number">0</span>&lt;=c0&lt;C:</span><br><span class="line">                ans.append((r0, c0))</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：Lee的方法。使用了<code>di, dj = dj, -di</code>刚好是这个右转的方向。然后用一个n来计算步数。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spiralMatrixIII</span><span class="params">(self, R: int, C: int, r0: int, c0: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">    ans = []</span><br><span class="line">    di, dj, step = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> len(ans) &lt; R*C:</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> range(step//<span class="number">2</span>+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span>&lt;=r0&lt;R <span class="keyword">and</span> <span class="number">0</span>&lt;=c0&lt;C:</span><br><span class="line">                ans.append((r0, c0))</span><br><span class="line">            r0, c0 = r0+di, c0+dj</span><br><span class="line">        di, dj, step = dj, -di, step+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>方法三：Lee的几何方法。根据到目标点的距离大小排序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spiralMatrixIII</span><span class="params">(self, R, C, r, c)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">key</span><span class="params">(<span class="params">(x, y)</span>)</span>:</span></span><br><span class="line">        x, y = x - r, y - c</span><br><span class="line">        <span class="keyword">return</span> (max(abs(x), abs(y)), -((math.atan2(<span class="number">-1</span>, <span class="number">1</span>) - math.atan2(x, y)) % (math.pi * <span class="number">2</span>)))</span><br><span class="line">    <span class="keyword">return</span> sorted([(i, j) <span class="keyword">for</span> i <span class="keyword">in</span> xrange(R) <span class="keyword">for</span> j <span class="keyword">in</span> xrange(C)], key=key)</span><br></pre></td></tr></table></figure>
<h3 id="53-Maximum-Subarray"><a href="#53-Maximum-Subarray" class="headerlink" title="53. Maximum Subarray"></a>53. Maximum Subarray</h3><h4 id="连续子数组的最大和。原题"><a href="#连续子数组的最大和。原题" class="headerlink" title="连续子数组的最大和。原题"></a>连续子数组的最大和。<a href="https://leetcode.com/problems/maximum-subarray/description/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [4,-1,2,1] has the largest sum &#x3D; 6.</span><br></pre></td></tr></table></figure>
<p>方法一：书中的思想。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    cp_nums = nums[:]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">        <span class="keyword">if</span> cp_nums[i<span class="number">-1</span>] &gt; <span class="number">0</span>:</span><br><span class="line">            cp_nums[i] += cp_nums[i<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> max(cp_nums)</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：one-liner。注意<code>accumulate</code>是把函数放到后面的。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    <span class="keyword">from</span> itertools <span class="keyword">import</span> accumulate</span><br><span class="line">    <span class="keyword">return</span> max(accumulate(nums, <span class="keyword">lambda</span> x, y: x+y <span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">else</span> y))</span><br></pre></td></tr></table></figure>
<h3 id="918-Maximum-Sum-Circular-Subarray"><a href="#918-Maximum-Sum-Circular-Subarray" class="headerlink" title="918. Maximum Sum Circular Subarray"></a>918. Maximum Sum Circular Subarray</h3><h4 id="连续数组的最大和，数组可以首位相连，但是最大长度不能超过一个数组。原题"><a href="#连续数组的最大和，数组可以首位相连，但是最大长度不能超过一个数组。原题" class="headerlink" title="连续数组的最大和，数组可以首位相连，但是最大长度不能超过一个数组。原题"></a>连续数组的最大和，数组可以首位相连，但是最大长度不能超过一个数组。<a href="https://leetcode.com/problems/maximum-sum-circular-subarray/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,-2,3,-2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Subarray [3] has maximum sum 3</span><br></pre></td></tr></table></figure>
<p>方法一：by @Lee215。看完这个解法豁然开朗，只需要同时找到一个累加和最小的子数组，再用总数减掉。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSubarraySumCircular</span><span class="params">(self, A: List[int])</span> -&gt; int:</span></span><br><span class="line">    total = cur_max = cur_min = <span class="number">0</span></span><br><span class="line">    sum_max, sum_min = float(<span class="string">'-inf'</span>), float(<span class="string">'inf'</span>)</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> A:</span><br><span class="line">        cur_max = max(cur_max+a, a)</span><br><span class="line">        sum_max = max(sum_max, cur_max)</span><br><span class="line">        cur_min = min(cur_min+a, a)</span><br><span class="line">        sum_min = min(sum_min, cur_min)</span><br><span class="line">        total += a</span><br><span class="line">    <span class="keyword">return</span> max(sum_max, total-sum_min) <span class="keyword">if</span> sum_max &gt; <span class="number">0</span> <span class="keyword">else</span> sum_max</span><br></pre></td></tr></table></figure>
<h3 id="904-Fruit-Into-Baskets"><a href="#904-Fruit-Into-Baskets" class="headerlink" title="904. Fruit Into Baskets"></a>904. Fruit Into Baskets</h3><h4 id="实际上该题抽象为求最大滑动窗口的长度，滑动窗口不同元素最多不超过两个。原题"><a href="#实际上该题抽象为求最大滑动窗口的长度，滑动窗口不同元素最多不超过两个。原题" class="headerlink" title="实际上该题抽象为求最大滑动窗口的长度，滑动窗口不同元素最多不超过两个。原题"></a>实际上该题抽象为求最大滑动窗口的长度，滑动窗口不同元素最多不超过两个。<a href="https://leetcode.com/problems/fruit-into-baskets/description/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tree &#x3D; [3,3,3,1,2,1,1,2,3,3,4]   # 5</span><br><span class="line">tree &#x3D; [1,0,1,4,1,4,1,2,3]  # 5</span><br><span class="line">tree &#x3D; [1,2,3,2,2]  # 4</span><br><span class="line">tree &#x3D; [0,1,6,6,4,4,6]  # 5</span><br></pre></td></tr></table></figure>
<p>一开始没有找到滑动窗口的左边界，老是想直接删除一个key，后来看别人代码受到启发，可以用一个内循环来解决，可以逐个删除，然后判断是否为空。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">totalFruit</span><span class="params">(self, tree)</span>:</span></span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">    basket = Counter()</span><br><span class="line">    l, res = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> range(len(tree)):</span><br><span class="line">        basket[tree[r]] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> len(basket) &gt; <span class="number">2</span>:</span><br><span class="line">            basket[tree[l]] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> basket[tree[l]] == <span class="number">0</span>:</span><br><span class="line">                basket.pop(tree[l])</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        res = max(res, r-l+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="27-Remove-Element"><a href="#27-Remove-Element" class="headerlink" title="27. Remove Element"></a>27. Remove Element</h3><h4 id="从数组中删除元素，在原数组修改，要求返回一个长度。原题"><a href="#从数组中删除元素，在原数组修改，要求返回一个长度。原题" class="headerlink" title="从数组中删除元素，在原数组修改，要求返回一个长度。原题"></a>从数组中删除元素，在原数组修改，要求返回一个长度。<a href="https://leetcode.com/problems/remove-element/description/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Given nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2,</span><br><span class="line">Your function should return length &#x3D; 5,</span><br></pre></td></tr></table></figure>
<p>方法一：前后指针，r要从<code>n</code>开始，以<code>n-1</code>作比较，这里r不是从<code>n-1</code>开始是因为<code>nums=[]</code>的情况，否则<code>l+1</code>将超出数组范围。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums, val)</span>:</span></span><br><span class="line">    l, r = <span class="number">0</span>, len(nums)</span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        <span class="keyword">if</span> nums[l] == val:</span><br><span class="line">            nums[l], nums[r<span class="number">-1</span>] = nums[r<span class="number">-1</span>], nums[l]</span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：快慢指针，几乎和283题中的方法一样。 </font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums, val)</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[j] != val:</span><br><span class="line">            nums[i] = nums[j]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>
<h3 id="349-Intersection-of-Two-Arrays"><a href="#349-Intersection-of-Two-Arrays" class="headerlink" title="349. Intersection of Two Arrays"></a>349. Intersection of Two Arrays</h3><h4 id="求两个数组的交集。返回的数组必须元素唯一，可以无序。原题"><a href="#求两个数组的交集。返回的数组必须元素唯一，可以无序。原题" class="headerlink" title="求两个数组的交集。返回的数组必须元素唯一，可以无序。原题"></a>求两个数组的交集。返回的数组必须元素唯一，可以无序。<a href="https://leetcode.com/problems/intersection-of-two-arrays/" target="_blank" rel="noopener">原题</a></h4><p>思路：一开始看到这题以为是两个链表求相交点。最后发现<code>Intersection</code>不应该理解为“十字路口”而应该是“交集”。这里翻了一下<code>discuss</code>，大部分都是使用方法一，其它方法要么太繁琐，要么效率低。值得注意的是，此题的相关话题还有一项是<code>Binary Search</code>也就是说，可能会有一个较为高效的二分搜索法的实现方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line">Input: nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]</span><br><span class="line">Output: [9,4]</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3"><strong>方法一：最快的方法。</strong></font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intersection</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> list(set(nums1) &amp; set(nums2))</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：Sort &amp; Two Pointers.</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intersection</span><span class="params">(self, nums1: <span class="string">'List[int]'</span>, nums2: <span class="string">'List[int]'</span>)</span> -&gt; 'List[int]':</span></span><br><span class="line">    nums1.sort()</span><br><span class="line">    nums2.sort()</span><br><span class="line">    i, n1 = <span class="number">0</span>, len(nums1)</span><br><span class="line">    j, n2 = <span class="number">0</span>, len(nums2)</span><br><span class="line">    ans, last = [], <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n1 <span class="keyword">and</span> j &lt; n2:</span><br><span class="line">        <span class="keyword">if</span> nums1[i] == nums2[j]:</span><br><span class="line">            <span class="keyword">if</span> nums1[i] != last:</span><br><span class="line">                ans.append(nums1[i])</span><br><span class="line">                last = nums1[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums1[i] &gt; nums2[j]:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums1[i] &lt; nums2[j]:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="350-Intersection-of-Two-Arrays-II"><a href="#350-Intersection-of-Two-Arrays-II" class="headerlink" title="350. Intersection of Two Arrays II"></a>350. Intersection of Two Arrays II</h3><h4 id="和上题不同的是要返回所有的交集元素。原题"><a href="#和上题不同的是要返回所有的交集元素。原题" class="headerlink" title="和上题不同的是要返回所有的交集元素。原题"></a>和上题不同的是要返回所有的交集元素。<a href="https://leetcode.com/problems/intersection-of-two-arrays-ii/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]</span><br><span class="line">Output: [2,2]</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3"><strong>方法一：Counter实现了&amp;操作可以直接取交集。</strong></font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intersect</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">    a, b = map(Counter, (nums1, nums2))</span><br><span class="line">    <span class="keyword">return</span> list((a &amp; b).elements())</span><br></pre></td></tr></table></figure>
<p>方法二：不使用<code>Counter</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intersect</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">    counter = defaultdict(int)</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> num1 <span class="keyword">in</span> nums1:</span><br><span class="line">        counter[num1] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> num2 <span class="keyword">in</span> nums2:</span><br><span class="line">        <span class="keyword">if</span> counter[num2] != <span class="number">0</span>:</span><br><span class="line">            res.append(num2)</span><br><span class="line">            counter[num2] -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法三：可以采用上题349的方法，只需要去掉<code>last</code>即可。</font>

<h3 id="905-Sort-Array-By-Parity"><a href="#905-Sort-Array-By-Parity" class="headerlink" title="905. Sort Array By Parity"></a>905. Sort Array By Parity</h3><h4 id="将一个数组重新排列，是偶数在前奇数在后。原题"><a href="#将一个数组重新排列，是偶数在前奇数在后。原题" class="headerlink" title="将一个数组重新排列，是偶数在前奇数在后。原题"></a>将一个数组重新排列，是偶数在前奇数在后。<a href="https://leetcode.com/problems/sort-array-by-parity/description/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,1,2,4]</span><br><span class="line">Output: [2,4,3,1]</span><br><span class="line">The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3"><strong>方法一：双指针。</strong></font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortArrayByParity</span><span class="params">(self, A)</span>:</span></span><br><span class="line">    l, r = <span class="number">0</span>, len(A)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        <span class="keyword">while</span> l&lt;r <span class="keyword">and</span> A[l]&amp;<span class="number">1</span>==<span class="number">0</span>:</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l&lt;r <span class="keyword">and</span> A[r]&amp;<span class="number">1</span>==<span class="number">1</span>:</span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">        A[l], A[r] = A[r], A[l]</span><br><span class="line">    <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure>
<p>方法二：列表生成式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortArrayByParity</span><span class="params">(self, A)</span>:</span></span><br><span class="line">    even = [num <span class="keyword">for</span> num <span class="keyword">in</span> A <span class="keyword">if</span> num &amp; <span class="number">1</span> == <span class="number">0</span>]</span><br><span class="line">    odd = [num <span class="keyword">for</span> num <span class="keyword">in</span> A <span class="keyword">if</span> num &amp; <span class="number">1</span> == <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> even + odd</span><br></pre></td></tr></table></figure>
<h3 id="922-Sort-Array-By-Parity-II"><a href="#922-Sort-Array-By-Parity-II" class="headerlink" title="922. Sort Array By Parity II"></a>922. Sort Array By Parity II</h3><h4 id="输入一个奇数偶数数量相同的数组，返回下标和其对应的值都是奇数或偶数，即奇偶交叉。和905相似。原题"><a href="#输入一个奇数偶数数量相同的数组，返回下标和其对应的值都是奇数或偶数，即奇偶交叉。和905相似。原题" class="headerlink" title="输入一个奇数偶数数量相同的数组，返回下标和其对应的值都是奇数或偶数，即奇偶交叉。和905相似。原题"></a>输入一个奇数偶数数量相同的数组，返回下标和其对应的值都是奇数或偶数，即奇偶交叉。和905相似。<a href="https://leetcode.com/contest/weekly-contest-106/problems/sort-array-by-parity-ii/" target="_blank" rel="noopener">原题</a></h4><font color="#32CD32" size="3"><strong>方法一：使用切片的特性赋值。</strong></font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortArrayByParityII</span><span class="params">(self, A)</span>:</span></span><br><span class="line">    res = [<span class="literal">None</span>] * len(A)</span><br><span class="line">    res[::<span class="number">2</span>] = (num <span class="keyword">for</span> num <span class="keyword">in</span> A <span class="keyword">if</span> num &amp; <span class="number">1</span> == <span class="number">0</span>)</span><br><span class="line">    res[<span class="number">1</span>::<span class="number">2</span>] = (num <span class="keyword">for</span> num <span class="keyword">in</span> A <span class="keyword">if</span> num &amp; <span class="number">1</span> == <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：双指针。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortArrayByParityII</span><span class="params">(self, A: <span class="string">'List[int]'</span>)</span> -&gt; 'List[int]':</span></span><br><span class="line">    j = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(A), <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> A[i] &amp; <span class="number">1</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">while</span> A[j] &amp; <span class="number">1</span> == <span class="number">1</span>:</span><br><span class="line">                j += <span class="number">2</span></span><br><span class="line">            A[i], A[j] = A[j], A[i]</span><br><span class="line">    <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure>
<h3 id="933-Number-of-Recent-Calls"><a href="#933-Number-of-Recent-Calls" class="headerlink" title="933. Number of Recent Calls"></a>933. Number of Recent Calls</h3><h4 id="输入一个时间t，返回3000毫秒内所有的请求个数。原题"><a href="#输入一个时间t，返回3000毫秒内所有的请求个数。原题" class="headerlink" title="输入一个时间t，返回3000毫秒内所有的请求个数。原题"></a>输入一个时间t，返回3000毫秒内所有的请求个数。<a href="https://leetcode.com/problems/number-of-recent-calls/" target="_blank" rel="noopener">原题</a></h4><p>方法一：deque.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecentCounter</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.q = collections.deque()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ping</span><span class="params">(self, t: <span class="string">'int'</span>)</span> -&gt; 'int':</span></span><br><span class="line">        self.q.append(t)</span><br><span class="line">        <span class="keyword">while</span> self.q[<span class="number">0</span>] &lt; t - <span class="number">3000</span>:</span><br><span class="line">            self.q.popleft()</span><br><span class="line">        <span class="keyword">return</span> len(self.q)</span><br></pre></td></tr></table></figure>
<h3 id="937-Reorder-Log-Files"><a href="#937-Reorder-Log-Files" class="headerlink" title="937. Reorder Log Files"></a>937. Reorder Log Files</h3><h4 id="按照规则将log文件排序。原题"><a href="#按照规则将log文件排序。原题" class="headerlink" title="按照规则将log文件排序。原题"></a>按照规则将log文件排序。<a href="https://leetcode.com/problems/reorder-log-files/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;a1 9 2 3 1&quot;,&quot;g1 act car&quot;,&quot;zo4 4 7&quot;,&quot;ab1 off key dog&quot;,&quot;a8 act zoo&quot;]</span><br><span class="line">Output: [&quot;g1 act car&quot;,&quot;a8 act zoo&quot;,&quot;ab1 off key dog&quot;,&quot;a1 9 2 3 1&quot;,&quot;zo4 4 7&quot;]</span><br></pre></td></tr></table></figure>
<p>方法一：列表生成式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reorderLogFiles</span><span class="params">(self, logs)</span>:</span></span><br><span class="line">    letter_logs = [l <span class="keyword">for</span> l <span class="keyword">in</span> logs <span class="keyword">if</span> l.split()[<span class="number">1</span>].isalpha()]</span><br><span class="line">    digit_logs = [l <span class="keyword">for</span> l <span class="keyword">in</span> logs <span class="keyword">if</span> <span class="keyword">not</span> l.split()[<span class="number">1</span>].isalpha()]</span><br><span class="line">    letter_logs.sort(key=<span class="keyword">lambda</span> x: x.split()[<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> letter_logs + digit_logs</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：sort. </font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reorderLogFiles</span><span class="params">(self, logs: <span class="string">'List[str]'</span>)</span> -&gt; 'List[str]':</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(log)</span>:</span></span><br><span class="line">        pk, text = log.split(<span class="string">" "</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span>, text) <span class="keyword">if</span> text[<span class="number">0</span>].isalpha() <span class="keyword">else</span> (<span class="number">1</span>, )</span><br><span class="line">    <span class="keyword">return</span> sorted(logs, key=f)</span><br></pre></td></tr></table></figure>
<h3 id="485-Max-Consecutive-Ones"><a href="#485-Max-Consecutive-Ones" class="headerlink" title="485. Max Consecutive Ones"></a>485. Max Consecutive Ones</h3><h4 id="输入一个二进制数组，返回最大的连续1的长度。原题"><a href="#输入一个二进制数组，返回最大的连续1的长度。原题" class="headerlink" title="输入一个二进制数组，返回最大的连续1的长度。原题"></a>输入一个二进制数组，返回最大的连续1的长度。<a href="https://leetcode.com/problems/max-consecutive-ones/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,0,1,1,1]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The first two digits or the last three digits are consecutive 1s.</span><br><span class="line">    The maximum number of consecutive 1s is 3.</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法一：不使用标准库。末尾补0是因为，如果原数组末尾是1的情况下，还需要计算一次max的值。缺点是改变了原数组。也可以使用再计算一次的方式。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(self, nums: <span class="string">'List[int]'</span>)</span> -&gt; 'int':</span></span><br><span class="line">    ans = count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums+[<span class="number">0</span>]:</span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ans = max(ans, count)</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>方法二：使用groupby。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    <span class="keyword">from</span> itertools <span class="keyword">import</span> groupby</span><br><span class="line">    max_con = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> d, group <span class="keyword">in</span> groupby(nums):</span><br><span class="line">        <span class="keyword">if</span> d == <span class="number">1</span>:</span><br><span class="line">            max_con = max(max_con, len(list(group)))</span><br><span class="line">    <span class="keyword">return</span> max_con</span><br></pre></td></tr></table></figure>
<p>方法三：split。不过这个效率不高。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    nums_str = <span class="string">''</span>.join(map(str, nums))</span><br><span class="line">    ones = nums_str.split(<span class="string">'0'</span>)</span><br><span class="line">    <span class="keyword">return</span> len(max(ones))</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法四：使用accumulate。Space-complex O(n)。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    <span class="keyword">from</span> itertools <span class="keyword">import</span> accumulate</span><br><span class="line">    <span class="keyword">return</span> max(accumulate(nums, <span class="keyword">lambda</span> x, y: x+y <span class="keyword">if</span> y==<span class="number">1</span> <span class="keyword">else</span> y))</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法五：二进制的方法，将一个数不断左移并按位与，直到它为0，次数就是连续的1的个数。不过由于给的是数组不是数字，所以总体比方法四慢一丢丢。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    ans, b = <span class="number">0</span>, int(<span class="string">''</span>.join(map(str, nums)), <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">while</span> b:</span><br><span class="line">        b = b &amp; (b&lt;&lt;<span class="number">1</span>)</span><br><span class="line">        ans += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="1004-Max-Consecutive-Ones-III"><a href="#1004-Max-Consecutive-Ones-III" class="headerlink" title="1004. Max Consecutive Ones III"></a>1004. Max Consecutive Ones III</h3><h4 id="与上题不同的是，有K次机会可以将0变成1-原题"><a href="#与上题不同的是，有K次机会可以将0变成1-原题" class="headerlink" title="与上题不同的是，有K次机会可以将0变成1. 原题"></a>与上题不同的是，有K次机会可以将0变成1. <a href="https://leetcode.com/problems/max-consecutive-ones-iii/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: A &#x3D; [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K &#x3D; 3</span><br><span class="line">Output: 10</span><br><span class="line">Explanation: </span><br><span class="line">[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]</span><br><span class="line">Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.</span><br></pre></td></tr></table></figure>
<p>方法一：这题竞赛时没想出来，受上题影响，思路跑到了<code>groupby</code>那里，想着怎么分组后操作。实际上此题完全不同，应该使用滑动窗口。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestOnes</span><span class="params">(self, A: List[int], K: int)</span> -&gt; int:</span></span><br><span class="line">    ans = i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(A)):</span><br><span class="line">        K -= A[j]==<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> K &lt; <span class="number">0</span>:</span><br><span class="line">            K += A[i]==<span class="number">0</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        ans = max(ans, j-i+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="496-Next-Greater-Element-I"><a href="#496-Next-Greater-Element-I" class="headerlink" title="496. Next Greater Element I"></a>496. Next Greater Element I</h3><h4 id="找出数组nums2中对应的nums1元素的位置之后的第一个比nums1大的元素。nums1是nums2的子集，二者均无重复的元素。原题"><a href="#找出数组nums2中对应的nums1元素的位置之后的第一个比nums1大的元素。nums1是nums2的子集，二者均无重复的元素。原题" class="headerlink" title="找出数组nums2中对应的nums1元素的位置之后的第一个比nums1大的元素。nums1是nums2的子集，二者均无重复的元素。原题"></a>找出数组nums2中对应的nums1元素的位置之后的第一个比nums1大的元素。nums1是nums2的子集，二者均无重复的元素。<a href="https://leetcode.com/problems/next-greater-element-i/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [4,1,2], nums2 &#x3D; [1,3,4,2].</span><br><span class="line">Output: [-1,3,-1]</span><br><span class="line">Explanation:</span><br><span class="line">    For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.</span><br><span class="line">    For number 1 in the first array, the next greater number for it in the second array is 3.</span><br><span class="line">    For number 2 in the first array, there is no next greater number for it in the second array, so output -1.</span><br><span class="line">    </span><br><span class="line">Input: nums1 &#x3D; [2,4], nums2 &#x3D; [1,2,3,4].</span><br><span class="line">Output: [3,-1]</span><br><span class="line">Explanation:</span><br><span class="line">    For number 2 in the first array, the next greater number for it in the second array is 3.</span><br><span class="line">    For number 4 in the first array, there is no next greater number for it in the second array, so output -1.</span><br></pre></td></tr></table></figure>
<p>方法一：暴力法，因为题中给了范围数组长度小于1000，所以也没有超时。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElement</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> num1 <span class="keyword">in</span> nums1:</span><br><span class="line">        index = nums2.index(num1)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums2[index+<span class="number">1</span>:]:</span><br><span class="line">            res.append(<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> num2 <span class="keyword">in</span> nums2[index+<span class="number">1</span>:]:</span><br><span class="line">                <span class="keyword">if</span> num2 &gt; num1:</span><br><span class="line">                    res.append(num2)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>方法二：one-liner，生成器一开始想到了，没想到next函数还可以设默认值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElement</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> [next((y <span class="keyword">for</span> y <span class="keyword">in</span> nums2[nums2.index(x):] <span class="keyword">if</span> y &gt; x), <span class="number">-1</span>) </span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> nums1]</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法三：Time: O(n). </font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElement</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">    st, d = [], &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> nums2:</span><br><span class="line">        <span class="keyword">while</span> st <span class="keyword">and</span> st[<span class="number">-1</span>] &lt; n:</span><br><span class="line">            d[st.pop()] = n</span><br><span class="line">        st.append(n)</span><br><span class="line">    <span class="keyword">return</span> list(map(<span class="keyword">lambda</span> x: d.get(x, <span class="number">-1</span>), nums1))</span><br></pre></td></tr></table></figure>
<h3 id="953-Verifying-an-Alien-Dictionary"><a href="#953-Verifying-an-Alien-Dictionary" class="headerlink" title="953. Verifying an Alien Dictionary"></a>953. Verifying an Alien Dictionary</h3><h4 id="判断一个字符串数组是否按照特定的字典顺序排序。原题"><a href="#判断一个字符串数组是否按照特定的字典顺序排序。原题" class="headerlink" title="判断一个字符串数组是否按照特定的字典顺序排序。原题"></a>判断一个字符串数组是否按照特定的字典顺序排序。<a href="https://leetcode.com/contest/weekly-contest-114/problems/verifying-an-alien-dictionary/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: words &#x3D; [&quot;hello&quot;,&quot;leetcode&quot;], order &#x3D; &quot;hlabcdefgijkmnopqrstuvwxyz&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: As &#39;h&#39; comes before &#39;l&#39; in this language, then the sequence is sorted.</span><br><span class="line">Input: words &#x3D; [&quot;word&quot;,&quot;world&quot;,&quot;row&quot;], order &#x3D; &quot;worldabcefghijkmnpqstuvxyz&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: As &#39;d&#39; comes after &#39;l&#39; in this language, then words[0] &gt; words[1], hence the sequence is unsorted.</span><br><span class="line">Input: words &#x3D; [&quot;apple&quot;,&quot;app&quot;], order &#x3D; &quot;abcdefghijklmnopqrstuvwxyz&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The first three characters &quot;app&quot; match, and the second string is shorter (in size.) According to lexicographical rules &quot;apple&quot; &gt; &quot;app&quot;, because &#39;l&#39; &gt; &#39;∅&#39;, where &#39;∅&#39; is defined as the blank character which is less than any other character (More info).</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法一：这道题想了很久，最后还是没有做出来，一开始想用zip来自己实现，也想到了sort，但是key里面的匿名函数一直没有想对，关键是二维数组也能排序这点没有想到。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isAlienSorted</span><span class="params">(self, words: <span class="string">'List[str]'</span>, order: <span class="string">'str'</span>)</span> -&gt; 'bool':</span></span><br><span class="line">    d = dict(zip(order, range(<span class="number">26</span>)))</span><br><span class="line">    <span class="keyword">return</span> words == sorted(words, key=<span class="keyword">lambda</span> w: [d[c] <span class="keyword">for</span> c <span class="keyword">in</span> w])</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：传统方法，优点在于提前退出。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isAlienSorted</span><span class="params">(self, words: <span class="string">'List[str]'</span>, order: <span class="string">'str'</span>)</span> -&gt; 'bool':</span></span><br><span class="line">    d = dict(zip(order, range(<span class="number">26</span>)))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(words)<span class="number">-1</span>):</span><br><span class="line">        word1, word2 = words[i:i+<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> c1, c2 <span class="keyword">in</span> zip(word1, word2):</span><br><span class="line">            <span class="keyword">if</span> c1 != c2:</span><br><span class="line">                <span class="keyword">if</span> d[c1] &gt; d[c2]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> len(word1) &gt; len(word2):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h3 id="506-Relative-Ranks"><a href="#506-Relative-Ranks" class="headerlink" title="506. Relative Ranks"></a>506. Relative Ranks</h3><h4 id="根据得分，返回排名。前三要用奖牌表示。原题"><a href="#根据得分，返回排名。前三要用奖牌表示。原题" class="headerlink" title="根据得分，返回排名。前三要用奖牌表示。原题"></a>根据得分，返回排名。前三要用奖牌表示。<a href="https://leetcode.com/problems/relative-ranks/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [5, 4, 3, 2, 1]</span><br><span class="line">Output: [&quot;Gold Medal&quot;, &quot;Silver Medal&quot;, &quot;Bronze Medal&quot;, &quot;4&quot;, &quot;5&quot;]</span><br><span class="line">Explanation: The first three athletes got the top three highest scores, so they got &quot;Gold Medal&quot;, &quot;Silver Medal&quot; and &quot;Bronze Medal&quot;. </span><br><span class="line">For the left two athletes, you just need to output their relative ranks according to their scores.</span><br></pre></td></tr></table></figure>
<p>方法一：先生成一个排行榜单，再根据每个得分把排序映射上去。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findRelativeRanks</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    ranks = list(map(str,range(<span class="number">1</span>, len(nums)+<span class="number">1</span>)))</span><br><span class="line">    ranks[:<span class="number">3</span>] = [<span class="string">"Gold Medal"</span>, <span class="string">"Silver Medal"</span>, <span class="string">"Bronze Medal"</span>]</span><br><span class="line">    sorted_nums = sorted(nums, reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> [ranks[sorted_nums.index(num)] <span class="keyword">for</span> num <span class="keyword">in</span> nums]  <span class="comment"># slow</span></span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：使用map映射。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findRelativeRanks</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    ranks = list(map(str,range(<span class="number">1</span>, len(nums)+<span class="number">1</span>)))</span><br><span class="line">    ranks[:<span class="number">3</span>] = [<span class="string">"Gold Medal"</span>, <span class="string">"Silver Medal"</span>, <span class="string">"Bronze Medal"</span>]</span><br><span class="line">    sorted_nums = sorted(nums, reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># map_rank = &#123;num: ranks[i] for i, num in enumerate(sorted_nums)&#125;</span></span><br><span class="line">    <span class="comment"># return list(map(map_rank.get, nums))</span></span><br><span class="line">    <span class="keyword">return</span> list(map(dict(zip(sorted_nums, ranks)).get, nums))</span><br></pre></td></tr></table></figure>
<h3 id="532-K-diff-Pairs-in-an-Array"><a href="#532-K-diff-Pairs-in-an-Array" class="headerlink" title="532. K-diff Pairs in an Array"></a>532. K-diff Pairs in an Array</h3><h4 id="找出差为k的不重复的成对元素的个数。原题"><a href="#找出差为k的不重复的成对元素的个数。原题" class="headerlink" title="找出差为k的不重复的成对元素的个数。原题"></a>找出差为k的不重复的成对元素的个数。<a href="https://leetcode.com/problems/k-diff-pairs-in-an-array/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [3, 1, 4, 1, 5], k &#x3D; 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).</span><br><span class="line">Although we have two 1s in the input, we should only return the number of unique pairs.</span><br></pre></td></tr></table></figure>
<p>方法一：Counter，一开始没想到，想sort或是set，然后实现不了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPairs</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">    c = Counter(nums)</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num, count <span class="keyword">in</span> c.items():</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> <span class="keyword">and</span> count &gt; <span class="number">1</span>) <span class="keyword">or</span> (k &gt; <span class="number">0</span> <span class="keyword">and</span> num+k <span class="keyword">in</span> c):</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="961-N-Repeated-Element-in-Size-2N-Array"><a href="#961-N-Repeated-Element-in-Size-2N-Array" class="headerlink" title="961. N-Repeated Element in Size 2N Array"></a>961. N-Repeated Element in Size 2N Array</h3><h4 id="找出2N长的数组中重复N次的数字，其它数字均只出现一次。此题不能用波义尔摩尔投票因为数量没有大于半数。原题"><a href="#找出2N长的数组中重复N次的数字，其它数字均只出现一次。此题不能用波义尔摩尔投票因为数量没有大于半数。原题" class="headerlink" title="找出2N长的数组中重复N次的数字，其它数字均只出现一次。此题不能用波义尔摩尔投票因为数量没有大于半数。原题"></a>找出2N长的数组中重复N次的数字，其它数字均只出现一次。此题不能用波义尔摩尔投票因为数量没有大于半数。<a href="https://leetcode.com/problems/n-repeated-element-in-size-2n-array/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,1,2,5,3,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法一：这题本意我看是哈希表，所以大部分答案都是Counter之类的，我看排行榜签名的Python选手也是这么用的，我是灵机一动一动动想出了一个数学方法。看上去迭代了两次数组，并使用了一些空间，但其实速度很快。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">repeatedNTimes</span><span class="params">(self, A)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (sum(A)-sum(set(A))) // (len(A)//<span class="number">2</span><span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：其实是找重复的数字，那么就数量是一定的话，其他数字的相邻两位中可能会有重复，其他一种不重复情况，<code>2234</code>和<code>2342</code>。此方法不能用于169题，因为169题中的其它元素是可能重复的。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">repeatedNTimes</span><span class="params">(self, A: <span class="string">'List[int]'</span>)</span> -&gt; 'int':</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(A)):</span><br><span class="line">        <span class="keyword">if</span> A[i] == A[i<span class="number">-1</span>] <span class="keyword">or</span> A[i] == A[i<span class="number">-2</span>]:</span><br><span class="line">            <span class="keyword">return</span> A[i]</span><br><span class="line">    <span class="keyword">return</span> A[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h3 id="967-Numbers-With-Same-Consecutive-Differences"><a href="#967-Numbers-With-Same-Consecutive-Differences" class="headerlink" title="967. Numbers With Same Consecutive Differences"></a>967. Numbers With Same Consecutive Differences</h3><h4 id="根据规则生成一组数组，数字长度为N，每两位的差为K。原题"><a href="#根据规则生成一组数组，数字长度为N，每两位的差为K。原题" class="headerlink" title="根据规则生成一组数组，数字长度为N，每两位的差为K。原题"></a>根据规则生成一组数组，数字长度为N，每两位的差为K。<a href="https://leetcode.com/problems/numbers-with-same-consecutive-differences/" target="_blank" rel="noopener">原题</a></h4><p>方法一：迭代生成，其实此题本是一道动态规划题，但由于解法不是，暂时归到数组里。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numsSameConsecDiff</span><span class="params">(self, N, K)</span>:</span></span><br><span class="line">    ans = &#123;x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>)&#125;</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(N<span class="number">-1</span>):</span><br><span class="line">        ans2 = set()</span><br><span class="line">        <span class="keyword">for</span> digit <span class="keyword">in</span> ans:</span><br><span class="line">            d = digit % <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> d - K &gt;= <span class="number">0</span>:</span><br><span class="line">                ans2.add(digit*<span class="number">10</span> + d - K)</span><br><span class="line">            <span class="keyword">if</span> d + K &lt;= <span class="number">9</span>:</span><br><span class="line">                ans2.add(digit*<span class="number">10</span> + d + K)</span><br><span class="line">        ans = ans2</span><br><span class="line">    <span class="keyword">if</span> N == <span class="number">1</span>:</span><br><span class="line">        ans.add(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> list(ans)</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：简化。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numsSameConsecDiff</span><span class="params">(self, N, K)</span>:</span></span><br><span class="line">    ans = range(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(N<span class="number">-1</span>):</span><br><span class="line">        ans = &#123;x*<span class="number">10</span>+y <span class="keyword">for</span> x <span class="keyword">in</span> ans <span class="keyword">for</span> y <span class="keyword">in</span> (x%<span class="number">10</span>-K, x%<span class="number">10</span>+K) </span><br><span class="line">               <span class="keyword">if</span> x <span class="keyword">and</span> <span class="number">0</span>&lt;=y&lt;<span class="number">10</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> list(ans)</span><br></pre></td></tr></table></figure>
<h3 id="561-Array-Partition-I"><a href="#561-Array-Partition-I" class="headerlink" title="561. Array Partition I"></a>561. Array Partition I</h3><h4 id="将数组两两分成一组，累加每组的最小值，使之尽量大。原题"><a href="#将数组两两分成一组，累加每组的最小值，使之尽量大。原题" class="headerlink" title="将数组两两分成一组，累加每组的最小值，使之尽量大。原题"></a>将数组两两分成一组，累加每组的最小值，使之尽量大。<a href="https://leetcode.com/problems/array-partition-i/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,4,3,2]</span><br><span class="line"></span><br><span class="line">Output: 4</span><br><span class="line">Explanation: n is 2, and the maximum sum of pairs is 4 &#x3D; min(1, 2) + min(3, 4).</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">arrayPairSum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sum(sorted(nums)[::<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<h3 id="566-Reshape-the-Matrix"><a href="#566-Reshape-the-Matrix" class="headerlink" title="566. Reshape the Matrix"></a>566. Reshape the Matrix</h3><h4 id="改变矩阵的形状，如果元素超出或不足，返回原矩阵。原题"><a href="#改变矩阵的形状，如果元素超出或不足，返回原矩阵。原题" class="headerlink" title="改变矩阵的形状，如果元素超出或不足，返回原矩阵。原题"></a>改变矩阵的形状，如果元素超出或不足，返回原矩阵。<a href="https://leetcode.com/problems/reshape-the-matrix/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">nums &#x3D; </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">r &#x3D; 1, c &#x3D; 4</span><br><span class="line">Output: </span><br><span class="line">[[1,2,3,4]]</span><br><span class="line">Explanation:</span><br><span class="line">The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.</span><br></pre></td></tr></table></figure>
<p>方法一：扁平化后重组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">matrixReshape</span><span class="params">(self, nums, r, c)</span>:</span></span><br><span class="line">    a = [x <span class="keyword">for</span> row <span class="keyword">in</span> nums <span class="keyword">for</span> x <span class="keyword">in</span> row]</span><br><span class="line">    n = len(a)</span><br><span class="line">    <span class="keyword">if</span> r*c != n:</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    <span class="keyword">return</span> [a[i*c:i*c+c] <span class="keyword">for</span> i <span class="keyword">in</span> range(r)]</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：使用itertools.</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">matrixReshape</span><span class="params">(self, nums, r, c)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> r*c != len(nums)*len(nums[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    <span class="keyword">from</span> itertools <span class="keyword">import</span> islice, chain</span><br><span class="line">    it = chain(*nums)</span><br><span class="line">    <span class="keyword">return</span> [list(islice(it, c)) <span class="keyword">for</span> _ <span class="keyword">in</span> range(r)]</span><br></pre></td></tr></table></figure>
<h3 id="575-Distribute-Candies"><a href="#575-Distribute-Candies" class="headerlink" title="575. Distribute Candies"></a>575. Distribute Candies</h3><h4 id="给姐姐弟弟分糖，两人数量一样，保证姐姐的种类最多，求姐姐最多能分到多少种。原题"><a href="#给姐姐弟弟分糖，两人数量一样，保证姐姐的种类最多，求姐姐最多能分到多少种。原题" class="headerlink" title="给姐姐弟弟分糖，两人数量一样，保证姐姐的种类最多，求姐姐最多能分到多少种。原题"></a>给姐姐弟弟分糖，两人数量一样，保证姐姐的种类最多，求姐姐最多能分到多少种。<a href="https://leetcode.com/problems/distribute-candies/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: candies &#x3D; [1,1,2,2,3,3]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">There are three different kinds of candies (1, 2 and 3), and two candies for each kind.</span><br><span class="line">Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too. </span><br><span class="line">The sister has three different kinds of candies.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">distributeCandies</span><span class="params">(self, candies)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> min(len(candies)//<span class="number">2</span>, len(set(candies)))</span><br></pre></td></tr></table></figure>
<h3 id="594-Longest-Harmonious-Subsequence"><a href="#594-Longest-Harmonious-Subsequence" class="headerlink" title="594. Longest Harmonious Subsequence"></a>594. Longest Harmonious Subsequence</h3><h4 id="最长的和谐子数组，即元素的最大值和最小值正好相差一的子数组，元素顺序无关，求最大子数组长度。原题"><a href="#最长的和谐子数组，即元素的最大值和最小值正好相差一的子数组，元素顺序无关，求最大子数组长度。原题" class="headerlink" title="最长的和谐子数组，即元素的最大值和最小值正好相差一的子数组，元素顺序无关，求最大子数组长度。原题"></a>最长的和谐子数组，即元素的最大值和最小值正好相差一的子数组，元素顺序无关，求最大子数组长度。<a href="https://leetcode.com/problems/longest-harmonious-subsequence/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,2,2,5,2,3,7]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The longest harmonious subsequence is [3,2,2,2,3].</span><br></pre></td></tr></table></figure>
<p>方法一：开始想错了，后来发现子数组只能包含两个元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findLHS</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    c = Counter(nums)</span><br><span class="line">    <span class="keyword">for</span> num, count <span class="keyword">in</span> c.items():</span><br><span class="line">        sum_count = count+c[num+<span class="number">1</span>] <span class="keyword">if</span> c[num+<span class="number">1</span>] <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        res = max(res, sum_count)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：one-liner.</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findLHS</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">    c = Counter(nums)</span><br><span class="line">    <span class="keyword">return</span> max([count+c[num+<span class="number">1</span>] <span class="keyword">for</span> num, count <span class="keyword">in</span> c.items() </span><br><span class="line">                <span class="keyword">if</span> num+<span class="number">1</span> <span class="keyword">in</span> c] <span class="keyword">or</span> [<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<h3 id="598-Range-Addition-II"><a href="#598-Range-Addition-II" class="headerlink" title="598. Range Addition II"></a>598. Range Addition II</h3><h4 id="这题看上去挺长，其实抽象起来很简单，把整个矩阵想象成一个积木，然后每次往上叠加，每次叠放的矩形都会和左上角对齐，所以最后完成的时候，左上角的一小块一定是最“厚”的，问题就变成和左上一样的厚度的面积。实际上等于叠放的所有矩形的最小长度和最小宽度的乘积。原题"><a href="#这题看上去挺长，其实抽象起来很简单，把整个矩阵想象成一个积木，然后每次往上叠加，每次叠放的矩形都会和左上角对齐，所以最后完成的时候，左上角的一小块一定是最“厚”的，问题就变成和左上一样的厚度的面积。实际上等于叠放的所有矩形的最小长度和最小宽度的乘积。原题" class="headerlink" title="这题看上去挺长，其实抽象起来很简单，把整个矩阵想象成一个积木，然后每次往上叠加，每次叠放的矩形都会和左上角对齐，所以最后完成的时候，左上角的一小块一定是最“厚”的，问题就变成和左上一样的厚度的面积。实际上等于叠放的所有矩形的最小长度和最小宽度的乘积。原题"></a>这题看上去挺长，其实抽象起来很简单，把整个矩阵想象成一个积木，然后每次往上叠加，每次叠放的矩形都会和左上角对齐，所以最后完成的时候，左上角的一小块一定是最“厚”的，问题就变成和左上一样的厚度的面积。实际上等于叠放的所有矩形的最小长度和最小宽度的乘积。<a href="https://leetcode.com/problems/range-addition-ii/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">m &#x3D; 3, n &#x3D; 3</span><br><span class="line">operations &#x3D; [[2,2],[3,3]]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: </span><br><span class="line">Initially, M &#x3D; </span><br><span class="line">[[0, 0, 0],</span><br><span class="line"> [0, 0, 0],</span><br><span class="line"> [0, 0, 0]]</span><br><span class="line"></span><br><span class="line">After performing [2,2], M &#x3D; </span><br><span class="line">[[1, 1, 0],</span><br><span class="line"> [1, 1, 0],</span><br><span class="line"> [0, 0, 0]]</span><br><span class="line"></span><br><span class="line">After performing [3,3], M &#x3D; </span><br><span class="line">[[2, 2, 1],</span><br><span class="line"> [2, 2, 1],</span><br><span class="line"> [1, 1, 1]]</span><br><span class="line"></span><br><span class="line">So the maximum integer in M is 2, and there are four of it in M. So return 4.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxCount</span><span class="params">(self, m, n, ops)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ops:</span><br><span class="line">        <span class="keyword">return</span> m*n</span><br><span class="line">    length, width = list(zip(*ops))</span><br><span class="line">    <span class="keyword">return</span> min(length) * min(width)</span><br></pre></td></tr></table></figure>
<h3 id="599-Minimum-Index-Sum-of-Two-Lists"><a href="#599-Minimum-Index-Sum-of-Two-Lists" class="headerlink" title="599. Minimum Index Sum of Two Lists"></a>599. Minimum Index Sum of Two Lists</h3><h4 id="找出两个人共同最喜欢的餐厅。如果有多个输出多个。原题"><a href="#找出两个人共同最喜欢的餐厅。如果有多个输出多个。原题" class="headerlink" title="找出两个人共同最喜欢的餐厅。如果有多个输出多个。原题"></a>找出两个人共同最喜欢的餐厅。如果有多个输出多个。<a href="https://leetcode.com/problems/minimum-index-sum-of-two-lists/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[&quot;Shogun&quot;,&quot;Tapioca Express&quot;,&quot;Burger King&quot;,&quot;KFC&quot;]</span><br><span class="line">[&quot;Piatti&quot;,&quot;The Grill at Torrey Pines&quot;,&quot;Tapioca Express&quot;,&quot;Shogun&quot;]</span><br><span class="line">Output: [&#39;Shogun&#39;, &#39;Tapioca Express&#39;]</span><br></pre></td></tr></table></figure>
<p>方法一：这里做了一个优化，以原list1的顺序输出数组，如果索引太大超出了最小索引和，这样即使是map2使用第一个元素也无法满足条件，直接退出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findRestaurant</span><span class="params">(self, list1, list2)</span>:</span></span><br><span class="line">    map2 = &#123;x: i <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(list2)&#125;</span><br><span class="line">    res, min_sum = [], float(<span class="string">'inf'</span>)</span><br><span class="line">    <span class="keyword">for</span> i, rest <span class="keyword">in</span> enumerate(list1):</span><br><span class="line">        <span class="comment"># optimize </span></span><br><span class="line">        <span class="keyword">if</span> i &gt; min_sum: </span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> rest <span class="keyword">in</span> map2:</span><br><span class="line">            <span class="keyword">if</span> i+map2[rest] &lt; min_sum:</span><br><span class="line">                res = [rest]</span><br><span class="line">                min_sum = i+map2[rest]</span><br><span class="line">            <span class="keyword">elif</span> i+map2[rest] == min_sum:</span><br><span class="line">                res += [rest]</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="605-Can-Place-Flowers"><a href="#605-Can-Place-Flowers" class="headerlink" title="605. Can Place Flowers"></a>605. Can Place Flowers</h3><h4 id="是否可以种下给定数量的花。两颗花不能挨着，给定的数组中满足这一条件。原题"><a href="#是否可以种下给定数量的花。两颗花不能挨着，给定的数组中满足这一条件。原题" class="headerlink" title="是否可以种下给定数量的花。两颗花不能挨着，给定的数组中满足这一条件。原题"></a>是否可以种下给定数量的花。两颗花不能挨着，给定的数组中满足这一条件。<a href="https://leetcode.com/problems/can-place-flowers/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: flowerbed &#x3D; [1,0,0,0,1], n &#x3D; 2</span><br><span class="line">Output: False</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canPlaceFlowers</span><span class="params">(self, flowerbed, n)</span>:</span></span><br><span class="line">    plots = [<span class="number">0</span>] + flowerbed + [<span class="number">0</span>]</span><br><span class="line">    p = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> p &lt;= len(flowerbed) <span class="keyword">and</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> plots[p] == <span class="number">0</span> <span class="keyword">and</span> plots[p<span class="number">-1</span>] == <span class="number">0</span> <span class="keyword">and</span> plots[p+<span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">            plots[p] = <span class="number">1</span></span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">        p += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="643-Maximum-Average-Subarray-I"><a href="#643-Maximum-Average-Subarray-I" class="headerlink" title="643. Maximum Average Subarray I"></a>643. Maximum Average Subarray I</h3><h4 id="最大的连续的长度为k的子数组的平均值。原题"><a href="#最大的连续的长度为k的子数组的平均值。原题" class="headerlink" title="最大的连续的长度为k的子数组的平均值。原题"></a>最大的连续的长度为k的子数组的平均值。<a href="https://leetcode.com/problems/maximum-average-subarray-i/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,12,-5,-6,50,3], k &#x3D; 4</span><br><span class="line">Output: 12.75</span><br><span class="line">Explanation: Maximum average is (12-5-6+50)&#x2F;4 &#x3D; 51&#x2F;4 &#x3D; 12.75</span><br></pre></td></tr></table></figure>
<p>方法一：参考了stefen大神的答案，自己写的滑动窗口居然超时了。accumulate也不是想不到，此答案厉害的地方在于 补0 和map操作。像这种固定长度的滑动窗口使用补0的<code>accumulate</code>，可以用到其他的题上。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMaxAverage</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">    sums = [<span class="number">0</span>] + list(itertools.accumulate(nums))</span><br><span class="line">    <span class="keyword">return</span> max(map(operator.sub, sums[k:], sums)) / k</span><br></pre></td></tr></table></figure>
<h3 id="661-Image-Smoother"><a href="#661-Image-Smoother" class="headerlink" title="661. Image Smoother"></a>661. Image Smoother</h3><h4 id="使图片平滑模糊，一个矩阵使每个点的值为周围所有点的平均值，包括自己。原题"><a href="#使图片平滑模糊，一个矩阵使每个点的值为周围所有点的平均值，包括自己。原题" class="headerlink" title="使图片平滑模糊，一个矩阵使每个点的值为周围所有点的平均值，包括自己。原题"></a>使图片平滑模糊，一个矩阵使每个点的值为周围所有点的平均值，包括自己。<a href="https://leetcode.com/problems/image-smoother/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[[1,1,1],</span><br><span class="line"> [1,0,1],</span><br><span class="line"> [1,1,1]]</span><br><span class="line">Output:</span><br><span class="line">[[0, 0, 0],</span><br><span class="line"> [0, 0, 0],</span><br><span class="line"> [0, 0, 0]]</span><br><span class="line">Explanation:</span><br><span class="line">For the point (0,0), (0,2), (2,0), (2,2): floor(3&#x2F;4) &#x3D; floor(0.75) &#x3D; 0</span><br><span class="line">For the point (0,1), (1,0), (1,2), (2,1): floor(5&#x2F;6) &#x3D; floor(0.83333333) &#x3D; 0</span><br><span class="line">For the point (1,1): floor(8&#x2F;9) &#x3D; floor(0.88888889) &#x3D; 0</span><br></pre></td></tr></table></figure>
<p>方法一：参考了评论区一位朋友的写法，不过效率不是很高，800ms，Solution给出的方法也是这个速度，看来如果优化的话，可能使用<code>numpy</code>会好一点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">imageSmoother</span><span class="params">(self, M)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> itertools</span><br><span class="line">    R, C = len(M), len(M[<span class="number">0</span>]) </span><br><span class="line">    res = [[<span class="number">0</span>]*C <span class="keyword">for</span> _ <span class="keyword">in</span> range(R)]</span><br><span class="line">    offset = list(itertools.product([<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>], [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(R):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(C):</span><br><span class="line">            points = [M[i+x][j+y] <span class="keyword">for</span> x, y <span class="keyword">in</span> offset</span><br><span class="line">                      <span class="keyword">if</span> <span class="number">0</span>&lt;=i+x&lt;R <span class="keyword">and</span> <span class="number">0</span>&lt;=j+y&lt;C]</span><br><span class="line">            res[i][j] = sum(points) // len(points)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="665-Non-decreasing-Array"><a href="#665-Non-decreasing-Array" class="headerlink" title="665. Non-decreasing Array"></a>665. Non-decreasing Array</h3><h4 id="判断是否改变一个数，可使其变成单调递增数组。原题"><a href="#判断是否改变一个数，可使其变成单调递增数组。原题" class="headerlink" title="判断是否改变一个数，可使其变成单调递增数组。原题"></a>判断是否改变一个数，可使其变成单调递增数组。<a href="https://leetcode.com/problems/non-decreasing-array/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,2,3]</span><br><span class="line">Output: True</span><br><span class="line">Explanation: You could modify the first 4 to 1 to get a non-decreasing array.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkPossibility</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    p = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; nums[i+<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">if</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            p = i</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">not</span> p) <span class="keyword">or</span> p == n<span class="number">-2</span> <span class="keyword">or</span> nums[p<span class="number">-1</span>] &lt;= nums[p+<span class="number">1</span>] <span class="keyword">or</span> \</span><br><span class="line">           nums[p] &lt;= nums[p+<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>If p = 0, then we could make the array good by setting A[p] = A[p+1]</li>
<li>if p = len(A) - 2, then we could make the array good by setting A[p+1] = A[p]</li>
<li>Otherwise, A[p-1], A[p], A[p+1], A[p+2] all exist, and:<ul>
<li>change A[p] to be between A[p-1] and A[p+1] if possible, or: [4, 8, 6]</li>
<li>change A[p+1] to be between A[p] and A[p+2] if possible. [4, 5, 3, 6]</li>
</ul>
</li>
</ul>
<h3 id="674-Longest-Continuous-Increasing-Subsequence"><a href="#674-Longest-Continuous-Increasing-Subsequence" class="headerlink" title="674. Longest Continuous Increasing Subsequence"></a>674. Longest Continuous Increasing Subsequence</h3><h4 id="最长连续递增子数组长度。原题"><a href="#最长连续递增子数组长度。原题" class="headerlink" title="最长连续递增子数组长度。原题"></a>最长连续递增子数组长度。<a href="https://leetcode.com/problems/longest-continuous-increasing-subsequence/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,5,4,7]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3. </span><br><span class="line">Even though [1,3,5,7] is also an increasing subsequence, it&#39;s not a continuous one where 5 and 7 are separated by 4.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findLengthOfLCIS</span><span class="params">(self, nums: <span class="string">'List[int]'</span>)</span> -&gt; 'int':</span></span><br><span class="line">    ans = anchor = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">and</span> nums[i] &lt;= nums[i<span class="number">-1</span>]:</span><br><span class="line">            anchor = i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ans = max(ans, i-anchor+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="682-Baseball-Game"><a href="#682-Baseball-Game" class="headerlink" title="682. Baseball Game"></a>682. Baseball Game</h3><h4 id="棒球游戏，给了一些积分规则。原题"><a href="#棒球游戏，给了一些积分规则。原题" class="headerlink" title="棒球游戏，给了一些积分规则。原题"></a>棒球游戏，给了一些积分规则。<a href="https://leetcode.com/problems/baseball-game/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;5&quot;,&quot;2&quot;,&quot;C&quot;,&quot;D&quot;,&quot;+&quot;]</span><br><span class="line">Output: 30</span><br><span class="line">Explanation: </span><br><span class="line">Round 1: You could get 5 points. The sum is: 5.</span><br><span class="line">Round 2: You could get 2 points. The sum is: 7.</span><br><span class="line">Operation 1: The round 2&#39;s data was invalid. The sum is: 5.  </span><br><span class="line">Round 3: You could get 10 points (the round 2&#39;s data has been removed). The sum is: 15.</span><br><span class="line">Round 4: You could get 5 + 10 &#x3D; 15 points. The sum is: 30.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calPoints</span><span class="params">(self, ops)</span>:</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> op <span class="keyword">in</span> ops:</span><br><span class="line">        <span class="keyword">if</span> op == <span class="string">'C'</span>:</span><br><span class="line">            stack.pop()</span><br><span class="line">        <span class="keyword">elif</span> op == <span class="string">'D'</span>:</span><br><span class="line">            stack.append(stack[<span class="number">-1</span>]*<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">elif</span> op == <span class="string">'+'</span>:</span><br><span class="line">            stack.append(stack[<span class="number">-1</span>] + stack[<span class="number">-2</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stack.append(int(op))</span><br><span class="line">    <span class="keyword">return</span> sum(stack)</span><br></pre></td></tr></table></figure>
<h3 id="690-Employee-Importance"><a href="#690-Employee-Importance" class="headerlink" title="690. Employee Importance"></a>690. Employee Importance</h3><h4 id="员工重要值。原题"><a href="#员工重要值。原题" class="headerlink" title="员工重要值。原题"></a>员工重要值。<a href="https://leetcode.com/problems/employee-importance/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1</span><br><span class="line">Output: 11</span><br><span class="line">Explanation:</span><br><span class="line">Employee 1 has importance value 5, and he has two direct subordinates: employee 2 and employee 3. They both have importance value 3. So the total importance value of employee 1 is 5 + 3 + 3 &#x3D; 11.</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法一：iteratively.</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getImportance</span><span class="params">(self, employees, id)</span>:</span></span><br><span class="line">    emp_dict = &#123;ep.id: (ep.importance, ep.subordinates) <span class="keyword">for</span> ep <span class="keyword">in</span> employees&#125;</span><br><span class="line">    res, stack = <span class="number">0</span>, [id]</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        value, subs = emp_dict.get(stack.pop())</span><br><span class="line">        res += value</span><br><span class="line">        stack += subs</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>方法二：recursively.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getImportance</span><span class="params">(self, employees, id)</span>:</span></span><br><span class="line">    emp_dict = &#123;ep.id: (ep.importance, ep.subordinates) <span class="keyword">for</span> ep <span class="keyword">in</span> employees&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(pk)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> emp_dict[pk][<span class="number">0</span>] + sum(dfs(sub) <span class="keyword">for</span> sub <span class="keyword">in</span> emp_dict[pk][<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> dfs(id)</span><br></pre></td></tr></table></figure>
<h3 id="724-Find-Pivot-Index"><a href="#724-Find-Pivot-Index" class="headerlink" title="724. Find Pivot Index"></a>724. Find Pivot Index</h3><h4 id="找到中心索引，使得左右两边和相等。左右求和时均不包含该索引。原题"><a href="#找到中心索引，使得左右两边和相等。左右求和时均不包含该索引。原题" class="headerlink" title="找到中心索引，使得左右两边和相等。左右求和时均不包含该索引。原题"></a>找到中心索引，使得左右两边和相等。左右求和时均不包含该索引。<a href="https://leetcode.com/problems/find-pivot-index/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">nums &#x3D; [1, 7, 3, 6, 5, 6]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: </span><br><span class="line">The sum of the numbers to the left of index 3 (nums[3] &#x3D; 6) is equal to the sum of numbers to the right of index 3.</span><br><span class="line">Also, 3 is the first index where this occurs.</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">nums &#x3D; [1,0]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
<p>方法一：指针。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pivotIndex</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    left, right, i = <span class="number">0</span>, sum(nums), <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(nums):</span><br><span class="line">        left += nums[i<span class="number">-1</span>] <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        right -= nums[i] </span><br><span class="line">        <span class="keyword">if</span> left == right:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：不使用指针。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pivotIndex</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    S, left = sum(nums), <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">        <span class="keyword">if</span> left == S-left-num:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        left += num</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="985-Sum-of-Even-Numbers-After-Queries"><a href="#985-Sum-of-Even-Numbers-After-Queries" class="headerlink" title="985. Sum of Even Numbers After Queries"></a>985. Sum of Even Numbers After Queries</h3><h4 id="计算Queries后，累加所有的偶数。原题"><a href="#计算Queries后，累加所有的偶数。原题" class="headerlink" title="计算Queries后，累加所有的偶数。原题"></a>计算Queries后，累加所有的偶数。<a href="https://leetcode.com/problems/sum-of-even-numbers-after-queries/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: A &#x3D; [1,2,3,4], queries &#x3D; [[1,0],[-3,1],[-4,0],[2,3]]</span><br><span class="line">Output: [8,6,2,4]</span><br><span class="line">Explanation: </span><br><span class="line">At the beginning, the array is [1,2,3,4].</span><br><span class="line">After adding 1 to A[0], the array is [2,2,3,4], and the sum of even values is 2 + 2 + 4 &#x3D; 8.</span><br><span class="line">After adding -3 to A[1], the array is [2,-1,3,4], and the sum of even values is 2 + 4 &#x3D; 6.</span><br><span class="line">After adding -4 to A[0], the array is [-2,-1,3,4], and the sum of even values is -2 + 4 &#x3D; 2.</span><br><span class="line">After adding 2 to A[3], the array is [-2,-1,3,6], and the sum of even values is -2 + 6 &#x3D; 4.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumEvenAfterQueries</span><span class="params">(self, A: <span class="string">'List[int]'</span>, queries: <span class="string">'List[List[int]]'</span>)</span> -&gt; 'List[int]':</span></span><br><span class="line">    res = []</span><br><span class="line">    sum_even = sum(x <span class="keyword">for</span> x <span class="keyword">in</span> A <span class="keyword">if</span> x &amp; <span class="number">1</span> == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> v, i <span class="keyword">in</span> queries:</span><br><span class="line">        <span class="keyword">if</span> A[i] &amp; <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">            sum_even -= A[i]</span><br><span class="line">        A[i] += v</span><br><span class="line">        <span class="keyword">if</span> A[i] &amp; <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">            sum_even += A[i]</span><br><span class="line">        res.append(sum_even)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="986-Interval-List-Intersections"><a href="#986-Interval-List-Intersections" class="headerlink" title="986. Interval List Intersections"></a>986. Interval List Intersections</h3><h4 id="两个区间列表求相交。原题"><a href="#两个区间列表求相交。原题" class="headerlink" title="两个区间列表求相交。原题"></a>两个区间列表求相交。<a href="https://leetcode.com/problems/interval-list-intersections/" target="_blank" rel="noopener">原题</a></h4><img src="/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%95%B0%E7%BB%84%E7%AF%87%EF%BC%89Array/interval1.png" class>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A &#x3D; [[0,2],[5,10],[13,23],[24,25]], B &#x3D; [[1,5],[8,12],[15,24],[25,26]]</span><br><span class="line">Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]</span><br><span class="line">Reminder: The inputs and the desired output are lists of Interval objects, and not arrays or lists.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intervalIntersection</span><span class="params">(self, A: <span class="string">'List[Interval]'</span>, B: <span class="string">'List[Interval]'</span>)</span> -&gt; 'List[Interval]':</span></span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> i &lt; len(A) <span class="keyword">and</span> j &lt; len(B):</span><br><span class="line">        lo = max(A[i].start, B[j].start)</span><br><span class="line">        hi = min(A[i].end, B[j].end)</span><br><span class="line">        <span class="keyword">if</span> lo &lt;= hi:</span><br><span class="line">            res.append(Interval(lo, hi))</span><br><span class="line">        <span class="keyword">if</span> A[i].end &gt; B[j].end:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="747-Largest-Number-At-Least-Twice-of-Others"><a href="#747-Largest-Number-At-Least-Twice-of-Others" class="headerlink" title="747. Largest Number At Least Twice of Others"></a>747. Largest Number At Least Twice of Others</h3><h4 id="最大的数是否大于等于所有其它数的两倍。原题"><a href="#最大的数是否大于等于所有其它数的两倍。原题" class="headerlink" title="最大的数是否大于等于所有其它数的两倍。原题"></a>最大的数是否大于等于所有其它数的两倍。<a href="https://leetcode.com/problems/largest-number-at-least-twice-of-others/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3, 6, 1, 0]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: 6 is the largest integer, and for every other number in the array x,</span><br><span class="line">6 is more than twice as big as x.  The index of value 6 is 1, so we return 1.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dominantIndex</span><span class="params">(self, nums: <span class="string">'List[int]'</span>)</span> -&gt; 'int':</span></span><br><span class="line">    max_v = max(nums)</span><br><span class="line">    <span class="keyword">if</span> all(max_v &gt;= <span class="number">2</span>*x <span class="keyword">for</span> x <span class="keyword">in</span> nums <span class="keyword">if</span> x!=max_v):</span><br><span class="line">        <span class="keyword">return</span> nums.index(max_v)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="766-Toeplitz-Matrix"><a href="#766-Toeplitz-Matrix" class="headerlink" title="766. Toeplitz Matrix"></a>766. Toeplitz Matrix</h3><h4 id="Toeplitz矩阵，即对角矩阵，斜角具有相同的值，判断一个矩阵是否是对角矩阵。原题"><a href="#Toeplitz矩阵，即对角矩阵，斜角具有相同的值，判断一个矩阵是否是对角矩阵。原题" class="headerlink" title="Toeplitz矩阵，即对角矩阵，斜角具有相同的值，判断一个矩阵是否是对角矩阵。原题"></a>Toeplitz矩阵，即对角矩阵，斜角具有相同的值，判断一个矩阵是否是对角矩阵。<a href="https://leetcode.com/problems/toeplitz-matrix/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">matrix &#x3D; [</span><br><span class="line">  [1,2,3,4],</span><br><span class="line">  [5,1,2,3],</span><br><span class="line">  [9,5,1,2]</span><br><span class="line">]</span><br><span class="line">Output: True</span><br><span class="line">Explanation:</span><br><span class="line">In the above grid, the diagonals are:</span><br><span class="line">&quot;[9]&quot;, &quot;[5, 5]&quot;, &quot;[1, 1, 1]&quot;, &quot;[2, 2, 2]&quot;, &quot;[3, 3]&quot;, &quot;[4]&quot;.</span><br><span class="line">In each diagonal all elements are the same, so the answer is True.</span><br></pre></td></tr></table></figure>
<p>方法一：嵌套循环。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isToeplitzMatrix</span><span class="params">(self, matrix: <span class="string">'List[List[int]]'</span>)</span> -&gt; 'bool':</span></span><br><span class="line">    <span class="keyword">return</span> all(x==<span class="number">0</span> <span class="keyword">or</span> y==<span class="number">0</span> <span class="keyword">or</span> matrix[x<span class="number">-1</span>][y<span class="number">-1</span>]==val</span><br><span class="line">               <span class="keyword">for</span> x, rows <span class="keyword">in</span> enumerate(matrix)</span><br><span class="line">               <span class="keyword">for</span> y, val <span class="keyword">in</span> enumerate(rows))</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：切片，与上述方法在效率空间上没有差距，更喜欢这个方法。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isToeplitzMatrix</span><span class="params">(self, matrix: <span class="string">'List[List[int]]'</span>)</span> -&gt; 'bool':</span></span><br><span class="line">    <span class="keyword">return</span> all(matrix[i][<span class="number">1</span>:]==matrix[i<span class="number">-1</span>][:<span class="number">-1</span>]</span><br><span class="line">               <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(matrix)))</span><br></pre></td></tr></table></figure>
<h3 id="830-Positions-of-Large-Groups"><a href="#830-Positions-of-Large-Groups" class="headerlink" title="830. Positions of Large Groups"></a>830. Positions of Large Groups</h3><h4 id="根据指定字符串分组，超过三个元素的称为大组，求所有大组的位置。原题"><a href="#根据指定字符串分组，超过三个元素的称为大组，求所有大组的位置。原题" class="headerlink" title="根据指定字符串分组，超过三个元素的称为大组，求所有大组的位置。原题"></a>根据指定字符串分组，超过三个元素的称为大组，求所有大组的位置。<a href="https://leetcode.com/problems/positions-of-large-groups/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abcdddeeeeaabbbcd&quot;</span><br><span class="line">Output: [[3,5],[6,9],[12,14]]</span><br></pre></td></tr></table></figure>
<p>方法一：groupby.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largeGroupPositions</span><span class="params">(self, S: <span class="string">'str'</span>)</span> -&gt; 'List[List[int]]':</span></span><br><span class="line">    groups = itertools.groupby(S)</span><br><span class="line">    index, ans = <span class="number">0</span>, []</span><br><span class="line">    <span class="keyword">for</span> s, group <span class="keyword">in</span> groups:</span><br><span class="line">        count = len(list(group))</span><br><span class="line">        <span class="keyword">if</span> count &gt;= <span class="number">3</span>:</span><br><span class="line">            ans.append([index, index+count<span class="number">-1</span>])</span><br><span class="line">        index += count</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>方法二：two pointers.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largeGroupPositions</span><span class="params">(self, S: <span class="string">'str'</span>)</span> -&gt; 'List[List[int]]':</span></span><br><span class="line">    i = <span class="number">0</span> <span class="comment"># start of each group</span></span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(S)):</span><br><span class="line">        <span class="keyword">if</span> j == len(S)<span class="number">-1</span> <span class="keyword">or</span> S[j] != S[j+<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">if</span> j - i &gt;= <span class="number">2</span>:</span><br><span class="line">                ans.append([i, j])</span><br><span class="line">            i = j + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="832-Flipping-an-Image"><a href="#832-Flipping-an-Image" class="headerlink" title="832. Flipping an Image"></a>832. Flipping an Image</h3><h4 id="水平翻转一张图片并反转-invert-原题"><a href="#水平翻转一张图片并反转-invert-原题" class="headerlink" title="水平翻转一张图片并反转(invert). 原题"></a>水平翻转一张图片并反转(invert). <a href="https://leetcode.com/problems/flipping-an-image/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,1,0],[1,0,1],[0,0,0]]</span><br><span class="line">Output: [[1,0,0],[0,1,0],[1,1,1]]</span><br><span class="line">Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].</span><br><span class="line">Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flipAndInvertImage</span><span class="params">(self, A: <span class="string">'List[List[int]]'</span>)</span> -&gt; 'List[List[int]]':</span></span><br><span class="line">    <span class="keyword">return</span> [[x ^ <span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> reversed(row)] <span class="keyword">for</span> row <span class="keyword">in</span> A]</span><br></pre></td></tr></table></figure>
<h3 id="840-Magic-Squares-In-Grid"><a href="#840-Magic-Squares-In-Grid" class="headerlink" title="840. Magic Squares In Grid"></a>840. Magic Squares In Grid</h3><h4 id="找出grid中数独的个数。原题"><a href="#找出grid中数独的个数。原题" class="headerlink" title="找出grid中数独的个数。原题"></a>找出grid中数独的个数。<a href="https://leetcode.com/problems/magic-squares-in-grid/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Input: [[4,3,8,4],</span><br><span class="line">        [9,5,1,9],</span><br><span class="line">        [2,7,6,2]]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: </span><br><span class="line">The following subgrid is a 3 x 3 magic square:</span><br><span class="line">438</span><br><span class="line">951</span><br><span class="line">276</span><br><span class="line"></span><br><span class="line">while this one is not:</span><br><span class="line">384</span><br><span class="line">519</span><br><span class="line">762</span><br><span class="line"></span><br><span class="line">In total, there is only one magic square inside the given grid.</span><br></pre></td></tr></table></figure>
<p>方法一：Brute Force.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numMagicSquaresInside</span><span class="params">(self, grid: <span class="string">'List[List[int]]'</span>)</span> -&gt; 'int':</span></span><br><span class="line">    digits = set(range(<span class="number">1</span>, <span class="number">10</span>))</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_sudoku</span><span class="params">(matrix)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> matrix[<span class="number">1</span>][<span class="number">1</span>] != <span class="number">5</span>:   <span class="comment"># for optimization</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> set(sum(matrix, [])) != digits:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> &#123;sum(row) <span class="keyword">for</span> row <span class="keyword">in</span> matrix&#125; != &#123;<span class="number">15</span>&#125;:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> &#123;sum(col) <span class="keyword">for</span> col <span class="keyword">in</span> zip(*matrix)&#125; != &#123;<span class="number">15</span>&#125;:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> matrix[<span class="number">0</span>][<span class="number">0</span>] + matrix[<span class="number">1</span>][<span class="number">1</span>] + matrix[<span class="number">2</span>][<span class="number">2</span>] != <span class="number">15</span> <span class="keyword">or</span> \</span><br><span class="line">           matrix[<span class="number">2</span>][<span class="number">0</span>] + matrix[<span class="number">1</span>][<span class="number">1</span>] + matrix[<span class="number">0</span>][<span class="number">2</span>] != <span class="number">15</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)<span class="number">-2</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])<span class="number">-2</span>):</span><br><span class="line">            matrix = [rows[j:j+<span class="number">3</span>] <span class="keyword">for</span> rows <span class="keyword">in</span> grid[i:i+<span class="number">3</span>]]</span><br><span class="line">            <span class="comment"># print(matrix)</span></span><br><span class="line">            <span class="keyword">if</span> is_sudoku(matrix):</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>方法二：参考了大神的解法。外层循环中只把左上角的点传入子方法进行判断，并在外循环判断中心点是否为5；</p>
<p>另外一个规律就是，满足条件数独的9宫格中，4个角都是偶数，4个边都是奇数，并且沿着一个方向必然是’43816729’的正序或者倒序。所以当左上角为偶数时，并满足顺序要求，另两个条件也自然满足了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numMagicSquaresInside</span><span class="params">(self, g: <span class="string">'List[List[int]]'</span>)</span> -&gt; 'int':</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_sudoku</span><span class="params">(i, j)</span>:</span></span><br><span class="line">        <span class="comment"># clockwise begin i, j</span></span><br><span class="line">        s = <span class="string">''</span>.join(str(g[i + x//<span class="number">3</span>][j + x%<span class="number">3</span>])</span><br><span class="line">                    <span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">3</span>))</span><br><span class="line">        <span class="keyword">return</span> g[i][j] &amp; <span class="number">1</span> == <span class="number">0</span> <span class="keyword">and</span> (</span><br><span class="line">            s <span class="keyword">in</span> <span class="string">'43816729'</span>*<span class="number">2</span> <span class="keyword">or</span> s <span class="keyword">in</span> <span class="string">'43816729'</span>[::<span class="number">-1</span>]*<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum(is_sudoku(i, j) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(g)<span class="number">-2</span>)</span><br><span class="line">               <span class="keyword">for</span> j <span class="keyword">in</span> range(len(g[<span class="number">0</span>])<span class="number">-2</span>) <span class="keyword">if</span> g[i+<span class="number">1</span>][j+<span class="number">1</span>] == <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<h3 id="849-Maximize-Distance-to-Closest-Person"><a href="#849-Maximize-Distance-to-Closest-Person" class="headerlink" title="849. Maximize Distance to Closest Person"></a>849. Maximize Distance to Closest Person</h3><h4 id="一排电影院座位，离人的最远距离。数组中必含有一个1和0。原题"><a href="#一排电影院座位，离人的最远距离。数组中必含有一个1和0。原题" class="headerlink" title="一排电影院座位，离人的最远距离。数组中必含有一个1和0。原题"></a>一排电影院座位，离人的最远距离。数组中必含有一个1和0。<a href="https://leetcode.com/problems/maximize-distance-to-closest-person/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,0,0,0,1,0,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line">If Alex sits in the second open seat (seats[2]), then the closest person has distance 2.</span><br><span class="line">If Alex sits in any other open seat, the closest person has distance 1.</span><br><span class="line">Thus, the maximum distance to the closest person is 2.</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法一：groupby。需要注意两个地方：一个是group是一个生成器，必须转成list才可以求长度；另一个地方是<code>reversed(seats)</code>也是一个生成器，所以这里要用切片。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxDistToClosest</span><span class="params">(self, seats: <span class="string">'List[int]'</span>)</span> -&gt; 'int':</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    groups = itertools.groupby(seats)</span><br><span class="line">    <span class="keyword">for</span> seat, group <span class="keyword">in</span> groups:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> seat:</span><br><span class="line">            ans = max(ans, (len(list(group))+<span class="number">1</span>) // <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> max(ans, seats.index(<span class="number">1</span>), seats[::<span class="number">-1</span>].index(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>方法二：two pointers. 在第一个1出现之前长度都是j。直到第二个1出现时，计算方式变为平均数。这里使用<code>i = j + 1</code>而不是<code>i = j</code>是因为有根据i判断的条件，在计算平均距离时又将其加了回来。最后的<code>len(seats)-i</code>是为了<code>[1, 0, 0, 0]</code>末尾的0作结算。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxDistToClosest</span><span class="params">(self, seats: <span class="string">'List[int]'</span>)</span> -&gt; 'int':</span></span><br><span class="line">    ans = i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(seats)):</span><br><span class="line">        <span class="comment"># print(j, i, ans)</span></span><br><span class="line">        <span class="keyword">if</span> seats[j] == <span class="number">1</span>:</span><br><span class="line">            dis = (j - i + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                dis = j    </span><br><span class="line">            ans = max(ans, dis)</span><br><span class="line">            i = j + <span class="number">1</span></span><br><span class="line">    <span class="comment"># print(ans)</span></span><br><span class="line">    <span class="keyword">return</span> max(ans, len(seats)-i)</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法三：方法二的简洁写法。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxDistToClosest</span><span class="params">(self, seats: <span class="string">'List[int]'</span>)</span> -&gt; 'int':</span></span><br><span class="line">    ans = i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(seats)):</span><br><span class="line">        <span class="keyword">if</span> seats[j] == <span class="number">1</span>:</span><br><span class="line">            ans = max(ans, ((j-i+<span class="number">1</span>)//<span class="number">2</span>, j)[i==<span class="number">0</span>])</span><br><span class="line">            i = j + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> max(ans, len(seats)-i)</span><br></pre></td></tr></table></figure>
<h3 id="867-Transpose-Matrix"><a href="#867-Transpose-Matrix" class="headerlink" title="867. Transpose Matrix"></a>867. Transpose Matrix</h3><h4 id="转置矩阵。原题"><a href="#转置矩阵。原题" class="headerlink" title="转置矩阵。原题"></a>转置矩阵。<a href="https://leetcode.com/problems/transpose-matrix/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">Output: [[1,4,7],[2,5,8],[3,6,9]]</span><br></pre></td></tr></table></figure>
<p>方法一：zip。 这里testcase并没有检测其中的元素是否为list。所以不需要转换。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transpose</span><span class="params">(self, A: <span class="string">'List[List[int]]'</span>)</span> -&gt; 'List[List[int]]':</span></span><br><span class="line">    <span class="keyword">return</span> list(zip(*A))</span><br></pre></td></tr></table></figure>
<p>方法二：zip原理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transpose</span><span class="params">(self, A: <span class="string">'List[List[int]]'</span>)</span> -&gt; 'List[List[int]]':</span></span><br><span class="line">    <span class="keyword">return</span> list(map(<span class="keyword">lambda</span> *arg: arg, *A))</span><br></pre></td></tr></table></figure>
<p>方法三：列表生成式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transpose</span><span class="params">(self, A: <span class="string">'List[List[int]]'</span>)</span> -&gt; 'List[List[int]]':</span></span><br><span class="line">    <span class="keyword">return</span> [[A[i][j] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A))]</span><br><span class="line">           <span class="keyword">for</span> j <span class="keyword">in</span> range(len(A[<span class="number">0</span>]))]</span><br></pre></td></tr></table></figure>
<p>方法四：numpy.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transpose</span><span class="params">(self, A)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">    <span class="keyword">return</span> np.transpose(A).tolist()</span><br></pre></td></tr></table></figure>
<h3 id="888-Fair-Candy-Swap"><a href="#888-Fair-Candy-Swap" class="headerlink" title="888. Fair Candy Swap"></a>888. Fair Candy Swap</h3><h4 id="公平的糖果交换。两个人有很多糖果酒吧，交换其中一间使，糖果相同，可能有多个答案，返回任意一个。原题"><a href="#公平的糖果交换。两个人有很多糖果酒吧，交换其中一间使，糖果相同，可能有多个答案，返回任意一个。原题" class="headerlink" title="公平的糖果交换。两个人有很多糖果酒吧，交换其中一间使，糖果相同，可能有多个答案，返回任意一个。原题"></a>公平的糖果交换。两个人有很多糖果酒吧，交换其中一间使，糖果相同，可能有多个答案，返回任意一个。<a href="https://leetcode.com/problems/fair-candy-swap/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A &#x3D; [1,1], B &#x3D; [2,2]</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure>
<p>方法一：Solution中的答案。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fairCandySwap</span><span class="params">(self, A: <span class="string">'List[int]'</span>, B: <span class="string">'List[int]'</span>)</span> -&gt; 'List[int]':</span></span><br><span class="line">    diff = (sum(B) - sum(A)) // <span class="number">2</span></span><br><span class="line">    set_b = set(B)</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> A:</span><br><span class="line">        <span class="keyword">if</span> diff + a <span class="keyword">in</span> set_b:</span><br><span class="line">            <span class="keyword">return</span> a, diff + a</span><br></pre></td></tr></table></figure>
<h3 id="896-Monotonic-Array"><a href="#896-Monotonic-Array" class="headerlink" title="896. Monotonic Array"></a>896. Monotonic Array</h3><h4 id="判断一个数组是不是单调递增或递减。原题"><a href="#判断一个数组是不是单调递增或递减。原题" class="headerlink" title="判断一个数组是不是单调递增或递减。原题"></a>判断一个数组是不是单调递增或递减。<a href="https://leetcode.com/problems/monotonic-array/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,2,3]</span><br><span class="line">Output: true</span><br><span class="line"></span><br><span class="line">Input: [6,5,4,4]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法一：迭代两次。但是由于是生成器，平均效率比下面要高。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isMonotonic</span><span class="params">(self, A: <span class="string">'List[int]'</span>)</span> -&gt; 'bool':</span></span><br><span class="line">    <span class="keyword">return</span> all(A[i] &lt;= A[i+<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)<span class="number">-1</span>)) <span class="keyword">or</span> \</span><br><span class="line">           all(A[i] &gt;= A[i+<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)<span class="number">-1</span>))</span><br></pre></td></tr></table></figure>
<p>方法二：迭代一次。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isMonotonic</span><span class="params">(self, A: <span class="string">'List[int]'</span>)</span> -&gt; 'bool':</span></span><br><span class="line">    increasing = decreasing = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> A[i+<span class="number">1</span>] &gt; A[i]:</span><br><span class="line">            decreasing = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> A[i+<span class="number">1</span>] &lt; A[i]:</span><br><span class="line">            increasing = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> decreasing <span class="keyword">and</span> <span class="keyword">not</span> increasing:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>方法三：python2的一种写法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isMonotonic</span><span class="params">(self, A)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">not</span> &#123;cmp(i, j) <span class="keyword">for</span> i, j <span class="keyword">in</span> zip(A, A[<span class="number">1</span>:])&#125; &gt;= &#123;<span class="number">1</span>, <span class="number">-1</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="977-Squares-of-a-Sorted-Array"><a href="#977-Squares-of-a-Sorted-Array" class="headerlink" title="977. Squares of a Sorted Array"></a>977. Squares of a Sorted Array</h3><h4 id="求一个有序数组，平方后的有序结果。原题"><a href="#求一个有序数组，平方后的有序结果。原题" class="headerlink" title="求一个有序数组，平方后的有序结果。原题"></a>求一个有序数组，平方后的有序结果。<a href="https://leetcode.com/problems/squares-of-a-sorted-array/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [-4,-1,0,3,10]</span><br><span class="line">Output: [0,1,9,16,100]</span><br></pre></td></tr></table></figure>
<p>方法一：双指针填充数组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortedSquares</span><span class="params">(self, A: <span class="string">'List[int]'</span>)</span> -&gt; 'List[int]':</span></span><br><span class="line">    answer = [<span class="number">0</span>] * len(A)</span><br><span class="line">    l, r = <span class="number">0</span>, len(A) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">        left, right = abs(A[l]), abs(A[r])</span><br><span class="line">        <span class="keyword">if</span> left &gt; right:</span><br><span class="line">            answer[r - l] = left * left</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            answer[r - l] = right * right</span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure>
<h3 id="941-Valid-Mountain-Array"><a href="#941-Valid-Mountain-Array" class="headerlink" title="941. Valid Mountain Array"></a>941. Valid Mountain Array</h3><h4 id="验证是否是山峰数组，前段单调增（不重复），后段单调减，必须是单峰值。原题"><a href="#验证是否是山峰数组，前段单调增（不重复），后段单调减，必须是单峰值。原题" class="headerlink" title="验证是否是山峰数组，前段单调增（不重复），后段单调减，必须是单峰值。原题"></a>验证是否是山峰数组，前段单调增（不重复），后段单调减，必须是单峰值。<a href="https://leetcode.com/problems/valid-mountain-array/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,3,2,1]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p>方法一：传统迭代方式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validMountainArray</span><span class="params">(self, A: <span class="string">'List[int]'</span>)</span> -&gt; 'bool':</span></span><br><span class="line">    increasing = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> A[i] == A[i+<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> A[i] &gt; A[i+<span class="number">1</span>]:</span><br><span class="line">            increasing = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> increasing <span class="keyword">and</span> (A[i] &lt; A[i+<span class="number">1</span>] <span class="keyword">or</span> i ==<span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> i == len(A)<span class="number">-2</span> <span class="keyword">and</span> increasing:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> len(A) &gt;= <span class="number">3</span></span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：这个方法挺新颖，根据值来递增索引。中途暂停一下判断峰值是否在首位点。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validMountainArray</span><span class="params">(self, A: <span class="string">'List[int]'</span>)</span> -&gt; 'bool':</span></span><br><span class="line">    l, r = <span class="number">0</span>, len(A)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> A[l] &lt; A[l+<span class="number">1</span>]:</span><br><span class="line">        l += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> l==<span class="number">0</span> <span class="keyword">or</span> l == r:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> A[l] &gt; A[l+<span class="number">1</span>]:</span><br><span class="line">        l += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> l == r</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法三：Lee神的双指针，想象两个人同时从左右两边爬山，最终是否相遇在一点。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validMountainArray</span><span class="params">(self, A: <span class="string">'List[int]'</span>)</span> -&gt; 'bool':</span></span><br><span class="line">    l, r, n = <span class="number">0</span>, len(A)<span class="number">-1</span>, len(A)</span><br><span class="line">    <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> A[l] &lt; A[l+<span class="number">1</span>]: l += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> r &gt; <span class="number">0</span> <span class="keyword">and</span> A[r] &lt; A[r<span class="number">-1</span>]: r -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt; l==r &lt; n<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="845-Longest-Mountain-in-Array"><a href="#845-Longest-Mountain-in-Array" class="headerlink" title="845. Longest Mountain in Array"></a><a href="https://leetcode.com/problems/longest-mountain-in-array/" target="_blank" rel="noopener">845. Longest Mountain in Array</a></h3><h4 id="数组中最长的山峰。题和字符串篇821一样的解法。"><a href="#数组中最长的山峰。题和字符串篇821一样的解法。" class="headerlink" title="数组中最长的山峰。题和字符串篇821一样的解法。"></a>数组中最长的山峰。题和字符串篇821一样的解法。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,1,4,7,3,2,5]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The largest mountain is [1,4,7,3,2] which has length 5.</span><br></pre></td></tr></table></figure>
<p>方法一：左右各遍历一次。此题有很多相似题都有这个解法。53 Maximum Subarray，121 Best Time to Buy and Sell Stock，152 Maximum Product Subarray，238 Product of Array Except Self，739 Daily Temperatures，769 Max Chunks to Make Sorted，770 Max Chunks to Make Sorted II，821 Shortest Distance to a Character，845 Longest Mountain in Array</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestMountain</span><span class="params">(self, A: List[int])</span> -&gt; int:</span></span><br><span class="line">    N = len(A)</span><br><span class="line">    left = [<span class="number">0</span>] * N</span><br><span class="line">    right = [<span class="number">0</span>] * N</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N):</span><br><span class="line">        <span class="keyword">if</span> A[i] &gt; A[i<span class="number">-1</span>]:</span><br><span class="line">            left[i] += left[i<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N<span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>): </span><br><span class="line">        <span class="keyword">if</span> A[i] &lt; A[i<span class="number">-1</span>]:</span><br><span class="line">            right[i<span class="number">-1</span>] += right[i] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max((l+r+<span class="number">1</span> <span class="keyword">for</span> l, r <span class="keyword">in</span> zip(left, right) <span class="keyword">if</span> l <span class="keyword">and</span> r), default=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：时间复杂度还可以优化，空间可以降到O(1)， 一次遍历。使用两个数字来表示上坡和下坡，当有下拨并且再次上坡时，或者相等的时候重置up,down为0。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestMountain</span><span class="params">(self, A: List[int])</span> -&gt; int:</span></span><br><span class="line">    res = up = down = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(A)):</span><br><span class="line">        <span class="keyword">if</span> down <span class="keyword">and</span> A[i]&gt;A[i<span class="number">-1</span>] <span class="keyword">or</span> A[i]==A[i<span class="number">-1</span>]:</span><br><span class="line">            up = down = <span class="number">0</span></span><br><span class="line">        up += A[i] &gt; A[i<span class="number">-1</span>]</span><br><span class="line">        down += A[i] &lt; A[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> up <span class="keyword">and</span> down: res = max(res, up+down+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="942-DI-String-Match"><a href="#942-DI-String-Match" class="headerlink" title="942. DI String Match"></a>942. DI String Match</h3><h4 id="根据一个”IDID”字符串（I表示增加，D表示减少）生成一个数组，数组元素不能重复，答案不唯一。原题"><a href="#根据一个”IDID”字符串（I表示增加，D表示减少）生成一个数组，数组元素不能重复，答案不唯一。原题" class="headerlink" title="根据一个”IDID”字符串（I表示增加，D表示减少）生成一个数组，数组元素不能重复，答案不唯一。原题"></a>根据一个”IDID”字符串（I表示增加，D表示减少）生成一个数组，数组元素不能重复，答案不唯一。<a href="https://leetcode.com/problems/di-string-match/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;IDID&quot;</span><br><span class="line">Output: [0,4,1,3,2]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diStringMatch</span><span class="params">(self, S: <span class="string">'str'</span>)</span> -&gt; 'List[int]':</span></span><br><span class="line">    l = r = <span class="number">0</span></span><br><span class="line">    ans = [<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> S:</span><br><span class="line">        <span class="keyword">if</span> s == <span class="string">'I'</span>:</span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">            ans.append(r)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l -= <span class="number">1</span></span><br><span class="line">            ans.append(l)</span><br><span class="line">    <span class="keyword">return</span> [x-l <span class="keyword">for</span> x <span class="keyword">in</span> ans]</span><br></pre></td></tr></table></figure>
<h3 id="1007-Minimum-Domino-Rotations-For-Equal-Row"><a href="#1007-Minimum-Domino-Rotations-For-Equal-Row" class="headerlink" title="1007. Minimum Domino Rotations For Equal Row"></a>1007. Minimum Domino Rotations For Equal Row</h3><h4 id="旋转最小次，是上下的多米诺骨牌有一行全部相同。原题"><a href="#旋转最小次，是上下的多米诺骨牌有一行全部相同。原题" class="headerlink" title="旋转最小次，是上下的多米诺骨牌有一行全部相同。原题"></a>旋转最小次，是上下的多米诺骨牌有一行全部相同。<a href="https://leetcode.com/problems/minimum-domino-rotations-for-equal-row/" target="_blank" rel="noopener">原题</a></h4>
<p>方法一：竞赛时写的Brute Force.当时觉得炒鸡硬核。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minDominoRotations</span><span class="params">(self, A: List[int], B: List[int])</span> -&gt; int:</span></span><br><span class="line">    ans = reduce(<span class="keyword">lambda</span> x, y: set(x) &amp; set(y), zip(A, B))</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ans:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        a = set(ans).pop()</span><br><span class="line">        dul = sum(a==c==d <span class="keyword">for</span> c, d <span class="keyword">in</span> zip(A, B))</span><br><span class="line">        <span class="keyword">return</span> min(A.count(a), B.count(a)) - dul</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：Lee神的方法。有个地方想错了，想要算出重复的值，实际上就是求非目标值的最小值就行了。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minDominoRotations</span><span class="params">(self, A: List[int], B: List[int])</span> -&gt; int:</span></span><br><span class="line">    ans = reduce(<span class="keyword">lambda</span> x, y: x &amp; y, map(set, zip(A, B)))</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ans:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        a = ans.pop()</span><br><span class="line">        <span class="keyword">return</span> min(len(A)-A.count(a), len(B)-B.count(a))</span><br></pre></td></tr></table></figure>
<h3 id="48-Rotate-Image"><a href="#48-Rotate-Image" class="headerlink" title="48. Rotate Image"></a>48. Rotate Image</h3><h4 id="矩阵顺时针旋转90度。原题"><a href="#矩阵顺时针旋转90度。原题" class="headerlink" title="矩阵顺时针旋转90度。原题"></a>矩阵顺时针旋转90度。<a href="https://leetcode.com/problems/rotate-image/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Given input matrix &#x3D; </span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">rotate the input matrix in-place such that it becomes:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>方法一：使用zip。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">	matrix[:] = list(zip(*reversed(matrix)))</span><br></pre></td></tr></table></figure>
<p>方法二：通用写法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    matrix.reverse()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(matrix[<span class="number">0</span>])):</span><br><span class="line">            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]</span><br></pre></td></tr></table></figure>
<p>方法三：找到四个点，直接互换。</p>
<img src="/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%95%B0%E7%BB%84%E7%AF%87%EF%BC%89Array/rotate_img.png" class width="300" height="200">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, A: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    n = len(A)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n//<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n-n//<span class="number">2</span>):</span><br><span class="line">            A[i][j], A[~j][i], A[~i][~j], A[j][~i] = \</span><br><span class="line">                     A[~j][i], A[~i][~j], A[j][~i], A[i][j]</span><br></pre></td></tr></table></figure>
<h3 id="1020-Partition-Array-Into-Three-Parts-With-Equal-Sum"><a href="#1020-Partition-Array-Into-Three-Parts-With-Equal-Sum" class="headerlink" title="1020. Partition Array Into Three Parts With Equal Sum"></a>1020. Partition Array Into Three Parts With Equal Sum</h3><h4 id="一个数组是否可以分成三个和相同的部分。原题"><a href="#一个数组是否可以分成三个和相同的部分。原题" class="headerlink" title="一个数组是否可以分成三个和相同的部分。原题"></a>一个数组是否可以分成三个和相同的部分。<a href="https://leetcode.com/problems/partition-array-into-three-parts-with-equal-sum/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,2,1,-6,6,-7,9,1,2,0,1]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 0 + 2 + 1 &#x3D; -6 + 6 - 7 + 9 + 1 &#x3D; 2 + 0 + 1</span><br></pre></td></tr></table></figure>
<p>方法一：竞赛时写的Time: O(n²)的方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canThreePartsEqualSum</span><span class="params">(self, A: List[int])</span> -&gt; bool:</span></span><br><span class="line">    a = list(itertools.accumulate(A))</span><br><span class="line">    n, a_set = len(a), set(a)</span><br><span class="line">    <span class="keyword">for</span> i, total <span class="keyword">in</span> enumerate(a):</span><br><span class="line">        <span class="keyword">if</span> total==a[<span class="number">-1</span>]//<span class="number">3</span> <span class="keyword">and</span> total*<span class="number">2</span> <span class="keyword">in</span> a_set:</span><br><span class="line">            <span class="keyword">if</span> n<span class="number">-1</span>-a[::<span class="number">-1</span>].index(total*<span class="number">2</span>) &gt; i:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：其实不需要遍历。每部分的和可以通过总和/3得到。比如每部分和为3，只要找到3和6，并且3在6的左边。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canThreePartsEqualSum</span><span class="params">(self, A: List[int])</span> -&gt; bool:</span></span><br><span class="line">    a = list(itertools.accumulate(A))</span><br><span class="line">    total = sum(A)</span><br><span class="line">    <span class="keyword">if</span> total % <span class="number">3</span> != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    one = total // <span class="number">3</span></span><br><span class="line">    two = one * <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> one <span class="keyword">in</span> a:</span><br><span class="line">        l_index = a.index(one)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> two <span class="keyword">in</span> a[l_index:]:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="1021-Best-Sightseeing-Pair"><a href="#1021-Best-Sightseeing-Pair" class="headerlink" title="1021. Best Sightseeing Pair"></a>1021. Best Sightseeing Pair</h3><h4 id="得分最高的两个景点。原题"><a href="#得分最高的两个景点。原题" class="headerlink" title="得分最高的两个景点。原题"></a>得分最高的两个景点。<a href="https://leetcode.com/problems/best-sightseeing-pair/" target="_blank" rel="noopener">原题</a></h4><p>两个景点之间有距离。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [8,1,5,2,6]</span><br><span class="line">Output: 11</span><br><span class="line">Explanation: i &#x3D; 0, j &#x3D; 2, A[i] + A[j] + i - j &#x3D; 8 + 5 + 0 - 2 &#x3D; 11</span><br></pre></td></tr></table></figure>
<p>方法一：<code>cur</code>保存着一个上一次最好的景点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxScoreSightseeingPair</span><span class="params">(self, A: List[int])</span> -&gt; int:</span></span><br><span class="line">    cur = res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> A:</span><br><span class="line">        res = max(res, cur + a)</span><br><span class="line">        cur = max(cur, a) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="56-Merge-Intervals"><a href="#56-Merge-Intervals" class="headerlink" title="56. Merge Intervals"></a>56. Merge Intervals</h3><h4 id="合并时间段。如果时间段有重叠，则将其合并成一个。原题"><a href="#合并时间段。如果时间段有重叠，则将其合并成一个。原题" class="headerlink" title="合并时间段。如果时间段有重叠，则将其合并成一个。原题"></a>合并时间段。如果时间段有重叠，则将其合并成一个。<a href="https://leetcode.com/problems/merge-intervals/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">Output: [[1,6],[8,10],[15,18]]</span><br><span class="line">Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].</span><br></pre></td></tr></table></figure>
<p>方法一：先排序，在根据条件判断是合并还是修改。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class Interval:</span></span><br><span class="line"><span class="comment">#     def __init__(self, s=0, e=0):</span></span><br><span class="line"><span class="comment">#         self.start = s</span></span><br><span class="line"><span class="comment">#         self.end = e</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, intervals: List[Interval])</span> -&gt; List[Interval]:</span></span><br><span class="line">        intervals.sort(key=operator.attrgetter(<span class="string">'start'</span>))</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> interval <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ans <span class="keyword">or</span> ans[<span class="number">-1</span>].end &lt; interval.start:</span><br><span class="line">                ans.append(interval)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans[<span class="number">-1</span>].end = max(ans[<span class="number">-1</span>].end, interval.end)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="57-Insert-Interval"><a href="#57-Insert-Interval" class="headerlink" title="57. Insert Interval"></a>57. Insert Interval</h3><h4 id="有一个排好序的时间段，并且没有重复，现在有一个新的段，要求插入其中，如果有重合需要合并。原题"><a href="#有一个排好序的时间段，并且没有重复，现在有一个新的段，要求插入其中，如果有重合需要合并。原题" class="headerlink" title="有一个排好序的时间段，并且没有重复，现在有一个新的段，要求插入其中，如果有重合需要合并。原题"></a>有一个排好序的时间段，并且没有重复，现在有一个新的段，要求插入其中，如果有重合需要合并。<a href="https://leetcode.com/problems/insert-interval/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval &#x3D; [4,8]</span><br><span class="line">Output: [[1,2],[3,10],[12,16]]</span><br><span class="line">Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].</span><br></pre></td></tr></table></figure>
<p>方法一：用56的方法合并，使用二分法将其插入。140ms。这题本来想用二分法找到索引，然后前后切片做，后来发现边界太多不好判断，还是从头到尾遍历一遍比较稳。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, inter: List[List[int]], newInterval: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    n = len(inter)</span><br><span class="line">    i = bisect.insort(inter, [*newInterval])</span><br><span class="line">    <span class="comment"># print(inter, i)</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">or</span> stack[<span class="number">-1</span>][<span class="number">1</span>] &lt; inter[j][<span class="number">0</span>]:</span><br><span class="line">            stack.append(inter[j])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stack[<span class="number">-1</span>][<span class="number">1</span>] = max(stack[<span class="number">-1</span>][<span class="number">1</span>], inter[j][<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> stack</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：stefan的方法1，我改了点，条件语句改成长度比较了。启发1，用长度记录索引，简洁明了。72ms</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, inter: List[List[int]], newInterval: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    s, e = newInterval</span><br><span class="line">    left = [i <span class="keyword">for</span> i <span class="keyword">in</span> inter <span class="keyword">if</span> i[<span class="number">1</span>] &lt; s]</span><br><span class="line">    right = [i <span class="keyword">for</span> i <span class="keyword">in</span> inter <span class="keyword">if</span> i[<span class="number">0</span>] &gt; e]</span><br><span class="line">    <span class="keyword">if</span> len(left) + len(right) != len(inter):</span><br><span class="line">        s = min(s, inter[len(left)][<span class="number">0</span>])</span><br><span class="line">        e = max(e, inter[~len(right)][<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> left + [[s, e]] + right</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法三：stefan的方法2，和方法二思路一样，写法上不同。right里添加时索引是-1。还有一种一次遍历的实现就是每次都求一下s, e。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, inter: List[List[int]], newInterval: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    s, e = newInterval</span><br><span class="line">    parts = merge, left, right = [], [], []</span><br><span class="line">    <span class="keyword">for</span> start, end <span class="keyword">in</span> inter:</span><br><span class="line">        parts[(end&lt;s) - (start&gt;e)].append((start, end))</span><br><span class="line">    <span class="keyword">if</span> merge:</span><br><span class="line">        s = min(s, merge[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">        e = max(e, merge[<span class="number">-1</span>][<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> left + [[s, e]] + right</span><br></pre></td></tr></table></figure>
<h3 id="1030-Matrix-Cells-in-Distance-Order"><a href="#1030-Matrix-Cells-in-Distance-Order" class="headerlink" title="1030. Matrix Cells in Distance Order"></a>1030. Matrix Cells in Distance Order</h3><h4 id="矩阵坐标距离指定点的排序。原题"><a href="#矩阵坐标距离指定点的排序。原题" class="headerlink" title="矩阵坐标距离指定点的排序。原题"></a>矩阵坐标距离指定点的排序。<a href="https://leetcode.com/problems/matrix-cells-in-distance-order/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: R &#x3D; 2, C &#x3D; 2, r0 &#x3D; 0, c0 &#x3D; 1</span><br><span class="line">Output: [[0,1],[0,0],[1,1],[1,0]]</span><br><span class="line">Explanation: The distances from (r0, c0) to other cells are: [0,1,1,2]</span><br><span class="line">The answer [[0,1],[1,1],[0,0],[1,0]] would also be accepted as correct.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoCitySchedCost</span><span class="params">(self, costs: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    costs.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>]-x[<span class="number">1</span>]) </span><br><span class="line">    <span class="keyword">return</span> sum(i[<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> costs[:len(costs)//<span class="number">2</span>]) + sum(j[<span class="number">1</span>] <span class="keyword">for</span> j <span class="keyword">in</span> costs[len(costs)//<span class="number">2</span>:])</span><br></pre></td></tr></table></figure>
<h3 id="1033-Moving-Stones-Until-Consecutive"><a href="#1033-Moving-Stones-Until-Consecutive" class="headerlink" title="1033. Moving Stones Until Consecutive"></a>1033. Moving Stones Until Consecutive</h3><h4 id="三个石子移到连续的位置，最少和最多需要几步。原题"><a href="#三个石子移到连续的位置，最少和最多需要几步。原题" class="headerlink" title="三个石子移到连续的位置，最少和最多需要几步。原题"></a>三个石子移到连续的位置，最少和最多需要几步。<a href="https://leetcode.com/problems/moving-stones-until-consecutive/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: a &#x3D; 1, b &#x3D; 2, c &#x3D; 5</span><br><span class="line">Output: [1,2]</span><br><span class="line">Explanation: Move the stone from 5 to 3, or move the stone from 5 to 4 to 3.</span><br><span class="line">Input: a &#x3D; 4, b &#x3D; 3, c &#x3D; 2</span><br><span class="line">Output: [0,0]</span><br><span class="line">Explanation: We cannot make any moves.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numMovesStones</span><span class="params">(self, a: int, b: int, c: int)</span> -&gt; List[int]:</span></span><br><span class="line">    a, b, c = sorted((a, b, c))</span><br><span class="line">    <span class="keyword">if</span> c-b==<span class="number">1</span> <span class="keyword">and</span> b-a==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, c-a<span class="number">-2</span></span><br><span class="line">    <span class="keyword">elif</span> c-b&lt;=<span class="number">2</span> <span class="keyword">or</span> b-a&lt;=<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>, c-a<span class="number">-2</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>, c-a<span class="number">-2</span></span><br></pre></td></tr></table></figure>
<h3 id="1051-Height-Checker"><a href="#1051-Height-Checker" class="headerlink" title="1051. Height Checker"></a>1051. Height Checker</h3><h4 id="高度检查。原题"><a href="#高度检查。原题" class="headerlink" title="高度检查。原题"></a>高度检查。<a href="https://leetcode.com/problems/height-checker/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heightChecker</span><span class="params">(self, heights: List[int])</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">return</span> sum(a!=b <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(heights, sorted(heights)))</span><br></pre></td></tr></table></figure>
<h3 id="1052-Grumpy-Bookstore-Owner"><a href="#1052-Grumpy-Bookstore-Owner" class="headerlink" title="1052. Grumpy Bookstore Owner"></a>1052. Grumpy Bookstore Owner</h3><h4 id="这题描述的比较抽象，其实就是一个滑动窗口的问题。原题"><a href="#这题描述的比较抽象，其实就是一个滑动窗口的问题。原题" class="headerlink" title="这题描述的比较抽象，其实就是一个滑动窗口的问题。原题"></a>这题描述的比较抽象，其实就是一个滑动窗口的问题。<a href="https://leetcode.com/problems/grumpy-bookstore-owner/" target="_blank" rel="noopener">原题</a></h4><p>方法一：一开始我用的双端队列，并且使用了compress.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSatisfied</span><span class="params">(self, customers: List[int], grumpy: List[int], X: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">from</span> itertools <span class="keyword">import</span> compress</span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    base_satisfied = sum(compress(customers, map(<span class="keyword">lambda</span> x: x^<span class="number">1</span>, grumpy)))</span><br><span class="line">    q = deque([customers[i] <span class="keyword">if</span> grumpy[i]==<span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span>  <span class="keyword">for</span> i <span class="keyword">in</span> range(X)])</span><br><span class="line">    cur_sum = <span class="number">0</span></span><br><span class="line">    max_sum = cur_sum</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(grumpy)):</span><br><span class="line">        <span class="keyword">if</span> grumpy[i] == <span class="number">1</span>:</span><br><span class="line">            q.append(customers[i])</span><br><span class="line">            cur_sum += q[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            q.append(<span class="number">0</span>)</span><br><span class="line">        cur_sum -= q.popleft()</span><br><span class="line">        max_sum = max(max_sum, cur_sum)</span><br><span class="line">    <span class="keyword">return</span> max_sum + base_satisfied</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：其实不需要双端队列。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSatisfied</span><span class="params">(self, customers: List[int], grumpy: List[int], X: int)</span> -&gt; int:</span></span><br><span class="line">    n = len(grumpy)</span><br><span class="line">    base = sum(c <span class="keyword">for</span> c, g <span class="keyword">in</span> zip(customers, grumpy) <span class="keyword">if</span> g == <span class="number">0</span>)</span><br><span class="line">    max_added = added = sum(c <span class="keyword">for</span> c, g <span class="keyword">in</span> zip(customers, grumpy[:X]) <span class="keyword">if</span> g == <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(X, n):</span><br><span class="line">        added -= customers[i-X] * grumpy[i-X]</span><br><span class="line">        added += customers[i] * grumpy[i]</span><br><span class="line">        max_added = max(max_added, added)</span><br><span class="line">    <span class="keyword">return</span> max_added + base</span><br></pre></td></tr></table></figure>
<h3 id="1139-Largest-1-Bordered-Square"><a href="#1139-Largest-1-Bordered-Square" class="headerlink" title="1139. Largest 1-Bordered Square"></a>1139. Largest 1-Bordered Square</h3><h4 id="最大的以1为边长的正方形。原题"><a href="#最大的以1为边长的正方形。原题" class="headerlink" title="最大的以1为边长的正方形。原题"></a>最大的以1为边长的正方形。<a href="https://leetcode.com/problems/largest-1-bordered-square/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [[1,1,1],[1,0,1],[1,1,1]]</span><br><span class="line">Output: 9</span><br></pre></td></tr></table></figure>
<p>方法一：开始以为像其他小岛问题那样，要回溯延伸。其实此题是暴力法。先对数组进行一个预处理，判断每个点上面和左面连续的1的个数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largest1BorderedSquare</span><span class="params">(self, g: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    R, C = len(g), len(g[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line">    top, left = deepcopy(g), deepcopy(g)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(R):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(C):</span><br><span class="line">            <span class="keyword">if</span> g[i][j]:</span><br><span class="line">                <span class="keyword">if</span> i: top[i][j] = top[i - <span class="number">1</span>][j] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> j: left[i][j] = left[i][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> range(min(R, C), <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(R-w+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(C-w+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> top[i+w<span class="number">-1</span>][j] &gt;= w <span class="keyword">and</span> top[i+w<span class="number">-1</span>][j+w<span class="number">-1</span>] &gt;= w:</span><br><span class="line">                    <span class="keyword">if</span> left[i][j+w<span class="number">-1</span>] &gt;= w <span class="keyword">and</span> left[i+w<span class="number">-1</span>][j+w<span class="number">-1</span>] &gt;= w:</span><br><span class="line">                        <span class="keyword">return</span> w * w</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="1078-Occurrences-After-Bigram"><a href="#1078-Occurrences-After-Bigram" class="headerlink" title="1078. Occurrences After Bigram"></a>1078. Occurrences After Bigram</h3><h4 id="打印第三个单词。原题"><a href="#打印第三个单词。原题" class="headerlink" title="打印第三个单词。原题"></a>打印第三个单词。<a href="https://leetcode.com/problems/occurrences-after-bigram/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: text &#x3D; &quot;alice is a good girl she is a good student&quot;, first &#x3D; &quot;a&quot;, second &#x3D; &quot;good&quot;</span><br><span class="line">Output: [&quot;girl&quot;,&quot;student&quot;]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findOcurrences</span><span class="params">(self, text: str, first: str, second: str)</span> -&gt; List[str]:</span></span><br><span class="line">    words = text.split()</span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(words)<span class="number">-2</span>):</span><br><span class="line">        <span class="keyword">if</span> words[i] == first <span class="keyword">and</span> words[i+<span class="number">1</span>] == second:</span><br><span class="line">            ans.append(words[i+<span class="number">2</span>]) </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="1144-Decrease-Elements-To-Make-Array-Zigzag"><a href="#1144-Decrease-Elements-To-Make-Array-Zigzag" class="headerlink" title="1144. Decrease Elements To Make Array Zigzag"></a>1144. Decrease Elements To Make Array Zigzag</h3><h4 id="每次操作某个元素-1，多少次操作后，可以使数组称为一个zigzag。原题"><a href="#每次操作某个元素-1，多少次操作后，可以使数组称为一个zigzag。原题" class="headerlink" title="每次操作某个元素-1，多少次操作后，可以使数组称为一个zigzag。原题"></a>每次操作某个元素-1，多少次操作后，可以使数组称为一个zigzag。<a href="https://leetcode.com/problems/decrease-elements-to-make-array-zigzag/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [9,6,1,6,2]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>
<p>方法一：暴力的方法。遍历两次。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">movesToMakeZigzag</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    even_sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n, <span class="number">2</span>):</span><br><span class="line">        left = float(<span class="string">'inf'</span>) <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">else</span> nums[i<span class="number">-1</span>]</span><br><span class="line">        right = float(<span class="string">'inf'</span>) <span class="keyword">if</span> i == n<span class="number">-1</span> <span class="keyword">else</span> nums[i+<span class="number">1</span>]</span><br><span class="line">        to_add = nums[i]-min(left, right)+<span class="number">1</span></span><br><span class="line">        even_sum += to_add <span class="keyword">if</span> to_add &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    odd_sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n, <span class="number">2</span>):</span><br><span class="line">        left = float(<span class="string">'inf'</span>) <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">else</span> nums[i<span class="number">-1</span>]</span><br><span class="line">        right = float(<span class="string">'inf'</span>) <span class="keyword">if</span> i == n<span class="number">-1</span> <span class="keyword">else</span> nums[i+<span class="number">1</span>]</span><br><span class="line">        to_min = nums[i]-min(left, right)+<span class="number">1</span></span><br><span class="line">        odd_sum += to_min <span class="keyword">if</span> to_min &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> min(even_sum, odd_sum)</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：利用奇偶性，整合到一次循环。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">movesToMakeZigzag</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    ans = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    ary = [float(<span class="string">'inf'</span>)] + nums + [float(<span class="string">'inf'</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(ary)<span class="number">-1</span>):  </span><br><span class="line">        ans[i % <span class="number">2</span>] += max(<span class="number">0</span>, ary[i]-min(ary[i<span class="number">-1</span>], ary[i+<span class="number">1</span>])+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> min(ans)</span><br></pre></td></tr></table></figure>
<h3 id="1089-Duplicate-Zeros"><a href="#1089-Duplicate-Zeros" class="headerlink" title="1089. Duplicate Zeros"></a>1089. Duplicate Zeros</h3><h4 id="复制数组中的0，数组长度不变，多出的元素将被“挤掉”。要求在原数组上修改。原题"><a href="#复制数组中的0，数组长度不变，多出的元素将被“挤掉”。要求在原数组上修改。原题" class="headerlink" title="复制数组中的0，数组长度不变，多出的元素将被“挤掉”。要求在原数组上修改。原题"></a>复制数组中的0，数组长度不变，多出的元素将被“挤掉”。要求在原数组上修改。<a href="https://leetcode.com/problems/duplicate-zeros/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,0,2,3,0,4,5,0]</span><br><span class="line">Output: null</span><br><span class="line">Explanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4]</span><br></pre></td></tr></table></figure>
<p>方法一：竞赛时的方法，需要注意末尾不要多加0。空间复杂度过高。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">duplicateZeros</span><span class="params">(self, arr: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="comment"># arr_reversed = arr[::-1]</span></span><br><span class="line">    <span class="comment"># ans = []</span></span><br><span class="line">    <span class="comment"># while len(ans) &lt; len(arr):</span></span><br><span class="line">    <span class="comment">#     val = arr_reversed.pop()</span></span><br><span class="line">    <span class="comment">#     if val == 0 and len(ans) &lt; len(arr)-1:</span></span><br><span class="line">    <span class="comment">#         ans.extend([0, 0])</span></span><br><span class="line">    <span class="comment">#     else:</span></span><br><span class="line">    <span class="comment">#         ans.append(val)</span></span><br><span class="line">    <span class="comment"># arr[:] = ans</span></span><br><span class="line">    arr[:] = [x <span class="keyword">for</span> a <span class="keyword">in</span> arr <span class="keyword">for</span> x <span class="keyword">in</span> ([a] <span class="keyword">if</span> a <span class="keyword">else</span> [<span class="number">0</span>, <span class="number">0</span>])][:len(arr)]</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：双指针的O(1)Space。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">duplicateZeros</span><span class="params">(self, arr: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    zero_c = arr.count(<span class="number">0</span>)</span><br><span class="line">    n = len(arr)</span><br><span class="line">    j = n + zero_c - <span class="number">1</span></span><br><span class="line">    i = n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> arr[i] != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> j &lt; n:</span><br><span class="line">                arr[j] = arr[i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> j &lt; n:</span><br><span class="line">                arr[j] = arr[i]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j &lt; n:</span><br><span class="line">                arr[j] = arr[i]</span><br><span class="line">        j -= <span class="number">1</span></span><br><span class="line">        i -= <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="1169-Invalid-Transactions"><a href="#1169-Invalid-Transactions" class="headerlink" title="1169. Invalid Transactions"></a>1169. Invalid Transactions</h3><h4 id="非法交易，单笔金额大于1000，或者60分钟内有异地交易，那么为非法交易。列出所有的非法交易。原题"><a href="#非法交易，单笔金额大于1000，或者60分钟内有异地交易，那么为非法交易。列出所有的非法交易。原题" class="headerlink" title="非法交易，单笔金额大于1000，或者60分钟内有异地交易，那么为非法交易。列出所有的非法交易。原题"></a>非法交易，单笔金额大于1000，或者60分钟内有异地交易，那么为非法交易。列出所有的非法交易。<a href="https://leetcode.com/problems/invalid-transactions/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: transactions &#x3D; [&quot;alice,20,800,mtv&quot;,&quot;alice,50,100,beijing&quot;]</span><br><span class="line">Output: [&quot;alice,20,800,mtv&quot;,&quot;alice,50,100,beijing&quot;]</span><br><span class="line">Explanation: The first transaction is invalid because the second transaction occurs within a difference of 60 minutes, have the same name and is in a different city. Similarly the second one is invalid too.</span><br></pre></td></tr></table></figure>
<p>方法一：暴力法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">invalidTransactions</span><span class="params">(self, transactions: List[str])</span> -&gt; List[str]:</span></span><br><span class="line">    ts = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> transactions:</span><br><span class="line">        name, time, amount, city = line.split(<span class="string">','</span>)</span><br><span class="line">        ts.append((name, time, amount, city))</span><br><span class="line">    city_times = collections.defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> ts:</span><br><span class="line">        city_times[t[<span class="number">0</span>]+<span class="string">','</span>+t[<span class="number">3</span>]].append(int(t[<span class="number">1</span>]))</span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> ts:</span><br><span class="line">        <span class="keyword">if</span> int(t[<span class="number">2</span>]) &gt; <span class="number">1000</span>:</span><br><span class="line">            ans.append(<span class="string">','</span>.join(t))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            diff_cities = (c <span class="keyword">for</span> c <span class="keyword">in</span> city_times.keys() <span class="keyword">if</span> c!=t[<span class="number">0</span>]+<span class="string">','</span>+t[<span class="number">3</span>] <span class="keyword">and</span> c.startswith(t[<span class="number">0</span>]+<span class="string">','</span>))</span><br><span class="line">            <span class="keyword">for</span> d_c <span class="keyword">in</span> diff_cities:</span><br><span class="line">                <span class="keyword">if</span> any(abs(tt-int(t[<span class="number">1</span>])) &lt;= <span class="number">60</span> <span class="keyword">for</span> tt <span class="keyword">in</span> city_times[d_c]):</span><br><span class="line">                    ans.append(<span class="string">','</span>.join(t))</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="1170-Compare-Strings-by-Frequency-of-the-Smallest-Character"><a href="#1170-Compare-Strings-by-Frequency-of-the-Smallest-Character" class="headerlink" title="1170. Compare Strings by Frequency of the Smallest Character"></a>1170. Compare Strings by Frequency of the Smallest Character</h3><h4 id="比较最小字符的频率。原题"><a href="#比较最小字符的频率。原题" class="headerlink" title="比较最小字符的频率。原题"></a>比较最小字符的频率。<a href="https://leetcode.com/problems/compare-strings-by-frequency-of-the-smallest-character/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: queries &#x3D; [&quot;cbd&quot;], words &#x3D; [&quot;zaaaz&quot;]</span><br><span class="line">Output: [1]</span><br><span class="line">Explanation: On the first query we have f(&quot;cbd&quot;) &#x3D; 1, f(&quot;zaaaz&quot;) &#x3D; 3 so f(&quot;cbd&quot;) &lt; f(&quot;zaaaz&quot;).</span><br></pre></td></tr></table></figure>
<p>方法一：暴力法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numSmallerByFrequency</span><span class="params">(self, queries: List[str], words: List[str])</span> -&gt; List[int]:</span></span><br><span class="line">    qq = [q.count(min(q)) <span class="keyword">for</span> q <span class="keyword">in</span> queries]</span><br><span class="line">    ww = [w.count(min(w)) <span class="keyword">for</span> w <span class="keyword">in</span> words]</span><br><span class="line">    <span class="keyword">return</span> [sum(q &lt; w <span class="keyword">for</span> w <span class="keyword">in</span> ww) <span class="keyword">for</span> q <span class="keyword">in</span> qq]</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：二分法</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numSmallerByFrequency</span><span class="params">(self, queries: List[str], words: List[str])</span> -&gt; List[int]:</span></span><br><span class="line">    qq = [q.count(min(q)) <span class="keyword">for</span> q <span class="keyword">in</span> queries]</span><br><span class="line">    ww = [w.count(min(w)) <span class="keyword">for</span> w <span class="keyword">in</span> words]</span><br><span class="line">    ww.sort()</span><br><span class="line">    n = len(ww)</span><br><span class="line">    <span class="keyword">return</span> [n-bisect.bisect_right(ww, q) <span class="keyword">for</span> q <span class="keyword">in</span> qq]</span><br></pre></td></tr></table></figure>
<h3 id="1122-Relative-Sort-Array"><a href="#1122-Relative-Sort-Array" class="headerlink" title="1122. Relative Sort Array"></a>1122. Relative Sort Array</h3><h4 id="按照数组2的相对位置给另一个数组排序。原题"><a href="#按照数组2的相对位置给另一个数组排序。原题" class="headerlink" title="按照数组2的相对位置给另一个数组排序。原题"></a>按照数组2的相对位置给另一个数组排序。<a href="https://leetcode.com/contest/weekly-contest-145/problems/relative-sort-array/" target="_blank" rel="noopener">原题</a></h4><p>方法一：和Lee神写法不谋而合，只不过自己用了乘法，其实加法就可以了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relativeSortArray</span><span class="params">(self, arr1: List[int], arr2: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    index = &#123;d: i <span class="keyword">for</span> i, d <span class="keyword">in</span> enumerate(arr2)&#125;</span><br><span class="line">    <span class="keyword">return</span> sorted(arr1, key=<span class="keyword">lambda</span> x: index.get(x, <span class="number">1000</span>+x))</span><br></pre></td></tr></table></figure>
<h3 id="1176-Diet-Plan-Performance"><a href="#1176-Diet-Plan-Performance" class="headerlink" title="1176. Diet Plan Performance"></a>1176. Diet Plan Performance</h3><h4 id="燃烧你的卡路里，卡路里和体重的关系。原题"><a href="#燃烧你的卡路里，卡路里和体重的关系。原题" class="headerlink" title="燃烧你的卡路里，卡路里和体重的关系。原题"></a>燃烧你的卡路里，卡路里和体重的关系。<a href="https://leetcode.com/problems/diet-plan-performance/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: calories &#x3D; [1,2,3,4,5], k &#x3D; 1, lower &#x3D; 3, upper &#x3D; 3</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: Since k &#x3D; 1, we consider each element of the array separately and compare it to lower and upper.</span><br><span class="line">calories[0] and calories[1] are less than lower so 2 points are lost.</span><br><span class="line">calories[3] and calories[4] are greater than upper so 2 points are gained.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dietPlanPerformance</span><span class="params">(self, calories: List[int], k: int, lower: int, upper: int)</span> -&gt; int:</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    calories.insert(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    cur_sum = sum(calories[:k])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(calories)-k+<span class="number">1</span>):</span><br><span class="line">        cur_sum -= calories[i<span class="number">-1</span>]</span><br><span class="line">        cur_sum += calories[i+k<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> cur_sum &gt; upper:</span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> cur_sum &lt; lower:</span><br><span class="line">            ans -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="1395-Count-Number-of-Teams"><a href="#1395-Count-Number-of-Teams" class="headerlink" title="1395. Count Number of Teams"></a>1395. Count Number of Teams</h3><h4 id="数字分组计数。原题"><a href="#数字分组计数。原题" class="headerlink" title="数字分组计数。原题"></a>数字分组计数。<a href="https://leetcode.com/problems/count-number-of-teams/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: rating &#x3D; [2,5,3,4,1]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: We can form three teams given the conditions. (2,3,4), (5,4,1), (5,3,1).</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numTeams</span><span class="params">(self, rating: List[int])</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">    n = len(rating)</span><br><span class="line">    greater = defaultdict(int)</span><br><span class="line">    less = defaultdict(int)</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> rating[i] &gt; rating[j]:</span><br><span class="line">                less[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                greater[i] += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> rating[i] &gt; rating[j]:</span><br><span class="line">                ans += less[j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans += greater[j]</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="1375-Bulb-Switcher-III"><a href="#1375-Bulb-Switcher-III" class="headerlink" title="1375. Bulb Switcher III"></a>1375. Bulb Switcher III</h3><h4 id="灯泡开关，记录灯泡全部变蓝的次数。原题"><a href="#灯泡开关，记录灯泡全部变蓝的次数。原题" class="headerlink" title="灯泡开关，记录灯泡全部变蓝的次数。原题"></a>灯泡开关，记录灯泡全部变蓝的次数。<a href="https://leetcode.com/problems/bulb-switcher-iii/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: light &#x3D; [2,1,3,5,4]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: All bulbs turned on, are blue at the moment 1, 2 and 4.</span><br></pre></td></tr></table></figure>
<p>方法一：使用堆。其实没必要增加O(n)的空间</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numTimesAllBlue</span><span class="params">(self, light: List[int])</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">import</span> heapq <span class="keyword">as</span> hq</span><br><span class="line">    s = []</span><br><span class="line">    hq.heapify(s)</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, b <span class="keyword">in</span> enumerate(light, <span class="number">1</span>):</span><br><span class="line">        hq.heappush(s, -b)</span><br><span class="line">        <span class="keyword">if</span> -s[<span class="number">0</span>] == i:</span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：只需要维护一个最大值变量即可</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numTimesAllBlue</span><span class="params">(self, light: List[int])</span> -&gt; int:</span></span><br><span class="line">    cur_max = ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, b <span class="keyword">in</span> enumerate(light, <span class="number">1</span>):</span><br><span class="line">        cur_max = max(cur_max, b)</span><br><span class="line">        <span class="keyword">if</span> cur_max == i:</span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法三：一行</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numTimesAllBlue</span><span class="params">(self, light: List[int])</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">return</span> sum(i==b <span class="keyword">for</span> i, b <span class="keyword">in</span> enumerate(itertools.accumulate(light, max), <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<h3 id="498-Diagonal-Traverse"><a href="#498-Diagonal-Traverse" class="headerlink" title="498. Diagonal Traverse"></a>498. Diagonal Traverse</h3><h4 id="对角线z字形遍历。原题"><a href="#对角线z字形遍历。原题" class="headerlink" title="对角线z字形遍历。原题"></a>对角线z字形遍历。<a href="https://leetcode.com/problems/diagonal-traverse/" target="_blank" rel="noopener">原题</a></h4><p>方法一：费劲心思去找i,j的关系，其实只需要知道一点，i和j都是越来越大的就行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findDiagonalOrder</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    dd = collections.defaultdict(list)</span><br><span class="line">    ans = []</span><br><span class="line">    m, n = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            dd[i+j].append(matrix[i][j])</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(m+n<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> k % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            dd[k].reverse()</span><br><span class="line">        ans.extend(dd[k])</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="1424-Diagonal-Traverse-II"><a href="#1424-Diagonal-Traverse-II" class="headerlink" title="1424. Diagonal Traverse II"></a>1424. Diagonal Traverse II</h3><h4 id="对角线遍历，每行长度可能不一样。原题"><a href="#对角线遍历，每行长度可能不一样。原题" class="headerlink" title="对角线遍历，每行长度可能不一样。原题"></a>对角线遍历，每行长度可能不一样。<a href="https://leetcode.com/problems/diagonal-traverse-ii/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findDiagonalOrder</span><span class="params">(self, g: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i, r <span class="keyword">in</span> enumerate(g):</span><br><span class="line">        <span class="keyword">for</span> j, a <span class="keyword">in</span> enumerate(r):</span><br><span class="line">            <span class="keyword">if</span> len(res) &lt;= i + j:</span><br><span class="line">                res.append([])</span><br><span class="line">            res[i + j].append(a)</span><br><span class="line">    <span class="keyword">return</span> [a <span class="keyword">for</span> r <span class="keyword">in</span> res <span class="keyword">for</span> a <span class="keyword">in</span> reversed(r)]</span><br></pre></td></tr></table></figure>
<h3 id="1365-How-Many-Numbers-Are-Smaller-Than-the-Current-Number"><a href="#1365-How-Many-Numbers-Are-Smaller-Than-the-Current-Number" class="headerlink" title="1365. How Many Numbers Are Smaller Than the Current Number"></a>1365. How Many Numbers Are Smaller Than the Current Number</h3><h4 id="数组中比当前数小的个数。原题"><a href="#数组中比当前数小的个数。原题" class="headerlink" title="数组中比当前数小的个数。原题"></a>数组中比当前数小的个数。<a href="https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/" target="_blank" rel="noopener">原题</a></h4><p>方法一：排序。T=O(n*lgn)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smallerNumbersThanCurrent</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    indices = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i, d <span class="keyword">in</span> enumerate(sorted(nums)):</span><br><span class="line">        indices.setdefault(d, i)</span><br><span class="line">    <span class="keyword">return</span> [indices[d] <span class="keyword">for</span> d <span class="keyword">in</span> nums]</span><br></pre></td></tr></table></figure>
<p>方法二：利用了数的范围在1~100之间。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smallerNumbersThanCurrent</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    count = [<span class="number">0</span>] * <span class="number">102</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        count[num+<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">    count = list(itertools.accumulate(count))</span><br><span class="line">    <span class="keyword">return</span> [count[num] <span class="keyword">for</span> num <span class="keyword">in</span> nums]</span><br></pre></td></tr></table></figure>
<h3 id="1366-Rank-Teams-by-Votes"><a href="#1366-Rank-Teams-by-Votes" class="headerlink" title="1366. Rank Teams by Votes"></a>1366. Rank Teams by Votes</h3><h4 id="投票选举。首先按照排名，然后按照字母顺序。原题"><a href="#投票选举。首先按照排名，然后按照字母顺序。原题" class="headerlink" title="投票选举。首先按照排名，然后按照字母顺序。原题"></a>投票选举。首先按照排名，然后按照字母顺序。<a href="https://leetcode.com/problems/rank-teams-by-votes/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: votes &#x3D; [&quot;ABC&quot;,&quot;ACB&quot;,&quot;ABC&quot;,&quot;ACB&quot;,&quot;ACB&quot;]</span><br><span class="line">Output: &quot;ACB&quot;</span><br><span class="line">Explanation: Team A was ranked first place by 5 voters. No other team was voted as first place so team A is the first team.</span><br><span class="line">Team B was ranked second by 2 voters and was ranked third by 3 voters.</span><br><span class="line">Team C was ranked second by 3 voters and was ranked third by 2 voters.</span><br><span class="line">As most of the voters ranked C second, team C is the second team and team B is the third.</span><br><span class="line"></span><br><span class="line">Input: votes &#x3D; [&quot;WXYZ&quot;,&quot;XYZW&quot;]</span><br><span class="line">Output: &quot;XWYZ&quot;</span><br><span class="line">Explanation: X is the winner due to tie-breaking rule. X has same votes as W for the first position but X has one vote as second position while W doesn&#39;t have any votes as second position.</span><br></pre></td></tr></table></figure>
<p>方法一：列举了所有的票数，然后对tuple进行排序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rankTeams</span><span class="params">(self, votes: List[str])</span> -&gt; str:</span></span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> Counter, defaultdict</span><br><span class="line">    cc = defaultdict(<span class="keyword">lambda</span> : [<span class="number">0</span>]*<span class="number">26</span>)</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> zip(*votes):</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> Counter(w).items():</span><br><span class="line">            cc[k][i] = v</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="comment"># print(cc)</span></span><br><span class="line">    cmp = (tuple(p) + (-ord(a), a) <span class="keyword">for</span> a, p <span class="keyword">in</span> cc.items())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(x[<span class="number">-1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> sorted(cmp, reverse=<span class="literal">True</span>))</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：忽略了一个问题，其实每个人都需要对所有人投票。根据第一个来进行初始化。数组同样可以比较大小，无须转化为tuple</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rankTeams</span><span class="params">(self, votes: List[str])</span> -&gt; str:</span></span><br><span class="line">    count = &#123;c: [<span class="number">0</span>] * len(votes[<span class="number">0</span>]) + [c] <span class="keyword">for</span> c <span class="keyword">in</span> votes[<span class="number">0</span>]&#125;</span><br><span class="line">    <span class="keyword">for</span> vote <span class="keyword">in</span> votes:</span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate(vote):</span><br><span class="line">            count[v][i] -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(sorted(votes[<span class="number">0</span>], key=count.get))</span><br></pre></td></tr></table></figure>
<h3 id="1331-Rank-Transform-of-an-Array"><a href="#1331-Rank-Transform-of-an-Array" class="headerlink" title="1331. Rank Transform of an Array"></a>1331. Rank Transform of an Array</h3><h4 id="将数组转化为排行。原题"><a href="#将数组转化为排行。原题" class="headerlink" title="将数组转化为排行。原题"></a>将数组转化为排行。<a href="https://leetcode.com/problems/rank-transform-of-an-array/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [40,10,20,30]</span><br><span class="line">Output: [4,1,2,3]</span><br><span class="line">Explanation: 40 is the largest element. 10 is the smallest. 20 is the second smallest. 30 is the third smallest.</span><br></pre></td></tr></table></figure>
<p>方法一：<code>setdefault</code>的妙用。 by Lee215</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">arrayRankTransform</span><span class="params">(self, arr: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    rank = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> sorted(arr):</span><br><span class="line">        rank.setdefault(a, len(rank)+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> map(rank.get, arr)</span><br></pre></td></tr></table></figure>
<h3 id="1306-Jump-Game-III"><a href="#1306-Jump-Game-III" class="headerlink" title="1306. Jump Game III"></a>1306. Jump Game III</h3><h4 id="跳跃游戏，从start开始，可以沿着value向前向后跳，求是否可以跳到0-原题"><a href="#跳跃游戏，从start开始，可以沿着value向前向后跳，求是否可以跳到0-原题" class="headerlink" title="跳跃游戏，从start开始，可以沿着value向前向后跳，求是否可以跳到0.原题"></a>跳跃游戏，从start开始，可以沿着value向前向后跳，求是否可以跳到0.<a href="https://leetcode.com/problems/jump-game-iii/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [4,2,3,0,3,1,2], start &#x3D; 5</span><br><span class="line">Output: true</span><br><span class="line">Explanation: </span><br><span class="line">All possible ways to reach at index 3 with value 0 are: </span><br><span class="line">index 5 -&gt; index 4 -&gt; index 1 -&gt; index 3 </span><br><span class="line">index 5 -&gt; index 6 -&gt; index 4 -&gt; index 1 -&gt; index 3</span><br></pre></td></tr></table></figure>
<p>方法一：Bfs.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canReach</span><span class="params">(self, arr: List[int], start: int)</span> -&gt; bool:</span></span><br><span class="line">    q, seen = collections.deque([start]), &#123;start&#125;</span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        i = q.popleft()</span><br><span class="line">        <span class="keyword">if</span> arr[i] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> nxt <span class="keyword">in</span> (i-arr[i], i+arr[i]):</span><br><span class="line">            <span class="keyword">if</span> nxt <span class="keyword">not</span> <span class="keyword">in</span> seen <span class="keyword">and</span> <span class="number">0</span>&lt;=nxt&lt;len(arr):</span><br><span class="line">                q.append(nxt)</span><br><span class="line">                seen.add(nxt)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>方法二：数组中元素均为非负数，所以用负数来标记已经跳过的点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canReach</span><span class="params">(self, arr: List[int], i: int)</span> -&gt; bool:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="number">0</span>&lt;=i&lt;len(arr) <span class="keyword">and</span> arr[i]&gt;=<span class="number">0</span>:</span><br><span class="line">        arr[i] = -arr[i]</span><br><span class="line">        <span class="keyword">return</span> arr[i]==<span class="number">0</span> <span class="keyword">or</span> self.canReach(arr, i+arr[i]) <span class="keyword">or</span> self.canReach(arr, i-arr[i])</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="1297-Maximum-Number-of-Occurrences-of-a-Substring"><a href="#1297-Maximum-Number-of-Occurrences-of-a-Substring" class="headerlink" title="1297. Maximum Number of Occurrences of a Substring"></a>1297. Maximum Number of Occurrences of a Substring</h3><h4 id="出现次数最多的子串。滑动窗口可伸缩，最多包含maxLetters个字母。原题"><a href="#出现次数最多的子串。滑动窗口可伸缩，最多包含maxLetters个字母。原题" class="headerlink" title="出现次数最多的子串。滑动窗口可伸缩，最多包含maxLetters个字母。原题"></a>出现次数最多的子串。滑动窗口可伸缩，最多包含maxLetters个字母。<a href="https://leetcode.com/problems/maximum-number-of-occurrences-of-a-substring/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxFreq</span><span class="params">(self, s: str, maxLetters: int, k: int, maxSize: int)</span> -&gt; int:</span></span><br><span class="line">    c = collections.Counter(s[i:i+k] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)-k+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> max([n <span class="keyword">for</span> sub, n <span class="keyword">in</span> c.items() <span class="keyword">if</span> len(set(sub)) &lt;= maxLetters] + [<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<h3 id="1291-Sequential-Digits"><a href="#1291-Sequential-Digits" class="headerlink" title="1291. Sequential Digits"></a>1291. Sequential Digits</h3><h4 id="按序求组区间中的顺子。原题"><a href="#按序求组区间中的顺子。原题" class="headerlink" title="按序求组区间中的顺子。原题"></a>按序求组区间中的顺子。<a href="https://leetcode.com/problems/sequential-digits/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: low &#x3D; 1000, high &#x3D; 13000</span><br><span class="line">Output: [1234,2345,3456,4567,5678,6789,12345]</span><br></pre></td></tr></table></figure>
<p>方法一：开始时用的转化字符串的方式。不优雅，借鉴了他人解法。生成器有个好处是你可以暂时先不关心顺序。因为low&gt;=10，所以一开始不会以9开头。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sequentialDigits</span><span class="params">(self, low: int, high: int)</span> -&gt; List[int]:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">(digit)</span>:</span></span><br><span class="line">        num = digit</span><br><span class="line">        <span class="keyword">while</span> num &lt;= high <span class="keyword">and</span> digit &lt; <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">if</span> num &gt;= low:</span><br><span class="line">                <span class="keyword">yield</span> num</span><br><span class="line">            digit += <span class="number">1</span></span><br><span class="line">            num = num*<span class="number">10</span> + digit</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> sorted(num <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">9</span>) <span class="keyword">for</span> num <span class="keyword">in</span> gen(i))</span><br></pre></td></tr></table></figure>
<h3 id="1275-Find-Winner-on-a-Tic-Tac-Toe-Game"><a href="#1275-Find-Winner-on-a-Tic-Tac-Toe-Game" class="headerlink" title="1275. Find Winner on a Tic Tac Toe Game"></a>1275. Find Winner on a Tic Tac Toe Game</h3><h4 id="三子棋的游戏，谁先连到3个子谁就赢。原题"><a href="#三子棋的游戏，谁先连到3个子谁就赢。原题" class="headerlink" title="三子棋的游戏，谁先连到3个子谁就赢。原题"></a>三子棋的游戏，谁先连到3个子谁就赢。<a href="https://leetcode.com/problems/find-winner-on-a-tic-tac-toe-game/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: moves &#x3D; [[0,0],[2,0],[1,1],[2,1],[2,2]]</span><br><span class="line">Output: &quot;A&quot;</span><br><span class="line">Explanation: &quot;A&quot; wins, he always plays first.</span><br><span class="line">&quot;X  &quot;    &quot;X  &quot;    &quot;X  &quot;    &quot;X  &quot;    &quot;X  &quot;</span><br><span class="line">&quot;   &quot; -&gt; &quot;   &quot; -&gt; &quot; X &quot; -&gt; &quot; X &quot; -&gt; &quot; X &quot;</span><br><span class="line">&quot;   &quot;    &quot;O  &quot;    &quot;O  &quot;    &quot;OO &quot;    &quot;OOX&quot;</span><br></pre></td></tr></table></figure>
<p>方法一：这题是为数不多easy里面想了时间那么长的，除了暴力法没有想到什么思路。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tictactoe</span><span class="params">(self, moves: List[List[int]])</span> -&gt; str:</span></span><br><span class="line">    line = collections.defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> i, (x, y) <span class="keyword">in</span> enumerate(moves):</span><br><span class="line">        p = <span class="string">'A'</span> <span class="keyword">if</span> i&amp;<span class="number">1</span>==<span class="number">0</span> <span class="keyword">else</span> <span class="string">'B'</span> </span><br><span class="line">        xk, yk = <span class="string">'x_&#123;&#125;'</span>.format(x), <span class="string">'y_&#123;&#125;'</span>.format(y)</span><br><span class="line">        line[xk].append(p)</span><br><span class="line">        line[yk].append(p)</span><br><span class="line">        <span class="keyword">if</span> x == y:</span><br><span class="line">            line[<span class="string">'d_0'</span>].append(p)</span><br><span class="line">        <span class="keyword">if</span> x + y == <span class="number">2</span>:</span><br><span class="line">            line[<span class="string">'d_1'</span>].append(p)</span><br><span class="line">        <span class="keyword">if</span> any(len(l)==<span class="number">3</span> <span class="keyword">and</span> len(set(l))==<span class="number">1</span> <span class="keyword">for</span> l <span class="keyword">in</span> (line[xk], line[yk], line[<span class="string">'d_0'</span>], line[<span class="string">'d_1'</span>])):</span><br><span class="line">            <span class="keyword">return</span> p</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Draw'</span> <span class="keyword">if</span> len(moves) == <span class="number">9</span> <span class="keyword">else</span> <span class="string">'Pending'</span></span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：将A, B分为2组，这样比较时更简单一点。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tictactoe</span><span class="params">(self, moves: List[List[int]])</span> -&gt; str:</span></span><br><span class="line">    row, col = [[<span class="number">0</span>] * <span class="number">3</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>)], [[<span class="number">0</span>] * <span class="number">3</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">    d1, d2, p = [<span class="number">0</span>] * <span class="number">2</span>, [<span class="number">0</span>] * <span class="number">2</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> r, c <span class="keyword">in</span> moves:</span><br><span class="line">        row[p][r] += <span class="number">1</span></span><br><span class="line">        col[p][c] += <span class="number">1</span></span><br><span class="line">        d1[p] += r==c</span><br><span class="line">        d2[p] += r+c==<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">3</span> <span class="keyword">in</span> (row[p][r], col[p][c], d1[p], d2[p]):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'AB'</span>[p]</span><br><span class="line">        p ^= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Draw'</span> <span class="keyword">if</span> len(moves)==<span class="number">9</span> <span class="keyword">else</span> <span class="string">'Pending'</span></span><br></pre></td></tr></table></figure>
<h4 id="面试题-16-04-井字游戏"><a href="#面试题-16-04-井字游戏" class="headerlink" title="面试题 16.04. 井字游戏"></a><a href="https://leetcode-cn.com/problems/tic-tac-toe-lcci/" target="_blank" rel="noopener">面试题 16.04. 井字游戏</a></h4><h4 id="比1275简单一点，给定棋盘，判断谁赢。"><a href="#比1275简单一点，给定棋盘，判断谁赢。" class="headerlink" title="比1275简单一点，给定棋盘，判断谁赢。"></a>比1275简单一点，给定棋盘，判断谁赢。</h4><p>方法一：自己用if写的，评论有个正则的写法不错，学习一下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tictactoe</span><span class="params">(self, board: List[str])</span> -&gt; str:</span></span><br><span class="line">    N = len(board)</span><br><span class="line">    pattern = re.compile(<span class="string">r'^([XO])\1*$'</span>)</span><br><span class="line">    col = map(<span class="string">''</span>.join, zip(*board))</span><br><span class="line">    l_dig = (<span class="string">''</span>.join(board[i][i] <span class="keyword">for</span> i <span class="keyword">in</span> range(N))), </span><br><span class="line">    r_dig = (<span class="string">''</span>.join(board[N-i<span class="number">-1</span>][i] <span class="keyword">for</span> i <span class="keyword">in</span> range(N))), </span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> itertools.chain(board, col, l_dig, r_dig):</span><br><span class="line">        match_obj = pattern.match(line)</span><br><span class="line">        <span class="keyword">if</span> match_obj:</span><br><span class="line">            <span class="keyword">return</span> match_obj.group(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">' '</span> <span class="keyword">in</span> itertools.chain.from_iterable(board):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Pending'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Draw'</span></span><br></pre></td></tr></table></figure>
<h4 id="1260-Shift-2D-Grid"><a href="#1260-Shift-2D-Grid" class="headerlink" title="1260. Shift 2D Grid"></a>1260. Shift 2D Grid</h4><h4 id="2D滑动，每次列右移一次，首列下移一次。原题"><a href="#2D滑动，每次列右移一次，首列下移一次。原题" class="headerlink" title="2D滑动，每次列右移一次，首列下移一次。原题"></a>2D滑动，每次列右移一次，首列下移一次。<a href="https://leetcode.com/problems/shift-2d-grid/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [[1,2,3],[4,5,6],[7,8,9]], k &#x3D; 1</span><br><span class="line">Output: [[9,1,2],[3,4,5],[6,7,8]]</span><br></pre></td></tr></table></figure>
<p>方法一：deque。最直观的方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shiftGrid</span><span class="params">(self, g: List[List[int]], k: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">    m, n = len(g), len(g[<span class="number">0</span>])</span><br><span class="line">    q = collections.deque(zip(*g))</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(k):</span><br><span class="line">        head = q.pop()</span><br><span class="line">        q.appendleft(head[<span class="number">-1</span>:]+head[:<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> [a <span class="keyword">for</span> a <span class="keyword">in</span> zip(*q)]</span><br></pre></td></tr></table></figure>
<p>方法二：调了半天，找了一些规律，然而并没有方法一快多少，时间上差不多，反而是更难理解了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shiftGrid</span><span class="params">(self, g: List[List[int]], k: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">    m, n = len(g), len(g[<span class="number">0</span>])</span><br><span class="line">    mk = k % n</span><br><span class="line">    a = list(zip(*g))</span><br><span class="line">    a = a[-mk:] + a[:-mk]</span><br><span class="line">    <span class="keyword">return</span> zip(*[row[-((k//n+(i&lt;mk))%m):] + row[:-((k//n+(i&lt;mk))%m)] <span class="keyword">for</span> i, row <span class="keyword">in</span> enumerate(a)])</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法三：看来时间效率应该是差不多了，将数组转成一维，会发现规律。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shiftGrid</span><span class="params">(self, g: List[List[int]], k: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">    col, nums = len(g[<span class="number">0</span>]), sum(g, [])</span><br><span class="line">    k = k % len(nums)</span><br><span class="line">    nums = nums[-k:] + nums[:-k]</span><br><span class="line">    <span class="keyword">return</span> [nums[i:i+col] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(nums), col)]</span><br></pre></td></tr></table></figure>
<h3 id="1252-Cells-with-Odd-Values-in-a-Matrix"><a href="#1252-Cells-with-Odd-Values-in-a-Matrix" class="headerlink" title="1252. Cells with Odd Values in a Matrix"></a>1252. Cells with Odd Values in a Matrix</h3><h4 id="根据坐标每次将所在的行和列-1，这个点-2，统计所有的奇数个数。原题"><a href="#根据坐标每次将所在的行和列-1，这个点-2，统计所有的奇数个数。原题" class="headerlink" title="根据坐标每次将所在的行和列+1，这个点+2，统计所有的奇数个数。原题"></a>根据坐标每次将所在的行和列+1，这个点+2，统计所有的奇数个数。<a href="https://leetcode.com/problems/cells-with-odd-values-in-a-matrix/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 2, m &#x3D; 3, indices &#x3D; [[0,1],[1,1]]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Initial matrix &#x3D; [[0,0,0],[0,0,0]].</span><br><span class="line">After applying first increment it becomes [[1,2,1],[0,1,0]].</span><br><span class="line">The final matrix will be [[1,3,1],[1,3,1]] which contains 6 odd numbers.</span><br></pre></td></tr></table></figure>
<p>方法一：异或。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">oddCells</span><span class="params">(self, n: int, m: int, indices: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    row, col = [<span class="number">0</span>] * n, [<span class="number">0</span>] * m</span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> indices:</span><br><span class="line">        row[x] ^= <span class="number">1</span></span><br><span class="line">        col[y] ^= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> sum(r ^ c <span class="keyword">for</span> r <span class="keyword">in</span> row <span class="keyword">for</span> c <span class="keyword">in</span> col)</span><br></pre></td></tr></table></figure>
<h3 id="1248-Count-Number-of-Nice-Subarrays"><a href="#1248-Count-Number-of-Nice-Subarrays" class="headerlink" title="1248. Count Number of Nice Subarrays"></a>1248. Count Number of Nice Subarrays</h3><h4 id="找到包含k个奇数的子数组个数。原题"><a href="#找到包含k个奇数的子数组个数。原题" class="headerlink" title="找到包含k个奇数的子数组个数。原题"></a>找到包含k个奇数的子数组个数。<a href="https://leetcode.com/problems/count-number-of-nice-subarrays/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,1,2,1,1], k &#x3D; 3</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].</span><br></pre></td></tr></table></figure>
<p>方法一：找到所有的奇数索引，然后滑动窗口累加值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numberOfSubarrays</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    odd = [i <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums) <span class="keyword">if</span> num&amp;<span class="number">1</span>==<span class="number">1</span>]</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(odd)-k+<span class="number">1</span>):</span><br><span class="line">        pre = <span class="number">-1</span> <span class="keyword">if</span> <span class="keyword">not</span> i <span class="keyword">else</span> odd[i<span class="number">-1</span>]</span><br><span class="line">        hi = n <span class="keyword">if</span> i==len(odd)-k <span class="keyword">else</span> odd[i+k]</span><br><span class="line">        ans += (odd[i]-pre) * (hi-odd[i+k<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>方法二：遍历一次</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numberOfSubarrays</span><span class="params">(self, A: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">    i = count = res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(A)):</span><br><span class="line">        <span class="keyword">if</span> A[j] &amp; <span class="number">1</span>:</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> k == <span class="number">0</span>:</span><br><span class="line">            k += A[i] &amp; <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        res += count</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="1234-Replace-the-Substring-for-Balanced-String"><a href="#1234-Replace-the-Substring-for-Balanced-String" class="headerlink" title="1234. Replace the Substring for Balanced String"></a>1234. Replace the Substring for Balanced String</h3><h4 id="将每个QWER出现的次数变为一样，最少需要修改的子串长度是多少。原题"><a href="#将每个QWER出现的次数变为一样，最少需要修改的子串长度是多少。原题" class="headerlink" title="将每个QWER出现的次数变为一样，最少需要修改的子串长度是多少。原题"></a>将每个QWER出现的次数变为一样，最少需要修改的子串长度是多少。<a href="https://leetcode.com/problems/replace-the-substring-for-balanced-string/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;QQWE&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: We need to replace a &#39;Q&#39; to &#39;R&#39;, so that &quot;RQWE&quot; (or &quot;QRWE&quot;) is balanced.</span><br></pre></td></tr></table></figure>
<p>方法一：例子有地不好，子串必须是连续的。和lee大佬解法差不多。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">balancedString</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">    diff = Counter(s) - Counter(&#123;c: len(s)//<span class="number">4</span> <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">'QWER'</span>&#125;)</span><br><span class="line">    ans = float(<span class="string">'inf'</span>)</span><br><span class="line">    c = Counter()</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j, a <span class="keyword">in</span> enumerate(s):</span><br><span class="line">        c[a] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i!=len(s) <span class="keyword">and</span> <span class="keyword">not</span> diff-c:</span><br><span class="line">            ans = min(ans, j-i+<span class="number">1</span>)</span><br><span class="line">            c[s[i]] -= <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="1208-Get-Equal-Substrings-Within-Budget"><a href="#1208-Get-Equal-Substrings-Within-Budget" class="headerlink" title="1208. Get Equal Substrings Within Budget"></a>1208. Get Equal Substrings Within Budget</h3><h4 id="将字符串s变为t。需要ascii码的差，问在指定的差中，最长的可以变成的子串长度是多少。原题"><a href="#将字符串s变为t。需要ascii码的差，问在指定的差中，最长的可以变成的子串长度是多少。原题" class="headerlink" title="将字符串s变为t。需要ascii码的差，问在指定的差中，最长的可以变成的子串长度是多少。原题"></a>将字符串s变为t。需要ascii码的差，问在指定的差中，最长的可以变成的子串长度是多少。<a href="https://leetcode.com/problems/get-equal-substrings-within-budget/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;abcd&quot;, t &#x3D; &quot;bcdf&quot;, maxCost &#x3D; 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: &quot;abc&quot; of s can change to &quot;bcd&quot;. That costs 3, so the maximum length is 3.</span><br></pre></td></tr></table></figure>
<p>方法一：滑动窗口问题。比赛的答案。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">equalSubstring</span><span class="params">(self, s: str, t: str, maxCost: int)</span> -&gt; int:</span></span><br><span class="line">    diff = [abs(ord(a)-ord(b)) <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(s, t)]</span><br><span class="line">    q = collections.deque()</span><br><span class="line">    cur_sum = ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> diff:</span><br><span class="line">        q.append(d)</span><br><span class="line">        cur_sum += d</span><br><span class="line">        <span class="keyword">while</span> cur_sum &gt; maxCost:</span><br><span class="line">            cur_sum -= q.popleft()</span><br><span class="line">        ans = max(ans, len(q))</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>方法二：Lee215，开始比较迷惑为什么i, j 不用max来求值，看了评论发现有人和我有一样的疑惑，并且给了解释，对于此题而言，滑动窗口的长度不会缩短。因为只用了if 而不是while</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">equalSubstring</span><span class="params">(self, s: str, t: str, cost: int)</span> -&gt; int:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        cost -= abs(ord(s[j]) - ord(t[j]))</span><br><span class="line">        <span class="keyword">if</span> cost &lt; <span class="number">0</span>:</span><br><span class="line">            cost += abs(ord(s[i]) - ord(t[i]))</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> j - i + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="Sort-Colors"><a href="#Sort-Colors" class="headerlink" title="Sort Colors"></a>Sort Colors</h3><h4 id="0-1-2的数组排序。原题"><a href="#0-1-2的数组排序。原题" class="headerlink" title="0,1,2的数组排序。原题"></a>0,1,2的数组排序。<a href="https://leetcode.com/problems/sort-colors/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,0,2,1,1,0]</span><br><span class="line">Output: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure>
<p>方法一：没想到有快排的思想。维持三个区间<code>[0,i) [i,j),[j,k)</code>分别表示0，1，2的区间。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortColors</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        v = nums[k]</span><br><span class="line">        nums[k] = <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> v &lt; <span class="number">2</span>:</span><br><span class="line">            nums[j] = <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> v == <span class="number">0</span>:</span><br><span class="line">            nums[i] = <span class="number">0</span></span><br><span class="line">            i += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="1191-K-Concatenation-Maximum-Sum"><a href="#1191-K-Concatenation-Maximum-Sum" class="headerlink" title="1191. K-Concatenation Maximum Sum"></a>1191. K-Concatenation Maximum Sum</h3><h4 id="求k-arr的连续数组最大和。原题"><a href="#求k-arr的连续数组最大和。原题" class="headerlink" title="求k*arr的连续数组最大和。原题"></a>求k*arr的连续数组最大和。<a href="https://leetcode.com/problems/k-concatenation-maximum-sum/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [1,2], k &#x3D; 3</span><br><span class="line">Output: 9</span><br><span class="line">Input: arr &#x3D; [1,-2,1], k &#x3D; 5</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<p>方法一：想到了卡登算法，但是没想明白为啥要加(k-2)个数组的和，因为首位数组中间可以夹带(k-2)个数组，如果数组和是正数的话，就将它算进去</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kConcatenationMaxSum</span><span class="params">(self, arr: List[int], k: int, mod=<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span> -&gt; int:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">acc</span><span class="params">(nums)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> max(accumulate(nums+[<span class="number">0</span>], <span class="keyword">lambda</span> x, y: x+y <span class="keyword">if</span> x&gt;<span class="number">0</span> <span class="keyword">else</span> y))</span><br><span class="line">    <span class="keyword">return</span> ((k<span class="number">-2</span>)*max(sum(arr), <span class="number">0</span>) + acc(arr*<span class="number">2</span>)) % mod <span class="keyword">if</span> k &gt; <span class="number">1</span> <span class="keyword">else</span> acc(arr) % mod</span><br></pre></td></tr></table></figure>
<h3 id="448-Find-All-Numbers-Disappeared-in-an-Array"><a href="#448-Find-All-Numbers-Disappeared-in-an-Array" class="headerlink" title="448. Find All Numbers Disappeared in an Array"></a>448. Find All Numbers Disappeared in an Array</h3><h4 id="找出n长度的数组中1-n缺失的数字，有的数字会出现多次。原题"><a href="#找出n长度的数组中1-n缺失的数字，有的数字会出现多次。原题" class="headerlink" title="找出n长度的数组中1-n缺失的数字，有的数字会出现多次。原题"></a>找出n长度的数组中1-n缺失的数字，有的数字会出现多次。<a href="https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure>
<p>方法一：这道题解法挺新颖，看着这题和剑指offer中的有点类似，但是那道题是其它数字出现一次。这个题的解法是出现的位置的数变成负的，最后找正数的索引。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findDisappearedNumbers</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        index = abs(nums[i]) - <span class="number">1</span></span><br><span class="line">        nums[index] = -abs(nums[index])</span><br><span class="line">    <span class="keyword">return</span> [i+<span class="number">1</span> <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums) <span class="keyword">if</span> num&gt;<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h3 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="11. Container With Most Water"></a>11. Container With Most Water</h3><h4 id="最大的水容积，用坐标轴装水，有点像木桶原理。原题"><a href="#最大的水容积，用坐标轴装水，有点像木桶原理。原题" class="headerlink" title="最大的水容积，用坐标轴装水，有点像木桶原理。原题"></a>最大的水容积，用坐标轴装水，有点像木桶原理。<a href="https://leetcode.com/problems/container-with-most-water/" target="_blank" rel="noopener">原题</a></h4><p>方法一：双指针，开始没有想到指针如何移动。其实这样想，如果一个坐标比较矮，那就将其舍弃，因为宽度是越来越小的，所以需要更高的木桶才能弥补。</p>
<pre><code>def maxArea(self, height: List[int]) -&gt; int:
    lo, hi = 0, len(height)-1
    ans = 0
    while lo &lt; hi:
        ans = max(ans, (hi-lo)*min(height[hi], height[lo]))
        if height[lo] &lt; height[hi]:
            lo += 1
        else:
            hi -= 1
    return ans
</code></pre><h3 id="1498-Number-of-Subsequences-That-Satisfy-the-Given-Sum-Condition"><a href="#1498-Number-of-Subsequences-That-Satisfy-the-Given-Sum-Condition" class="headerlink" title="1498. Number of Subsequences That Satisfy the Given Sum Condition"></a>1498. Number of Subsequences That Satisfy the Given Sum Condition</h3><h4 id="给定一个数组，返回最大值最小值和小于目标值的子序列，可以不连续，的个数。原题"><a href="#给定一个数组，返回最大值最小值和小于目标值的子序列，可以不连续，的个数。原题" class="headerlink" title="给定一个数组，返回最大值最小值和小于目标值的子序列，可以不连续，的个数。原题"></a>给定一个数组，返回最大值最小值和小于目标值的子序列，可以不连续，的个数。<a href="https://leetcode.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,5,6,7], target &#x3D; 9</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: There are 4 subsequences that satisfy the condition.</span><br><span class="line">[3] -&gt; Min value + max value &lt;&#x3D; target (3 + 3 &lt;&#x3D; 9)</span><br><span class="line">[3,5] -&gt; (3 + 5 &lt;&#x3D; 9)</span><br><span class="line">[3,5,6] -&gt; (3 + 6 &lt;&#x3D; 9)</span><br><span class="line">[3,6] -&gt; (3 + 6 &lt;&#x3D; 9)</span><br></pre></td></tr></table></figure>
<p>方法一：一开始思路相对了，但是指针移动没想好。来自Lee215，累加的时候要计算一下mod否则效率会变很慢。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numSubseq</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">    nums.sort()</span><br><span class="line">    lo, hi = <span class="number">0</span>, len(nums)<span class="number">-1</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> lo &lt;= hi:</span><br><span class="line">        <span class="keyword">if</span> nums[lo] + nums[hi] &gt; target:</span><br><span class="line">            hi -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res += pow(<span class="number">2</span>, hi - lo, <span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br><span class="line">            lo += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res % (<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br></pre></td></tr></table></figure>
<h3 id="463-Island-Perimeter"><a href="#463-Island-Perimeter" class="headerlink" title="463. Island Perimeter"></a>463. Island Perimeter</h3><h4 id="小岛的周长，小岛中间没有湖。原题"><a href="#小岛的周长，小岛中间没有湖。原题" class="headerlink" title="小岛的周长，小岛中间没有湖。原题"></a>小岛的周长，小岛中间没有湖。<a href="https://leetcode.com/problems/island-perimeter/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[[0,1,0,0],</span><br><span class="line"> [1,1,1,0],</span><br><span class="line"> [0,1,0,0],</span><br><span class="line"> [1,1,0,0]]</span><br><span class="line"></span><br><span class="line">Output: 16</span><br></pre></td></tr></table></figure>
<p>方法一：stefan、因为中间没有湖，所以呢周长等于所以相邻格子不相等的个数。这里将列也放在一起计算了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">islandPerimeter</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    cols = list(map(list, zip(*grid)))</span><br><span class="line">    <span class="keyword">return</span> sum(sum(map(ne, [<span class="number">0</span>]+row, row+[<span class="number">0</span>])) <span class="keyword">for</span> row <span class="keyword">in</span> grid + cols)</span><br></pre></td></tr></table></figure>
<h3 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="15. 3Sum"></a>15. 3Sum</h3><h4 id="找出数组中3个数相加为0，返回所有的组合非重复。原题"><a href="#找出数组中3个数相加为0，返回所有的组合非重复。原题" class="headerlink" title="找出数组中3个数相加为0，返回所有的组合非重复。原题"></a>找出数组中3个数相加为0，返回所有的组合非重复。<a href="https://leetcode.com/problems/3sum/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given array nums &#x3D; [-1, 0, 1, 2, -1, -4],</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>方法一：这里看了提示后用的2sum的方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    nums.sort()</span><br><span class="line">    ans = []</span><br><span class="line">    seen = set()</span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        a = nums[i]</span><br><span class="line">        <span class="keyword">if</span> a <span class="keyword">in</span> seen:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        seen.add(a)</span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, n):</span><br><span class="line">            b = nums[j]</span><br><span class="line">            <span class="keyword">if</span> b <span class="keyword">in</span> d <span class="keyword">and</span> (<span class="keyword">not</span>(ans) <span class="keyword">or</span> (ans[<span class="number">-1</span>][<span class="number">0</span>]!=a <span class="keyword">or</span> ans[<span class="number">-1</span>][<span class="number">2</span>]!=b)):</span><br><span class="line">                ans.append((a, -a-b, b))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d[-a-b] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>方法二：讨论区看到的一个方法。明白了还有许多可以优化的地方。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    nums.sort()</span><br><span class="line">    ans, n = [], len(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>):</span><br><span class="line">        a = nums[i]</span><br><span class="line">        <span class="keyword">if</span> a &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span> <span class="comment"># 因为a&gt;0, b,c&gt;0，所以不可能和为0</span></span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">and</span> a == nums[i<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        lo, hi = i+<span class="number">1</span>, n<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            total = nums[lo] + nums[hi]</span><br><span class="line">            <span class="keyword">if</span> total &gt; -a:</span><br><span class="line">                hi -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> total &lt; -a:</span><br><span class="line">                lo += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> lo&lt;hi <span class="keyword">and</span> nums[lo]==nums[lo+<span class="number">1</span>]:</span><br><span class="line">                    lo += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> lo&lt;hi <span class="keyword">and</span> nums[hi]==nums[hi<span class="number">-1</span>]:</span><br><span class="line">                    hi -= <span class="number">1</span></span><br><span class="line">                ans.append((a, nums[lo], nums[hi]))</span><br><span class="line">                lo += <span class="number">1</span></span><br><span class="line">                hi -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="1508-Range-Sum-of-Sorted-Subarray-Sums"><a href="#1508-Range-Sum-of-Sorted-Subarray-Sums" class="headerlink" title="1508. Range Sum of Sorted Subarray Sums"></a>1508. Range Sum of Sorted Subarray Sums</h3><h4 id="数组的累加和排序，取区间中的数字和。原题"><a href="#数组的累加和排序，取区间中的数字和。原题" class="headerlink" title="数组的累加和排序，取区间中的数字和。原题"></a>数组的累加和排序，取区间中的数字和。<a href="https://leetcode.com/problems/range-sum-of-sorted-subarray-sums/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,4], n &#x3D; 4, left &#x3D; 1, right &#x3D; 5</span><br><span class="line">Output: 13 </span><br><span class="line">Explanation: All subarray sums are 1, 3, 6, 10, 2, 5, 9, 3, 7, 4. After sorting them in non-decreasing order we have the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from index le &#x3D; 1 to ri &#x3D; 5 is 1 + 2 + 3 + 3 + 4 &#x3D; 13.</span><br></pre></td></tr></table></figure>
<p>方法一：O(n^2)的方法。比赛的时候还用了accumulate， 但是其实没必要。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rangeSum</span><span class="params">(self, nums: List[int], n: int, left: int, right: int)</span> -&gt; int:</span></span><br><span class="line">    mod = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n):</span><br><span class="line">            cur += nums[j]</span><br><span class="line">            ans.append(cur)</span><br><span class="line">    ans.sort()</span><br><span class="line">    <span class="keyword">return</span> sum(ans[left<span class="number">-1</span>: right]) % mod</span><br></pre></td></tr></table></figure>
<h3 id="1509-Minimum-Difference-Between-Largest-and-Smallest-Value-in-Three-Moves"><a href="#1509-Minimum-Difference-Between-Largest-and-Smallest-Value-in-Three-Moves" class="headerlink" title="1509. Minimum Difference Between Largest and Smallest Value in Three Moves"></a>1509. Minimum Difference Between Largest and Smallest Value in Three Moves</h3><h4 id="删除3个数，数组的最大值最小值差最小是多少。原题"><a href="#删除3个数，数组的最大值最小值差最小是多少。原题" class="headerlink" title="删除3个数，数组的最大值最小值差最小是多少。原题"></a>删除3个数，数组的最大值最小值差最小是多少。<a href="https://leetcode.com/problems/minimum-difference-between-largest-and-smallest-value-in-three-moves/" target="_blank" rel="noopener">原题</a></h4><p>方法一：首次ac的方法。思路很直观，但是写法却有点复杂。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minDifference</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    nums.sort()</span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># print(nums)</span></span><br><span class="line">    ans = float(<span class="string">'inf'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        tmp = nums[i:n<span class="number">-3</span>+i]</span><br><span class="line">        ans = min(ans, max(tmp) - min(tmp))</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：2行就可以搞定。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minDifference</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    nums.sort()</span><br><span class="line">    <span class="keyword">return</span> min(b-a <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(nums[:<span class="number">4</span>], nums[<span class="number">-4</span>:]))</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法三：堆求也可以。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minDifference</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    nums.sort()</span><br><span class="line">    <span class="keyword">return</span> min(a - b <span class="keyword">for</span> a,b <span class="keyword">in</span> zip(heapq.nlargest(<span class="number">4</span>, nums), heapq.nsmallest(<span class="number">4</span>, nums)[::<span class="number">-1</span>]))</span><br></pre></td></tr></table></figure>
<h3 id="1529-Bulb-Switcher-IV"><a href="#1529-Bulb-Switcher-IV" class="headerlink" title="1529. Bulb Switcher IV"></a>1529. Bulb Switcher IV</h3><h4 id="灯泡开关，每次只能开关从后开始的连续的n个，问变成目标状态，最少需要几次操作。原题"><a href="#灯泡开关，每次只能开关从后开始的连续的n个，问变成目标状态，最少需要几次操作。原题" class="headerlink" title="灯泡开关，每次只能开关从后开始的连续的n个，问变成目标状态，最少需要几次操作。原题"></a>灯泡开关，每次只能开关从后开始的连续的n个，问变成目标状态，最少需要几次操作。<a href="https://leetcode.com/problems/bulb-switcher-iv/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: target &#x3D; &quot;10111&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Initial configuration &quot;00000&quot;.</span><br><span class="line">flip from the third bulb:  &quot;00000&quot; -&gt; &quot;00111&quot;</span><br><span class="line">flip from the first bulb:  &quot;00111&quot; -&gt; &quot;11000&quot;</span><br><span class="line">flip from the second bulb:  &quot;11000&quot; -&gt; &quot;10111&quot;</span><br><span class="line">We need at least 3 flip operations to form target.</span><br></pre></td></tr></table></figure>
<p>方法一：竞赛时的方法。 分组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minFlips</span><span class="params">(self, target: str)</span> -&gt; int:</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    first = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> l, g <span class="keyword">in</span> itertools.groupby(target):</span><br><span class="line">        <span class="keyword">if</span> l == <span class="string">'0'</span> <span class="keyword">and</span> first:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">        first = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：上诉方法补0 优化。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minFlips</span><span class="params">(self, target: str)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">return</span> len(list(itertools.groupby(<span class="string">'0'</span> + target))) - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法三：不分组，一次遍历。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minFlips</span><span class="params">(self, target: str)</span> -&gt; int:</span></span><br><span class="line">    ans, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> target:</span><br><span class="line">        <span class="keyword">if</span> int(c) == b:</span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">            b = <span class="number">1</span> - b</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="442-Find-All-Duplicates-in-an-Array"><a href="#442-Find-All-Duplicates-in-an-Array" class="headerlink" title="442. Find All Duplicates in an Array"></a>442. Find All Duplicates in an Array</h3><h4 id="找到所有重复的元素，数组中的元素都在1-n之间，n为数组的长度。原题"><a href="#找到所有重复的元素，数组中的元素都在1-n之间，n为数组的长度。原题" class="headerlink" title="找到所有重复的元素，数组中的元素都在1~n之间，n为数组的长度。原题"></a>找到所有重复的元素，数组中的元素都在1~n之间，n为数组的长度。<a href="https://leetcode.com/problems/find-all-duplicates-in-an-array/" target="_blank" rel="noopener">原题</a></h4><p>方法一：要求在O(n)时间，O(1)空间实现，那么就考虑修改原数组来节省空间。以负值来记录是否出现过。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> nums[abs(x)<span class="number">-1</span>] &lt; <span class="number">0</span>:</span><br><span class="line">            res.append(abs(x))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            nums[abs(x)<span class="number">-1</span>] *= <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="713-Subarray-Product-Less-Than-K"><a href="#713-Subarray-Product-Less-Than-K" class="headerlink" title="713. Subarray Product Less Than K"></a>713. Subarray Product Less Than K</h3><h4 id="连续子数组乘积小于k的个数，元素为正数。原题"><a href="#连续子数组乘积小于k的个数，元素为正数。原题" class="headerlink" title="连续子数组乘积小于k的个数，元素为正数。原题"></a>连续子数组乘积小于k的个数，元素为正数。<a href="https://leetcode.com/problems/subarray-product-less-than-k/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [10, 5, 2, 6], k &#x3D; 100</span><br><span class="line">Output: 8</span><br><span class="line">Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].</span><br><span class="line">Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.</span><br></pre></td></tr></table></figure>
<p>方法一：一开始想到了双端队列，但是累加时end-start+1数量没想到。此题用双指针即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    start = ans = <span class="number">0</span></span><br><span class="line">    prod = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> end, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">        <span class="keyword">while</span> start&lt;=end <span class="keyword">and</span> prod*num&gt;=k:</span><br><span class="line">            prod //= nums[start]</span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line">        prod = <span class="number">1</span> <span class="keyword">if</span> start&gt;end <span class="keyword">else</span> prod*num</span><br><span class="line">        ans += (end-start+<span class="number">1</span>) * (start&lt;=end)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="915-Partition-Array-into-Disjoint-Intervals"><a href="#915-Partition-Array-into-Disjoint-Intervals" class="headerlink" title="915. Partition Array into Disjoint Intervals"></a>915. Partition Array into Disjoint Intervals</h3><h4 id="将数组拆成两个非空数组，要求左侧的每个元素都小于等于右侧的每个元素，求左侧最小的长度，假设答案一定存在。原题"><a href="#将数组拆成两个非空数组，要求左侧的每个元素都小于等于右侧的每个元素，求左侧最小的长度，假设答案一定存在。原题" class="headerlink" title="将数组拆成两个非空数组，要求左侧的每个元素都小于等于右侧的每个元素，求左侧最小的长度，假设答案一定存在。原题"></a>将数组拆成两个非空数组，要求左侧的每个元素都小于等于右侧的每个元素，求左侧最小的长度，假设答案一定存在。<a href="https://leetcode.com/problems/partition-array-into-disjoint-intervals/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,0,3,8,6]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: left &#x3D; [5,0,3], right &#x3D; [8,6]</span><br></pre></td></tr></table></figure>
<p>方法一：蛮简单的，two-pass的方法，这个累加函数的生成器不能直接reversed，要将其转换成数组，这里产生了一次遍历。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partitionDisjoint</span><span class="params">(self, A: List[int])</span> -&gt; int:</span></span><br><span class="line">    left = itertools.accumulate(A, max)</span><br><span class="line">    right = reversed(list(itertools.accumulate(reversed(A), min)))</span><br><span class="line">    next(right, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">for</span> i, (a, b) <span class="keyword">in</span> enumerate(zip(left, right)):</span><br><span class="line">        <span class="keyword">if</span> a &lt;= b:</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：one-pass. 这个方法不是很好想，思路是这样的，当当前数小于之前的最大值，那么久将其算入左侧的数组中。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partitionDisjoint</span><span class="params">(self, A: List[int])</span> -&gt; int:</span></span><br><span class="line">    p = <span class="number">0</span></span><br><span class="line">    cur_max = left_max = A[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i, a <span class="keyword">in</span> enumerate(A):</span><br><span class="line">        cur_max = max(cur_max, a)</span><br><span class="line">        <span class="keyword">if</span> a &lt; left_max:</span><br><span class="line">            left_max = cur_max</span><br><span class="line">            p = i</span><br><span class="line">    <span class="keyword">return</span> p + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="1562-Find-Latest-Group-of-Size-M"><a href="#1562-Find-Latest-Group-of-Size-M" class="headerlink" title="1562. Find Latest Group of Size M"></a>1562. Find Latest Group of Size M</h3><h4 id="将一个全是0的字符串按照arr的索引顺序变为1，整体被0分割成若干段，问最后有m个长度的”1”的段时是第几步、原题"><a href="#将一个全是0的字符串按照arr的索引顺序变为1，整体被0分割成若干段，问最后有m个长度的”1”的段时是第几步、原题" class="headerlink" title="将一个全是0的字符串按照arr的索引顺序变为1，整体被0分割成若干段，问最后有m个长度的”1”的段时是第几步、原题"></a>将一个全是0的字符串按照arr的索引顺序变为1，整体被0分割成若干段，问最后有m个长度的”1”的段时是第几步、<a href="https://leetcode.com/problems/find-latest-group-of-size-m/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [3,5,1,2,4], m &#x3D; 1</span><br><span class="line">Output: 4</span><br><span class="line">Explanation:</span><br><span class="line">Step 1: &quot;00100&quot;, groups: [&quot;1&quot;]</span><br><span class="line">Step 2: &quot;00101&quot;, groups: [&quot;1&quot;, &quot;1&quot;]</span><br><span class="line">Step 3: &quot;10101&quot;, groups: [&quot;1&quot;, &quot;1&quot;, &quot;1&quot;]</span><br><span class="line">Step 4: &quot;11101&quot;, groups: [&quot;111&quot;, &quot;1&quot;]</span><br><span class="line">Step 5: &quot;11111&quot;, groups: [&quot;11111&quot;]</span><br><span class="line">The latest step at which there exists a group of size 1 is step 4.</span><br></pre></td></tr></table></figure>
<p>方法一：比赛时没做出来，Lee的方法。length表示第i个bit的长度，count表示这么长的group有多少个。严格来说<code>length[a-left]</code>和<code>lenght[a+right]</code>区间内都应该变成left+right+1。但是由于中间的后续用不到，所以不必赋值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findLatestStep</span><span class="params">(self, arr: List[int], m: int)</span> -&gt; int:</span></span><br><span class="line">    length = [<span class="number">0</span>] * (len(arr)+<span class="number">2</span>)</span><br><span class="line">    count = [<span class="number">0</span>] * (len(arr)+<span class="number">1</span>)</span><br><span class="line">    ans = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i, a <span class="keyword">in</span> enumerate(arr):</span><br><span class="line">        left, right = length[a<span class="number">-1</span>], length[a+<span class="number">1</span>]</span><br><span class="line">        length[a] = length[a-left] = length[a+right] = left + right + <span class="number">1</span></span><br><span class="line">        count[left] -= <span class="number">1</span></span><br><span class="line">        count[right] -= <span class="number">1</span></span><br><span class="line">        count[length[a]] += <span class="number">1</span></span><br><span class="line">        <span class="comment"># print(length, count)</span></span><br><span class="line">        <span class="keyword">if</span> count[m]:</span><br><span class="line">            ans = i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="334-Increasing-Triplet-Subsequence"><a href="#334-Increasing-Triplet-Subsequence" class="headerlink" title="334. Increasing Triplet Subsequence"></a>334. Increasing Triplet Subsequence</h3><h4 id="数组中是否有三个元素递增。原题"><a href="#数组中是否有三个元素递增。原题" class="headerlink" title="数组中是否有三个元素递增。原题"></a>数组中是否有三个元素递增。<a href="https://leetcode.com/problems/increasing-triplet-subsequence/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5]</span><br><span class="line">Output: true</span><br><span class="line">Input: [1,5,3,4,2]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p>方法一：首次ac的方法，看了要求在O(n)时间O(1)空间实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">increasingTriplet</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">    a = b = float(<span class="string">'inf'</span>)</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> num &gt; b: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        a = min(a, num)</span><br><span class="line">        <span class="keyword">if</span> a&lt;num&lt;b: b=num</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：这个stefan的方法，具有泛化性，如果求4，5个元素递增可以直接修改变量。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">inc = [float(<span class="string">'inf'</span>)] * <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">        i = bisect.bisect_left(inc, x)</span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        inc[i] = x</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="926-Flip-String-to-Monotone-Increasing"><a href="#926-Flip-String-to-Monotone-Increasing" class="headerlink" title="926. Flip String to Monotone Increasing"></a>926. Flip String to Monotone Increasing</h3><h4 id="将一个二进制字符串翻转成单调递增最少要几步。原题"><a href="#将一个二进制字符串翻转成单调递增最少要几步。原题" class="headerlink" title="将一个二进制字符串翻转成单调递增最少要几步。原题"></a>将一个二进制字符串翻转成单调递增最少要几步。<a href="https://leetcode.com/problems/flip-string-to-monotone-increasing/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;010110&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: We flip to get 011111, or alternatively 000111.</span><br></pre></td></tr></table></figure>
<p>方法一：看了一眼讨论区，就明白了，遍历时找到递增的点，也就是第一个1，记录后边的0和前边的1。这里我是在后面补1，也可以将ans初始化为len(S)-suffix_0。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minFlipsMonoIncr</span><span class="params">(self, S: str)</span> -&gt; int:</span></span><br><span class="line">    S += <span class="string">'1'</span></span><br><span class="line">    suffix_0, prefix_1 = S.count(<span class="string">'0'</span>), <span class="number">0</span></span><br><span class="line">    ans = float(<span class="string">'inf'</span>)</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> S:</span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">'0'</span>:</span><br><span class="line">            suffix_0 -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ans = min(ans, suffix_0+prefix_1)</span><br><span class="line">            prefix_1 += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="424-Longest-Repeating-Character-Replacement"><a href="#424-Longest-Repeating-Character-Replacement" class="headerlink" title="424. Longest Repeating Character Replacement"></a>424. Longest Repeating Character Replacement</h3><h4 id="由26个大写字母组成的字符串，在k次替换范围内，产生的最长的重复字符串是多少。原题"><a href="#由26个大写字母组成的字符串，在k次替换范围内，产生的最长的重复字符串是多少。原题" class="headerlink" title="由26个大写字母组成的字符串，在k次替换范围内，产生的最长的重复字符串是多少。原题"></a>由26个大写字母组成的字符串，在k次替换范围内，产生的最长的重复字符串是多少。<a href="https://leetcode.com/problems/longest-repeating-character-replacement/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;ABAB&quot;, k &#x3D; 2</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Replace the two &#39;A&#39;s with two &#39;B&#39;s or vice versa.</span><br></pre></td></tr></table></figure>
<p>方法一：滑动窗口加数组计数。time- O(26N)。while是没有必要的，left+1后 左边等号就会刚好=k, 不过这里的left, right表示的区间意义变了，表示的是最大的滑动窗口，窗口内的字符串不一定是可以满足条件的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">characterReplacement</span><span class="params">(self, s: str, k: int)</span> -&gt; int:</span></span><br><span class="line">    cnt = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">    left = ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> right, d <span class="keyword">in</span> enumerate(s):</span><br><span class="line">        cnt[ord(d)-ord(<span class="string">'A'</span>)] += <span class="number">1</span></span><br><span class="line">        <span class="comment"># while right-left+1-max(cnt) &gt; k:</span></span><br><span class="line">        <span class="keyword">if</span> right-left+<span class="number">1</span>-max(cnt) &gt; k:</span><br><span class="line">            cnt[ord(s[left])-ord(<span class="string">'A'</span>)] -= <span class="number">1</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        ans = max(ans, right-left+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>方法二：研究了很久也没弄明白，为什么maxf曾经最大的值，可以替代max(cnt)。理论上时间确实比上述快了。Time-O(N)。我试了一个特殊的例子，”BBBCADEF”1，在某些情况maxf &gt; max(cnt)的，但即便这样也没有影响if判断，猜测可能为right-left+1区间为最大区间。不过又将if改成while循环，依然没有影响。此解法还是有些疑惑。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">characterReplacement</span><span class="params">(self, s: str, k: int)</span> -&gt; int:</span></span><br><span class="line">    cnt = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">    left = ans = maxf = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> right, d <span class="keyword">in</span> enumerate(s):</span><br><span class="line">        cnt[ord(d)-ord(<span class="string">'A'</span>)] += <span class="number">1</span></span><br><span class="line">        maxf = max(maxf, cnt[ord(d)-ord(<span class="string">'A'</span>)])</span><br><span class="line">        <span class="comment"># while right-left+1-max(cnt) &gt; k:</span></span><br><span class="line">        <span class="comment"># print(maxf, max(cnt), left, right, ans)</span></span><br><span class="line">        <span class="keyword">if</span> right-left+<span class="number">1</span>-maxf &gt; k:</span><br><span class="line">            cnt[ord(s[left])-ord(<span class="string">'A'</span>)] -= <span class="number">1</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        ans = max(ans, right-left+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="398-Random-Pick-Index"><a href="#398-Random-Pick-Index" class="headerlink" title="398. Random Pick Index"></a>398. Random Pick Index</h3><h4 id="有这样一个数组，我想随机的去一个目标的元素，找到和目标相等的这些元素随机返回一个索引。原题"><a href="#有这样一个数组，我想随机的去一个目标的元素，找到和目标相等的这些元素随机返回一个索引。原题" class="headerlink" title="有这样一个数组，我想随机的去一个目标的元素，找到和目标相等的这些元素随机返回一个索引。原题"></a>有这样一个数组，我想随机的去一个目标的元素，找到和目标相等的这些元素随机返回一个索引。<a href="https://leetcode.com/problems/random-pick-index/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int[] nums &#x3D; new int[] &#123;1,2,3,3,3&#125;;</span><br><span class="line">Solution solution &#x3D; new Solution(nums);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; pick(3) should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.</span><br><span class="line">solution.pick(3);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; pick(1) should return 0. Since in the array only nums[0] is equal to 1.</span><br><span class="line">solution.pick(1);</span><br></pre></td></tr></table></figure>
<p>方法一：直接放到defaultdict中也没有超过空间限制。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nums: List[int])</span>:</span></span><br><span class="line">        self.p = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> i, d <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            self.p[d].append(i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self, target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> random.choice(self.p[target])</span><br></pre></td></tr></table></figure>
<p>方法二：一个新的方法叫作蓄水池取样，当遇见了一个目标数，就将它放到池子中，然后随机一个数。并在随到当前数时更新索引。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nums: List[int])</span>:</span></span><br><span class="line">        self.nums = nums</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self, target: int)</span> -&gt; int:</span></span><br><span class="line">        ans = <span class="literal">None</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(self.nums):</span><br><span class="line">            <span class="keyword">if</span> num == target:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                chance = random.randint(<span class="number">1</span>, count)</span><br><span class="line">                <span class="keyword">if</span> chance == count:</span><br><span class="line">                    ans = i</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="382-Linked-List-Random-Node"><a href="#382-Linked-List-Random-Node" class="headerlink" title="382. Linked List Random Node"></a>382. Linked List Random Node</h3><h4 id="在一个链表上随机取一个节点值。原题"><a href="#在一个链表上随机取一个节点值。原题" class="headerlink" title="在一个链表上随机取一个节点值。原题"></a>在一个链表上随机取一个节点值。<a href="https://leetcode.com/problems/linked-list-random-node/" target="_blank" rel="noopener">原题</a></h4><p>方法一：和398一样。假设链表无限大，不能够获取它的长度。这是非常经典的一个题。一个很大的数据流，对数据流的内容只能访问一次，随机算法使数据流中所有的被选中的概率相等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nums: List[int])</span>:</span></span><br><span class="line">        self.nums = nums</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self, target: int)</span> -&gt; int:</span></span><br><span class="line">        ans = <span class="literal">None</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(self.nums):</span><br><span class="line">            <span class="keyword">if</span> num == target:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                chance = random.randint(<span class="number">1</span>, count)</span><br><span class="line">                <span class="keyword">if</span> chance == count:</span><br><span class="line">                    ans = i</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="209-Minimum-Size-Subarray-Sum"><a href="#209-Minimum-Size-Subarray-Sum" class="headerlink" title="209. Minimum Size Subarray Sum"></a>209. Minimum Size Subarray Sum</h3><h4 id="累加和大于s的最短的子数组长度。原题"><a href="#累加和大于s的最短的子数组长度。原题" class="headerlink" title="累加和大于s的最短的子数组长度。原题"></a>累加和大于s的最短的子数组长度。<a href="https://leetcode.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: the subarray [4,3] has the minimal length under the problem constraint.</span><br></pre></td></tr></table></figure>
<p>方法一：滑动窗口。注意A为空的情况。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen</span><span class="params">(self, s: int, A: List[int])</span> -&gt; int:</span></span><br><span class="line">    i, ans = <span class="number">0</span>, len(A)+<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(A)):</span><br><span class="line">        s -= A[j]</span><br><span class="line">        <span class="keyword">while</span> s &lt;= <span class="number">0</span>:</span><br><span class="line">            ans = min(ans, j-i+<span class="number">1</span>)</span><br><span class="line">            s += A[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans % (len(A)+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="930-Binary-Subarrays-With-Sum"><a href="#930-Binary-Subarrays-With-Sum" class="headerlink" title="930. Binary Subarrays With Sum"></a>930. Binary Subarrays With Sum</h3><h4 id="求和我S的子数组个数，数组元素只包含0，1。原题"><a href="#求和我S的子数组个数，数组元素只包含0，1。原题" class="headerlink" title="求和我S的子数组个数，数组元素只包含0，1。原题"></a>求和我S的子数组个数，数组元素只包含0，1。<a href="https://leetcode.com/problems/binary-subarrays-with-sum/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: A &#x3D; [1,0,1,0,1], S &#x3D; 2</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: </span><br><span class="line">The 4 subarrays are bolded below:</span><br><span class="line">[1,0,1,0,1]</span><br><span class="line">[1,0,1,0,1]</span><br><span class="line">[1,0,1,0,1]</span><br><span class="line">[1,0,1,0,1]</span><br></pre></td></tr></table></figure>
<p>方法一：这种题要求at_most. 滑动窗口，用和小于等于S的子数组个数减去小于等于S-1的子数组个数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numSubarraysWithSum</span><span class="params">(self, A: List[int], S: int)</span> -&gt; int:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">at_most</span><span class="params">(S)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> S &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            S -= A[j]</span><br><span class="line">            <span class="keyword">while</span> S &lt; <span class="number">0</span>:</span><br><span class="line">                S += A[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            res += j-i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> at_most(S) - at_most(S<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="969-Pancake-Sorting"><a href="#969-Pancake-Sorting" class="headerlink" title="969. Pancake Sorting"></a>969. Pancake Sorting</h3><h4 id="煎饼排序。由1-n组成，没次只能reverse前k个，求k的数组，答案不唯一。原题"><a href="#煎饼排序。由1-n组成，没次只能reverse前k个，求k的数组，答案不唯一。原题" class="headerlink" title="煎饼排序。由1~n组成，没次只能reverse前k个，求k的数组，答案不唯一。原题"></a>煎饼排序。由1~n组成，没次只能reverse前k个，求k的数组，答案不唯一。<a href="https://leetcode.com/problems/pancake-sorting/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: A &#x3D; [3,2,4,1]</span><br><span class="line">Output: [4,2,4,3]</span><br><span class="line">Explanation: </span><br><span class="line">We perform 4 pancake flips, with k values 4, 2, 4, and 3.</span><br><span class="line">Starting state: A &#x3D; [3, 2, 4, 1]</span><br><span class="line">After 1st flip (k &#x3D; 4): A &#x3D; [1, 4, 2, 3]</span><br><span class="line">After 2nd flip (k &#x3D; 2): A &#x3D; [4, 1, 2, 3]</span><br><span class="line">After 3rd flip (k &#x3D; 4): A &#x3D; [3, 2, 1, 4]</span><br><span class="line">After 4th flip (k &#x3D; 3): A &#x3D; [1, 2, 3, 4], which is sorted.</span><br><span class="line">Notice that we return an array of the chosen k values of the pancake flips.</span><br></pre></td></tr></table></figure>
<p>方法一：例子中的做法不是很好，只需要每次找最大的，然后翻到首位，然后再全翻转使其到达末尾。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pancakeSort</span><span class="params">(self, A: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    ans, n = [], len(A)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> A[i] != i+<span class="number">1</span>:</span><br><span class="line">            j = A.index(i+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> j:</span><br><span class="line">                ans.append(j+<span class="number">1</span>)</span><br><span class="line">                A = A[:j+<span class="number">1</span>][::<span class="number">-1</span>] + A[j+<span class="number">1</span>:]</span><br><span class="line">            ans.append(i+<span class="number">1</span>)</span><br><span class="line">            A = A[:i+<span class="number">1</span>][::<span class="number">-1</span>] + A[i+<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：Lee的方法，这种方法把1也放进去了。其实是无所谓的。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pancakeSort</span><span class="params">(self, A: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    ans, n = [], len(A)</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(n, <span class="number">1</span>, <span class="number">-1</span>):</span><br><span class="line">        i = A.index(x)</span><br><span class="line">        ans.extend((i+<span class="number">1</span>, x))</span><br><span class="line">        A = A[:i:<span class="number">-1</span>] + A[:i]</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="1566-Detect-Pattern-of-Length-M-Repeated-K-or-More-Times"><a href="#1566-Detect-Pattern-of-Length-M-Repeated-K-or-More-Times" class="headerlink" title="1566. Detect Pattern of Length M Repeated K or More Times"></a>1566. Detect Pattern of Length M Repeated K or More Times</h3><h4 id="判断数组中是否有k次以上个重复的M大小的组。原题"><a href="#判断数组中是否有k次以上个重复的M大小的组。原题" class="headerlink" title="判断数组中是否有k次以上个重复的M大小的组。原题"></a>判断数组中是否有k次以上个重复的M大小的组。<a href="https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [1,2,4,4,4,4], m &#x3D; 1, k &#x3D; 3</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The pattern (4) of length 1 is repeated 4 consecutive times. Notice that pattern can be repeated k or more times but not less.</span><br></pre></td></tr></table></figure>
<p>方法一：暴力。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">containsPattern</span><span class="params">(self, arr: List[int], m: int, k: int)</span> -&gt; bool:</span></span><br><span class="line">    n = len(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        end = i + m*k</span><br><span class="line">        <span class="keyword">if</span> end &gt; n: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        tmp = arr[i:i+m]</span><br><span class="line">        <span class="comment"># if all(arr[i+m*j:i+m*j+m] == tmp for j in range(1, k)):</span></span><br><span class="line">        <span class="keyword">if</span> arr[i:i+m*k] == tmp*k:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：这个方法挺难想，为什么是<code>(k-1)*m</code>因为第一个用来比较，不算在内，如果在达到之前有一个不相等，则归零。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">containsPattern</span><span class="params">(self, arr: List[int], m: int, k: int)</span> -&gt; bool:</span></span><br><span class="line">    streak = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)-m):</span><br><span class="line">        streak = streak + <span class="number">1</span> <span class="keyword">if</span> arr[i] == arr[i+m] <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> streak == (k<span class="number">-1</span>)*m: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="228-Summary-Ranges"><a href="#228-Summary-Ranges" class="headerlink" title="228. Summary Ranges"></a>228. Summary Ranges</h3><h4 id="格式化一段range。原题"><a href="#格式化一段range。原题" class="headerlink" title="格式化一段range。原题"></a>格式化一段range。<a href="https://leetcode.com/problems/summary-ranges/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input:  [0,1,2,4,5,7]</span><br><span class="line">Output: [&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]</span><br><span class="line">Explanation: 0,1,2 form a continuous range; 4,5 form a continuous range.</span><br></pre></td></tr></table></figure>
<p>方法一：很简单，记录这题主要是学到了一个新的写法。先贴自己的解法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">summaryRanges</span><span class="params">(self, nums: List[int])</span> -&gt; List[str]:</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">or</span> stack[<span class="number">-1</span>][<span class="number">-1</span>]+<span class="number">1</span>&lt;d:</span><br><span class="line">            stack.append([d])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> len(stack[<span class="number">-1</span>]) == <span class="number">2</span>:</span><br><span class="line">                stack[<span class="number">-1</span>].pop()</span><br><span class="line">            stack[<span class="number">-1</span>].append(d)</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">'-&gt;'</span>.join(map(str, p)) <span class="keyword">for</span> p <span class="keyword">in</span> stack]</span><br></pre></td></tr></table></figure>
<p>方法二：stefan的写法。<code>[][1:] = 1,</code>数组会变成[1]。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">summaryRanges</span><span class="params">(self, nums: List[int])</span> -&gt; List[str]:</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">or</span> stack[<span class="number">-1</span>][<span class="number">-1</span>]+<span class="number">1</span>&lt;d:</span><br><span class="line">            stack.append([])</span><br><span class="line">        stack[<span class="number">-1</span>][<span class="number">1</span>:] = d, </span><br><span class="line">    <span class="keyword">return</span> [<span class="string">'-&gt;'</span>.join(map(str, p)) <span class="keyword">for</span> p <span class="keyword">in</span> stack]</span><br></pre></td></tr></table></figure>
<h3 id="769-Max-Chunks-To-Make-Sorted"><a href="#769-Max-Chunks-To-Make-Sorted" class="headerlink" title="769. Max Chunks To Make Sorted"></a>769. Max Chunks To Make Sorted</h3><h4 id="可以将一个数组分成几块小数组，然后使每个小数组排序后连接起来，整个大数组有序，问最多可以分成多少块。原题"><a href="#可以将一个数组分成几块小数组，然后使每个小数组排序后连接起来，整个大数组有序，问最多可以分成多少块。原题" class="headerlink" title="可以将一个数组分成几块小数组，然后使每个小数组排序后连接起来，整个大数组有序，问最多可以分成多少块。原题"></a>可以将一个数组分成几块小数组，然后使每个小数组排序后连接起来，整个大数组有序，问最多可以分成多少块。<a href="https://leetcode.com/problems/max-chunks-to-make-sorted/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [1,0,2,3,4]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation:</span><br><span class="line">We can split into two chunks, such as [1, 0], [2, 3, 4].</span><br><span class="line">However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible.</span><br></pre></td></tr></table></figure>
<p>方法一：直白来看，如果某一段包含了排序后应该有的所有的数，那么久将其分成一段。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxChunksToSorted</span><span class="params">(self, arr: List[int])</span> -&gt; int:</span></span><br><span class="line">    ans, n = <span class="number">0</span>, len(arr)</span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> sorted(arr[start:end]) == list(range(start, end)):</span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">            start = end</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：Lee的方法。当max(A[0]~A[i])==i时分割，其中包含了一个原理，如果更大的数参入到之前的段中，最大值就会更新，想要在某点和索引相等，就必须将比它小的数全找到。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxChunksToSorted</span><span class="params">(self, arr: List[int])</span> -&gt; int:</span></span><br><span class="line">    cur_max, ans = <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(arr):</span><br><span class="line">        cur_max = max(num, cur_max)</span><br><span class="line">        ans += cur_max==i</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="390-Elimination-Game"><a href="#390-Elimination-Game" class="headerlink" title="390. Elimination Game"></a>390. Elimination Game</h3><h4 id="消除游戏，从1-n的数组，每次从左到右隔一个删除，然后从右到左隔一个删除。最后剩下一个数字是哪个。原题"><a href="#消除游戏，从1-n的数组，每次从左到右隔一个删除，然后从右到左隔一个删除。最后剩下一个数字是哪个。原题" class="headerlink" title="消除游戏，从1~n的数组，每次从左到右隔一个删除，然后从右到左隔一个删除。最后剩下一个数字是哪个。原题"></a>消除游戏，从1~n的数组，每次从左到右隔一个删除，然后从右到左隔一个删除。最后剩下一个数字是哪个。<a href="https://leetcode.com/problems/elimination-game/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">n &#x3D; 9,</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br><span class="line">2 4 6 8</span><br><span class="line">2 6</span><br><span class="line">6</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<p>方法一：在用切片方法发现n能到1亿时，超时了；然后想到其实只需要控制一个范围即可。每次操作后，数组中的等差变为原来的2倍。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lastRemaining</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">    start, end, d = <span class="number">1</span>, n, <span class="number">1</span></span><br><span class="line">    op = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> start &lt; end:</span><br><span class="line">        <span class="comment"># print(start, end, d, op)</span></span><br><span class="line">        num = (end-start)//d + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> op:</span><br><span class="line">            start += d</span><br><span class="line">            end -= (num&amp;<span class="number">1</span>) * d</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            start += (num&amp;<span class="number">1</span>) * d</span><br><span class="line">            end -= d</span><br><span class="line">        op ^= <span class="number">1</span></span><br><span class="line">        d *= <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> start</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：整理代码。end其实无用，用一个num表示剩余的数字个数。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lastRemaining</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">    start = d = left = <span class="number">1</span></span><br><span class="line">    num = n</span><br><span class="line">    <span class="keyword">while</span> num &gt; <span class="number">1</span>:</span><br><span class="line">        start += (left <span class="keyword">or</span> (num&amp;<span class="number">1</span>)) * d</span><br><span class="line">        left ^= <span class="number">1</span></span><br><span class="line">        d *= <span class="number">2</span></span><br><span class="line">        num //= <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> start</span><br></pre></td></tr></table></figure>
<h3 id="853-Car-Fleet"><a href="#853-Car-Fleet" class="headerlink" title="853. Car Fleet"></a>853. Car Fleet</h3><h4 id="超车车队，说有这么一些车向同一个目的地出发，起始位置和速度不同，当快车遇见慢车时不能超过，而是跟在后面变成一个车队。问最后到达终点时有几个车队，1辆车也算一个车队。原题"><a href="#超车车队，说有这么一些车向同一个目的地出发，起始位置和速度不同，当快车遇见慢车时不能超过，而是跟在后面变成一个车队。问最后到达终点时有几个车队，1辆车也算一个车队。原题" class="headerlink" title="超车车队，说有这么一些车向同一个目的地出发，起始位置和速度不同，当快车遇见慢车时不能超过，而是跟在后面变成一个车队。问最后到达终点时有几个车队，1辆车也算一个车队。原题"></a>超车车队，说有这么一些车向同一个目的地出发，起始位置和速度不同，当快车遇见慢车时不能超过，而是跟在后面变成一个车队。问最后到达终点时有几个车队，1辆车也算一个车队。<a href="https://leetcode.com/problems/car-fleet/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: target &#x3D; 12, position &#x3D; [10,8,0,5,3], speed &#x3D; [2,4,1,1,3]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">The cars starting at 10 and 8 become a fleet, meeting each other at 12.</span><br><span class="line">The car starting at 0 doesn&#39;t catch up to any other car, so it is a fleet by itself.</span><br><span class="line">The cars starting at 5 and 3 become a fleet, meeting each other at 6.</span><br><span class="line">Note that no other cars meet these fleets before the destination, so the answer is 3.</span><br></pre></td></tr></table></figure>
<p>方法一：思路很快想出来了，就是排序，但是根据什么排序，怎么比较想了半天。问题出在这个例子上：<code>10, [0,4,2],[2,1,3]</code>这个排序后时<code>[(4, 6), (2, 2.6), (0, 5)]</code>，以起始点位置排序，当一个时间小于等于之前的时间时，那么这辆车就能追上之前的，变成一个车队；反之，则形成一个单独的车队。这个“之前的时间”指的不是挨着的前面的一个时间，而是之前最慢的一个车。也就是时间最大的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">carFleet</span><span class="params">(self, target: int, position: List[int], speed: List[int])</span> -&gt; int:</span></span><br><span class="line">    cars = ((target-p)/s <span class="keyword">for</span> p, s <span class="keyword">in</span> sorted(zip(position, speed), reverse=<span class="literal">True</span>))</span><br><span class="line">    ans = cur_t = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> cars:</span><br><span class="line">        <span class="keyword">if</span> t &gt; cur_t:</span><br><span class="line">            cur_t = t</span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="1574-Shortest-Subarray-to-be-Removed-to-Make-Array-Sorted"><a href="#1574-Shortest-Subarray-to-be-Removed-to-Make-Array-Sorted" class="headerlink" title="1574. Shortest Subarray to be Removed to Make Array Sorted"></a>1574. Shortest Subarray to be Removed to Make Array Sorted</h3><h4 id="删除一个最短的子数组使整个数组有序。问最短数组长度为多少。原题"><a href="#删除一个最短的子数组使整个数组有序。问最短数组长度为多少。原题" class="headerlink" title="删除一个最短的子数组使整个数组有序。问最短数组长度为多少。原题"></a>删除一个最短的子数组使整个数组有序。问最短数组长度为多少。<a href="https://leetcode.com/problems/shortest-subarray-to-be-removed-to-make-array-sorted/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [1,2,3,10,4,2,3,5]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The shortest subarray we can remove is [10,4,2] of length 3. The remaining elements after that will be [1,2,3,3,5] which are sorted.</span><br><span class="line">Another correct solution is to remove the subarray [3,10,4].</span><br></pre></td></tr></table></figure>
<p>方法一：这个题竞赛时没做出来，只想到从左到右找坏的点，没想到从右到左也需要找一次。而且找完之后，要控制两个指针，从0和j出发遍历，自己想的是从中间往两边遍历。边界条件非常多。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findLengthOfShortestSubarray</span><span class="params">(self, arr: List[int])</span> -&gt; int:</span></span><br><span class="line">    n = len(arr)</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i+<span class="number">1</span>&lt;n <span class="keyword">and</span> arr[i]&lt;=arr[i+<span class="number">1</span>]: i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i == n<span class="number">-1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    j = n<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> j &gt; i <span class="keyword">and</span> arr[j<span class="number">-1</span>] &lt;= arr[j]: j -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> j == <span class="number">0</span>: <span class="keyword">return</span> n<span class="number">-1</span></span><br><span class="line">    ans = min(n-i<span class="number">-1</span>, j)</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = j</span><br><span class="line">    <span class="keyword">while</span> left &lt;= i <span class="keyword">and</span> right &lt; n:</span><br><span class="line">        <span class="keyword">if</span> arr[right] &gt;= arr[left]:</span><br><span class="line">            ans = min(ans, right-left<span class="number">-1</span>)</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="835-Image-Overlap"><a href="#835-Image-Overlap" class="headerlink" title="835. Image Overlap"></a>835. Image Overlap</h3><h4 id="图片覆盖。两个二维矩阵，A可以向一个方向滑动N个单位，然后放到B上，如果都为1，则表示某个像素是覆盖的。求最多有多少个像素覆盖。原题"><a href="#图片覆盖。两个二维矩阵，A可以向一个方向滑动N个单位，然后放到B上，如果都为1，则表示某个像素是覆盖的。求最多有多少个像素覆盖。原题" class="headerlink" title="图片覆盖。两个二维矩阵，A可以向一个方向滑动N个单位，然后放到B上，如果都为1，则表示某个像素是覆盖的。求最多有多少个像素覆盖。原题"></a>图片覆盖。两个二维矩阵，A可以向一个方向滑动N个单位，然后放到B上，如果都为1，则表示某个像素是覆盖的。求最多有多少个像素覆盖。<a href="https://leetcode.com/problems/image-overlap/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: A &#x3D; [[1,1,0],</span><br><span class="line">            [0,1,0],</span><br><span class="line">            [0,1,0]]</span><br><span class="line">       B &#x3D; [[0,0,0],</span><br><span class="line">            [0,1,1],</span><br><span class="line">            [0,0,1]]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: We slide A to right by 1 unit and down by 1 unit.</span><br></pre></td></tr></table></figure>
<p>方法一：逆向思维，将1的点都求出来，然后每两个做比较。相同偏移量的算到一起。</p>
<pre><code>def largestOverlap(self, A: List[List[int]], B: List[List[int]]) -&gt; int:
    A = [(x, y) for x, row in enumerate(A) for y, d in enumerate(row) if d]
    B = [(x, y) for x, row in enumerate(B) for y, d in enumerate(row) if d]
    c = Counter((xa-xb, ya-yb) for xa, ya in A for xb, yb in B)
    return max(c.values() or [0])
</code></pre><p>方法二：数学的降维打击。卷积。其中涉及到了一些数学知识还没有完全参透。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.signal <span class="keyword">import</span> convolve2d</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestOverlap</span><span class="params">(self, A: List[List[int]], B: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> np.max(convolve2d(A, np.rot90(B, <span class="number">2</span>)))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.signal <span class="keyword">import</span> correlate2d</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestOverlap</span><span class="params">(self, A: List[List[int]], B: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> correlate2d(A, B).max()</span><br></pre></td></tr></table></figure>
<h3 id="42-Trapping-Rain-Water"><a href="#42-Trapping-Rain-Water" class="headerlink" title="42. Trapping Rain Water"></a>42. Trapping Rain Water</h3><h4 id="接雨水。给定一些柱状图的高度，问能接多少雨水。原题"><a href="#接雨水。给定一些柱状图的高度，问能接多少雨水。原题" class="headerlink" title="接雨水。给定一些柱状图的高度，问能接多少雨水。原题"></a>接雨水。给定一些柱状图的高度，问能接多少雨水。<a href="https://leetcode.com/problems/trapping-rain-water/" target="_blank" rel="noopener">原题</a></h4><img src="/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%95%B0%E7%BB%84%E7%AF%87%EF%BC%89Array/rainwatertrap.png" class>
<p>方法一：用了逆向思维，通过总面积-损失的水-柱体面积求的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> height: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    h_max, n = max(height), len(height)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_lost</span><span class="params">(heights, target)</span>:</span></span><br><span class="line">        cur_h = lost = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, h <span class="keyword">in</span> enumerate(heights):</span><br><span class="line">            lost += max(h-cur_h, <span class="number">0</span>) * i   </span><br><span class="line">            cur_h = max(cur_h, h)</span><br><span class="line">            <span class="keyword">if</span> h == target:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> lost</span><br><span class="line">    </span><br><span class="line">    lost = get_lost(height, h_max) + get_lost(height[::<span class="number">-1</span>], h_max)</span><br><span class="line">    <span class="keyword">return</span> n*h_max - lost - sum(height)</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：遍历一次，其实思路是一样的，从两边到中间，当遇见一次下降时，计算差值面积，就是蓄水面积。left_max, right_max可以看做是两面墙。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">    left, right = <span class="number">0</span>, len(height)<span class="number">-1</span></span><br><span class="line">    ans = left_max = right_max = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        left_max = max(left_max, height[left])</span><br><span class="line">        right_max = max(right_max, height[right])</span><br><span class="line">        <span class="keyword">if</span> left_max &lt; right_max:</span><br><span class="line">            ans += left_max - height[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ans += right_max - height[right]</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="36-Valid-Sudoku"><a href="#36-Valid-Sudoku" class="headerlink" title="36. Valid Sudoku"></a>36. Valid Sudoku</h3><h4 id="验证一个数独的正确性，只需要考虑填入数字的格子。原题"><a href="#验证一个数独的正确性，只需要考虑填入数字的格子。原题" class="headerlink" title="验证一个数独的正确性，只需要考虑填入数字的格子。原题"></a>验证一个数独的正确性，只需要考虑填入数字的格子。<a href="https://leetcode.com/problems/valid-sudoku/" target="_blank" rel="noopener">原题</a></h4><p>方法一：比较直观的写法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span><span class="params">(self, board: List[List[str]])</span> -&gt; bool:</span></span><br><span class="line">    row = [[<span class="literal">True</span>]*<span class="number">9</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>)]        </span><br><span class="line">    col = [[<span class="literal">True</span>]*<span class="number">9</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>)]</span><br><span class="line">    sub = [[<span class="literal">True</span>]*<span class="number">9</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">if</span> board[i][j] != <span class="string">'.'</span>:</span><br><span class="line">                d = int(board[i][j]) - <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> (row[i][d] <span class="keyword">and</span> col[j][d] <span class="keyword">and</span> sub[i//<span class="number">3</span>*<span class="number">3</span>+j//<span class="number">3</span>][d]):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                row[i][d] = col[j][d] = sub[i//<span class="number">3</span>*<span class="number">3</span>+j//<span class="number">3</span>][d] = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：Counter, by Stefan. 记录3种元素，如果有重复的 就说明不行。这里和python2有个区别，原来是用的+，python3中字典的values()方法返回的是一个<code>dict_values</code>的对象。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span><span class="params">(self, board: List[List[str]])</span> -&gt; bool:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> == max(collections.Counter(</span><br><span class="line">        x <span class="keyword">for</span> i, row <span class="keyword">in</span> enumerate(board)</span><br><span class="line">        <span class="keyword">for</span> j, c <span class="keyword">in</span> enumerate(row)</span><br><span class="line">        <span class="keyword">if</span> c != <span class="string">'.'</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> ((c, i), (j, c), (i//<span class="number">3</span>, j//<span class="number">3</span>, c))</span><br><span class="line">    ).values() <span class="keyword">or</span> [<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法三：同样来自Stefan，这个方法很有趣，将判断放到了生成器中。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span><span class="params">(self, board: List[List[str]])</span> -&gt; bool:</span></span><br><span class="line">    seen = set()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">not</span> any(x <span class="keyword">in</span> seen <span class="keyword">or</span> seen.add(x)</span><br><span class="line">                   <span class="keyword">for</span> i, row <span class="keyword">in</span> enumerate(board)</span><br><span class="line">                   <span class="keyword">for</span> j, c <span class="keyword">in</span> enumerate(row)</span><br><span class="line">                   <span class="keyword">if</span> c != <span class="string">'.'</span></span><br><span class="line">                   <span class="keyword">for</span> x <span class="keyword">in</span> ((c, i), (j, c), (i//<span class="number">3</span>, j//<span class="number">3</span>, c)))</span><br></pre></td></tr></table></figure>
<h3 id="1054-Distant-Barcodes"><a href="#1054-Distant-Barcodes" class="headerlink" title="1054. Distant Barcodes"></a><a href="https://leetcode.com/problems/distant-barcodes/" target="_blank" rel="noopener">1054. Distant Barcodes</a></h3><h4 id="分散的条形码，就是将一个数组中的元素重新排序，让其没有两个一样的相邻。原题"><a href="#分散的条形码，就是将一个数组中的元素重新排序，让其没有两个一样的相邻。原题" class="headerlink" title="分散的条形码，就是将一个数组中的元素重新排序，让其没有两个一样的相邻。原题"></a>分散的条形码，就是将一个数组中的元素重新排序，让其没有两个一样的相邻。<a href="ps://leetcode.com/problems/distant-barcodes/">原题</a></h4><p>方法一：我首次AC的方法就是用堆，取出一个或者2个数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rearrangeBarcodes</span><span class="params">(self, barcodes: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    c = Counter(barcodes)</span><br><span class="line">    heap = []</span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> c.items():</span><br><span class="line">        heapq.heappush(heap, (-v, k))</span><br><span class="line">    <span class="keyword">while</span> heap:</span><br><span class="line">        most, d1 = heapq.heappop(heap)</span><br><span class="line">        <span class="keyword">if</span> ans <span class="keyword">and</span> ans[<span class="number">-1</span>]==d1:</span><br><span class="line">            more, d2 = heapq.heappop(heap)</span><br><span class="line">            ans.append(d2)</span><br><span class="line">            <span class="keyword">if</span> more &lt; <span class="number">-1</span>:</span><br><span class="line">                heapq.heappush(heap, (more+<span class="number">1</span>, d2))</span><br><span class="line">            heapq.heappush(heap, (most, d1))</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        ans.append(d1)</span><br><span class="line">        <span class="keyword">if</span> most &lt; <span class="number">-1</span>:</span><br><span class="line">            heapq.heappush(heap, (most+<span class="number">1</span>, d1))</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：by Lee, 将最多的数字，按索引分割依次插入。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rearrangeBarcodes</span><span class="params">(self, barcodes: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    i, n = <span class="number">0</span>, len(barcodes)</span><br><span class="line">    ans = [<span class="number">0</span>] * n</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> collections.Counter(barcodes).most_common():</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(v):</span><br><span class="line">            ans[i] = k</span><br><span class="line">            i += <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= n: i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法三：by Lee，看到方法二时就想到了，这里需要注意一下，排序时要用一个元组，将一样的元素放到一起。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rearrangeBarcodes</span><span class="params">(self, a: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    count = collections.Counter(a)</span><br><span class="line">    a.sort(key=<span class="keyword">lambda</span> x: (count[x], x))</span><br><span class="line">    a[<span class="number">1</span>::<span class="number">2</span>], a[::<span class="number">2</span>] = a[:len(a)//<span class="number">2</span>], a[len(a)//<span class="number">2</span>:]</span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>
<h3 id="1588-Sum-of-All-Odd-Length-Subarrays"><a href="#1588-Sum-of-All-Odd-Length-Subarrays" class="headerlink" title="1588. Sum of All Odd Length Subarrays"></a><a href="https://leetcode.com/problems/sum-of-all-odd-length-subarrays/" target="_blank" rel="noopener">1588. Sum of All Odd Length Subarrays</a></h3><h4 id="求所有奇数长度的子数组的和。"><a href="#求所有奇数长度的子数组的和。" class="headerlink" title="求所有奇数长度的子数组的和。"></a>求所有奇数长度的子数组的和。</h4><p>方法一：这题给的范围比较小，竞赛时用O(n^2)暴力就解了，不过实际有O(n)的方法。通过前缀和的方式，累加，再通过减法算和。比如<code>[1,4,2,5,3]</code>。<code>j-i</code>表示的是子数组的长度。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumOddLengthSubarrays</span><span class="params">(self, arr: List[int])</span> -&gt; int:</span></span><br><span class="line">    n, sum_odd = len(arr), <span class="number">0</span></span><br><span class="line">    p_sum = [<span class="number">0</span>] + list(itertools.accumulate(arr))</span><br><span class="line">    <span class="keyword">for</span> i, p <span class="keyword">in</span> enumerate(p_sum):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, n + <span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">            <span class="comment"># print(i, j, p_sum[j], p_sum[i])</span></span><br><span class="line">            sum_odd += p_sum[j] - p_sum[i] </span><br><span class="line">    <span class="keyword">return</span> sum_odd</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0 1 1 0</span><br><span class="line">0 3 7 0</span><br><span class="line">0 5 15 0</span><br><span class="line">1 2 5 1</span><br><span class="line">1 4 12 1</span><br><span class="line">2 3 7 5</span><br><span class="line">2 5 15 5</span><br><span class="line">3 4 12 7</span><br><span class="line">4 5 15 12</span><br></pre></td></tr></table></figure>
<p>方法二：通过观察可以找到规律，每个数字出现的个数是有规律的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 subarray length 1</span><br><span class="line">1 2 X X X subarray length 2</span><br><span class="line">X 2 3 X X subarray length 2</span><br><span class="line">X X 3 4 X subarray length 2</span><br><span class="line">X X X 4 5 subarray length 2</span><br><span class="line">1 2 3 X X subarray length 3</span><br><span class="line">X 2 3 4 X subarray length 3</span><br><span class="line">X X 3 4 5 subarray length 3</span><br><span class="line">1 2 3 4 X subarray length 4</span><br><span class="line">X 2 3 4 5 subarray length 4</span><br><span class="line">1 2 3 4 5 subarray length 5</span><br><span class="line"></span><br><span class="line">5 8 9 8 5 total times each index was added.</span><br><span class="line">3 4 5 4 3 total times in odd length array with (x + 1) &#x2F; 2</span><br><span class="line">2 4 4 4 2 total times in even length array with x &#x2F; 2</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：在所有子数组中，不管奇偶总共有多少，比如包含2的子数组，左边有2个子数组，右边4个子数组，一共有2<em>4，也就是说<br><br>对于第i个元素，包含第i个元素的子数组=`(i+1) </em> (n-i)<code>奇数数组</code>(x+1)//2`, x表示总数。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumOddLengthSubarrays</span><span class="params">(self, arr: List[int])</span> -&gt; int:</span></span><br><span class="line">    ans, n = <span class="number">0</span>, len(arr)</span><br><span class="line">    <span class="keyword">for</span> i, a <span class="keyword">in</span> enumerate(arr):</span><br><span class="line">        ans += (((i+<span class="number">1</span>)*(n-i) + <span class="number">1</span>) // <span class="number">2</span>) * a</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="面试题-16-22-兰顿蚂蚁"><a href="#面试题-16-22-兰顿蚂蚁" class="headerlink" title="面试题 16.22. 兰顿蚂蚁"></a><a href="https://leetcode-cn.com/problems/langtons-ant-lcci/" target="_blank" rel="noopener">面试题 16.22. 兰顿蚂蚁</a></h3><blockquote>
<p><strong>兰顿蚂蚁</strong>（英语：Langton’s ant）是<a href="https://zh.wikipedia.org/wiki/細胞自動機" target="_blank" rel="noopener">细胞自动机</a>的例子。它由<a href="https://zh.wikipedia.org/w/index.php?title=克里斯托夫·兰顿&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">克里斯托夫·兰顿</a>在1986年提出，它由黑白格子和一只“蚂蚁”构成<a href="https://zh.wikipedia.org/wiki/兰顿蚂蚁#cite_note-1" target="_blank" rel="noopener">[1]</a>，是一个二维<a href="https://zh.wikipedia.org/wiki/图灵机" target="_blank" rel="noopener">图灵机</a>。兰顿蚂蚁拥有非常简单的逻辑和复杂的表现。在2000年兰顿蚂蚁的<a href="https://zh.wikipedia.org/wiki/圖靈完備性" target="_blank" rel="noopener">图灵完备性</a>被证明。兰顿蚂蚁的想法后来被推广，比如使用多种颜色。</p>
<p>若从全白的背景开始，在一开始的数百步，蚂蚁留下的路线会出现许多对称或重复的形状，然后会出现类似混沌的假随机，至约一万步后会出现以104步为周期无限重复的“高速公路”朝固定方向移动<a href="https://zh.wikipedia.org/wiki/兰顿蚂蚁#cite_note-2" target="_blank" rel="noopener">[2]</a>。在目前试过的所有起始状态，蚂蚁的路线最终都会变成高速公路，但尚无法证明这是无论任何起始状态都会导致的必然结果<a href="https://zh.wikipedia.org/wiki/兰顿蚂蚁#cite_note-3" target="_blank" rel="noopener">[3]</a>。</p>
</blockquote>
<p>这道题非常有意思。一只蚂蚁坐在由白色和黑色方格构成的无限网格上。开始时，网格全白，蚂蚁面向右侧。每行走一步，蚂蚁执行以下操作。返回能够包含蚂蚁走过的所有方格的最小矩形。</p>
<p>(1) 如果在白色方格上，则翻转方格的颜色，向右(顺时针)转 90 度，并向前移动一个单位。<br>(2) 如果在黑色方格上，则翻转方格的颜色，向左(逆时针方向)转 90 度，并向前移动一个单位</p>
<font color="#32CD32" size="3">方法一：刚看到此题时草率了，还想找到规律，后来一搜，原来在一万步之后才会出现某种规律，打扰了。此方法用了一个二维的双端队列模拟的。700ms, 40。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printKMoves</span><span class="params">(self, K: int)</span> -&gt; List[str]:</span></span><br><span class="line">    ax, ay = <span class="number">0</span>, <span class="number">0</span>  <span class="comment"># 蚂蚁🐜</span></span><br><span class="line">    di, dj, m, n = <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>  <span class="comment"># 方向和矩阵高，长</span></span><br><span class="line">    g = deque([deque([<span class="number">0</span>])])  <span class="comment"># 0 表示白色</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(K):</span><br><span class="line">        <span class="keyword">if</span> g[ax][ay]==<span class="number">0</span>:</span><br><span class="line">            di, dj = dj, -di  <span class="comment"># 顺时针</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            di, dj = -dj, di  <span class="comment"># 逆时针</span></span><br><span class="line">        g[ax][ay] ^= <span class="number">1</span>        <span class="comment"># 翻转</span></span><br><span class="line">        ax, ay = ax+di, ay+dj   <span class="comment"># 移动</span></span><br><span class="line">        <span class="keyword">if</span> ax <span class="keyword">in</span> (<span class="number">-1</span>, m):       <span class="comment"># 上下越界</span></span><br><span class="line">            g.append(deque([<span class="number">0</span>]*n))</span><br><span class="line">            g.rotate(ax&lt;<span class="number">0</span>)       <span class="comment"># 上越界，直接appendleft也可以，这里写到了一起</span></span><br><span class="line">            m += <span class="number">1</span></span><br><span class="line">            ax = max(ax, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">elif</span> ay &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> row <span class="keyword">in</span> g:</span><br><span class="line">                row.appendleft(<span class="number">0</span>)            </span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">            ay += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> ay &gt;= n:</span><br><span class="line">            <span class="keyword">for</span> row <span class="keyword">in</span> g:</span><br><span class="line">                row.append(<span class="number">0</span>)</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">    g[ax][ay] = <span class="number">-1</span></span><br><span class="line">    d = ((<span class="string">'LR'</span>, <span class="string">'UD'</span>)[di][(dj&gt;=<span class="number">0</span>)&amp;(di&gt;=<span class="number">0</span>)])  <span class="comment"># 阴间写法</span></span><br><span class="line">    <span class="comment"># d = &#123;(0, -1): 'L', (-1, 0): 'U', (1, 0): 'D', (0, 1): 'R'&#125;[di, dj] # 阳间写法</span></span><br><span class="line">    ans = [<span class="string">''</span>.join((<span class="string">'_X'</span>+d)[c] <span class="keyword">for</span> c <span class="keyword">in</span> row) <span class="keyword">for</span> row <span class="keyword">in</span> g]</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>方法二：受评论区大神启发，使用<code>defaultdict</code>来避免每次都移动数组。写法是不错，但是时间和空间上都比方法一差太多，时间是3，4倍，空间是10倍。所以我改了一下改成两个defaultdict，时间上虽然还是不如方法一，但是时间空间都好了一半。最后是1500ms, 240M。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printKMoves</span><span class="params">(self, K: int)</span> -&gt; List[str]:</span></span><br><span class="line">    ax, ay = <span class="number">0</span>, <span class="number">0</span>  <span class="comment"># 蚂蚁🐜</span></span><br><span class="line">    di, dj, m, n = <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>  <span class="comment"># 初始方向和矩阵高，长</span></span><br><span class="line">    g = defaultdict(<span class="keyword">lambda</span>: defaultdict(int))</span><br><span class="line">    r1 = r2 = c1 = c2 = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spread</span><span class="params">(x, y)</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> r1, r2, c1, c2</span><br><span class="line">        r1, r2, c1, c2 = min(r1, x), max(r2, x), min(c1, y), max(c2, y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(K):</span><br><span class="line">        <span class="keyword">if</span> g[ax][ay]==<span class="number">0</span>:</span><br><span class="line">            di, dj = dj, -di  <span class="comment"># 顺时针</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            di, dj = -dj, di  <span class="comment"># 逆时针</span></span><br><span class="line">        g[ax][ay] ^= <span class="number">1</span>        <span class="comment"># 翻转</span></span><br><span class="line">        ax, ay = ax+di, ay+dj   <span class="comment"># 移动</span></span><br><span class="line">        spread(ax, ay)</span><br><span class="line">    g[ax][ay] = <span class="number">-1</span></span><br><span class="line">    d = ((<span class="string">'LR'</span>, <span class="string">'UD'</span>)[di][(dj&gt;=<span class="number">0</span>)&amp;(di&gt;=<span class="number">0</span>)])  <span class="comment"># 阴间写法</span></span><br><span class="line">    <span class="comment"># d = &#123;(0, -1): 'L', (-1, 0): 'U', (1, 0): 'D', (0, 1): 'R'&#125;[di, dj] # 阳间写法</span></span><br><span class="line">    ans = [<span class="string">''</span>.join((<span class="string">'_X'</span>+d)[g[i][j]] </span><br><span class="line">           <span class="keyword">for</span> j <span class="keyword">in</span> range(c1, c2+<span class="number">1</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> range(r1, r2+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="41-First-Missing-Positive"><a href="#41-First-Missing-Positive" class="headerlink" title="41. First Missing Positive"></a><a href="https://leetcode.com/problems/first-missing-positive/" target="_blank" rel="noopener">41. First Missing Positive</a></h3><h4 id="找到数组中最小的缺失的正数。数组中可能包含负数。要求在O-N-时间，常数空间实现。"><a href="#找到数组中最小的缺失的正数。数组中可能包含负数。要求在O-N-时间，常数空间实现。" class="headerlink" title="找到数组中最小的缺失的正数。数组中可能包含负数。要求在O(N)时间，常数空间实现。"></a>找到数组中最小的缺失的正数。数组中可能包含负数。要求在O(N)时间，常数空间实现。</h4><p>方法一：难点在于复杂度的要求。这个方法没想到，但是感觉之前用过，忘记是哪道题了。就是将元素放在它对应的索引上。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        <span class="keyword">while</span> <span class="number">0</span> &lt;= nums[i]<span class="number">-1</span> &lt; len(nums) <span class="keyword">and</span> nums[nums[i]<span class="number">-1</span>] != nums[i]:</span><br><span class="line">            j = nums[i] - <span class="number">1</span></span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] != i+<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> len(nums) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="面试题-17-18-最短超串"><a href="#面试题-17-18-最短超串" class="headerlink" title="面试题 17.18. 最短超串"></a><a href="https://leetcode-cn.com/problems/shortest-supersequence-lcci/" target="_blank" rel="noopener">面试题 17.18. 最短超串</a></h4><h4 id="找到包含small所有元素最短子数组的最小索引。"><a href="#找到包含small所有元素最短子数组的最小索引。" class="headerlink" title="找到包含small所有元素最短子数组的最小索引。"></a>找到包含small所有元素最短子数组的最小索引。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">big &#x3D; [7,5,9,0,2,1,3,5,7,9,1,1,5,8,8,9,7]</span><br><span class="line">small &#x3D; [1,5,9]</span><br><span class="line">输出: [7,10]</span><br></pre></td></tr></table></figure>
<p>方法一：滑动窗口。挺简单的一次就AC了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortestSeq</span><span class="params">(self, big: List[int], small: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    ans, c, s = [], defaultdict(int), set(small)</span><br><span class="line">    i, min_len = <span class="number">0</span>, float(<span class="string">'inf'</span>)</span><br><span class="line">    <span class="keyword">for</span> end, d <span class="keyword">in</span> enumerate(big):</span><br><span class="line">        <span class="keyword">if</span> d <span class="keyword">in</span> s:</span><br><span class="line">            c[d] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> len(c) == len(s):</span><br><span class="line">            <span class="keyword">if</span> end-i+<span class="number">1</span> &lt; min_len:</span><br><span class="line">                min_len = end - i + <span class="number">1</span></span><br><span class="line">                ans = [i, end]</span><br><span class="line">            <span class="keyword">if</span> big[i] <span class="keyword">in</span> s:</span><br><span class="line">                c[big[i]] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> c[big[i]] == <span class="number">0</span>:</span><br><span class="line">                    c.pop(big[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="289-Game-of-Life"><a href="#289-Game-of-Life" class="headerlink" title="289. Game of Life"></a><a href="https://leetcode.com/problems/game-of-life/" target="_blank" rel="noopener">289. Game of Life</a></h3><blockquote>
<h4 id="生命游戏，简称为生命，是英国数学家约翰·何顿·康威在-1970-年发明的细胞自动机。"><a href="#生命游戏，简称为生命，是英国数学家约翰·何顿·康威在-1970-年发明的细胞自动机。" class="headerlink" title="生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。"></a>生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。</h4><p>给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：</p>
<p>如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；<br>如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；<br>如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；<br>如果死细胞周围正好有三个活细胞，则该位置死细胞复活；<br>根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。</p>
</blockquote>
<p>你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。<br>本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？</p>
<p>方法一：首次AC的方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gameOfLife</span><span class="params">(self, board: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    m, n = len(board), len(board[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count_live</span><span class="params">(i, j)</span>:</span></span><br><span class="line">        neighbors = ((<span class="number">1</span>, <span class="number">0</span>), (<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">-1</span>), </span><br><span class="line">                     (<span class="number">-1</span>, <span class="number">-1</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">-1</span>), (<span class="number">-1</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> sum(board[i+di][j+dj] <span class="keyword">for</span> di, dj <span class="keyword">in</span> neighbors </span><br><span class="line">                   <span class="keyword">if</span> <span class="number">0</span>&lt;=i+di&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=j+dj&lt;n)</span><br><span class="line">    </span><br><span class="line">    g = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            c = count_live(i, j)</span><br><span class="line">            g[i][j] = int(c==<span class="number">3</span> <span class="keyword">or</span> (c==<span class="number">2</span> <span class="keyword">and</span> board[i][j]))</span><br><span class="line"></span><br><span class="line">    board[:] = g</span><br></pre></td></tr></table></figure>
<p>方法二：如果面板是无限的，如何考虑呢？Stefan这样写，一个辅助函数来根据所有当前活着的细胞计算下一个状态的活细胞集。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gameOfLife</span><span class="params">(self, board: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gameOfLifeInfinite</span><span class="params">(live)</span>:</span></span><br><span class="line">        ctr = collections.Counter((I, J)</span><br><span class="line">                                  <span class="keyword">for</span> i, j <span class="keyword">in</span> live</span><br><span class="line">                                  <span class="keyword">for</span> I <span class="keyword">in</span> range(i<span class="number">-1</span>, i+<span class="number">2</span>)</span><br><span class="line">                                  <span class="keyword">for</span> J <span class="keyword">in</span> range(j<span class="number">-1</span>, j+<span class="number">2</span>)</span><br><span class="line">                                  <span class="keyword">if</span> I != i <span class="keyword">or</span> J != j)</span><br><span class="line">        <span class="keyword">return</span> &#123;ij</span><br><span class="line">                <span class="keyword">for</span> ij <span class="keyword">in</span> ctr</span><br><span class="line">                <span class="keyword">if</span> ctr[ij] == <span class="number">3</span> <span class="keyword">or</span> ctr[ij] == <span class="number">2</span> <span class="keyword">and</span> ij <span class="keyword">in</span> live&#125;</span><br><span class="line">    </span><br><span class="line">    live = &#123;(i, j) <span class="keyword">for</span> i, row <span class="keyword">in</span> enumerate(board) <span class="keyword">for</span> j, live <span class="keyword">in</span> enumerate(row) <span class="keyword">if</span> live&#125;</span><br><span class="line">    live = gameOfLifeInfinite(live)</span><br><span class="line">    <span class="keyword">for</span> i, row <span class="keyword">in</span> enumerate(board):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(row)):</span><br><span class="line">            row[j] = int((i, j) <span class="keyword">in</span> live)</span><br></pre></td></tr></table></figure>
<p>方法三：此题可以使用生成器来建模，在《effictive python》中有一个非常经典的例子，《Fluent Python》中作者也提到了这个例子。我在次基础上修改了一点，主要是针对边界处理。每一个细胞都表示为一个协程，并令这些协程步调一致地向前推进。<code>step_cell</code>是一个协程，会生成·<code>Transition</code>对象用来表示细胞的状态迁移。每个细胞都可以通过运行<code>step_cell</code>来迁移到下一个状态。待所有细胞都迁移好之后，游戏的始终就会向前走一步。只要<code>simulate</code>协程在推进，这个过程就会一直持续下去。协程的优势就在于此。它令开发者所用的实现代码相互解耦。这使得程序好像能够平行地运行多个协程，也使得开发者能够在不修改协程的前提下，逐渐改进发布指令时所用的代码。不过书中说的一点没有明白”如果传入的坐标越界，那就自动折回，这使得网格看上去好像是一种无限循环的空间”，书中使用了取余的方式，但是本题中越界应该返回0。这套模板代码演示了如何用协程分离程序中的各个关注点，而关注点的分离，正是一条重要的设计原则。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">Query = namedtuple(<span class="string">'Query'</span>, <span class="string">'y x'</span>)   <span class="comment"># 用于查询细胞的状态，这里实现很巧妙可以使协程通过此对象向外围环境查询信息</span></span><br><span class="line">Transition = namedtuple(<span class="string">'Transition'</span>, <span class="string">'y x state'</span>)  <span class="comment"># 表示细胞的状态迁移</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gameOfLife</span><span class="params">(self, board: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.board = board</span><br><span class="line">        self.TICK = object()	<span class="comment"># 停止标识，标志着一轮模拟结束</span></span><br><span class="line">        sim = self.simulate(len(board), len(board[<span class="number">0</span>]))</span><br><span class="line">        ans = self.live_a_generation(sim)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                board[i][j] = ans[i,j]</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count_neighbors</span><span class="params">(self, y, x)</span>:</span>		<span class="comment">#查询了细胞周围的8个细胞状态</span></span><br><span class="line">        n_ = <span class="keyword">yield</span> Query(y + <span class="number">1</span>, x + <span class="number">0</span>)  <span class="comment"># North</span></span><br><span class="line">        ne = <span class="keyword">yield</span> Query(y + <span class="number">1</span>, x + <span class="number">1</span>)  <span class="comment"># Northeast</span></span><br><span class="line">        e_ = <span class="keyword">yield</span> Query(y + <span class="number">0</span>, x + <span class="number">1</span>)  <span class="comment"># East</span></span><br><span class="line">        se = <span class="keyword">yield</span> Query(y - <span class="number">1</span>, x + <span class="number">1</span>)  <span class="comment"># Southeast</span></span><br><span class="line">        s_ = <span class="keyword">yield</span> Query(y - <span class="number">1</span>, x + <span class="number">0</span>)  <span class="comment"># South</span></span><br><span class="line">        sw = <span class="keyword">yield</span> Query(y - <span class="number">1</span>, x - <span class="number">1</span>)  <span class="comment"># Southwest</span></span><br><span class="line">        w_ = <span class="keyword">yield</span> Query(y + <span class="number">0</span>, x - <span class="number">1</span>)  <span class="comment"># West</span></span><br><span class="line">        nw = <span class="keyword">yield</span> Query(y + <span class="number">1</span>, x - <span class="number">1</span>)  <span class="comment"># Northwest</span></span><br><span class="line">        neighbor_states = [n_, ne, e_, se, s_, sw, w_, nw]</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> state <span class="keyword">in</span> neighbor_states:</span><br><span class="line">            <span class="keyword">if</span> state == <span class="number">1</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">game_logic</span><span class="params">(self, state, neighbors)</span>:</span>   <span class="comment"># 游戏逻辑</span></span><br><span class="line">        <span class="keyword">if</span> state == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> neighbors &lt; <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>     <span class="comment"># Die: Too few</span></span><br><span class="line">            <span class="keyword">elif</span> neighbors &gt; <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>     <span class="comment"># Die: Too many</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> neighbors == <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>     <span class="comment"># Regenerate</span></span><br><span class="line">        <span class="keyword">return</span> state</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">step_cell</span><span class="params">(self, y, x)</span>:</span>		</span><br><span class="line">        state = <span class="keyword">yield</span> Query(y, x)		<span class="comment"># 查询当前细胞状态</span></span><br><span class="line">        neighbors = <span class="keyword">yield</span> <span class="keyword">from</span> self.count_neighbors(y, x)  <span class="comment"># 查询周围细胞状态，`count_neighbors`协程</span></span><br><span class="line">        next_state = self.game_logic(state, neighbors)		<span class="comment"># 细胞的下一次状态</span></span><br><span class="line">        <span class="keyword">yield</span> Transition(y, x, next_state)		<span class="comment"># 生成迁移对象，将细胞在下一轮的状态告诉外部代码</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">simulate</span><span class="params">(self, height, width)</span>:</span>    <span class="comment">#  模拟协程</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> range(height):</span><br><span class="line">                <span class="keyword">for</span> x <span class="keyword">in</span> range(width):</span><br><span class="line">                    <span class="keyword">yield</span> <span class="keyword">from</span> self.step_cell(y, x)</span><br><span class="line">            <span class="keyword">yield</span> self.TICK</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">live_a_generation</span><span class="params">(self, sim)</span>:</span>			<span class="comment"># 主函数</span></span><br><span class="line">        M, N = len(self.board), len(self.board[<span class="number">0</span>])</span><br><span class="line">        progeny = Grid(M, N)</span><br><span class="line">        item = next(sim)</span><br><span class="line">        <span class="keyword">while</span> item <span class="keyword">is</span> <span class="keyword">not</span> self.TICK:		<span class="comment"># 对所有的细胞向前推进一步</span></span><br><span class="line">            <span class="keyword">if</span> isinstance(item, Query):</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;=item.y&lt;M <span class="keyword">and</span> <span class="number">0</span>&lt;=item.x&lt;N:</span><br><span class="line">                    state = self.board[item.y][item.x]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    state = <span class="number">0</span></span><br><span class="line">                item = sim.send(state)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                progeny[item.y, item.x] = item.state</span><br><span class="line">                item = next(sim)</span><br><span class="line">        <span class="keyword">return</span> progeny</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grid</span><span class="params">(object)</span>:</span>		<span class="comment"># 用于表示细胞网格</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, height, width)</span>:</span></span><br><span class="line">        self.height = height</span><br><span class="line">        self.width = width</span><br><span class="line">        self.rows = []</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.height):</span><br><span class="line">            self.rows.append([<span class="number">0</span>] * self.width)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        output = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> self.rows:</span><br><span class="line">            <span class="keyword">for</span> cell <span class="keyword">in</span> row:</span><br><span class="line">                output += str(cell)</span><br><span class="line">            output += <span class="string">'\n'</span></span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        y, x = index</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span>&lt;=y&lt;self.height <span class="keyword">and</span> <span class="number">0</span>&lt;=x&lt;self.width:</span><br><span class="line">            <span class="keyword">return</span> self.rows[y][x]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, index, state)</span>:</span></span><br><span class="line">        y, x = index</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span>&lt;=y&lt;self.height <span class="keyword">and</span> <span class="number">0</span>&lt;=x&lt;self.width:</span><br><span class="line">            self.rows[y % self.height][x % self.width] = state</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    <div>
      
        
      
    </div>

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/LeetCode/" rel="tag">
            <i class="fa fa-tag"></i> LeetCode</a>
          
            <a href="/tags/Python/" rel="tag">
            <i class="fa fa-tag"></i> Python</a>
          
            <a href="/tags/Algorithm/" rel="tag">
            <i class="fa fa-tag"></i> Algorithm</a>
          
            <a href="/tags/Array/" rel="tag">
            <i class="fa fa-tag"></i> Array</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E9%93%BE%E8%A1%A8%E7%AF%87%EF%BC%89LinkedList/" rel="next" title="LeetCode算法题整理（链表篇）LinkedList">
                <i class="fa fa-chevron-left"></i> LeetCode算法题整理（链表篇）LinkedList
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%95%B0%E5%AD%A6%E7%AF%87%EF%BC%89Math/" rel="prev" title="LeetCode算法题整理（数学篇）Math">
                LeetCode算法题整理（数学篇）Math <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript" target="_blank" rel="noopener">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="xiaoliji" />
          <p class="site-author-name" itemprop="name">xiaoliji</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">35</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/darkTianTian" target="_blank" title="GitHub" rel="external nofollow">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.hackerrank.com/xiaoliji?hr_r=1" target="_blank" title="HackerRank" rel="external nofollow">
                  
                    <i class="fa fa-fw fa-hackerrank"></i>
                  
                    
                      HackerRank
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://leetcode.com/darktiantian/" target="_blank" title="LeetCode" rel="external nofollow">
                  
                    <i class="fa fa-fw fa-leetcode"></i>
                  
                    
                      LeetCode
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.jianshu.com/u/de42f74901fd" target="_blank" title="简书" rel="external nofollow">
                  
                    <i class="fa fa-fw fa-book"></i>
                  
                    
                      简书
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#26-Remove-Duplicates-from-Sorted-Array"><span class="nav-number">1.</span> <span class="nav-text">26. Remove Duplicates from Sorted Array</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#删除排序数组中重复的元素-在原数组上操作，返回一个长度，标识前n个元素为目标数组。原题"><span class="nav-number">1.1.</span> <span class="nav-text">删除排序数组中重复的元素, 在原数组上操作，返回一个长度，标识前n个元素为目标数组。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#80-Remove-Duplicates-from-Sorted-Array-II"><span class="nav-number">2.</span> <span class="nav-text">80. Remove Duplicates from Sorted Array II</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#和上题一样，但是可以允许重复两次。原题"><span class="nav-number">2.1.</span> <span class="nav-text">和上题一样，但是可以允许重复两次。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#66-Plus-One"><span class="nav-number">3.</span> <span class="nav-text">66. Plus One</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#给数组加一，元素为非负整数，不以0开头，每个元素只有一个数字。原题"><span class="nav-number">3.1.</span> <span class="nav-text">给数组加一，元素为非负整数，不以0开头，每个元素只有一个数字。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#989-Add-to-Array-Form-of-Integer"><span class="nav-number">4.</span> <span class="nav-text">989. Add to Array-Form of Integer</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#和66题很相似。不同的是这个K会大于10，以至于余数也会大于10。原题"><span class="nav-number">4.1.</span> <span class="nav-text">和66题很相似。不同的是这个K会大于10，以至于余数也会大于10。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#88-Merge-Sorted-Array"><span class="nav-number">5.</span> <span class="nav-text">88. Merge Sorted Array</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#合并两个有序数组，在nums1上修改。原题"><span class="nav-number">5.1.</span> <span class="nav-text">合并两个有序数组，在nums1上修改。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#118-Pascal’s-Triangle"><span class="nav-number">6.</span> <span class="nav-text">118. Pascal’s Triangle</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#杨辉三角。原题"><span class="nav-number">6.1.</span> <span class="nav-text">杨辉三角。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#119-Pascal’s-Triangle-II"><span class="nav-number">7.</span> <span class="nav-text">119.Pascal’s Triangle II</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#杨辉三角，只打印一层。原题"><span class="nav-number">7.1.</span> <span class="nav-text">杨辉三角，只打印一层。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#169-Majority-Element"><span class="nav-number">8.</span> <span class="nav-text">169. Majority Element</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#找出数组中出现次数超过一半的元素。原题"><span class="nav-number">8.1.</span> <span class="nav-text">找出数组中出现次数超过一半的元素。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#229-Majority-Element-II"><span class="nav-number">9.</span> <span class="nav-text">229. Majority Element II</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#找到数组中出现超过n-3次的元素。原题"><span class="nav-number">9.1.</span> <span class="nav-text">找到数组中出现超过n&#x2F;3次的元素。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#189-Rotate-Array"><span class="nav-number">10.</span> <span class="nav-text">189. Rotate Array</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#旋转数组。进阶：使用O-1-空间实现。原题"><span class="nav-number">10.1.</span> <span class="nav-text">旋转数组。进阶：使用O(1)空间实现。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#217-Contains-Duplicate"><span class="nav-number">11.</span> <span class="nav-text">217. Contains Duplicate</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数组中是否包含重复元素。原题"><span class="nav-number">11.1.</span> <span class="nav-text">数组中是否包含重复元素。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#219-Contains-Duplicate-II"><span class="nav-number">12.</span> <span class="nav-text">219. Contains Duplicate II</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数组中是否包含重复元素，且元素下标差小于等于k。原题"><span class="nav-number">12.1.</span> <span class="nav-text">数组中是否包含重复元素，且元素下标差小于等于k。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#220-Contains-Duplicate-III"><span class="nav-number">13.</span> <span class="nav-text">220. Contains Duplicate III</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#是否存在索引差k范围内的绝对值不大于t的两个值。原题"><span class="nav-number">13.1.</span> <span class="nav-text">是否存在索引差k范围内的绝对值不大于t的两个值。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#283-Move-Zeroes"><span class="nav-number">14.</span> <span class="nav-text">283. Move Zeroes</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#将数组0元素移动到末尾，保证其他元素顺序。原题"><span class="nav-number">14.1.</span> <span class="nav-text">将数组0元素移动到末尾，保证其他元素顺序。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#54-Spiral-Matrix"><span class="nav-number">15.</span> <span class="nav-text">54. Spiral Matrix</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#螺旋矩阵，顺时针打印矩阵。原题"><span class="nav-number">15.1.</span> <span class="nav-text">螺旋矩阵，顺时针打印矩阵。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#59-Spiral-Matrix-II"><span class="nav-number">16.</span> <span class="nav-text">59. Spiral Matrix II</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#按照顺时针的顺序生成一个矩阵。原题"><span class="nav-number">16.1.</span> <span class="nav-text">按照顺时针的顺序生成一个矩阵。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#885-Spiral-Matrix-III"><span class="nav-number">17.</span> <span class="nav-text">885. Spiral Matrix III</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#从二维数组中的某一个点开始顺时针旋转输出所有的坐标。原题"><span class="nav-number">17.1.</span> <span class="nav-text">从二维数组中的某一个点开始顺时针旋转输出所有的坐标。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#53-Maximum-Subarray"><span class="nav-number">18.</span> <span class="nav-text">53. Maximum Subarray</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#连续子数组的最大和。原题"><span class="nav-number">18.1.</span> <span class="nav-text">连续子数组的最大和。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#918-Maximum-Sum-Circular-Subarray"><span class="nav-number">19.</span> <span class="nav-text">918. Maximum Sum Circular Subarray</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#连续数组的最大和，数组可以首位相连，但是最大长度不能超过一个数组。原题"><span class="nav-number">19.1.</span> <span class="nav-text">连续数组的最大和，数组可以首位相连，但是最大长度不能超过一个数组。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#904-Fruit-Into-Baskets"><span class="nav-number">20.</span> <span class="nav-text">904. Fruit Into Baskets</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实际上该题抽象为求最大滑动窗口的长度，滑动窗口不同元素最多不超过两个。原题"><span class="nav-number">20.1.</span> <span class="nav-text">实际上该题抽象为求最大滑动窗口的长度，滑动窗口不同元素最多不超过两个。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#27-Remove-Element"><span class="nav-number">21.</span> <span class="nav-text">27. Remove Element</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#从数组中删除元素，在原数组修改，要求返回一个长度。原题"><span class="nav-number">21.1.</span> <span class="nav-text">从数组中删除元素，在原数组修改，要求返回一个长度。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#349-Intersection-of-Two-Arrays"><span class="nav-number">22.</span> <span class="nav-text">349. Intersection of Two Arrays</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#求两个数组的交集。返回的数组必须元素唯一，可以无序。原题"><span class="nav-number">22.1.</span> <span class="nav-text">求两个数组的交集。返回的数组必须元素唯一，可以无序。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#350-Intersection-of-Two-Arrays-II"><span class="nav-number">23.</span> <span class="nav-text">350. Intersection of Two Arrays II</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#和上题不同的是要返回所有的交集元素。原题"><span class="nav-number">23.1.</span> <span class="nav-text">和上题不同的是要返回所有的交集元素。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#905-Sort-Array-By-Parity"><span class="nav-number">24.</span> <span class="nav-text">905. Sort Array By Parity</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#将一个数组重新排列，是偶数在前奇数在后。原题"><span class="nav-number">24.1.</span> <span class="nav-text">将一个数组重新排列，是偶数在前奇数在后。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#922-Sort-Array-By-Parity-II"><span class="nav-number">25.</span> <span class="nav-text">922. Sort Array By Parity II</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#输入一个奇数偶数数量相同的数组，返回下标和其对应的值都是奇数或偶数，即奇偶交叉。和905相似。原题"><span class="nav-number">25.1.</span> <span class="nav-text">输入一个奇数偶数数量相同的数组，返回下标和其对应的值都是奇数或偶数，即奇偶交叉。和905相似。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#933-Number-of-Recent-Calls"><span class="nav-number">26.</span> <span class="nav-text">933. Number of Recent Calls</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#输入一个时间t，返回3000毫秒内所有的请求个数。原题"><span class="nav-number">26.1.</span> <span class="nav-text">输入一个时间t，返回3000毫秒内所有的请求个数。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#937-Reorder-Log-Files"><span class="nav-number">27.</span> <span class="nav-text">937. Reorder Log Files</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#按照规则将log文件排序。原题"><span class="nav-number">27.1.</span> <span class="nav-text">按照规则将log文件排序。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#485-Max-Consecutive-Ones"><span class="nav-number">28.</span> <span class="nav-text">485. Max Consecutive Ones</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#输入一个二进制数组，返回最大的连续1的长度。原题"><span class="nav-number">28.1.</span> <span class="nav-text">输入一个二进制数组，返回最大的连续1的长度。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1004-Max-Consecutive-Ones-III"><span class="nav-number">29.</span> <span class="nav-text">1004. Max Consecutive Ones III</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#与上题不同的是，有K次机会可以将0变成1-原题"><span class="nav-number">29.1.</span> <span class="nav-text">与上题不同的是，有K次机会可以将0变成1. 原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#496-Next-Greater-Element-I"><span class="nav-number">30.</span> <span class="nav-text">496. Next Greater Element I</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#找出数组nums2中对应的nums1元素的位置之后的第一个比nums1大的元素。nums1是nums2的子集，二者均无重复的元素。原题"><span class="nav-number">30.1.</span> <span class="nav-text">找出数组nums2中对应的nums1元素的位置之后的第一个比nums1大的元素。nums1是nums2的子集，二者均无重复的元素。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#953-Verifying-an-Alien-Dictionary"><span class="nav-number">31.</span> <span class="nav-text">953. Verifying an Alien Dictionary</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#判断一个字符串数组是否按照特定的字典顺序排序。原题"><span class="nav-number">31.1.</span> <span class="nav-text">判断一个字符串数组是否按照特定的字典顺序排序。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#506-Relative-Ranks"><span class="nav-number">32.</span> <span class="nav-text">506. Relative Ranks</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#根据得分，返回排名。前三要用奖牌表示。原题"><span class="nav-number">32.1.</span> <span class="nav-text">根据得分，返回排名。前三要用奖牌表示。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#532-K-diff-Pairs-in-an-Array"><span class="nav-number">33.</span> <span class="nav-text">532. K-diff Pairs in an Array</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#找出差为k的不重复的成对元素的个数。原题"><span class="nav-number">33.1.</span> <span class="nav-text">找出差为k的不重复的成对元素的个数。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#961-N-Repeated-Element-in-Size-2N-Array"><span class="nav-number">34.</span> <span class="nav-text">961. N-Repeated Element in Size 2N Array</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#找出2N长的数组中重复N次的数字，其它数字均只出现一次。此题不能用波义尔摩尔投票因为数量没有大于半数。原题"><span class="nav-number">34.1.</span> <span class="nav-text">找出2N长的数组中重复N次的数字，其它数字均只出现一次。此题不能用波义尔摩尔投票因为数量没有大于半数。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#967-Numbers-With-Same-Consecutive-Differences"><span class="nav-number">35.</span> <span class="nav-text">967. Numbers With Same Consecutive Differences</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#根据规则生成一组数组，数字长度为N，每两位的差为K。原题"><span class="nav-number">35.1.</span> <span class="nav-text">根据规则生成一组数组，数字长度为N，每两位的差为K。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#561-Array-Partition-I"><span class="nav-number">36.</span> <span class="nav-text">561. Array Partition I</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#将数组两两分成一组，累加每组的最小值，使之尽量大。原题"><span class="nav-number">36.1.</span> <span class="nav-text">将数组两两分成一组，累加每组的最小值，使之尽量大。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#566-Reshape-the-Matrix"><span class="nav-number">37.</span> <span class="nav-text">566. Reshape the Matrix</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#改变矩阵的形状，如果元素超出或不足，返回原矩阵。原题"><span class="nav-number">37.1.</span> <span class="nav-text">改变矩阵的形状，如果元素超出或不足，返回原矩阵。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#575-Distribute-Candies"><span class="nav-number">38.</span> <span class="nav-text">575. Distribute Candies</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#给姐姐弟弟分糖，两人数量一样，保证姐姐的种类最多，求姐姐最多能分到多少种。原题"><span class="nav-number">38.1.</span> <span class="nav-text">给姐姐弟弟分糖，两人数量一样，保证姐姐的种类最多，求姐姐最多能分到多少种。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#594-Longest-Harmonious-Subsequence"><span class="nav-number">39.</span> <span class="nav-text">594. Longest Harmonious Subsequence</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#最长的和谐子数组，即元素的最大值和最小值正好相差一的子数组，元素顺序无关，求最大子数组长度。原题"><span class="nav-number">39.1.</span> <span class="nav-text">最长的和谐子数组，即元素的最大值和最小值正好相差一的子数组，元素顺序无关，求最大子数组长度。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#598-Range-Addition-II"><span class="nav-number">40.</span> <span class="nav-text">598. Range Addition II</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#这题看上去挺长，其实抽象起来很简单，把整个矩阵想象成一个积木，然后每次往上叠加，每次叠放的矩形都会和左上角对齐，所以最后完成的时候，左上角的一小块一定是最“厚”的，问题就变成和左上一样的厚度的面积。实际上等于叠放的所有矩形的最小长度和最小宽度的乘积。原题"><span class="nav-number">40.1.</span> <span class="nav-text">这题看上去挺长，其实抽象起来很简单，把整个矩阵想象成一个积木，然后每次往上叠加，每次叠放的矩形都会和左上角对齐，所以最后完成的时候，左上角的一小块一定是最“厚”的，问题就变成和左上一样的厚度的面积。实际上等于叠放的所有矩形的最小长度和最小宽度的乘积。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#599-Minimum-Index-Sum-of-Two-Lists"><span class="nav-number">41.</span> <span class="nav-text">599. Minimum Index Sum of Two Lists</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#找出两个人共同最喜欢的餐厅。如果有多个输出多个。原题"><span class="nav-number">41.1.</span> <span class="nav-text">找出两个人共同最喜欢的餐厅。如果有多个输出多个。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#605-Can-Place-Flowers"><span class="nav-number">42.</span> <span class="nav-text">605. Can Place Flowers</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#是否可以种下给定数量的花。两颗花不能挨着，给定的数组中满足这一条件。原题"><span class="nav-number">42.1.</span> <span class="nav-text">是否可以种下给定数量的花。两颗花不能挨着，给定的数组中满足这一条件。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#643-Maximum-Average-Subarray-I"><span class="nav-number">43.</span> <span class="nav-text">643. Maximum Average Subarray I</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#最大的连续的长度为k的子数组的平均值。原题"><span class="nav-number">43.1.</span> <span class="nav-text">最大的连续的长度为k的子数组的平均值。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#661-Image-Smoother"><span class="nav-number">44.</span> <span class="nav-text">661. Image Smoother</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使图片平滑模糊，一个矩阵使每个点的值为周围所有点的平均值，包括自己。原题"><span class="nav-number">44.1.</span> <span class="nav-text">使图片平滑模糊，一个矩阵使每个点的值为周围所有点的平均值，包括自己。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#665-Non-decreasing-Array"><span class="nav-number">45.</span> <span class="nav-text">665. Non-decreasing Array</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#判断是否改变一个数，可使其变成单调递增数组。原题"><span class="nav-number">45.1.</span> <span class="nav-text">判断是否改变一个数，可使其变成单调递增数组。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#674-Longest-Continuous-Increasing-Subsequence"><span class="nav-number">46.</span> <span class="nav-text">674. Longest Continuous Increasing Subsequence</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#最长连续递增子数组长度。原题"><span class="nav-number">46.1.</span> <span class="nav-text">最长连续递增子数组长度。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#682-Baseball-Game"><span class="nav-number">47.</span> <span class="nav-text">682. Baseball Game</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#棒球游戏，给了一些积分规则。原题"><span class="nav-number">47.1.</span> <span class="nav-text">棒球游戏，给了一些积分规则。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#690-Employee-Importance"><span class="nav-number">48.</span> <span class="nav-text">690. Employee Importance</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#员工重要值。原题"><span class="nav-number">48.1.</span> <span class="nav-text">员工重要值。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#724-Find-Pivot-Index"><span class="nav-number">49.</span> <span class="nav-text">724. Find Pivot Index</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#找到中心索引，使得左右两边和相等。左右求和时均不包含该索引。原题"><span class="nav-number">49.1.</span> <span class="nav-text">找到中心索引，使得左右两边和相等。左右求和时均不包含该索引。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#985-Sum-of-Even-Numbers-After-Queries"><span class="nav-number">50.</span> <span class="nav-text">985. Sum of Even Numbers After Queries</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#计算Queries后，累加所有的偶数。原题"><span class="nav-number">50.1.</span> <span class="nav-text">计算Queries后，累加所有的偶数。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#986-Interval-List-Intersections"><span class="nav-number">51.</span> <span class="nav-text">986. Interval List Intersections</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#两个区间列表求相交。原题"><span class="nav-number">51.1.</span> <span class="nav-text">两个区间列表求相交。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#747-Largest-Number-At-Least-Twice-of-Others"><span class="nav-number">52.</span> <span class="nav-text">747. Largest Number At Least Twice of Others</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#最大的数是否大于等于所有其它数的两倍。原题"><span class="nav-number">52.1.</span> <span class="nav-text">最大的数是否大于等于所有其它数的两倍。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#766-Toeplitz-Matrix"><span class="nav-number">53.</span> <span class="nav-text">766. Toeplitz Matrix</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Toeplitz矩阵，即对角矩阵，斜角具有相同的值，判断一个矩阵是否是对角矩阵。原题"><span class="nav-number">53.1.</span> <span class="nav-text">Toeplitz矩阵，即对角矩阵，斜角具有相同的值，判断一个矩阵是否是对角矩阵。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#830-Positions-of-Large-Groups"><span class="nav-number">54.</span> <span class="nav-text">830. Positions of Large Groups</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#根据指定字符串分组，超过三个元素的称为大组，求所有大组的位置。原题"><span class="nav-number">54.1.</span> <span class="nav-text">根据指定字符串分组，超过三个元素的称为大组，求所有大组的位置。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#832-Flipping-an-Image"><span class="nav-number">55.</span> <span class="nav-text">832. Flipping an Image</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#水平翻转一张图片并反转-invert-原题"><span class="nav-number">55.1.</span> <span class="nav-text">水平翻转一张图片并反转(invert). 原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#840-Magic-Squares-In-Grid"><span class="nav-number">56.</span> <span class="nav-text">840. Magic Squares In Grid</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#找出grid中数独的个数。原题"><span class="nav-number">56.1.</span> <span class="nav-text">找出grid中数独的个数。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#849-Maximize-Distance-to-Closest-Person"><span class="nav-number">57.</span> <span class="nav-text">849. Maximize Distance to Closest Person</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一排电影院座位，离人的最远距离。数组中必含有一个1和0。原题"><span class="nav-number">57.1.</span> <span class="nav-text">一排电影院座位，离人的最远距离。数组中必含有一个1和0。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#867-Transpose-Matrix"><span class="nav-number">58.</span> <span class="nav-text">867. Transpose Matrix</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#转置矩阵。原题"><span class="nav-number">58.1.</span> <span class="nav-text">转置矩阵。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#888-Fair-Candy-Swap"><span class="nav-number">59.</span> <span class="nav-text">888. Fair Candy Swap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#公平的糖果交换。两个人有很多糖果酒吧，交换其中一间使，糖果相同，可能有多个答案，返回任意一个。原题"><span class="nav-number">59.1.</span> <span class="nav-text">公平的糖果交换。两个人有很多糖果酒吧，交换其中一间使，糖果相同，可能有多个答案，返回任意一个。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#896-Monotonic-Array"><span class="nav-number">60.</span> <span class="nav-text">896. Monotonic Array</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#判断一个数组是不是单调递增或递减。原题"><span class="nav-number">60.1.</span> <span class="nav-text">判断一个数组是不是单调递增或递减。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#977-Squares-of-a-Sorted-Array"><span class="nav-number">61.</span> <span class="nav-text">977. Squares of a Sorted Array</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#求一个有序数组，平方后的有序结果。原题"><span class="nav-number">61.1.</span> <span class="nav-text">求一个有序数组，平方后的有序结果。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#941-Valid-Mountain-Array"><span class="nav-number">62.</span> <span class="nav-text">941. Valid Mountain Array</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#验证是否是山峰数组，前段单调增（不重复），后段单调减，必须是单峰值。原题"><span class="nav-number">62.1.</span> <span class="nav-text">验证是否是山峰数组，前段单调增（不重复），后段单调减，必须是单峰值。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#845-Longest-Mountain-in-Array"><span class="nav-number">63.</span> <span class="nav-text">845. Longest Mountain in Array</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数组中最长的山峰。题和字符串篇821一样的解法。"><span class="nav-number">63.1.</span> <span class="nav-text">数组中最长的山峰。题和字符串篇821一样的解法。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#942-DI-String-Match"><span class="nav-number">64.</span> <span class="nav-text">942. DI String Match</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#根据一个”IDID”字符串（I表示增加，D表示减少）生成一个数组，数组元素不能重复，答案不唯一。原题"><span class="nav-number">64.1.</span> <span class="nav-text">根据一个”IDID”字符串（I表示增加，D表示减少）生成一个数组，数组元素不能重复，答案不唯一。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1007-Minimum-Domino-Rotations-For-Equal-Row"><span class="nav-number">65.</span> <span class="nav-text">1007. Minimum Domino Rotations For Equal Row</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#旋转最小次，是上下的多米诺骨牌有一行全部相同。原题"><span class="nav-number">65.1.</span> <span class="nav-text">旋转最小次，是上下的多米诺骨牌有一行全部相同。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#48-Rotate-Image"><span class="nav-number">66.</span> <span class="nav-text">48. Rotate Image</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#矩阵顺时针旋转90度。原题"><span class="nav-number">66.1.</span> <span class="nav-text">矩阵顺时针旋转90度。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1020-Partition-Array-Into-Three-Parts-With-Equal-Sum"><span class="nav-number">67.</span> <span class="nav-text">1020. Partition Array Into Three Parts With Equal Sum</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一个数组是否可以分成三个和相同的部分。原题"><span class="nav-number">67.1.</span> <span class="nav-text">一个数组是否可以分成三个和相同的部分。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1021-Best-Sightseeing-Pair"><span class="nav-number">68.</span> <span class="nav-text">1021. Best Sightseeing Pair</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#得分最高的两个景点。原题"><span class="nav-number">68.1.</span> <span class="nav-text">得分最高的两个景点。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#56-Merge-Intervals"><span class="nav-number">69.</span> <span class="nav-text">56. Merge Intervals</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#合并时间段。如果时间段有重叠，则将其合并成一个。原题"><span class="nav-number">69.1.</span> <span class="nav-text">合并时间段。如果时间段有重叠，则将其合并成一个。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#57-Insert-Interval"><span class="nav-number">70.</span> <span class="nav-text">57. Insert Interval</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#有一个排好序的时间段，并且没有重复，现在有一个新的段，要求插入其中，如果有重合需要合并。原题"><span class="nav-number">70.1.</span> <span class="nav-text">有一个排好序的时间段，并且没有重复，现在有一个新的段，要求插入其中，如果有重合需要合并。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1030-Matrix-Cells-in-Distance-Order"><span class="nav-number">71.</span> <span class="nav-text">1030. Matrix Cells in Distance Order</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#矩阵坐标距离指定点的排序。原题"><span class="nav-number">71.1.</span> <span class="nav-text">矩阵坐标距离指定点的排序。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1033-Moving-Stones-Until-Consecutive"><span class="nav-number">72.</span> <span class="nav-text">1033. Moving Stones Until Consecutive</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#三个石子移到连续的位置，最少和最多需要几步。原题"><span class="nav-number">72.1.</span> <span class="nav-text">三个石子移到连续的位置，最少和最多需要几步。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1051-Height-Checker"><span class="nav-number">73.</span> <span class="nav-text">1051. Height Checker</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#高度检查。原题"><span class="nav-number">73.1.</span> <span class="nav-text">高度检查。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1052-Grumpy-Bookstore-Owner"><span class="nav-number">74.</span> <span class="nav-text">1052. Grumpy Bookstore Owner</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#这题描述的比较抽象，其实就是一个滑动窗口的问题。原题"><span class="nav-number">74.1.</span> <span class="nav-text">这题描述的比较抽象，其实就是一个滑动窗口的问题。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1139-Largest-1-Bordered-Square"><span class="nav-number">75.</span> <span class="nav-text">1139. Largest 1-Bordered Square</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#最大的以1为边长的正方形。原题"><span class="nav-number">75.1.</span> <span class="nav-text">最大的以1为边长的正方形。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1078-Occurrences-After-Bigram"><span class="nav-number">76.</span> <span class="nav-text">1078. Occurrences After Bigram</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#打印第三个单词。原题"><span class="nav-number">76.1.</span> <span class="nav-text">打印第三个单词。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1144-Decrease-Elements-To-Make-Array-Zigzag"><span class="nav-number">77.</span> <span class="nav-text">1144. Decrease Elements To Make Array Zigzag</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#每次操作某个元素-1，多少次操作后，可以使数组称为一个zigzag。原题"><span class="nav-number">77.1.</span> <span class="nav-text">每次操作某个元素-1，多少次操作后，可以使数组称为一个zigzag。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1089-Duplicate-Zeros"><span class="nav-number">78.</span> <span class="nav-text">1089. Duplicate Zeros</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#复制数组中的0，数组长度不变，多出的元素将被“挤掉”。要求在原数组上修改。原题"><span class="nav-number">78.1.</span> <span class="nav-text">复制数组中的0，数组长度不变，多出的元素将被“挤掉”。要求在原数组上修改。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1169-Invalid-Transactions"><span class="nav-number">79.</span> <span class="nav-text">1169. Invalid Transactions</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#非法交易，单笔金额大于1000，或者60分钟内有异地交易，那么为非法交易。列出所有的非法交易。原题"><span class="nav-number">79.1.</span> <span class="nav-text">非法交易，单笔金额大于1000，或者60分钟内有异地交易，那么为非法交易。列出所有的非法交易。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1170-Compare-Strings-by-Frequency-of-the-Smallest-Character"><span class="nav-number">80.</span> <span class="nav-text">1170. Compare Strings by Frequency of the Smallest Character</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#比较最小字符的频率。原题"><span class="nav-number">80.1.</span> <span class="nav-text">比较最小字符的频率。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1122-Relative-Sort-Array"><span class="nav-number">81.</span> <span class="nav-text">1122. Relative Sort Array</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#按照数组2的相对位置给另一个数组排序。原题"><span class="nav-number">81.1.</span> <span class="nav-text">按照数组2的相对位置给另一个数组排序。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1176-Diet-Plan-Performance"><span class="nav-number">82.</span> <span class="nav-text">1176. Diet Plan Performance</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#燃烧你的卡路里，卡路里和体重的关系。原题"><span class="nav-number">82.1.</span> <span class="nav-text">燃烧你的卡路里，卡路里和体重的关系。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1395-Count-Number-of-Teams"><span class="nav-number">83.</span> <span class="nav-text">1395. Count Number of Teams</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数字分组计数。原题"><span class="nav-number">83.1.</span> <span class="nav-text">数字分组计数。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1375-Bulb-Switcher-III"><span class="nav-number">84.</span> <span class="nav-text">1375. Bulb Switcher III</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#灯泡开关，记录灯泡全部变蓝的次数。原题"><span class="nav-number">84.1.</span> <span class="nav-text">灯泡开关，记录灯泡全部变蓝的次数。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#498-Diagonal-Traverse"><span class="nav-number">85.</span> <span class="nav-text">498. Diagonal Traverse</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对角线z字形遍历。原题"><span class="nav-number">85.1.</span> <span class="nav-text">对角线z字形遍历。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1424-Diagonal-Traverse-II"><span class="nav-number">86.</span> <span class="nav-text">1424. Diagonal Traverse II</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对角线遍历，每行长度可能不一样。原题"><span class="nav-number">86.1.</span> <span class="nav-text">对角线遍历，每行长度可能不一样。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1365-How-Many-Numbers-Are-Smaller-Than-the-Current-Number"><span class="nav-number">87.</span> <span class="nav-text">1365. How Many Numbers Are Smaller Than the Current Number</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数组中比当前数小的个数。原题"><span class="nav-number">87.1.</span> <span class="nav-text">数组中比当前数小的个数。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1366-Rank-Teams-by-Votes"><span class="nav-number">88.</span> <span class="nav-text">1366. Rank Teams by Votes</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#投票选举。首先按照排名，然后按照字母顺序。原题"><span class="nav-number">88.1.</span> <span class="nav-text">投票选举。首先按照排名，然后按照字母顺序。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1331-Rank-Transform-of-an-Array"><span class="nav-number">89.</span> <span class="nav-text">1331. Rank Transform of an Array</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#将数组转化为排行。原题"><span class="nav-number">89.1.</span> <span class="nav-text">将数组转化为排行。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1306-Jump-Game-III"><span class="nav-number">90.</span> <span class="nav-text">1306. Jump Game III</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#跳跃游戏，从start开始，可以沿着value向前向后跳，求是否可以跳到0-原题"><span class="nav-number">90.1.</span> <span class="nav-text">跳跃游戏，从start开始，可以沿着value向前向后跳，求是否可以跳到0.原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1297-Maximum-Number-of-Occurrences-of-a-Substring"><span class="nav-number">91.</span> <span class="nav-text">1297. Maximum Number of Occurrences of a Substring</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#出现次数最多的子串。滑动窗口可伸缩，最多包含maxLetters个字母。原题"><span class="nav-number">91.1.</span> <span class="nav-text">出现次数最多的子串。滑动窗口可伸缩，最多包含maxLetters个字母。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1291-Sequential-Digits"><span class="nav-number">92.</span> <span class="nav-text">1291. Sequential Digits</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#按序求组区间中的顺子。原题"><span class="nav-number">92.1.</span> <span class="nav-text">按序求组区间中的顺子。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1275-Find-Winner-on-a-Tic-Tac-Toe-Game"><span class="nav-number">93.</span> <span class="nav-text">1275. Find Winner on a Tic Tac Toe Game</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#三子棋的游戏，谁先连到3个子谁就赢。原题"><span class="nav-number">93.1.</span> <span class="nav-text">三子棋的游戏，谁先连到3个子谁就赢。原题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#面试题-16-04-井字游戏"><span class="nav-number">93.2.</span> <span class="nav-text">面试题 16.04. 井字游戏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#比1275简单一点，给定棋盘，判断谁赢。"><span class="nav-number">93.3.</span> <span class="nav-text">比1275简单一点，给定棋盘，判断谁赢。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1260-Shift-2D-Grid"><span class="nav-number">93.4.</span> <span class="nav-text">1260. Shift 2D Grid</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2D滑动，每次列右移一次，首列下移一次。原题"><span class="nav-number">93.5.</span> <span class="nav-text">2D滑动，每次列右移一次，首列下移一次。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1252-Cells-with-Odd-Values-in-a-Matrix"><span class="nav-number">94.</span> <span class="nav-text">1252. Cells with Odd Values in a Matrix</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#根据坐标每次将所在的行和列-1，这个点-2，统计所有的奇数个数。原题"><span class="nav-number">94.1.</span> <span class="nav-text">根据坐标每次将所在的行和列+1，这个点+2，统计所有的奇数个数。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1248-Count-Number-of-Nice-Subarrays"><span class="nav-number">95.</span> <span class="nav-text">1248. Count Number of Nice Subarrays</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#找到包含k个奇数的子数组个数。原题"><span class="nav-number">95.1.</span> <span class="nav-text">找到包含k个奇数的子数组个数。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1234-Replace-the-Substring-for-Balanced-String"><span class="nav-number">96.</span> <span class="nav-text">1234. Replace the Substring for Balanced String</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#将每个QWER出现的次数变为一样，最少需要修改的子串长度是多少。原题"><span class="nav-number">96.1.</span> <span class="nav-text">将每个QWER出现的次数变为一样，最少需要修改的子串长度是多少。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1208-Get-Equal-Substrings-Within-Budget"><span class="nav-number">97.</span> <span class="nav-text">1208. Get Equal Substrings Within Budget</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#将字符串s变为t。需要ascii码的差，问在指定的差中，最长的可以变成的子串长度是多少。原题"><span class="nav-number">97.1.</span> <span class="nav-text">将字符串s变为t。需要ascii码的差，问在指定的差中，最长的可以变成的子串长度是多少。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sort-Colors"><span class="nav-number">98.</span> <span class="nav-text">Sort Colors</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#0-1-2的数组排序。原题"><span class="nav-number">98.1.</span> <span class="nav-text">0,1,2的数组排序。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1191-K-Concatenation-Maximum-Sum"><span class="nav-number">99.</span> <span class="nav-text">1191. K-Concatenation Maximum Sum</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#求k-arr的连续数组最大和。原题"><span class="nav-number">99.1.</span> <span class="nav-text">求k*arr的连续数组最大和。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#448-Find-All-Numbers-Disappeared-in-an-Array"><span class="nav-number">100.</span> <span class="nav-text">448. Find All Numbers Disappeared in an Array</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#找出n长度的数组中1-n缺失的数字，有的数字会出现多次。原题"><span class="nav-number">100.1.</span> <span class="nav-text">找出n长度的数组中1-n缺失的数字，有的数字会出现多次。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-Container-With-Most-Water"><span class="nav-number">101.</span> <span class="nav-text">11. Container With Most Water</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#最大的水容积，用坐标轴装水，有点像木桶原理。原题"><span class="nav-number">101.1.</span> <span class="nav-text">最大的水容积，用坐标轴装水，有点像木桶原理。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1498-Number-of-Subsequences-That-Satisfy-the-Given-Sum-Condition"><span class="nav-number">102.</span> <span class="nav-text">1498. Number of Subsequences That Satisfy the Given Sum Condition</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#给定一个数组，返回最大值最小值和小于目标值的子序列，可以不连续，的个数。原题"><span class="nav-number">102.1.</span> <span class="nav-text">给定一个数组，返回最大值最小值和小于目标值的子序列，可以不连续，的个数。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#463-Island-Perimeter"><span class="nav-number">103.</span> <span class="nav-text">463. Island Perimeter</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#小岛的周长，小岛中间没有湖。原题"><span class="nav-number">103.1.</span> <span class="nav-text">小岛的周长，小岛中间没有湖。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-3Sum"><span class="nav-number">104.</span> <span class="nav-text">15. 3Sum</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#找出数组中3个数相加为0，返回所有的组合非重复。原题"><span class="nav-number">104.1.</span> <span class="nav-text">找出数组中3个数相加为0，返回所有的组合非重复。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1508-Range-Sum-of-Sorted-Subarray-Sums"><span class="nav-number">105.</span> <span class="nav-text">1508. Range Sum of Sorted Subarray Sums</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数组的累加和排序，取区间中的数字和。原题"><span class="nav-number">105.1.</span> <span class="nav-text">数组的累加和排序，取区间中的数字和。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1509-Minimum-Difference-Between-Largest-and-Smallest-Value-in-Three-Moves"><span class="nav-number">106.</span> <span class="nav-text">1509. Minimum Difference Between Largest and Smallest Value in Three Moves</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#删除3个数，数组的最大值最小值差最小是多少。原题"><span class="nav-number">106.1.</span> <span class="nav-text">删除3个数，数组的最大值最小值差最小是多少。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1529-Bulb-Switcher-IV"><span class="nav-number">107.</span> <span class="nav-text">1529. Bulb Switcher IV</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#灯泡开关，每次只能开关从后开始的连续的n个，问变成目标状态，最少需要几次操作。原题"><span class="nav-number">107.1.</span> <span class="nav-text">灯泡开关，每次只能开关从后开始的连续的n个，问变成目标状态，最少需要几次操作。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#442-Find-All-Duplicates-in-an-Array"><span class="nav-number">108.</span> <span class="nav-text">442. Find All Duplicates in an Array</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#找到所有重复的元素，数组中的元素都在1-n之间，n为数组的长度。原题"><span class="nav-number">108.1.</span> <span class="nav-text">找到所有重复的元素，数组中的元素都在1~n之间，n为数组的长度。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#713-Subarray-Product-Less-Than-K"><span class="nav-number">109.</span> <span class="nav-text">713. Subarray Product Less Than K</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#连续子数组乘积小于k的个数，元素为正数。原题"><span class="nav-number">109.1.</span> <span class="nav-text">连续子数组乘积小于k的个数，元素为正数。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#915-Partition-Array-into-Disjoint-Intervals"><span class="nav-number">110.</span> <span class="nav-text">915. Partition Array into Disjoint Intervals</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#将数组拆成两个非空数组，要求左侧的每个元素都小于等于右侧的每个元素，求左侧最小的长度，假设答案一定存在。原题"><span class="nav-number">110.1.</span> <span class="nav-text">将数组拆成两个非空数组，要求左侧的每个元素都小于等于右侧的每个元素，求左侧最小的长度，假设答案一定存在。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1562-Find-Latest-Group-of-Size-M"><span class="nav-number">111.</span> <span class="nav-text">1562. Find Latest Group of Size M</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#将一个全是0的字符串按照arr的索引顺序变为1，整体被0分割成若干段，问最后有m个长度的”1”的段时是第几步、原题"><span class="nav-number">111.1.</span> <span class="nav-text">将一个全是0的字符串按照arr的索引顺序变为1，整体被0分割成若干段，问最后有m个长度的”1”的段时是第几步、原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#334-Increasing-Triplet-Subsequence"><span class="nav-number">112.</span> <span class="nav-text">334. Increasing Triplet Subsequence</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数组中是否有三个元素递增。原题"><span class="nav-number">112.1.</span> <span class="nav-text">数组中是否有三个元素递增。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#926-Flip-String-to-Monotone-Increasing"><span class="nav-number">113.</span> <span class="nav-text">926. Flip String to Monotone Increasing</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#将一个二进制字符串翻转成单调递增最少要几步。原题"><span class="nav-number">113.1.</span> <span class="nav-text">将一个二进制字符串翻转成单调递增最少要几步。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#424-Longest-Repeating-Character-Replacement"><span class="nav-number">114.</span> <span class="nav-text">424. Longest Repeating Character Replacement</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#由26个大写字母组成的字符串，在k次替换范围内，产生的最长的重复字符串是多少。原题"><span class="nav-number">114.1.</span> <span class="nav-text">由26个大写字母组成的字符串，在k次替换范围内，产生的最长的重复字符串是多少。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#398-Random-Pick-Index"><span class="nav-number">115.</span> <span class="nav-text">398. Random Pick Index</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#有这样一个数组，我想随机的去一个目标的元素，找到和目标相等的这些元素随机返回一个索引。原题"><span class="nav-number">115.1.</span> <span class="nav-text">有这样一个数组，我想随机的去一个目标的元素，找到和目标相等的这些元素随机返回一个索引。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#382-Linked-List-Random-Node"><span class="nav-number">116.</span> <span class="nav-text">382. Linked List Random Node</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#在一个链表上随机取一个节点值。原题"><span class="nav-number">116.1.</span> <span class="nav-text">在一个链表上随机取一个节点值。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#209-Minimum-Size-Subarray-Sum"><span class="nav-number">117.</span> <span class="nav-text">209. Minimum Size Subarray Sum</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#累加和大于s的最短的子数组长度。原题"><span class="nav-number">117.1.</span> <span class="nav-text">累加和大于s的最短的子数组长度。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#930-Binary-Subarrays-With-Sum"><span class="nav-number">118.</span> <span class="nav-text">930. Binary Subarrays With Sum</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#求和我S的子数组个数，数组元素只包含0，1。原题"><span class="nav-number">118.1.</span> <span class="nav-text">求和我S的子数组个数，数组元素只包含0，1。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#969-Pancake-Sorting"><span class="nav-number">119.</span> <span class="nav-text">969. Pancake Sorting</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#煎饼排序。由1-n组成，没次只能reverse前k个，求k的数组，答案不唯一。原题"><span class="nav-number">119.1.</span> <span class="nav-text">煎饼排序。由1~n组成，没次只能reverse前k个，求k的数组，答案不唯一。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1566-Detect-Pattern-of-Length-M-Repeated-K-or-More-Times"><span class="nav-number">120.</span> <span class="nav-text">1566. Detect Pattern of Length M Repeated K or More Times</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#判断数组中是否有k次以上个重复的M大小的组。原题"><span class="nav-number">120.1.</span> <span class="nav-text">判断数组中是否有k次以上个重复的M大小的组。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#228-Summary-Ranges"><span class="nav-number">121.</span> <span class="nav-text">228. Summary Ranges</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#格式化一段range。原题"><span class="nav-number">121.1.</span> <span class="nav-text">格式化一段range。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#769-Max-Chunks-To-Make-Sorted"><span class="nav-number">122.</span> <span class="nav-text">769. Max Chunks To Make Sorted</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#可以将一个数组分成几块小数组，然后使每个小数组排序后连接起来，整个大数组有序，问最多可以分成多少块。原题"><span class="nav-number">122.1.</span> <span class="nav-text">可以将一个数组分成几块小数组，然后使每个小数组排序后连接起来，整个大数组有序，问最多可以分成多少块。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#390-Elimination-Game"><span class="nav-number">123.</span> <span class="nav-text">390. Elimination Game</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#消除游戏，从1-n的数组，每次从左到右隔一个删除，然后从右到左隔一个删除。最后剩下一个数字是哪个。原题"><span class="nav-number">123.1.</span> <span class="nav-text">消除游戏，从1~n的数组，每次从左到右隔一个删除，然后从右到左隔一个删除。最后剩下一个数字是哪个。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#853-Car-Fleet"><span class="nav-number">124.</span> <span class="nav-text">853. Car Fleet</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#超车车队，说有这么一些车向同一个目的地出发，起始位置和速度不同，当快车遇见慢车时不能超过，而是跟在后面变成一个车队。问最后到达终点时有几个车队，1辆车也算一个车队。原题"><span class="nav-number">124.1.</span> <span class="nav-text">超车车队，说有这么一些车向同一个目的地出发，起始位置和速度不同，当快车遇见慢车时不能超过，而是跟在后面变成一个车队。问最后到达终点时有几个车队，1辆车也算一个车队。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1574-Shortest-Subarray-to-be-Removed-to-Make-Array-Sorted"><span class="nav-number">125.</span> <span class="nav-text">1574. Shortest Subarray to be Removed to Make Array Sorted</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#删除一个最短的子数组使整个数组有序。问最短数组长度为多少。原题"><span class="nav-number">125.1.</span> <span class="nav-text">删除一个最短的子数组使整个数组有序。问最短数组长度为多少。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#835-Image-Overlap"><span class="nav-number">126.</span> <span class="nav-text">835. Image Overlap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#图片覆盖。两个二维矩阵，A可以向一个方向滑动N个单位，然后放到B上，如果都为1，则表示某个像素是覆盖的。求最多有多少个像素覆盖。原题"><span class="nav-number">126.1.</span> <span class="nav-text">图片覆盖。两个二维矩阵，A可以向一个方向滑动N个单位，然后放到B上，如果都为1，则表示某个像素是覆盖的。求最多有多少个像素覆盖。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#42-Trapping-Rain-Water"><span class="nav-number">127.</span> <span class="nav-text">42. Trapping Rain Water</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#接雨水。给定一些柱状图的高度，问能接多少雨水。原题"><span class="nav-number">127.1.</span> <span class="nav-text">接雨水。给定一些柱状图的高度，问能接多少雨水。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#36-Valid-Sudoku"><span class="nav-number">128.</span> <span class="nav-text">36. Valid Sudoku</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#验证一个数独的正确性，只需要考虑填入数字的格子。原题"><span class="nav-number">128.1.</span> <span class="nav-text">验证一个数独的正确性，只需要考虑填入数字的格子。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1054-Distant-Barcodes"><span class="nav-number">129.</span> <span class="nav-text">1054. Distant Barcodes</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分散的条形码，就是将一个数组中的元素重新排序，让其没有两个一样的相邻。原题"><span class="nav-number">129.1.</span> <span class="nav-text">分散的条形码，就是将一个数组中的元素重新排序，让其没有两个一样的相邻。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1588-Sum-of-All-Odd-Length-Subarrays"><span class="nav-number">130.</span> <span class="nav-text">1588. Sum of All Odd Length Subarrays</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#求所有奇数长度的子数组的和。"><span class="nav-number">130.1.</span> <span class="nav-text">求所有奇数长度的子数组的和。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面试题-16-22-兰顿蚂蚁"><span class="nav-number">131.</span> <span class="nav-text">面试题 16.22. 兰顿蚂蚁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#41-First-Missing-Positive"><span class="nav-number">132.</span> <span class="nav-text">41. First Missing Positive</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#找到数组中最小的缺失的正数。数组中可能包含负数。要求在O-N-时间，常数空间实现。"><span class="nav-number">132.1.</span> <span class="nav-text">找到数组中最小的缺失的正数。数组中可能包含负数。要求在O(N)时间，常数空间实现。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#面试题-17-18-最短超串"><span class="nav-number">132.2.</span> <span class="nav-text">面试题 17.18. 最短超串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#找到包含small所有元素最短子数组的最小索引。"><span class="nav-number">132.3.</span> <span class="nav-text">找到包含small所有元素最短子数组的最小索引。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#289-Game-of-Life"><span class="nav-number">133.</span> <span class="nav-text">289. Game of Life</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#生命游戏，简称为生命，是英国数学家约翰·何顿·康威在-1970-年发明的细胞自动机。"><span class="nav-number">133.1.</span> <span class="nav-text">生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xiaoliji</span>
</div>
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_pv">
  本站访客数:<span id="busuanzi_value_site_pv"></span>
</span>
</div>
<div class="powered-by">

  Powered by <a class="theme-link" href="https://hexo.io" target="_blank" rel="texternal nofollow noopener">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="texternal nofollow noopener">
    NexT.Mist
  </a>
</div>


<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共199.3k字</span>
</div>
        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  

    
      <script id="dsq-count-scr" src="https://.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://darktiantian.github.io.git/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%95%B0%E7%BB%84%E7%AF%87%EF%BC%89Array/';
          this.page.identifier = 'LeetCode算法题整理（数组篇）Array/';
          this.page.title = 'LeetCode算法题整理（数组篇）Array';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.json";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("MuBXc6gVka7X95yN3qhh8Akg-gzGzoHsz", "flbiG5OQDhWpAaCRLDETaoPF");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  

</body>
</html>
