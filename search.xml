<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode算法题整理（并发篇）Threading]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%B9%B6%E5%8F%91%E7%AF%87%EF%BC%89Threading%2F</url>
    <content type="text"><![CDATA[1114. Print in Order按照指定的顺序打印，三个线程的方法。 方法一：Lock 锁对象法。 123456789101112131415161718192021from threading import Lockclass Foo: def __init__(self): self.locks = (Lock(),Lock()) self.locks[0].acquire() self.locks[1].acquire() def first(self, printFirst): printFirst() self.locks[0].release() def second(self, printSecond): with self.locks[0]: printSecond() self.locks[1].release() def third(self, printThird): with self.locks[1]: printThird() 方法二：信号量。Semaphore 123456789101112131415161718from threading import Semaphoreclass Foo: def __init__(self): self.gates = (Semaphore(0),Semaphore(0)) def first(self, printFirst): printFirst() self.gates[0].release() def second(self, printSecond): with self.gates[0]: printSecond() self.gates[1].release() def third(self, printThird): with self.gates[1]: printThird() 方法三：Event事件对象法。原理同上，用wait方法作为阻塞，用set来释放线程，默认类赋值就是阻塞的。 12345678910111213141516171819import threadingclass Foo: def __init__(self): self.e1 = threading.Event() self.e2 = threading.Event() def first(self, printFirst: 'Callable[[], None]') -&gt; None: printFirst() self.e1.set() def second(self, printSecond: 'Callable[[], None]') -&gt; None: self.e1.wait() printSecond() self.e2.set() def third(self, printThird: 'Callable[[], None]') -&gt; None: self.e2.wait() printThird() 方法四：Barrier障碍法。Barrier初始化的时候定义了parties = 2个等待线程，调用完了parties个wait就会释放线程。 12345678910111213141516171819import threadingclass Foo: def __init__(self): self.b1 = threading.Barrier(2) self.b2 = threading.Barrier(2) def first(self, printFirst: 'Callable[[], None]') -&gt; None: printFirst() self.b1.wait() def second(self, printSecond: 'Callable[[], None]') -&gt; None: self.b1.wait() printSecond() self.b2.wait() def third(self, printThird: 'Callable[[], None]') -&gt; None: self.b2.wait() printThird() 方法五：队列法。直接使用多线程专用的阻塞队列，对于队列为空时，get方法就会自动阻塞，直到put使之非空才会释放进程。 12345678910111213141516171819import queueclass Foo: def __init__(self): self.q1 = queue.Queue() self.q2 = queue.Queue() def first(self, printFirst: 'Callable[[], None]') -&gt; None: printFirst() self.q1.put(0) def second(self, printSecond: 'Callable[[], None]') -&gt; None: self.q1.get() printSecond() self.q2.put(0) def third(self, printThird: 'Callable[[], None]') -&gt; None: self.q2.get() printThird() 方法六：反过来，对于定容队列来说，如果队列满了，put方法也是阻塞。 123456789101112131415161718192021import queueclass Foo: def __init__(self): self.q1 = queue.Queue(1) self.q1.put(0) self.q2 = queue.Queue(1) self.q2.put(0) def first(self, printFirst: 'Callable[[], None]') -&gt; None: printFirst() self.q1.get() def second(self, printSecond: 'Callable[[], None]') -&gt; None: self.q1.put(0) printSecond() self.q2.get() def third(self, printThird: 'Callable[[], None]') -&gt; None: self.q2.put(0) printThird() 方法七：Condition 1234567891011121314151617181920212223242526from threading import Conditionclass Foo: def __init__(self): self.exec_condition = Condition() self.order = 0 self.first_finish = lambda: self.order == 1 self.second_finish = lambda: self.order == 2 def first(self, printFirst): with self.exec_condition: printFirst() self.order = 1 self.exec_condition.notify(2) def second(self, printSecond): with self.exec_condition: self.exec_condition.wait_for(self.first_finish) printSecond() self.order = 2 self.exec_condition.notify() def third(self, printThird): with self.exec_condition: self.exec_condition.wait_for(self.second_finish) printThird()]]></content>
      <categories>
        <category>Concurrency</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（单词查找树篇）Trie]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%8D%95%E8%AF%8D%E6%9F%A5%E6%89%BE%E6%A0%91%E7%AF%87%EF%BC%89Trie%2F</url>
    <content type="text"><![CDATA[此篇为预留篇章，其中的算法有些还未使用Trie进行优化。 1023. Camelcase Matching驼峰匹配。原题12345678910Input: queries = [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern = &quot;FB&quot;Output: [true,false,true,true,false]Explanation: &quot;FooBar&quot; can be generated like this &quot;F&quot; + &quot;oo&quot; + &quot;B&quot; + &quot;ar&quot;.&quot;FootBall&quot; can be generated like this &quot;F&quot; + &quot;oot&quot; + &quot;B&quot; + &quot;all&quot;.&quot;FrameBuffer&quot; can be generated like this &quot;F&quot; + &quot;rame&quot; + &quot;B&quot; + &quot;uffer&quot;.[&quot;CompetitiveProgramming&quot;,&quot;CounterPick&quot;,&quot;ControlPanel&quot;]&quot;CooP&quot;[false,false,true] 方法一：竞赛时AC的方法。 1234567891011121314151617def camelMatch(self, queries: List[str], pattern: str) -&gt; List[bool]: ans = [] for word in queries: p = 0 for i, c in enumerate(word): if p == len(pattern): ans.append(all(char.islower() for char in word[i:])) break if c == pattern[p]: p += 1 else: if c.isupper(): ans.append(False) break else: ans.append(all(char.islower() for char in pattern[p:])) return ans 方法二：首先判断单词和pattern是否具有相同的大写字母。iter保证了每次c开始的位置是从上一个匹配结束的地方开始的。这个非常重要，保证了比较的顺序。 123456789def camelMatch(self, qs: List[str], p: str) -&gt; List[bool]: def u(s): return [c for c in s if c.isupper()] def issub(s, t): it = iter(t) # importand, pass the `Coop` testcase return all(c in it for c in p) return [u(q)==u(p) and issub(p, q) for q in qs] 212. Word Search II在矩阵中搜索多个单词，返回存在的单词。原题12345678910Input: board = [ [&apos;o&apos;,&apos;a&apos;,&apos;a&apos;,&apos;n&apos;], [&apos;e&apos;,&apos;t&apos;,&apos;a&apos;,&apos;e&apos;], [&apos;i&apos;,&apos;h&apos;,&apos;k&apos;,&apos;r&apos;], [&apos;i&apos;,&apos;f&apos;,&apos;l&apos;,&apos;v&apos;]]words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]Output: [&quot;eat&quot;,&quot;oath&quot;] 方法一：和单词搜索一样，大体的原理还是回溯法，但是要考虑一些优化，所以用Trie 这里有个地方注意要在循环刚开始前将g[i][j]设为’#’不能过早地放在return 前。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class TrieNode: def __init__(self): self.child = collections.defaultdict(TrieNode) self.is_word = Falseclass Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -&gt; None: cur = self.root for letter in word: cur = cur.child[letter] cur.is_word = True def search(self, word: str) -&gt; bool: cur = self.root for letter in word: cur = cur.child.get(letter) if not cur: return False return cur.is_word class Solution: def findWords(self, g: List[List[str]], words: List[str]) -&gt; List[str]: def dfs(i, j, node, path): if node.is_word: ans.append(path) node.is_word = False if not R&gt;i&gt;=0&lt;=j&lt;C: return tmp = g[i][j] node = node.child.get(tmp) if not node: return g[i][j] = '#' for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)): dfs(x, y, node, path+tmp) g[i][j] = tmp R, C = len(g), len(g[0]) ans = [] trie = Trie() node = trie.root for w in words: trie.insert(w) for i in range(R): for j in range(C): dfs(i, j, node, "") return ans 211. Add and Search Word - Data structure design和前缀单词查找树题一样，区别在于，这里搜索的时候可以使用’.’来匹配所有的字母。原题1234567addWord(&quot;bad&quot;)addWord(&quot;dad&quot;)addWord(&quot;mad&quot;)search(&quot;pad&quot;) -&gt; falsesearch(&quot;bad&quot;) -&gt; truesearch(&quot;.ad&quot;) -&gt; truesearch(&quot;b..&quot;) -&gt; true 方法一：Trie + dfs. 12345678910111213141516171819202122232425262728class TrieNode: def __init__(self): self.child = collections.defaultdict(TrieNode) self.is_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def addWord(self, word: str) -&gt; None: cur = self.root for c in word: cur = cur.child[c] cur.is_word = True def search(self, word: str) -&gt; bool: def dfs(cur, w): if not cur: return False if not w: return cur.is_word if w[0] != '.': return dfs(cur.child.get(w[0]), w[1:]) else: return any(dfs(c, w[1:]) for c in cur.child.values()) return dfs(self.root, word) 820. Short Encoding of Words这个题描述的有点乱，简单来说就是将一个单词列表转成另一个单词列表，使前者的单词每一个都是后者的后缀。求列表的长度加上分隔符#。原题123Input: words = [&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]Output: 10Explanation: S = &quot;time#bell#&quot; and indexes = [0, 2, 5]. 方法一：因为数据不都大，所以直接用set。 123456def minimumLengthEncoding(self, words: List[str]) -&gt; int: s = set(words) for w in words: for i in range(1, len(w)): s.discard(w[i:]) return sum(len(w)+1 for w in s) 方法二：单词查找树。最后不为空的node表示只是后缀的一部分。 123456789def minimumLengthEncoding(self, words: List[str]) -&gt; int: root = dict() leaves = [] for word in set(words): cur = root for w in reversed(word): cur[w] = cur = cur.get(w, dict()) leaves.append((cur, len(word)+1)) return sum(d for node, d in leaves if len(node)==0) 1032. Stream of Characters给定一些单词，查询字母，判断是否能和前k步的字母组成某个单词。原题12345678910111213StreamChecker streamChecker = new StreamChecker([&quot;cd&quot;,&quot;f&quot;,&quot;kl&quot;]); // init the dictionary.streamChecker.query(&apos;a&apos;); // return falsestreamChecker.query(&apos;b&apos;); // return falsestreamChecker.query(&apos;c&apos;); // return falsestreamChecker.query(&apos;d&apos;); // return true, because &apos;cd&apos; is in the wordliststreamChecker.query(&apos;e&apos;); // return falsestreamChecker.query(&apos;f&apos;); // return true, because &apos;f&apos; is in the wordliststreamChecker.query(&apos;g&apos;); // return falsestreamChecker.query(&apos;h&apos;); // return falsestreamChecker.query(&apos;i&apos;); // return falsestreamChecker.query(&apos;j&apos;); // return falsestreamChecker.query(&apos;k&apos;); // return falsestreamChecker.query(&apos;l&apos;); // return true, because &apos;kl&apos; is in the wordlist 方法一：我写的方法和这个差不多，但是超时了，这里Lee用了一些内置的方法，才不会超时。但是耗时也很长。 123456789101112class StreamChecker: def __init__(self, words: List[str]): T = lambda: collections.defaultdict(T) self.trie = T() for w in words: reduce(dict.__getitem__, w, self.trie)['#'] = True self.waiting = [] def query(self, letter: str) -&gt; bool: self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node] return any('#' in node for node in self.waiting) 方法二：这个方法倒置单词存储，这样可以提前退出循环，而且维持一个最大的单词的长度即可。 123456789101112131415161718192021class StreamChecker: def __init__(self, words: List[str]): T = lambda: collections.defaultdict(T) self.trie = T() for w in words: reduce(dict.__getitem__, w[::-1], self.trie)['#'] = True self.S = "" self.W = max(map(len, words)) def query(self, letter: str) -&gt; bool: self.S = (letter + self.S)[:self.W] cur = self.trie for c in self.S: if c in cur: cur = cur[c] if cur['#']: return True else: break return False]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（栈篇）Stack]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%A0%88%E7%AF%87%EF%BC%89Stack%2F</url>
    <content type="text"><![CDATA[1021. Remove Outermost Parentheses删除最外层的括号。原题12345678910Input: &quot;(()())(())&quot;Output: &quot;()()()&quot;The input string is &quot;(()())(())&quot;, with primitive decomposition &quot;(()())&quot; + &quot;(())&quot;.After removing outer parentheses of each part, this is &quot;()()&quot; + &quot;()&quot; = &quot;()()()&quot;.Input: &quot;(()())(())(()(()))&quot;Output: &quot;()()()()(())&quot;The input string is &quot;(()())(())(()(()))&quot;, with primitive decomposition &quot;(()())&quot; + &quot;(())&quot; + &quot;(()(()))&quot;.After removing outer parentheses of each part, this is &quot;()()&quot; + &quot;()&quot; + &quot;()(())&quot; = &quot;()()()()(())&quot;.Input: &quot;()()&quot;Output: &quot;&quot; 方法一：比赛时的丑陋写法。使用索引记录位置坐切片。 1234567891011121314151617def removeOuterParentheses(self, S: str) -&gt; str: l = 0 left = right = 0 ans = '' for i, p in enumerate(S): if p =='(': left += 1 if left == 1: l = i else: right += 1 if left == right: ans += S[l+1:i] l = i + 1 left = right = 0 # print(ans) return ans 方法二：优化。 123456789def removeOuterParentheses(self, S: str) -&gt; str: ans, opened = [], 0 for s in S: if s == '(' and opened &gt; 0: ans.append(s) if s == ')' and opened &gt; 1: ans.append(s) opened += 1 if s=='(' else -1 return ''.join(ans) 1047. Remove All Adjacent Duplicates In String每两个相邻的相同字符串可以消掉。类似于连连看。原题12345678def removeDuplicates(self, S: str) -&gt; str: stack = [] for c in S: if stack and stack[-1] == c: stack.pop() else: stack.append(c) return ''.join(stack) 1172. Dinner Plate Stacks有这样一堆栈，每个栈有个容量，可以在指定索引下删除某个栈，每次push时需要在最左的不满的栈。原题12345Input: [&quot;DinnerPlates&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;popAtStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;popAtStack&quot;,&quot;popAtStack&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;][[2],[1],[2],[3],[4],[5],[0],[20],[21],[0],[2],[],[],[],[],[]]Output: [null,null,null,null,null,null,2,null,null,20,21,5,4,3,1,-1] 方法一：一开始被题吓到了，竞赛时没做出来，核心思想在于维护一个堆，记录不满的栈。以便插入时可以找到该索引。 class DinnerPlates: 12345678910111213141516171819202122232425262728def __init__(self, capacity: int): self.c = capacity self.q = [] self.emp = []def push(self, val: int) -&gt; None: if self.emp: index = heapq.heappop(self.emp) self.q[index].append(val) else: if self.q and len(self.q[-1])!=self.c: self.q[-1].append(val) else: self.q.append([val])def pop(self) -&gt; int: while self.q: if self.q[-1]: return self.q[-1].pop() self.q.pop() return -1def popAtStack(self, index: int) -&gt; int: heapq.heappush(self.emp, index) if self.q[index]: return self.q[index].pop() else: return -1 901. Online Stock Span实时找出数据流中连续的比不大于当前值的个数。原题1234567891011121314Input: [&quot;StockSpanner&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;], [[],[100],[80],[60],[70],[60],[75],[85]]Output: [null,1,1,1,2,1,4,6]Explanation: First, S = StockSpanner() is initialized. Then:S.next(100) is called and returns 1,S.next(80) is called and returns 1,S.next(60) is called and returns 1,S.next(70) is called and returns 2,S.next(60) is called and returns 1,S.next(75) is called and returns 4,S.next(85) is called and returns 6.Note that (for example) S.next(75) returned 4, because the last 4 prices(including today&apos;s price of 75) were less than or equal to today&apos;s price. 方法一：&lt;=可以累加。 1234567891011class StockSpanner: def __init__(self): self.stack = [] def next(self, price: int) -&gt; int: cnt = 1 while self.stack and self.stack[-1][0] &lt;= price: cnt += self.stack.pop()[1] self.stack.append((price, cnt)) return cnt 1299. Replace Elements with Greatest Element on Right Side根据数组重新生成一个数组，每个元素对应原数组右侧最大的数字。原题12Input: arr = [17,18,5,4,6,1]Output: [18,6,6,6,1,-1] 方法一：栈 12345678def replaceElements(self, arr: List[int]) -&gt; List[int]: stack = [-1] for i in range(len(arr)-1, 0, -1): if arr[i] &lt; stack[-1]: stack.append(stack[-1]) else: stack.append(arr[i]) return stack[::-1] 方法二：Lee215. 1234def replaceElements(self, arr: List[int], mx=-1) -&gt; List[int]: for i in range(len(arr)-1, -1, -1): arr[i], mx = mx, max(mx, arr[i]) return arr 1249. Minimum Remove to Make Valid Parentheses删除字符串中多余的括号。原题123Input: s = &quot;lee(t(c)o)de)&quot;Output: &quot;lee(t(c)o)de&quot;Explanation: &quot;lee(t(co)de)&quot; , &quot;lee(t(c)ode)&quot; would also be accepted. 方法一：比较笨的方法，遍历了两次。 123456789101112131415def minRemoveToMakeValid(self, s: str) -&gt; str: def helper(arr, sig): ans, opened = [], 0 for c in arr: if opened &lt;= 0 and c==sig[1]: continue if c == sig[0]: opened += 1 elif c == sig[1]: opened -= 1 ans.append(c) return ans return ''.join(reversed(helper(reversed(helper(list(s), ('(', ')'))), (')', '(')))) 方法二：stack、这个方法有点不好理解， 最后的while 循环时为了防止末尾有过多的( 123456789101112131415def minRemoveToMakeValid(self, s: str) -&gt; str: stack, cur = [], '' for c in s: if c == '(': stack.append(cur) cur = '' elif c == ')': if stack: cur = '&#123;&#125;(&#123;&#125;)'.format(stack.pop(), cur) else: cur += c while stack: cur = stack.pop() + cur return cur 1190. Reverse Substrings Between Each Pair of Parentheses将括号内的字符串反转。原题123Input: s = &quot;(u(love)i)&quot;Output: &quot;iloveu&quot;Explanation: The substring &quot;love&quot; is reversed first, then the whole string is reversed. 方法一：用了和1249一样的解法。 123456789101112def reverseParentheses(self, s: str) -&gt; str: stack, cur = [], '' for c in s: if c == '(': stack.append(cur) cur = '' elif c == ')': if stack: cur = '&#123;&#125;&#123;&#125;'.format(stack.pop(), cur[::-1]) else: cur += c return cur 1209. Remove All Adjacent Duplicates in String II将字符串中连续的k的字母全部删除，返回剩余的字符串。原题123Input: s = &quot;abcd&quot;, k = 2Output: &quot;abcd&quot;Explanation: There&apos;s nothing to delete. 方法一：这道题虽然ac了，但是复杂度太高了。 12345678def removeDuplicates(self, s: str, k: int) -&gt; str: stack = [] for c in s: if len(stack)&gt;=k-1 and all(a==c for a in stack[-k+1:]): stack = stack[:-k+1] else: stack.append(c) return ''.join(stack) 方法二：相同字符的记录个数。 12345678910def removeDuplicates(self, s: str, k: int) -&gt; str: stack = [['#', 0]] for c in s: if stack[-1][0] == c: stack[-1][1] += 1 if stack[-1][1] == k: stack.pop() else: stack.append([c, 1]) return ''.join(c*k for c, k in stack) 1475. Final Prices With a Special Discount in a Shop找出数组中后面元素比当前元素小的差。原题1234567Input: prices = [8,4,6,2,3]Output: [4,2,4,2,3]Explanation: For item 0 with price[0]=8 you will receive a discount equivalent to prices[1]=4, therefore, the final price you will pay is 8 - 4 = 4. For item 1 with price[1]=4 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 4 - 2 = 2. For item 2 with price[2]=6 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 6 - 2 = 4. For items 3 and 4 you will not receive any discount at all. 方法一：暴力法。 1234567891011def finalPrices(self, prices: List[int]) -&gt; List[int]: n = len(prices) ans = [] for i in range(n): for j in range(i+1, n): if prices[j] &lt;= prices[i]: ans.append(prices[i]-prices[j]) break else: ans.append(prices[i]) return ans 方法二：stack. by lee215 1234567def finalPrices(self, A: List[int]) -&gt; List[int]: stack = [] for i, a in enumerate(A): while stack and A[stack[-1]] &gt;= a: A[stack.pop()] -= a stack.append(i) return A 739. Daily Temperature找出比当前元素之后的大的值，计算索引差，没有则是0。原题方法一：刚刚做完1475的题，一样的解法。 123456789def dailyTemperatures(self, T: List[int]) -&gt; List[int]: stack = [] ans = [0] * len(T) for i, t in enumerate(T): while stack and T[stack[-1]] &lt; t: j = stack.pop() ans[j] = i - j stack.append(i) return ans 394. Decode String就是根据括号来重复字符串。原题12345Input: s = &quot;3[a]2[bc]&quot;Output: &quot;aaabcbc&quot;Input: s = &quot;3[a2[c]]&quot;Output: &quot;accaccacc&quot; 方法一：使用了两个栈，分别存储数字和字母。 123456789101112131415def decodeString(self, s: str) -&gt; str: stack, cur, digit, d = [], '', [], '' for c in s: if c == '[': digit.append(d) d = '' stack.append(cur) cur = '' elif c == ']': cur = stack.pop() + int(digit.pop()) * cur elif c.isdigit(): d += c else: cur += c return cur 方法二：使用一个stack，因为这个规律是有保证的，左括号前一定是数字。 12345678910111213141516def decodeString(self, s: str) -&gt; str: stack, cur, d = [], '', '' for c in s: if c == '[': stack.append(cur) stack.append(d) d = '' cur = '' elif c == ']': num = stack.pop() cur = stack.pop() + int(num) * cur elif c.isdigit(): d += c else: cur += c return cur 1541. Minimum Insertions to Balance a Parentheses String平衡一个括号对，最少需要插入多少次，括号对为一个(对应2个)。原题123Input: s = &quot;(()))&quot;Output: 1Explanation: The second &apos;(&apos; has two matching &apos;))&apos;, but the first &apos;(&apos; has only &apos;)&apos; matching. We need to to add one more &apos;)&apos; at the end of the string to be &quot;(())))&quot; which is balanced. 方法一：比赛时卡住了。这是Lee215的解法。想到了用栈和这种方式，但是没想好如何内部处理。 1234567891011121314def minInsertions(self, s: str) -&gt; int: ans = right = 0 for c in s: if c == '(': if right&amp;1 == 1: right -= 1 ans += 1 right += 2 else: right -= 1 if right &lt; 0: right += 2 ans += 1 return ans + right 856. Score of Parentheses括号的分数，根据规则计算括号的分数。()表示1分；AB表示A+B，(A)表示A*2。原题123456Input: &quot;()&quot;Output: 1Input: &quot;(())&quot;Output: 2Input: &quot;(()(()))&quot;Output: 6 方法一：首次AC的方法。 12345678910111213141516def scoreOfParentheses(self, S: str) -&gt; int: stack = [] for c in S: if c == '(': stack.append(c) else: if stack[-1] == '(': stack.pop() stack.append(1) else: v = 0 while stack[-1] != '(': v += stack.pop() stack.pop() stack.append(2 * v) return sum(stack) 方法二：Lee的方法太盖了，但是不知道咋想的，这个思路的过程我还是没想明白。 123456789def scoreOfParentheses(self, S: str) -&gt; int: stack, cur = [], 0 for i in S: if i == '(': stack.append(cur) cur = 0 else: cur += stack.pop() + max(cur, 1) return cur 方法三：O(1)space的方法，同样牛逼。 123456def scoreOfParentheses(self, S): res = l = 0 for a, b in itertools.izip(S, S[1:]): if a + b == '()': res += 2 ** l l += 1 if a == '(' else -1 return res 方法四：这个方法倒是没想到。 12def scoreOfParentheses(self, S): return eval(S.replace(')(', ')+(').replace('()', '1').replace(')', ')*2'))]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（回溯篇）BackTracking]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%9B%9E%E6%BA%AF%E7%AF%87%EF%BC%89BackTracking%2F</url>
    <content type="text"><![CDATA[93. Restore IP Addresses恢复IP地址。原题12Input: &quot;25525511135&quot;Output: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;] 方法一：需要注意0的情况。 12345678910111213141516171819202122def restoreIpAddresses(self, s: str) -&gt; List[str]: def backtrack(ip, remain, part): if part &lt; 0: return if not remain and part==0: ans.append(ip) else: ip += '.' * bool(ip) n = len(remain) if n &gt;= 1: backtrack(ip+remain[:1], remain[1:], part-1) if n &gt;= 2 and remain[0]!='0': backtrack(ip+remain[:2], remain[2:], part-1) if n &gt;= 3: if 99 &lt; int(remain[:3]) &lt; 256: backtrack(ip+remain[:3], remain[3:], part-1) ans = [] if s: backtrack('', s, 4) return list(ans) 131. Palindrome Partitioning回文串切分。原题123456Input: &quot;aab&quot;Output:[ [&quot;aa&quot;,&quot;b&quot;], [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]] 方法一：原始回溯。 12345678910111213def partition(self, s: str) -&gt; List[List[str]]: def backtrack(s, remain): if not remain: ans.append(s) else: for i in range(1, len(remain)+1): # 这里是n+1，因为整个字符串也有可能。 if remain[:i] == remain[:i][::-1]: backtrack(s+[remain[:i]], remain[i:]) ans = [] if s: backtrack([], s) return ans 方法二：使用列表生成式。 1234def partition(self, s: str) -&gt; List[List[str]]: return s and [[s[:i]] + suffix for i in range(1, len(s)+1) if s[:i]==s[i-1::-1] for suffix in self.partition(s[i:])] or [[]] 77. Combinations实现组合。原题12345678910Input: n = 4, k = 2Output:[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 方法一：回溯。700ms, 比Solution中的慢了100ms. 123456789101112def combine(self, n: int, k: int) -&gt; List[List[int]]: def backtrack(a, k, rest): if k == 1: ans.extend(a+[num] for num in rest) else: for i, h in enumerate(rest): backtrack(a+[h], k-1, rest[i+1:]) ans = [] backtrack([], k, list(range(1, n+1))) return ans 方法二：Solution中的递归。 1234567891011121314def combine(self, n: int, k: int) -&gt; List[List[int]]: def backtrack(first=1, cur=[]): if len(cur) == k: ans.append(cur[:]) else: for i in range(first, n+1): cur.append(i) backtrack(i+1, cur) cur.pop() ans = [] backtrack() return ans 方法三：列表生成式写法，递归。 12345def combine(self, n: int, k: int) -&gt; List[List[int]]: if k == 0: return [[]] return [pre+[i] for i in range(k, n+1) for pre in self.combine(i-1, k-1)] 39. Combination Sum和77类似，找出和为指定数值的组合，候选数字可以重复使用。原题1234567Input: candidates = [2,3,5], target = 8,A solution set is:[ [2,2,2,2], [2,3,3], [3,5]] 方法一：将候选组排序，并记录当前的索引值。 123456789101112131415def combinationSum(self, candidates: List[int], target: int) -&gt; List[List[int]]: def backtrack(g, i, target): if target == 0: ans.append(g) elif target &lt; candidates[i]: return for j in range(i, n): backtrack(g+[candidates[j]], j, target-candidates[j]) ans = [] n = len(candidates) candidates.sort() backtrack([], 0, target) return ans 方法二：时隔一年又重做一遍，感觉方法更加精炼了。sort感觉没啥必要。 1234567891011121314151617def combinationSum(self, cn: List[int], target: int) -&gt; List[List[int]]: def backtrack(i, t, p): if t == 0: ans.append(p[:]) return if t &lt; 0: return for j in range(i, len(cn)): c = cn[j] p.append(c) backtrack(j, t-c, p) p.pop() ans = [] backtrack(0, target, []) return ans 40. Combination Sum II组合求和，和39类似，区别在于候选数字中可能有重复数字，但每个数字只能使用一次。原题麻烦的地方在于如何保证结果是非重复的。当j==i时，cn[j]==cn[j-1]说明前面刚刚用了和这个一样的数字。可以继续使用。比如[1,1,6]。当j!=i，cn[j]==cn[j-1]时，说明想以j开头同样找数组，这样肯定会找出一个重复的。 12345678910111213141516171819def combinationSum2(self, candidates: List[int], target: int) -&gt; List[List[int]]: def backtrack(g, i, target): if target == 0: ans.append(g) return for j in range(i, n): # avoid duplicate result if j != i and candidates[j]==candidates[j-1]: continue if candidates[j] &gt; target: break backtrack(g+[candidates[j]], j+1, target-candidates[j]) ans = [] n = len(candidates) candidates.sort() backtrack([], 0, target) return ans 216. Combination Sum III组合求和，从1~9选出k个不重复的数，和为n。原题12Input: k = 3, n = 9Output: [[1,2,6], [1,3,5], [2,3,4]] 123456789101112def combinationSum3(self, k: int, n: int) -&gt; List[List[int]]: def backtrack(g, i, target, k): if k==0 and target==0: ans.append(g) if k &lt; 0 or target &lt; 0: return for j in range(i, 10): backtrack(g+[j], j+1, target-j, k-1) ans = [] backtrack([], 1, n, k) return ans 方法二：递归，使用last作为上限。 123456789def combinationSum3(self, k: int, n: int) -&gt; List[List[int]]: def combs(k, n, cap): if not k: return [[]] * (not n) return [comb + [last] for last in range(1, cap) for comb in combs(k-1, n-last, last)] return combs(k, n, 10) 78. Subsets输出给定无重复集合的子集组合。原题123456789101112Input: nums = [1,2,3]Output:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 方法一：常规写法。 123456789101112def subsets(self, nums: List[int]) -&gt; List[List[int]]: def backtrack(g, i, n): if not n: ans.append(g) for j in range(i, len(nums)): backtrack(g+[nums[j]], j+1, n-1) ans = [] for n in range(len(nums)+1): backtrack([], 0, n) return ans 方法二：做一个递增就好了。 12345def subsets(self, nums: List[int]) -&gt; List[List[int]]: ans = [[]] for num in nums: ans += [pre+[num] for pre in ans] return ans 方法三：使用索引来做。 123456789101112131415def subsets(self, nums: List[int]) -&gt; List[List[int]]: self.ans = [] def dfs(i, n, p): if not n: self.ans.append(p[:]) return for j in range(i, len(nums)): d = nums[j] p.append(d) dfs(j+1, n-1, p) p.pop() [dfs(0, i, []) for i in range(0, len(nums)+1)] return self.ans 90. Subsets II和78类似，区别在于给定的数组有重复元素。原题方法一：用到了40题中解法去重的代码。 123456789101112131415def subsetsWithDup(self, nums: List[int]) -&gt; List[List[int]]: def backtrack(g, i, n): if not n: ans.append(g) for j in range(i, len(nums)): if j!=i and nums[j]==nums[j-1]: continue backtrack(g+[nums[j]], j+1, n-1) ans = [] nums.sort() for n in range(len(nums)+1): backtrack([], 0, n) return ans 79. Word Search矩阵中的路径。原题12345678910board =[ [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;], [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;], [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]]Given word = &quot;ABCCED&quot;, return true.Given word = &quot;SEE&quot;, return true.Given word = &quot;ABCB&quot;, return false. 12345678910111213141516171819def exist(self, g: List[List[str]], word: str) -&gt; bool: def dfs(i, j, word): if not word: return True original, g[i][j] = g[i][j], '-' for x, y in ((i+1, j), (i, j+1), (i, j-1), (i-1, j)): if 0&lt;=x&lt;R and 0&lt;=y&lt;C and g[x][y] == word[0]: if dfs(x, y, word[1:]): return True g[i][j] = original return False R, C = len(g), len(g[0]) for i in range(R): for j in range(C): if g[i][j] == word[0] and dfs(i, j, word[1:]): return True return False 200. Number of Islands小岛的个数。原题1234567Input:11110110101100000000Output: 1 方法一：常规写法。 1234567891011121314151617181920def numIslands(self, grid: List[List[str]]) -&gt; int: if not grid: return 0 R, C = len(grid), len(grid[0]) seen = set() count = 0 def spread(i, j): seen.add((i, j)) for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)): if (0&lt;=x&lt;R and 0&lt;=y&lt;C and (x, y) not in seen and grid[x][y]=='1'): spread(x, y) for i in range(R): for j in range(C): if (i, j) not in seen and grid[i][j]=='1': count += 1 spread(i, j) return count 方法二：当登录一座岛屿时，使这座岛屿下沉，变为’0’。不明白为什么比上个方法慢了20ms。 123456789def numIslands(self, grid: List[List[str]]) -&gt; int: def sink(i, j): if 0&lt;=i&lt;len(grid) and 0&lt;=j&lt;len(grid[i]) and grid[i][j]=='1': grid[i][j] = '0' list(map(sink, (i-1, i+1, i, i), (j, j, j-1, j+1))) # important, return generator without list return 1 return 0 return sum(sink(i, j) for i in range(len(grid)) for j in range(len(grid[i]))) 1254. Number of Closed Islands和200类似，但是与边界相连的岛不能算了。原题1234Input: grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]Output: 2Explanation: Islands in gray are closed because they are completely surrounded by water (group of 1s). 方法一：下沉法。先把边界的岛屿处理，然后再累计。 123456789101112131415def closedIsland(self, g: List[List[int]]) -&gt; int: m, n = len(g), len(g[0]) def sink(i, j): if m&gt;i&gt;=0&lt;=j&lt;n and g[i][j]==0: g[i][j] = 1 list(map(sink, (i-1, i+1, i, i), (j, j, j-1, j+1))) return 1 return 0 list(map(sink, [0]*n, range(n))) list(map(sink, [m-1]*n, range(n))) list(map(sink, range(m), [0]*m)) list(map(sink, range(m), [n-1]*m)) return sum(sink(i, j) for i in range(1, m-1) for j in range(1, n-1)) 130. Surrounded Regions将四周被包围的O翻转成X，边缘不算包围。原题方法一：传统的方法在延伸的时候判断不出是否到达边界。所以这里先得到边界的点，然后从边界往里延伸，将所有的O变为S，第二次遍历时，将S恢复成O，其他设为X。 123456789101112def solve(self, board: List[List[str]]) -&gt; None: if not board: return R, C = len(board), len(board[0]) bounds = [(i, j) for k in range(R+C) for i, j in ((0, k), (R-1, k), (k, 0), (k, C-1)) if i &lt; R and j &lt; C] while bounds: x, y = bounds.pop() if 0&lt;=x&lt;R and 0&lt;=y&lt;C and board[x][y]=='O': board[x][y] = 'S' bounds += (x-1, y), (x+1, y), (x, y-1), (x, y+1) board[:] = [['XO'[c=='S'] for c in row] for row in board] 417. Pacific Atlantic Water Flow太平洋大西洋水流向，假设陆地上可以沿着高度不高于的地方流淌，求能同时流入两个海洋的陆地坐标。原题1234567891011121314151617Given the following 5x5 matrix: Pacific ~ ~ ~ ~ ~ ~ 1 2 2 3 (5) * ~ 3 2 3 (4) (4) * ~ 2 4 (5) 3 1 * ~ (6) (7) 1 4 5 * ~ (5) 1 1 2 4 * * * * * * AtlanticReturn:[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix). Pacific ~ ~ ~ ~ 1 2 (3) * ~ (8) (9) (4) * ~ (7) (6) (5) * * * * * Atlantic 方法一：一开始我以为从左上的点只能往右或下方向找陆地，事实上还是要寻找四个方向。这应该是最暴力的解法了。但是看了几个高票答案都没我这个快。 1234567891011121314151617181920def pacificAtlantic(self, matrix: List[List[int]]) -&gt; List[List[int]]: if not matrix: return [] p_land = set() a_land = set() R, C = len(matrix), len(matrix[0]) def spread(i, j, land): land.add((i, j)) for x, y in ((i+1, j), (i, j+1), (i-1, j), (i, j-1)): if (0&lt;=x&lt;R and 0&lt;=y&lt;C and matrix[x][y] &gt;= matrix[i][j] and (x, y) not in land): spread(x, y, land) for i in range(R): spread(i, 0, p_land) spread(i, C-1, a_land) for j in range(C): spread(0, j, p_land) spread(R-1, j, a_land) return list(p_land &amp; a_land) 526. Beautiful Arrangement完美安排，给定1~N的数字，生成一种排列，是第i位的数字能被i整除，或者i能被第i位的数字整除，索引从1开始。原题123456789101112131415Input: 2Output: 2Explanation: The first beautiful arrangement is [1, 2]:Number at the 1st position (i=1) is 1, and 1 is divisible by i (i=1).Number at the 2nd position (i=2) is 2, and 2 is divisible by i (i=2).The second beautiful arrangement is [2, 1]:Number at the 1st position (i=1) is 2, and 2 is divisible by i (i=1).Number at the 2nd position (i=2) is 1, and i (i=2) is divisible by 1. 方法一：常规写法，1300ms，beats50%. 12345678910111213141516def countArrangement(self, N: int) -&gt; int: def backtrack(g, rest): nonlocal count if not rest: count += 1 index = len(g) + 1 for i, num in enumerate(rest): if num % index == 0 or index % num == 0: # print(g, i, num, index, rest) g.append(num) backtrack(g, rest[:i]+rest[i+1:]) g.pop() count = 0 backtrack([], list(range(1, N+1))) return count 方法二：去掉了方法一中一些无用的空间和操作。1000ms, beats 67%. 123456789101112131415161718def countArrangement(self, N: int) -&gt; int: def backtrack(g): nonlocal count if not rest: count += 1 index = len(g) + 1 for num in rest: if num % index == 0 or index % num == 0: g.append(num) rest.remove(num) backtrack(g) g.pop() rest.add(num) count = 0 rest = set(range(1, N+1)) backtrack([]) return count 方法三：这里从后往前构建，最后构造1，因为1的位置放任何数字都可以。152ms 123456789def countArrangement(self, N: int) -&gt; int: def backtrack(i, rest): if i == 1: return 1 return sum(backtrack(i-1, rest-&#123;x&#125;) for x in rest if x % i == 0 or i % x == 0) return backtrack(N, set(range(1, N+1))) 方法四：在3的基础上优化，每次调用方法时可以利用之前的结果。52ms 1234567891011121314151617cache = &#123;&#125;class Solution: def countArrangement(self, N: int) -&gt; int: def backtrack(i, rest): if i == 1: return 1 key = i, rest if key in cache: return cache[key] ans = sum(backtrack(i-1, rest[:j]+rest[j+1:]) for j, x in enumerate(rest) if x % i == 0 or i % x == 0) # print(ans, i, rest) cache[key] = ans return ans return backtrack(N, tuple(range(1, N+1))) 22. Generate Parentheses生成n对合法的括号。原题1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 方法一：常规写法。 123456789101112def generateParenthesis(self, n: int) -&gt; List[str]: def backtrack(p, l, r): if len(p) == n*2: ans.append(p) if l &lt; n: backtrack(p+'(', l+1, r) if r &lt; l: backtrack(p+')', l, r+1) ans = [] backtrack('', 0, 0) return ans 方法二：生成器写法。 123456789def generateParenthesis(self, n: int) -&gt; List[str]: def gen_parens(p, l, r): if r &gt;= l &gt;= 0: if not r: yield p yield from gen_parens(p+'(', l-1, r) yield from gen_parens(p+')', l, r-1) return list(gen_parens('', n, n)) 89. Gray Code灰码问题。给定一个n表示n位。从0开始每次改变一个位的数字，产生所有的组合。原题123456789101112131415Input: 2Output: [0,1,3,2]Explanation:00 - 001 - 111 - 310 - 2For a given n, a gray code sequence may not be uniquely defined.For example, [0,2,3,1] is also a valid gray code sequence.00 - 010 - 211 - 301 - 1 方法一：回溯法。一定要有顺序，一开始我误以为n位的进制0或1的组合。但是不行，因为不能从01跨越到10。这个问题我想了很久没有想出来如何解决，看到discuss中一个java版本的受到了启发。 12345678910111213141516171819202122def grayCode(self, n: int) -&gt; List[int]: def backtrack(p, n): if not n: ans.append(int(''.join(p), 2)) return for i in range(2): p += binary[i] if p[-1] == '0': backtrack(p, n-1) else: binary[0], binary[1] = binary[1], binary[0] backtrack(p, n-1) binary[0], binary[1] = binary[1], binary[0] p = p[:-1] if not n: return [0] ans = [] binary = list('01') backtrack('', n) return ans 方法二：此题有规律，这个规律讲不太好，有点像之字形那种感觉，倒序的时候在最高位补1。就能满足每个数只变化一位的要求。 1234567890 1 11 110 10 111 101 100start: [0] # [0]i = 0: [0, 1] # [0, 1]i = 1: [0, 1, 3, 2] # [00, 01, 11, 10]i = 2: [0, 1, 3, 2, 6, 7, 5, 4] # [000, 001, 011, 010, 110, 111, 101, 100] 123456def grayCode(self, n: int) -&gt; List[int]: ans = [0] for i in range(n): # ans += [x + pow(2, i) for x in reversed(ans)] ans += (x | 1&lt;&lt;i for x in reversed(ans)) return ans 842. Split Array into Fibonacci Sequence一串数组组成的字符串拆成斐波那契数列。原题123456Input: &quot;123456579&quot;Output: [123,456,579]Input: &quot;112358130&quot;Output: []Explanation: The task is impossible. ps: 此题第一天做的时候想了很久，提交了n个错误答案，后来第二天做的时候，20分钟就做出来了。 方法一：第一次AC的答案。需要注意几个点。首先只有当元素结果大于2才算数列；主循环中range(1, len(rest)+1)否则会丢失最后元素；因为0的存在，所以要考虑0不能作为数字的开头；最后题中要求每个数字要在int32范围内。224ms. 123456789101112131415def splitIntoFibonacci(self, S: str) -&gt; List[int]: def backtrack(p, rest): if not rest and len(p) &gt; 2: ans.append(list(map(int, p))) for i in range(1, len(rest)+1): if len(p) &lt; 2 or int(rest[:i])==int(p[-1])+int(p[-2]): if len(rest[:i]) &gt; 1 and rest[0]=='0': continue if int(rest[:i]) &gt; 2**31-1: continue backtrack(p+[rest[:i]], rest[i:]) ans = [] backtrack([], S) return ans[0] if ans else [] 优化二：添加一个flag，在找到结果后返回。188ms, beats 26%. 12345678910111213141516171819def splitIntoFibonacci(self, S: str) -&gt; List[int]: def backtrack(p, rest): # print(p, rest) if not rest and len(p) &gt; 2: ans.append(list(map(int, p))) return True for i in range(1, len(rest)+1): if len(p) &lt; 2 or int(rest[:i])==int(p[-1])+int(p[-2]): if len(rest[:i]) &gt; 1 and rest[0]=='0': break if int(rest[:i]) &gt; 2**31-1: break if backtrack(p+[rest[:i]], rest[i:]): return True return False ans = [] backtrack([], S) return ans[0] if ans else [] 优化三：每个元素既然小于2**31-1那么，最长长度为10。在主循环中加入此条件可以提升到52ms。 12345678910111213141516171819def splitIntoFibonacci(self, S: str) -&gt; List[int]: def backtrack(p, rest): if not rest and len(p) &gt; 2: return list(map(int, p)) for i in range(1, min(11, len(rest)+1)): to_add = rest[:i] if len(p) &lt; 2 or int(to_add)==int(p[-1])+int(p[-2]): if len(to_add) &gt; 1 and rest.startswith('0'): break if int(to_add) &gt; 2**31-1: break seq = backtrack(p+[to_add], rest[i:]) if seq: return seq return [] ans = backtrack([], S) return ans 优化4：当前两个数和已经为3位数时，下一个数没必要从1开始了。44ms。无论怎么提交都达不到迭代的40ms。猜测可能是递归栈的瓶颈了吧。 1234567891011121314151617181920212223242526def splitIntoFibonacci(self, S: str) -&gt; List[int]: def backtrack(p, rest): if not rest and len(p) &gt; 2: p[:] = list(map(int, p)) return True if len(p) &gt;= 2: next_num = int(p[-1]) + int(p[-2]) start = len(str(next_num)) else: start = 1 for i in range(start, min(11, len(rest)+1)): to_add = rest[:i] if len(p) &lt; 2 or int(to_add)==next_num: if len(to_add) &gt; 1 and rest.startswith('0'): break if int(to_add) &gt; 2**31-1: break p.append(to_add) if backtrack(p, rest[i:]): return True p.pop() return False ans = [] backtrack(ans, S) return ans 方法二：迭代。 123456789101112131415161718192021222324def splitIntoFibonacci(self, S: str) -&gt; List[int]: for i in range(min(10, len(S))): a = S[:i+1] if a != '0' and a.startswith('0'): break a = int(a) for j in range(i+1, min(i+10, len(S))): b = S[i+1:j+1] if b != '0' and b.startswith('0'): break b = int(b) fib = [a, b] k = j + 1 while k &lt; len(S): nxt = fib[-2] + fib[-1] nxt_str = str(nxt) if nxt &lt;= 2**31-1 and S[k:].startswith(nxt_str): fib.append(nxt) k += len(nxt_str) else: break else: if len(fib) &gt; 2: return fib return [] 60. Permutation Sequence全排列中的第k个。原题12Input: n = 3, k = 3Output: &quot;213&quot; 方法一：其实一开始想到了数学跳过去前几个结果，不过想着暴力的解决一下，结果却超时了。 123456789101112131415161718def getPermutation(self, n: int, k: int) -&gt; str: self.k = k def backtrack(s, rest): if not rest: self.k -= 1 if self.k == 0: return s return '' for i in range(len(rest)): old = s s += rest[i] ans = backtrack(s, rest[:i]+rest[i+1:]) if ans: return ans s = old return '' nums = list(map(str, range(1, n+1))) return backtrack('', nums) 优化二：如果当前的k大于整个全排列的个数，那么跳过。比如1234从1开始，最多有3!个，如果k比它大，那么结果肯定不是1开头的数。40ms. 12345678910111213141516171819202122def getPermutation(self, n: int, k: int) -&gt; str: self.k = k def backtrack(s, rest): if not rest: self.k -= 1 if self.k == 0: return s return '' for i in range(len(rest)): if self.k &gt; math.factorial(len(rest)-1): self.k -= math.factorial(len(rest)-1) continue old = s s += rest[i] ans = backtrack(s, rest[:i]+rest[i+1:]) if ans: return ans s = old return '' nums = list(map(str, range(1, n+1))) return backtrack('', nums) 方法二：改变一下思路，根据k的大小来确定每个位置的数。这道题想了不到个小时，最终原创出自己的写法。耗时36ms，beats 99%。果然数据规律才是致命的降维打击。 1234567891011def getPermutation(self, n: int, k: int) -&gt; str: ans = '' nums = list(map(str, range(1, n+1))) fact = math.factorial(len(nums)-1) while k != 1: i = (k - 1) // fact k -= i * fact ans += nums.pop(i) fact //= len(nums) ans += ''.join(nums) return ans 方法三：根据solution中调整了一些点。关于k索引的问题可以在一开始就-1，然后循环中便可以使用divmod内置函数来求值。 1234567891011def getPermutation(self, n: int, k: int) -&gt; str: ans = '' nums = list(map(str, range(1, n+1))) fact = math.factorial(len(nums)-1) k -= 1 while k: i, k = divmod(k, fact) ans += nums.pop(i) fact //= len(nums) ans += ''.join(nums) return ans 46. Permutations数组全排列。原题12345678910Input: [1,2,3]Output:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 方法一：recursively. 锁定头部法。思想为拿出一个数字作为头部，剩下的递归。 1234def permute(self, nums): return [[n] + p for i, n in enumerate(nums) for p in self.permute(nums[:i]+nums[i+1:])] or [[]] 方法二：到处插入法。 1234def permute(self, nums: 'List[int]') -&gt; 'List[List[int]]': return nums and [p[:i] + [nums[0]] + p[i:] for p in self.permute(nums[1:]) for i in range(len(nums))] or [[]] 方法二：iteratively. 思想为拿出一个数字插入到现有排序中的各个位置。 1234567def permute(self, nums): ans = [[]] for n in nums: ans = [l[:i] + [n] + l[i:] for l in ans for i in range(len(l)+1)] return ans 47. Permutations II全排列并去重。原题1234567Input: [1,1,2]Output:[ [1,1,2], [1,2,1], [2,1,1]] 思路：当然可以使用set来去重，或者考虑一种迭代的方式。 展开。拿着每个数字向上一个结果中插入到每一个位置。 123456789101112131415def permuteUnique(self, nums): ans = [[]] for j, n in enumerate(nums): new_ans = [] for l in ans: for i in range(len(l)+1): new_ans.append(l[:i]+[n]+l[i:]) print('\t j &#123;0&#125; - &#123;3&#125; + [&#123;2&#125;] + &#123;4&#125;'.format(j, i, n, l[:i], l[i:])) # if i&lt;len(l) and l[i]==n: break #handles duplication if i&lt;len(l) and l[i]==n: print('\t \t l[&#123;&#125;] == &#123;&#125;'.format(i, n)) break #handles duplication ans = new_ans print('j &#123;&#125; afer inner ans &#123;&#125;'.format(j, ans)) return ans 输入nums=[1, 2, 3] 123456789101112 j 0 - [] + [1] + []j 0 afer inner ans [[1]] j 1 - [] + [2] + [1] j 1 - [1] + [2] + []j 1 afer inner ans [[2, 1], [1, 2]] j 2 - [] + [3] + [2, 1] j 2 - [2] + [3] + [1] j 2 - [2, 1] + [3] + [] j 2 - [] + [3] + [1, 2] j 2 - [1] + [3] + [2] j 2 - [1, 2] + [3] + []j 2 afer inner ans [[3, 2, 1], [2, 3, 1], [2, 1, 3], [3, 1, 2], [1, 3, 2], [1, 2, 3]] 理解一下是如何去重的，我们输入nums=[1, 2, 1] 123456789101112 j 0 - [] + [1] + []j 0 afer inner ans [[1]] j 1 - [] + [2] + [1] j 1 - [1] + [2] + []j 1 afer inner ans [[2, 1], [1, 2]] j 2 - [] + [1] + [2, 1] j 2 - [2] + [1] + [1] l[1] == 1 j 2 - [] + [1] + [1, 2] l[0] == 1j 2 afer inner ans [[1, 2, 1], [2, 1, 1], [1, 1, 2]][[1, 2, 1], [2, 1, 1], [1, 1, 2]] 列表生成式整合。Stefan大神的写法。使用index来找非重复的临界值。 1234567def permuteUnique(self, nums): ans = [[]] for n in nums: ans = [l[:i]+[n]+l[i:] for l in ans for i in range((l+[n]).index(n)+1)] return ans 递归也可以 12345def permuteUnique(self, nums: List[int]) -&gt; List[List[int]]: return nums and [p[:i] + [nums[0]] + p[i:] for p in self.permuteUnique(nums[1:]) for i in range((p+[nums[0]]).index(nums[0])+1) ] or [[]] 1079. Letter Tile Possibilities本来是一道回溯的题，结果测试用例过于简单，所以暴力法就解出来了。原题123Input: &quot;AAB&quot;Output: 8Explanation: The possible sequences are &quot;A&quot;, &quot;B&quot;, &quot;AA&quot;, &quot;AB&quot;, &quot;BA&quot;, &quot;AAB&quot;, &quot;ABA&quot;, &quot;BAA&quot;. 1234def numTilePossibilities(self, tiles: str) -&gt; int: from itertools import permutations n = len(tiles) return sum(len(set(permutations(tiles, i))) for i in range(1, n+1)) 1415. The k-th Lexicographical String of All Happy Strings of Length n列出第k个快乐字符串（a,b,c）组成并没有连续相同的字母。原题方法一：回溯法。列出所有的值，排序索引。 123456789101112131415def getHappyString(self, n: int, k: int) -&gt; str: combine = [] s = 'abc' def backtrack(cur, n): if n == 0: combine.append(cur) return for c in s: if not (cur and cur[-1]==c): backtrack(cur+c, n-1) backtrack('', n) combine.sort() return combine[k-1] if k &lt;= len(combine) else '' 方法二：开始想的就是这种方法，后来想偏了，想用数学的方式直接求目标字符串，最后没有写出来。 12345678def getHappyString(self, n: int, k: int) -&gt; str: nxt = &#123;'a': 'bc', 'b': 'ac', 'c': 'ab'&#125; q = collections.deque(['a', 'b', 'c']) while len(q[0]) != n: u = q.popleft() for v in nxt[u[-1]]: q.append(u + v) return q[k - 1] if len(q) &gt;= k else '' 1255. Maximum Score Words Formed by Letters给定一些单词，每个字母有得分，不过每个字母用多少是有限制的。问最大得分是多少，一个典型的背包问题。原题123456Input: words = [&quot;dog&quot;,&quot;cat&quot;,&quot;dad&quot;,&quot;good&quot;], letters = [&quot;a&quot;,&quot;a&quot;,&quot;c&quot;,&quot;d&quot;,&quot;d&quot;,&quot;d&quot;,&quot;g&quot;,&quot;o&quot;,&quot;o&quot;], score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0]Output: 23Explanation:Score a=1, c=9, d=5, g=3, o=2Given letters, we can form the words &quot;dad&quot; (5+1+5) and &quot;good&quot; (3+2+2+5) with a score of 23.Words &quot;dad&quot; and &quot;dog&quot; only get a score of 21. 方法一：回溯。累加单词的分数可以提前退出递归。 123456789101112131415def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -&gt; int: self.ans, n = 0, len(words) wc = [Counter(w) for w in words] ws = [sum(v*score[ord(k)-ord('a')] for k, v in wc[i].items()) for i in range(n)] def dfs(i, s, left): if s + sum(ws[i:]) &lt;= self.ans: return self.ans = max(self.ans, s) for j, wcnt in enumerate(wc[i:], i): if all(n &lt;= left.get(c, 0) for c, n in wcnt.items()): dfs(j+1, s+ws[j], left-wcnt) dfs(0, 0, Counter(letters)) return self.ans 方法二：这个和我一开始想的方法很像。 123456789101112def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -&gt; int: def backtrack(i, left): if i == len(words): return 0 wc = Counter(words[i]) if all(n&lt;=left[c] for c, n in wc.items()): cur_score = sum(v*score[ord(k)-ord('a')] for k, v in wc.items()) ans = max(cur_score + backtrack(i+1, left-wc), backtrack(i+1, left)) else: ans = backtrack(i+1, left) return ans return backtrack(0, Counter(letters)) 1239. Maximum Length of a Concatenated String with Unique Characters最长的不重复的字符串组合。原题1234Input: arr = [&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;]Output: 4Explanation: All possible concatenations are &quot;&quot;,&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;,&quot;uniq&quot; and &quot;ique&quot;.Maximum length is 4. 方法一：回溯法。 1234567891011def maxLength(self, arr: List[str]) -&gt; int: def dfs(i, seen): if i == len(arr): return 0 if set(arr[i]) &amp; seen or len(set(arr[i]))!=len(arr[i]): ans = dfs(i+1, seen) else: ans = max(len(arr[i]) + dfs(i+1, seen|set(arr[i])), dfs(i+1, seen)) return ans return dfs(0, set()) 方法二：Lee215的解法。append的方式，会将每步累加的追加的ans中。 123456789def maxLength(self, arr: List[str]) -&gt; int: ans = [set()] for a in arr: if len(set(a)) != len(a):continue a = set(a) for c in ans[:]: if a &amp; c: continue ans.append(a | c) return max(len(a) for a in ans) 51. N-Queens著名的N皇后问题，将N个皇后摆在N*N的棋盘中，直线，斜线不能同时存在2个皇后。问所有的摆放位置。原题方法一：调了一次就AC了。记录第一次AC的方法。 123456789101112131415161718192021222324252627282930313233def solveNQueens(self, n: int) -&gt; List[List[str]]: l_dig = [False] * (n*2-1) r_dig = [False] * (n*2-1) row = [False] * n col = [False] * n def backtrack(i, j, k, g): # print(i, j, k, g) row[i] = True col[j] = True l_dig[i+j] = True r_dig[j-i+n-1] = True g[i][j] = 'Q' if not k-1: ans.append([''.join(row) for row in g]) for x in range(i+1, n): if not row[x]: for y in range(n): if not col[y]: if not l_dig[x+y] and not r_dig[y-x+n-1]: backtrack(x, y, k-1, g) row[i] = False col[j] = False l_dig[i+j] = False r_dig[j-i+n-1] = False g[i][j] = '.' ans = [] for j in range(n): g = [['.']*n for _ in range(n)] backtrack(0, j, n, g) return ans 方法二：row是不必要的，因为遍历行是不会有重复的。 12345678910111213141516171819202122232425def solveNQueens(self, n: int) -&gt; List[List[str]]: l_dig = [False] * (n*2-1) r_dig = [False] * (n*2-1) col = [False] * n def backtrack(i, j, k, g): # print(i, j, k, g) col[j] = l_dig[i+j] = r_dig[j-i+n-1] = True g[i][j] = 'Q' if not k-1: ans.append([''.join(row) for row in g]) for x in range(i+1, n): for y in range(n): if not col[y]: if not l_dig[x+y] and not r_dig[y-x+n-1]: backtrack(x, y, k-1, g) col[j] = l_dig[i+j] = r_dig[j-i+n-1] = False g[i][j] = '.' ans = [] for j in range(n): g = [['.']*n for _ in range(n)] backtrack(0, j, n, g) return ans 方法三：上述两种方法，用时800ms，此方法52ms，直接以行为单位进行回溯。 123456789101112131415161718192021222324def solveNQueens(self, n: int) -&gt; List[List[str]]: l_dig = [False] * (n*2-1) r_dig = [False] * (n*2-1) col = [False] * n def backtrack(i, g): # print(i, j, k, g) if i == n: ans.append(list(g)) return for j in range(n): if not col[j] and not l_dig[i+j] and not r_dig[j-i+n-1]: row = '.'*j + 'Q' + '.'*(n-j-1) g.append(row) col[j] = l_dig[i+j] = r_dig[j-i+n-1] = True backtrack(i+1, g) col[j] = l_dig[i+j] = r_dig[j-i+n-1] = False g.pop() ans = [] backtrack(0, []) return ans 52. N-Queens II和上边一样的N皇后问题，要求最后有多少种。原题方法一：不再需要一个数组来记录棋盘了，只需要计数就行。然后通过一个数组标记每行的棋子的纵坐标。而且无需重置，因为值会覆盖之前的。本质上还是回溯方法。 12345678910111213141516171819202122def totalNQueens(self, n: int) -&gt; int: rows = [-1] * n def valid(k): for i in range(k): if rows[i]==rows[k] or abs(rows[k]-rows[i]) == k-i: return False return True def dfs(i): if i == n: nonlocal ans ans += 1 return for j in range(n): rows[i] = j if valid(i): dfs(i+1) ans = 0 dfs(0) return ans 37. Sudoku Solver解9*9的数独。原题方法一：首次AC的方法，嗨呀，递归调用时忘记写return True了，调了半天。 1234567891011121314151617181920212223242526272829303132def solveSudoku(self, g: List[List[str]]) -&gt; None: """ Do not return anything, modify board in-place instead. """ row = [[True]*9 for i in range(9)] col = [[True]*9 for i in range(9)] sub = [[True]*9 for i in range(9)] to_add = [] for i in range(9): for j in range(9): if g[i][j] != '.': d = int(g[i][j]) - 1 row[i][d] = col[j][d] = sub[i//3*3+j//3][d] = False else: to_add.append((i, j)) def backtrack(): if not to_add: return True i, j = to_add.pop() for d in range(9): if row[i][d] and col[j][d] and sub[i//3*3+j//3][d]: g[i][j] = str(d+1) row[i][d] = col[j][d] = sub[i//3*3+j//3][d] = False if backtrack(): return True g[i][j] = '.' row[i][d] = col[j][d] = sub[i//3*3+j//3][d] = True to_add.append((i, j)) return False backtrack() 980. Unique Paths III二维数组中有0，1，2，-1四种格子，要求从1开始走到2，经过所有的0，一共有多少种走法。方法一：回溯法，思路很清晰，很快就写出来了，方向变量写错了调了半天。只需要关注0的个数就行。有优化的地方，因为1和2只有一个，所以可以先遍历一次找出0个个数和1的位置。 123456789101112131415161718192021222324def uniquePathsIII(self, g: List[List[int]]) -&gt; int: M, N = len(g) , len(g[0]) f = sum(g, []) zero = f.count(0) self.ans = 0 def bf(i, j, n): ori = g[i][j] if ori == 2: if n==zero+2: self.ans += 1 return g[i][j] = -1 for x, y in ((i+1, j), (i, j+1), (i-1, j), (i, j-1)): if 0&lt;=x&lt;M and 0&lt;=y&lt;N and g[x][y] in (0, 2): bf(x, y, n+1) g[i][j] = ori for i in range(M): for j in range(N): if g[i][j] == 1: bf(i, j, 1) return self.ans 491. Increasing Subsequences求一个数组的所有的长度2以上的递增子序列。方法一：联系了几道题，求最大长度的是用的dp，不适合这个。这里发现和subsets的组合有点像。于是用了78题中的方法二。因为数组本身最大也就15长度，所以方法并不很耗时。 12345def findSubsequences(self, nums: List[int]) -&gt; List[List[int]]: ans = [[]] for num in nums: ans += [pre+[num] for pre in ans if not pre or pre[-1]&lt;=num] return list(&#123;tuple(a) for a in ans if len(a)&gt;=2&#125;) 方法二：我想用90的方法直接去重，试了一下，发现90题依赖数组有序才能去重，所以这里并不适用。只能最后通过转化tuple，set再去重。效率只有方法一的一半。 12345678910111213141516def findSubsequences(self, nums: List[int]) -&gt; List[List[int]]: def dfs(i, m, p): if not m: ans.append(p[:]) return for j in range(i, n): d = nums[j] if not p or d &gt;= p[-1]: p.append(d) dfs(j+1, m-1, p) p.pop() n, ans = len(nums), [] [dfs(0, i, []) for i in range(2, n+1)] return list(&#123;tuple(a) for a in ans&#125;) 方法三：Stefan的方法，我想的就差了一步，ans可以直接用set。 12345def findSubsequences(self, nums: List[int]) -&gt; List[List[int]]: ans = &#123;()&#125; for num in nums: ans |= &#123;pre+(num, ) for pre in ans if not pre or pre[-1]&lt;=num&#125; return [a for a in ans if len(a)&gt;=2]]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>BackTracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵中单词的路径，很多人都错了]]></title>
    <url>%2F%E7%9F%A9%E9%98%B5%E4%B8%AD%E5%8D%95%E8%AF%8D%E7%9A%84%E8%B7%AF%E5%BE%84%EF%BC%8C%E5%BE%88%E5%A4%9A%E4%BA%BA%E9%83%BD%E9%94%99%E4%BA%86%2F</url>
    <content type="text"><![CDATA[刷过《剑指Offer》的同学，想必都会对这道题有印象，但是如果你之前是在牛客网或者AcWing其他的网站做这道题，那么即便AC通过了所有的测试，你的答案也可能是错误的。我自己之前也是被这个答案误导过，下面我来详细地解释一下自己曾经写过的错误代码，以免以后再次犯同样的错误。 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 LeetCode传送门 牛客网传送门 我从Python的排行榜中复制出来了一个比较“流行”的写法。代码如下，这个代码有两处错误。 12345678910111213141516171819202122def hasPath(self, matrix, rows, cols, path): # write code here for i in range(rows): for j in range(cols): if matrix[i*cols+j]==path[0]: if self.find(list(matrix),rows,cols,path[1:],i,j): return True return Falsedef find(self,matrix,rows,cols,path,i,j): if not path: return True matrix[i*cols+j]='-' if j+1&lt;cols and matrix[i*cols+(j+1)]==path[0]: return self.find(matrix,rows,cols,path[1:],i,j+1) elif j-1&gt;=0 and matrix[i*cols+(j-1)]==path[0]: return self.find(matrix,rows,cols,path[1:],i,j-1) elif i+1&lt;rows and matrix[(i+1)*cols+j]==path[0]: return self.find(matrix,rows,cols,path[1:],i+1,j) elif i-1&gt;=0 and matrix[(i-1)*cols+j]==path[0]: return self.find(matrix,rows,cols,path[1:],i-1,j) else: return False 其中一处错误很明显。在函数find中，他选择了右左下上的顺序，那么如果右边开始匹配，并且右边匹配上了一个字符，那么会继续递归，最后结果如果返回了False，那么接下来的左下上就会被跳过，错误地返回了False。我们来举个栗子🌰。 如果矩阵如上图中那样，并且开始寻找字符转SEE。根据上述算法，当找到S时，先选择往下走，找到了一个E，然后返回了False，忽略了上面的SEE。 于是我将find方法改成了下面这样。 1234567891011121314def find(matrix, rows, cols, path, i, j): if not path: return True matrix[i*cols + j] = '-' up, down, left, right = False, False, False, False if j + 1 &lt; cols and matrix[i * cols + j + 1] == path[0]: down = spread(matrix, rows, cols, path[1:], i, j + 1) if j - 1 &gt;= 0 and matrix[i * cols + j - 1] == path[0]: left = spread(matrix, rows, cols, path[1:], i, j - 1) if i + 1 &lt; rows and matrix[(i + 1) * cols + j] == path[0]: right = spread(matrix, rows, cols, path[1:], i + 1, j) if i - 1 &gt;= 0 and matrix[(i - 1) * cols + j] == path[0]: up = spread(matrix, rows, cols, path[1:], i - 1, j) return up or down or left or right 这之后的很长一段时间，我一直以为这个写法是正确的。直到我在LeetCode上发现这道原题，自信满满地提交自己认为正确的答案，被这个TestCase教做人。我当时提交的完整答案是这样的。这个输入参数有一些不一样的地方，LeetCode输入的是二维数组，牛客是一个字符串，这里写的是LeetCode的写法。这里因为是二维数组，所以要做深拷贝。 1234567891011121314151617181920212223def exist(self, g: List[List[str]], word: str) -&gt; bool: from copy import deepcopy R, C = len(g), len(g[0]) def spread(g, i, j, w): if not w: return True g[i][j] = '-' spreaded = False print('cur -&gt; (&#123;&#125;, &#123;&#125;) &#123;&#125;, &#123;&#125;'.format(i, j, w, g)) for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)): if 0&lt;=x&lt;R and 0&lt;=y&lt;C and w[0]==g[x][y]: if spread(g, x, y, w[1:]): spreaded = True print('spreaded &#123;&#125;, recover (&#123;&#125;, &#123;&#125;), after &#123;&#125;'.format(spreaded, i, j, g)) return spreaded for i in range(R): for j in range(C): if g[i][j] == word[0]: if spread(deepcopy(g), i, j, word[1:]): return True return False 未通过的TestCase为：目标字符串为ABCESEEEFS。 为了方便观察问题，我加了两行输出。 123456789101112131415161718cur -&gt; (0, 0) BCESEEEFS, [[&apos;-&apos;, &apos;B&apos;, &apos;C&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;S&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]cur -&gt; (0, 1) CESEEEFS, [[&apos;-&apos;, &apos;-&apos;, &apos;C&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;S&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]cur -&gt; (0, 2) ESEEEFS, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;S&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]cur -&gt; (1, 2) SEEEFS, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;S&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]cur -&gt; (1, 3) EEEFS, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]cur -&gt; (0, 3) EEFS, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]spreaded False, g [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]cur -&gt; (2, 3) EEFS, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;-&apos;]]cur -&gt; (2, 2) EFS, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;-&apos;, &apos;-&apos;]]spreaded False, g [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;-&apos;, &apos;-&apos;]]spreaded False, g [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;-&apos;, &apos;-&apos;]]spreaded False, g [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;-&apos;, &apos;-&apos;]]spreaded False, g [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;-&apos;, &apos;-&apos;]]spreaded False, g [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;-&apos;, &apos;-&apos;]]spreaded False, g [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;-&apos;, &apos;-&apos;]]spreaded False, g [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;-&apos;, &apos;-&apos;]]cur -&gt; (2, 0) BCESEEEFS, [[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;S&apos;], [&apos;-&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]spreaded False, g [[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;S&apos;], [&apos;-&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]] 这个稍微看一下就明白了，虽然每次匹配第一个字符串A的时候传入了一个新的二维数组，但是在找A之后的路径时，每次返回False的时候没有将-恢复成原来的字母。下面请记住我代码中写的方向顺序为上下左右。 在上面的几步延伸之后，回到了ABC然后右边的字母没有恢复，所以返回了False。于是我们可以先记录一下之前的字母，然后在得到结果后将其恢复。 123456789101112131415161718192021222324def exist(self, g: List[List[str]], word: str) -&gt; bool: from copy import deepcopy R, C = len(g), len(g[0]) def spread(g, i, j, w): if not w: return True original, g[i][j] = g[i][j], '-' spreaded = False print('cur -&gt; (&#123;&#125;, &#123;&#125;) &#123;&#125;, &#123;&#125;'.format(i, j, w, g)) for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)): if 0&lt;=x&lt;R and 0&lt;=y&lt;C and w[0]==g[x][y]: if spread(g, x, y, w[1:]): spreaded = True g[i][j] = original print('spreaded &#123;&#125;, recover (&#123;&#125;, &#123;&#125;), after &#123;&#125;'.format(spreaded, i, j, g)) return spreaded for i in range(R): for j in range(C): if g[i][j] == word[0]: if spread(deepcopy(g), i, j, word[1:]): return True return False 输出为: 12345678910111213141516171819202122232425262728293031323334cur -&gt; (0, 0) BCESEEEFS, [[&apos;-&apos;, &apos;B&apos;, &apos;C&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;S&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]cur -&gt; (0, 1) CESEEEFS, [[&apos;-&apos;, &apos;-&apos;, &apos;C&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;S&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]cur -&gt; (0, 2) ESEEEFS, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;S&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]cur -&gt; (1, 2) SEEEFS, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;S&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]cur -&gt; (1, 3) EEEFS, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]cur -&gt; (0, 3) EEFS, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]spreaded False, recover (0, 3), after [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]cur -&gt; (2, 3) EEFS, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;-&apos;]]cur -&gt; (2, 2) EFS, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;-&apos;, &apos;-&apos;]]spreaded False, recover (2, 2), after [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;-&apos;]]spreaded False, recover (2, 3), after [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]spreaded False, recover (1, 3), after [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;S&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]spreaded False, recover (1, 2), after [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;S&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]cur -&gt; (0, 3) SEEEFS, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;S&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]cur -&gt; (1, 3) EEEFS, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]cur -&gt; (2, 3) EEFS, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;-&apos;]]cur -&gt; (2, 2) EFS, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;-&apos;, &apos;-&apos;]]cur -&gt; (1, 2) FS, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;-&apos;, &apos;-&apos;]]cur -&gt; (1, 1) S, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;-&apos;, &apos;-&apos;]]spreaded True, recover (1, 1), after [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;-&apos;, &apos;-&apos;]]spreaded True, recover (1, 2), after [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;-&apos;, &apos;-&apos;]]spreaded True, recover (2, 2), after [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;-&apos;]]spreaded True, recover (2, 3), after [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]cur -&gt; (1, 2) EEFS, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]cur -&gt; (2, 2) EFS, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;-&apos;, &apos;E&apos;]]cur -&gt; (2, 3) FS, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;-&apos;, &apos;-&apos;]]spreaded False, recover (2, 3), after [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;-&apos;, &apos;E&apos;]]spreaded False, recover (2, 2), after [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]spreaded False, recover (1, 2), after [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]spreaded True, recover (1, 3), after [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;S&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]spreaded True, recover (0, 3), after [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;S&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]spreaded True, recover (0, 2), after [[&apos;-&apos;, &apos;-&apos;, &apos;C&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;S&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]spreaded True, recover (0, 1), after [[&apos;-&apos;, &apos;B&apos;, &apos;C&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;S&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]spreaded True, recover (0, 0), after [[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;S&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]] 这个例子非常复杂也非常棒，由衷感谢提交这个TestCase的人让我意识到自己的愚蠢，此例子一共做了4次尝试，让我们用图解的方式来还原一下。因为是上下左右这个顺序，所以尝试过程如下： 这一次，我们代码可能通过功能测试了，但是想想如果每个匹配第一个字符串都深拷贝一个数组，如果数组特别大，那么将耗费大量时间，其实我们在做好恢复工作后就不需要在拷贝数组了。将其去掉后： 12345678910111213141516171819202122def exist(self, g: List[List[str]], word: str) -&gt; bool: R, C = len(g), len(g[0]) def spread(i, j, w): if not w: return True original, g[i][j] = g[i][j], '-' spreaded = False for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)): if 0&lt;=x&lt;R and 0&lt;=y&lt;C and w[0]==g[x][y]: if spread(x, y, w[1:]): spreaded = True g[i][j] = original return spreaded for i in range(R): for j in range(C): if g[i][j] == word[0]: if spread(i, j, word[1:]): return True return False 自信提交后，又被这样一个TestCase教育了，返回超时。 12[[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a...&quot;baaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; 想了半天终于明白，我在四个方向寻找是否可以延伸时，只要有一个方向可以，那么我就无需再判断其他方向了。 所以这里加一个break即可。 123456789101112131415161718192021def exist(self, g: List[List[str]], word: str) -&gt; bool: R, C = len(g), len(g[0]) def spread(i, j, w): if not w: return True original, g[i][j] = g[i][j], '-' spreaded = False for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)): if (0&lt;=x&lt;R and 0&lt;=y&lt;C and w[0]==g[x][y] and spread(x, y, w[1:])): spreaded = True break g[i][j] = original return spreaded for i in range(R): for j in range(C): if g[i][j] == word[0] and spread(i, j, word[1:]): return True return False 以上就是最终的代码，试了一下LeetCode评论区的高票代码，其中有一个写法，将主循环的g[i][j]==word[0]移到了spread中判断，个人觉得这个是为什么比它快了100ms以上的原因。此文中的最终方法AC188ms，而那个代码需要336ms。 通过一番深入的分析，自己对于回溯有了更深一步的认识，同时也明白了一个深刻的道理，不要轻信他人的代码，包括此文中的也是。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[龟速爬天梯]]></title>
    <url>%2F%E9%BE%9F%E9%80%9F%E7%88%AC%E5%A4%A9%E6%A2%AF%2F</url>
    <content type="text"><![CDATA[好激动，第一次离大神这么近像每个周日一样，9点半起来，然后点了外卖，整理了一下最近的笔记。然后开始等待LeetCode Contest的到来。这周的题确实相对来说比较简单，做着做着发现到了最后一题。然后最后一题也只有Medium难度。感觉还没有Q3难，用了递归就做出来了。 惊奇的发现，居然用了一小时就做完了。以前有时还会卡在第3题，然后看了排行榜，开始还有点担心，Q2是否算作弊，不过后来完成了一看，排行榜前十的大神也是这么写的，而且还没我写的优雅，（虽然用了三方库）。 吃过早饭，然后该review一下题目，优化一下解法并整理到相关博客中。给自己定个小目标，向前200努力。 好气，lee神居然比我先发了答案，我俩的方法是一样的，😦错过了好几个赞。]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法篇目录汇总]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%E7%AF%87%E7%9B%AE%E5%BD%95%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[前言从去年9开始刷算法题，截止到今天，陆续用了大概半年的时间，已经完成《剑指Offer》中的题目，LeetCode中Easy难度的题型也已经基本完成了。由于相关算法博客日益增多，所以建立此目录方便快速查找。另外有一些题型在初期分类不是很合适，所以在完成Easy题之后对所有种类了解的情况下，重新修改一些题的分类。 目录 《剑指Offer》 LeetCode 数组篇 LeetCode 链表篇 LeetCode 二叉树篇 LeetCode 哈希篇 LeetCode 字符串篇 LeetCode 位运算篇 LeetCode 二分法篇 LeetCode 回溯篇 LeetCode 栈篇 LeetCode 数学篇 LeetCode 设计篇 LeetCode 动态规划篇 LeetCode 贪心篇 LeetCode 单词查找树篇 LeetCode 正则篇 LeetCode 图篇 LeetCode sql篇 总结目前收录大概不到300题，但是并没有追求数量，每道题都是先思考用自己的方法做，然后再不断地优化，最后结合Solution和Discuss里大神的写法进行修改。一开始有时候一道题想好几天，后来一天可以完成5，6道题，期间也通过Weekly Contest来测试自己，前几次只能做出一两道题，后来有时候甚至最后一题也差点几步就完成，收货颇丰。刷到差不多后半段的时候，基本上有些题就是换汤不换药，可以用之前的解法做出来，或者是几道题的步骤加起来。 关于分类，因为LeetCode中的分类其实是多对多的关系，这里博客中并不想记录重复的题，所以分类是没有按照LeetCode中来分的，有时候会根据题目分类，有时候会根据答案的最优解分类。答案中标记绿色的部分表示是最优解，但不唯一；极个别用红色标出为错误答案，因为具有强烈的误导性，所以记录下来。 期间在Discuss中单方面结识了两位大神，一位叫Stefan Pochmann，另一位叫lee215。两者都是万星大神，博客中有一些题的最优解都是这两位的答案。前者在小题号时比较活跃，后者在大题号时较活跃，他们俩的答案总是给人眼前一亮的感觉，从中学习到了很多，也能应用到其它一些题上。 关于周赛，周赛的时候感觉又和刷别的题不一样，周赛一般的解法偏向于解答速度，有什么现成的库就直接用，哪个解法最稳用那个，因为Bug会有惩罚时间，排行榜前十的也是这么做的。而平时刷题更倾向于时间复杂度和空间复杂度低，并且写法优雅。 有时候Discuss中也没有自己满意的答案，也会自己冥思苦想想出一个优雅的解法，然后Share给大家，获得几个点赞。这种赞同还有看到Contest上升的排名，都会让自己信心十足，去面对更加艰难的挑战。2019年给自己定了一个小目标，解题达到500+，rating达到1800+，star达到200+。接下来准备重新整理一下目前的题，然后按照类别进行一次解答，疑难题会记录到LeetCode的flashcard中反复训练。不断告诉自己，不要为了刷题而刷题，重要的是思考的过程。然后优化一些还不够优雅的答案，最后迈向Medium难度。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（图篇）Graph]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%9B%BE%E7%AF%87%EF%BC%89Graph%2F</url>
    <content type="text"><![CDATA[990. Satisfiability of Equality Equations满足所有方程式，判断是否存在变量的值满足所有的等式与不等式。原题解析：所有的相等的点，在图中是联通的。 123456789Input: [&quot;a==b&quot;,&quot;b!=a&quot;]Output: falseExplanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second. There is no way to assign the variables to satisfy both equations.Input: [&quot;a==b&quot;,&quot;b==c&quot;,&quot;a==c&quot;]Output: trueInput: [&quot;a==b&quot;,&quot;b!=c&quot;,&quot;c==a&quot;]Output: false 方法一：set. 1234567891011121314151617181920def equationsPossible(self, equations: 'List[str]') -&gt; 'bool': equals = [] equations.sort(key=operator.itemgetter(1), reverse=True) # print(equations) for x, e, _, y in equations: if e == '=': for i, eq in enumerate(equals): if x in eq or y in eq: equals[i].update(&#123;x, y&#125;) break else: equals.append(&#123;x, y&#125;) else: if x == y: return False for eq in equals: if x in eq and y in eq: return False # print(equals) return True 方法二：union find. 并查集。find方法可以想象成一个链表，返回的是链表末尾key,val相等的元素。同时建立连接关系。如a==b, b==c时fc={&#39;a&#39;: &#39;b&#39;, &#39;b&#39;: &#39;c&#39;, &#39;c&#39;: &#39;c&#39;}比较a!=c时就会最终找到fc[&#39;a&#39;] == &#39;c&#39;；如a==b, c==a时，fc={&#39;a&#39;: &#39;b&#39;, &#39;b&#39;: &#39;b&#39;, &#39;c&#39;: &#39;b&#39;}。 12345678910111213141516def equationsPossible(self, equations: 'List[str]') -&gt; 'bool': equations.sort(key=lambda e: e[1] == '!') uf = &#123;a: a for a in string.ascii_lowercase&#125; def find(x): if x != uf[x]: uf[x] = find(uf[x]) return uf[x] for a, e, _, b in equations: if e == "=": uf[find(a)] = find(b) else: if find(a) == find(b): return False return True 997. Find the Town Judge找到小镇审判长。审判长被除自己以外的所有人信任，并且不信任任何人。根据信任列表找出审判长。原题123456Input: N = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]]Output: 3Input: N = 3, trust = [[1,3],[2,3],[3,1]]Output: -1Input: N = 3, trust = [[1,3],[2,3]]Output: 3 方法一：brute force. 123456789101112def findJudge(self, N: int, trust: List[List[int]]) -&gt; int: if not trust: return N a, b = zip(*trust) candidates = collections.Counter(b) villages = set(a) for c, votes in candidates.most_common(): if votes &lt; N - 1: return -1 if c not in villages: return c return -1 方法二：定向图。 12345678910def findJudge(self, N: int, trust: List[List[int]]) -&gt; int: count = [0] * (N + 1) for i, j in trust: count[i] -= 1 count[j] += 1 print(count) for i in range(1, N + 1): if count[i] == N - 1: return i return -1 133. Clone Graph深拷贝一个简单环。原题 1234567891011def cloneGraph(self, node: 'Node') -&gt; 'Node': cp = collections.defaultdict(lambda: Node(0, [])) nodes = [node] seen = set() while nodes: n = nodes.pop() cp[n].val = n.val cp[n].neighbors = [cp[x] for x in n.neighbors] nodes.extend(x for x in n.neighbors if x not in seen) seen.add(n) return cp[node] 1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance找到距离范围内邻居最少的城市。原题 123456789Input: n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4Output: 3Explanation: The figure above describes the graph. The neighboring cities at a distanceThreshold = 4 for each city are:City 0 -&gt; [City 1, City 2] City 1 -&gt; [City 0, City 2, City 3] City 2 -&gt; [City 0, City 1, City 3] City 3 -&gt; [City 1, City 2] Cities 0 and 3 have 2 neighboring cities at a distanceThreshold = 4, but we have to return city 3 since it has the greatest number. 方法一：狄克斯特拉算法。这里没想到用一个堆来维持最小的距离。 123456789101112131415161718192021222324def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -&gt; int: g = collections.defaultdict(list) for u, v, w in edges: g[u].append((v, w)) g[v].append((u, w)) def count_neighbor(city): heap = [(0, city)] dist = &#123;&#125; while heap: cur_w, u = heapq.heappop(heap) if u in dist: continue if u != city: dist[u] = cur_w for v, w in g[u]: if v in dist: continue if cur_w + w &lt;= distanceThreshold: heapq.heappush(heap, (cur_w+w, v)) return len(dist) return min(range(n), key=lambda x: (count_neighbor(x), -x)) 方法二：弗洛伊德算法，这个时间复杂度为O(N^3)，space: O(N^2)但是代码简单。把每个节点当成中转点k，如果dis[i][j] &gt; dis[i][k] + dis[k][j]说明从k走，i, j距离更短。 123456789101112def findTheCity(self, n: int, edges: List[List[int]], maxd: int) -&gt; int: dis = [[float('inf')] * n for _ in range(n)] for i, j, w in edges: dis[i][j] = dis[j][i] = w for i in range(n): dis[i][i] = 0 for k in range(n): for i in range(n): for j in range(n): dis[i][j] = min(dis[i][j], dis[i][k]+dis[k][j]) ans = &#123;sum(d&lt;=maxd for d in dis[i]): i for i in range(n)&#125; # 这里id大的会将小的覆盖 return ans[min(ans)] 1267. Count Servers that Communicate找到2个以上的服务器连接个数，服务器可以在一行或是一列算是连接上。原题123Input: grid = [[1,1,0,0],[0,0,1,0],[0,0,1,0],[0,0,0,1]]Output: 4Explanation: The two servers in the first row can communicate with each other. The two servers in the third column can communicate with each other. The server at right bottom corner can&apos;t communicate with any other server. 方法一：和小岛问题不同，这个服务器可以隔空连接，AC时用的dfs方法，效率非常慢。实际上只需要记录横纵左边即可，遍历两次 12345678910111213def countServers(self, g: List[List[int]]) -&gt; int: X, Y = [0]*300, [0]*300 m, n = len(g), len(g[0]) for i in range(m): for j in range(n): X[i] += g[i][j] Y[j] += g[i][j] ans = 0 for i in range(m): for j in range(n): if g[i][j]==1 and (X[i]&gt;1 or Y[j]&gt;1): ans += 1 return ans 方法二：行列累计求和，但是只是用来判断而不是累加，然后遍历所有的元素。 123def countServers(self, g: List[List[int]]) -&gt; int: X, Y = tuple(map(sum, g)), tuple(map(sum, zip(*g))) return sum(X[i]+Y[j]&gt;2 for i in range(len(g)) for j in range(len(g[0])) if g[i][j]) 886. Possible Bipartition将不喜欢的人放在两组中，根据关系是否能将其分为2组。原题123456Input: N = 4, dislikes = [[1,2],[1,3],[2,4]]Output: trueExplanation: group1 [1,4], group2 [2,3]Input: N = 3, dislikes = [[1,2],[1,3],[2,3]]Output: false 方法一：dfs。此题想了半个多点才想明白，等同于在一个无向图中，寻找一个奇数边的环。 123456789101112131415161718192021222324def possibleBipartition(self, N: int, dislikes: List[List[int]]) -&gt; bool: g = [[] for _ in range(N+1)] for a, b in dislikes: g[a].append(b) g[b].append(a) seen = set() def dfs(i, p, p_len): seen.add(i) p[i] = p_len for nxt in g[i]: if nxt not in seen: if dfs(nxt, p, p_len+1): return True elif nxt in p and (p_len-p[nxt])&amp;1==0: return True p.pop(i) return False p = &#123;&#125; for i in range(1, N+1): if i not in seen and dfs(i, p, 0): return False return True 方法二：染色思想。0代表红色，1代表蓝色，每次将其不喜欢的人染成另一种颜色。这个代码比较简洁，不过稍微慢了一丢丢，50ms左右。 123456789101112131415def possibleBipartition(self, N: int, dislikes: List[List[int]]) -&gt; bool: g = [[] for _ in range(N+1)] for a, b in dislikes: g[a].append(b) g[b].append(a) color = &#123;&#125; def dfs(i, c=0): if i in color: return color[i]==c color[i] = c return all(dfs(j, c^1) for j in g[i]) return all(dfs(i) for i in range(1, N+1) if i not in color) 207. Course Schedule课程调度，课程有依赖关系，问是否能完成所有的课程。原题1234Input: numCourses = 2, prerequisites = [[1,0]]Output: trueExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible. 方法一：dfs。注意这里状态要用3中，1表示遍历过，-1表示正在遍历，0表未遍历。这样可以避免重复的遍历。 12345678910111213def canFinish(self, n: int, prerequisites: List[List[int]]) -&gt; bool: g = [[] for _ in range(n)] for a, b in prerequisites: g[a].append(b) seen = [0] * n def dfs(i): if seen[i] in &#123;1, -1&#125;: return seen[i]==1 seen[i] = -1 if any(not dfs(j) for j in g[i]): return False seen[i] = 1 return True 方法二：这个方法优雅一点，来自Lee215. BFS Topological Sorting. 12345678910111213def canFinish(self, n: int, prerequisites: List[List[int]]) -&gt; bool: g = collections.defaultdict(list) degree = [0] * n for u, v in prerequisites: g[v].append(u) degree[u] -= 1 bfs = [i for i in range(n) if degree[i]==0] for i in bfs: for j in g[i]: degree[j] += 1 if degree[j] == 0: bfs.append(j) return len(bfs)==n 1462. Course Schedule IV和上题差不多，问题不一样，问的是根据给定的依赖关系，判断两节课是否有依赖。原题方法一：dfs. 这个方法想了超出比赛时间限制了。但是也没过多久就优化 出来了。 1234567891011121314151617def checkIfPrerequisite(self, n: int, prerequisites: List[List[int]], queries: List[List[int]]) -&gt; List[bool]: g = [[] for _ in range(n)] q = [set() for _ in range(n)] for u, v in prerequisites: g[u].append(v) def dfs(i): if q[i]: return q[i] q[i].update(g[i]) for j in g[i]: q[i].update(dfs(j)) return q[i] for i in range(n): dfs(i) return [b in q[a] for a, b in queries] 方法二：弗洛伊德算法，和求城市最小距离一样。时间复杂度是O(n3) 12345678910def checkIfPrerequisite(self, n: int, prerequisites: List[List[int]], queries: List[List[int]]) -&gt; List[bool]: g = [[False]*n for _ in range(n)] for u, v in prerequisites: g[u][v] = True for k in range(n): for i in range(n): for j in range(n): g[i][j] = g[i][j] or (g[i][k] and g[k][j]) return [g[i][j] for i, j in queries] 方法三：bfs. 拓扑排序。 12345678910111213141516def checkIfPrerequisite(self, n: int, prerequisites: List[List[int]], queries: List[List[int]]) -&gt; List[bool]: g = collections.defaultdict(list) degree = [0] * n pres = [set() for _ in range(n)] for u, v in prerequisites: g[u].append(v) degree[v] -= 1 pres[v].add(u) bfs = [i for i in range(n) if degree[i]==0] for i in bfs: for j in g[i]: degree[j] += 1 pres[j] |= pres[i] if degree[j] == 0: bfs.append(j) return [a in pres[b] for a, b in queries] 1466. Reorder Routes to Make All Paths Lead to the City Zero有一个有向图，两个节点之间只有一条边，要求所有的边指向0，需要改多少条边的方向。原题123Input: n = 6, connections = [[0,1],[1,3],[2,3],[4,0],[4,5]]Output: 3Explanation: Change the direction of edges show in red such that each node can reach the node 0 (capital). 方法一：此题竞赛时未作出。一个效率不是很高的方法。用父节点去重。set记录原始顺序，遍历无向图。 123456789101112131415161718def minReorder(self, n: int, connections: List[List[int]]) -&gt; int: self.ans = 0 g = collections.defaultdict(list) roads = set() for u, v in connections: g[u].append(v) g[v].append(u) roads.add((u, v)) def dfs(i, parent): self.ans += (parent, i) in roads for j in g[i]: if j == parent: continue dfs(j, i) dfs(0, -1) return self.ans 方法二：比赛时想的思路，dfs内容未想出来。 123456789101112131415161718192021def minReorder(self, n: int, connections: List[List[int]]) -&gt; int: g1 = collections.defaultdict(list) g2 = collections.defaultdict(list) for u, v in connections: g1[u].append(v) g2[v].append(u) seen = set() def dfs(i): seen.add(i) ans = 0 for j in g1[i]: if j not in seen: ans += 1 + dfs(j) for k in g2[i]: if k not in seen: ans += dfs(k) return ans return dfs(0) 1210. Minimum Moves to Reach Target with Rotations一个占位2格的蛇，从左上走到右下需要最少的步数，可以旋转。原题123456789Input: grid = [[0,0,0,0,0,1], [1,1,0,0,1,0], [0,0,0,0,1,1], [0,0,1,0,1,0], [0,1,1,0,0,0], [0,1,1,0,0,0]]Output: 11Explanation:One possible solution is [right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise, right, down]. 方法一：这题没想到在写完还有10分钟，其实思路很简单，就是拿两个点当成一个点。一个点的bfs就很容易了。 123456789101112131415161718192021222324252627282930313233343536def minimumMoves(self, g: List[List[int]]) -&gt; int: n = len(g) q = collections.deque([((0, 0), (0, 1), 0)]) seen = set(((0, 0), (0, 1))) while q: tail, head, step = q.popleft() if tail[0] == head[0] == head[1] == n-1 and tail[1]==n-2: return step if tail[0] == head[0] and tail[0]!=n-1: # horizontal d_tail, d_head = (tail[0]+1, tail[1]), (head[0]+1, head[1]) if g[d_tail[0]][d_tail[1]] == g[d_head[0]][d_head[1]] == 0: if (tail, d_tail) not in seen: q.append((tail, d_tail, step+1)) seen.add((tail, d_tail)) if tail[1] == head[1] and tail[1]!=n-1: # vertical r_tail, r_head = (tail[0], tail[1]+1), (head[0], head[1]+1) if g[r_tail[0]][r_tail[1]] == g[r_head[0]][r_head[1]] == 0: if (tail, r_tail) not in seen: q.append((tail, r_tail, step+1)) seen.add((tail, r_tail)) if head[1] != n-1: r_head = head[0], head[1]+1 r_tail = tail[0], tail[1]+1 if g[r_head[0]][r_head[1]] == g[r_tail[0]][r_tail[1]] == 0: if (r_tail, r_head) not in seen: q.append((r_tail, r_head, step+1)) seen.add((r_tail, r_head)) if head[0] != n-1: d_head = head[0]+1, head[1] d_tail = tail[0]+1, tail[1] if g[d_head[0]][d_head[1]] == g[d_tail[0]][d_tail[1]] == 0: if (d_tail, d_head) not in seen: q.append((d_tail, d_head, step+1)) seen.add((d_tail, d_head)) return -1 方法二：另一种思路将蛇的横竖状态记录，这样一个点也能表示。 123456789101112131415161718def minimumMoves(self, g: List[List[int]]) -&gt; int: n = len(g) q, seen, target = [(0, 0, 0, 0)], set(), (n-1, n-2, 0) for r, c, dr, step in q: if (r, c, dr) == target: return step if (r, c, dr) not in seen: seen.add((r, c, dr)) if dr: if c+1&lt;n and g[r][c+1]==g[r+1][c+1]==0: q += [(r, c+1, 1, step+1), (r, c, 0, step+1)] if r+2&lt;n and g[r+2][c]==0: q += [(r+1, c, 1, step+1)] else: if r+1&lt;n and g[r+1][c]==g[r+1][c+1]==0: q += [(r+1, c, 0, step+1), (r, c, 1, step+1)] if c+2&lt;n and g[r][c+2]==0: q += [(r, c+1, 0, step+1)] return -1 1202. Smallest String With Swaps给定一组pairs表明索引对可以互换，求这个字符串能换的最小值时多少，同一对可以进行多次互换。原题12345Input: s = &quot;dcab&quot;, pairs = [[0,3],[1,2]]Output: &quot;bacd&quot;Explaination: Swap s[0] and s[3], s = &quot;bcad&quot;Swap s[1] and s[2], s = &quot;bacd&quot; 方法一：看了几个例子想一想就明白了，实际上是一道连通器的题，将连通的索引单独排序就是最小的值。 竞赛时ac的方法用的是dfs. 内存用的有点多。 1234567891011121314151617181920212223242526def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -&gt; str: g = [[] for _ in range(len(s))] ans = [''] * len(s) for a, b in pairs: g[a].append(b) g[b].append(a) seen = [False] * len(s) def dfs(i, p): if not seen[i]: seen[i] = True p.append(i) for j in g[i]: dfs(j, p) return p groups = [] for i in range(len(s)): tmp = dfs(i, []) if tmp: groups.append(tmp) for idx in groups: letters = iter(sorted(s[i] for i in idx)) for i in sorted(idx): ans[i] = next(letters) return ''.join(ans) 方法二：做了一点优化。 1234567891011121314151617181920212223def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -&gt; str: g = [[] for _ in range(len(s))] ans = [''] * len(s) for a, b in pairs: g[a].append(b) g[b].append(a) seen = [False] * len(s) def dfs(i): seen[i] = True p.append(i) for j in g[i]: if not seen[j]: dfs(j) for i in range(len(s)): p = [] if not seen[i]: dfs(i) letters = iter(sorted(s[i] for i in p)) for i in sorted(p): ans[i] = next(letters) return ''.join(ans) 方法三：union-find。这个评论区里看到的方法写得很标准。 1234567891011121314151617181920def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -&gt; str: class UF: def __init__(self, n): self.p = list(range(n)) def union(self, x, y): self.p[self.find(x)] = self.find(y) def find(self, x): if x!=self.p[x]: self.p[x] = self.find(self.p[x]) return self.p[x] uf, res, m = UF(len(s)), [], defaultdict(list) for x, y in pairs: uf.union(x, y) for i in range(len(s)): m[uf.find(i)].append(s[i]) for comp_id in m.keys(): m[comp_id].sort(reverse=True) for i in range(len(s)): res.append(m[uf.find(i)].pop()) return ''.join(res) 787. Cheapest Flights Within K Stops经过K个站点的最便宜的航班。原题方法一：狄克斯特拉算法，只不过多了一个条件，经过K个站点。不需要用seen记录已经去过的点，因为该点可能有更少步数的到达方式。 123456789101112131415def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -&gt; int: g = collections.defaultdict(list) for u, v, w in flights: g[u].append((v, w)) q = [(0, src, 0)] heapq.heapify(q) while q: p, city, step = heapq.heappop(q) if city == dst: return p for v, w in g[city]: if step &lt; K+1: heapq.heappush(q, (p+w, v, step+1)) return -1 332. Reconstruct Itinerary重建行程，根据火车票来寻找行程，答案不唯一。原题12Input: [[&quot;MUC&quot;, &quot;LHR&quot;], [&quot;JFK&quot;, &quot;MUC&quot;], [&quot;SFO&quot;, &quot;SJC&quot;], [&quot;LHR&quot;, &quot;SFO&quot;]]Output: [&quot;JFK&quot;, &quot;MUC&quot;, &quot;LHR&quot;, &quot;SFO&quot;, &quot;SJC&quot;] 方法一：首次ac的方法，直接修改g。 123456789101112131415161718192021222324def findItinerary(self, tickets: List[List[str]]) -&gt; List[str]: g = collections.defaultdict(list) for u, v in tickets: g[u].append(v) for u in g.keys(): g[u].sort() def dfs(city, p): # print(city, p, g) p.append(city) if not g: return p org = g[city] for i, nxt in enumerate(g[city]): g[city] = g[city][:i] + g[city][i+1:] if not g[city]: del g[city] if dfs(nxt, p): return p g[city] = org if not org: del g[city] p.pop() return dfs('JFK', []) 方法二：用两个倒序可以解决 12345678910111213def findItinerary(self, tickets: List[List[str]]) -&gt; List[str]: g = collections.defaultdict(list) for u, v in sorted(tickets, reverse=True): g[u].append(v) ans = [] def dfs(city): while g[city]: dfs(g[city].pop()) ans.append(city) dfs('JFK') return ans[::-1] 1519. Number of Nodes in the Sub-Tree With the Same Label有一个数的图，每个节点有个字母，返回每个节点的子树中包含这个字母的总个数。原题方法一：这个题作为竞赛的第二题是在是太恶心了，结束后我想了很长时间才想出来。dfs + counter, 每个节点都有它独立的一个counter。 因为字母不同、 12345678910111213141516171819202122def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -&gt; List[int]: g = collections.defaultdict(list) for u, v in edges: g[u].append(v) g[v].append(u) seen = [False] * n c = Counter() def dfs(node): cur = Counter() seen[node] = True for nxt in g[node]: if not seen[nxt]: cur += dfs(nxt) label = labels[node] cur[label] += 1 ans[node] = cur[label] return cur ans = [0] * n dfs(0) return ans 方法二：优化方法一 1234567891011121314151617def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -&gt; List[int]: g = collections.defaultdict(list) for u, v in edges: g[u].append(v) g[v].append(u) def dfs(node, p): cur = Counter(labels[node]) for nxt in g[node]: if nxt != p: cur += dfs(nxt, node) ans[node] = cur[labels[node]] return cur ans = [0] * n dfs(0, -1) return ans 478. Generate Random Point in a Circle在给定圆的范围内随机生成点。原题方法一：严格来说 这是一道几何题，为什么要将其开方，因为如果没有开方，对于一个圆来说，半径越小的地方点就越密集，因为在该周长上所有的点分布是一样的。开方可以让半径小的点降低分布。 1234567891011121314class Solution: def __init__(self, radius: float, x_center: float, y_center: float): self.r = radius self.x = x_center self.y = y_center def randPoint(self) -&gt; List[float]: import random edge = math.sqrt(random.random()) * self.r deg = random.random()*2*math.pi x = self.x + edge*math.cos(deg) y = self.y + edge*math.sin(deg) return x, y 1559. Detect Cycles in 2D Grid2D 矩阵中判断是否有环。原题方法一：这个题就差一点没想出来，就是怎么避免重复的路径，那就是需要和前一个点比对。看了这个提示后瞬间就完成了。时间空间待优化。 1234567891011121314151617181920def containsCycle(self, g: List[List[str]]) -&gt; bool: m, n = len(g), len(g[0]) visited = [[False] * n for _ in range(m)] def spread(x, y, c, a, b): if visited[x][y]: return True visited[x][y] = True for i, j in ((x-1, y), (x+1, y), (x, y-1), (x, y+1)): if 0&lt;=i&lt;m and 0&lt;=j&lt;n and c==g[i][j] and (i, j)!=(a, b): if spread(i, j, c, x, y): return True return False for i in range(m): for j in range(n): if not visited[i][j] and spread(i, j, g[i][j], i, j): return True return False 310. Minimum Height Trees有一个无向图，0~n-1这些节点，每两个节点只有一条边，找出这种节点，当以节点为根时，组成的树有最小的高度。原题1234567891011Input: n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]] 0 1 2 \ | / 3 | 4 | 5 Output: [3, 4] 方法一：这个解法很棒，评论区的解法，以前看这种题的时候，想到的是bfs，这个解法的核心思想是剪枝。每次将叶子节点剪去。最后剩下的 一个或者2个节点 就是最小高度的根节点。 1234567891011121314151617def findMinHeightTrees(self, n: int, edges: List[List[int]]) -&gt; List[int]: if n == 1: return [0] g = collections.defaultdict(set) for u, v in edges: g[u].add(v) g[v].add(u) leaves = [i for i in range(n) if len(g[i])==1] while n &gt; 2: n -= len(leaves) new_leaves = [] for i in leaves: j = g[i].pop() g[j].remove(i) if len(g[j])==1: new_leaves.append(j) leaves = new_leaves return leaves 127. Word Ladder每次可以改变单词中的一个字母，但必须在wordList中，问最少需要多少次能达到目标单词。原题123456789Input:beginWord = &quot;hit&quot;,endWord = &quot;cog&quot;,wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]Output: 5Explanation: As one shortest transformation is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,return its length 5. 方法一：BFS很好想，但是要想如何去重，wordList可能非常大，所以不能遍历，因为只有26个字母可以变，所以可以变换完比较。 12345678910111213def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -&gt; int: q = [(beginWord, 1)] words_set = set(wordList) letters = string.ascii_lowercase for w, step in q: if w == endWord: return step for i in range(len(w)): for c in letters: nw = w[:i] + c + w[i+1:] if nw in words_set: q.append((nw, step+1)) words_set.remove(nw) return 0 547. Friend Circles朋友圈，一堆人拉帮结伙，朋友关系可以传递。通过二维数组表示i, j两个人是否是朋友。问N个人有多少个帮派。原题1234567Input: [[1,1,0], [1,1,0], [0,0,1]]Output: 2Explanation:The 0th and 1st students are direct friends, so they are in a friend circle. The 2nd student himself is in a friend circle. So return 2. 方法一：典型的Union-Find。最后结果还要遍历一下，才是最终结果。[[1,0,0,1],[0,1,1,0],[0,1,1,1],[1,0,1,1]]这个case在union之后，是[3,2,3,3]因为2的朋友在1计算之后变成了3。最终点更新了。所以遍历之后是[3,3,3,3] 123456789101112131415161718def findCircleNum(self, M: List[List[int]]) -&gt; int: def union(x, y): uf[find(x)] = find(y) def find(x): if x != uf[x]: uf[x] = find(uf[x]) return uf[x] N = len(M) uf = list(range(N)) for i in range(N): for j in range(N): if M[i][j]: union(i, j) return len(&#123;find(i) for i in range(N)&#125;) 方法二：评论中有个dfs 也不错，行列循环分开了。 12345678910111213141516def findCircleNum(self, M: List[List[int]]) -&gt; int: ans, N = 0, len(M) seen = set() def dfs(i): for j, r in enumerate(M[i]): if r and j not in seen: seen.add(j) dfs(j) for i in range(N): if i not in seen: ans += 1 dfs(i) return ans 方法三：stefan的科学库和numpy写法。 1234567891011import scipy.sparseclass Solution(object): def findCircleNum(self, M): return scipy.sparse.csgraph.connected_components(M)[0] import numpy as npclass Solution(object): def findCircleNum(self, M): return len(set(map(tuple, (np.matrix(M, dtype='bool')**len(M)).A))) 1584. Min Cost to Connect All Points所有点最小的曼哈顿距离|xi - xj| + |yi - yj|和为多少。原题方法一：贪心法。这题有很多方法，然而比赛时一种也没写出来。首先贪心可以，由于是n^2的复杂度，所以没有敢写。 毕竟n=1000。评论区的做法，为什么贪心可行，想象一下，最后所有的点相连，每2点只有一条边，而且是最小的边。 1234567891011121314151617def minCostConnectPoints(self, points: List[List[int]]) -&gt; int: n, ans = len(points), 0 seen = set() dis = [float('inf')] * n cur = 0 # n-1 edges for i in range(n-1): x, y = points[cur] seen.add(cur) for j, (nx, ny) in enumerate(points): if j in seen: continue dis[j] = min(dis[j], abs(nx-x)+abs(ny-y)) s, cur = min((d, j) for j, d in enumerate(dis)) dis[cur] = float('inf') ans += s return ans 方法二：最小生成树。这是经典的最小生成树问题，有两种实现的方式，一种是Prim算法。一种是Kruskal算法。比贪心法慢了400ms，花费1580ms，还以为是我实现的问题，结果看评论区中的要2s多。空间则是贪心的5倍多。因为此题需要找到各个边的权重，所以即使是Prim算法，时间复杂度也是O(n^2)。Prim算法是每次以新的顶点找到最小的权重边。 1234567891011121314151617181920def minCostConnectPoints(self, p: List[List[int]]) -&gt; int: def manhattan(x, y): return abs(x[0]-y[0]) + abs(x[1]-y[1]) ans, n = 0, len(p) seen = set() vertices = [(0, (0, 0))] while len(seen) &lt; n: # print(vertices, seen) w, (u, v) = heapq.heappop(vertices) if v in seen: continue ans += w seen.add(v) for j in range(n): if j not in seen and j!=v: heapq.heappush(vertices, (manhattan(p[j], p[v]), (v, j))) return ans 方法三：Kruskal，克鲁斯卡尔算法。原理是Union-Find。按照所有的权重看，每次产生一条边，但不一定和已有的边构成环。理论上来说比Prim算法要慢。实际运行却比prim快了1、200ms。 1234567891011121314151617181920212223242526def minCostConnectPoints(self, p: List[List[int]]) -&gt; int: edges, n, cnt, ans = [], len(p), 1, 0 def manhattan(x, y): return abs(p[x][0]-p[y][0]) + abs(p[x][1]-p[y][1]) edges = [(manhattan(i, j), (i, j)) for i in range(n) for j in range(i+1, n)] heapq.heapify(edges) def union(x, y): uf[find(x)] = find(y) def find(x): if x != uf[x]: uf[x] = find(uf[x]) return uf[x] uf = list(range(n)) while cnt &lt; n: d, (u, v) = heapq.heappop(edges) if find(u) != find(v): ans += d cnt += 1 union(u, v) return ans 684. Redundant Connection多余的边，有一个无向图有N个节点，和N个边，对于一个连通器来说，刚好多了一条边。找到这条多余的边，所有的边给的[u, v]均满足u&lt;v。原题123456Input: [[1,2], [1,3], [2,3]]Output: [2,3]Explanation: The given undirected graph will be like this: 1 / \2 - 3 方法一：使用传统的Union-Find。 12345678910111213141516def findRedundantConnection(self, edges: List[List[int]]) -&gt; List[int]: def union(x, y): uf[find(x)] = find(y) def find(x): if x != uf[x]: uf[x] = find(uf[x]) return uf[x] n = len(edges) uf = list(range(n+1)) for u, v in edges: if find(u)==find(v): return u, v union(u, v) 方法二：stefan. 考虑没用上的条件 u&lt;v。 可以利用字符串的replace。将所有出现的点，替换成最大的。 123456def findRedundantConnection(self, edges: List[List[int]]) -&gt; List[int]: tree = ''.join(map(chr, range(1001))) for u, v in edges: if tree[u] == tree[v]: return u, v tree = tree.replace(tree[u], tree[v]) 685. Redundant Connection II同684一样，区别在于有向图，也是多出一条边，但这条边是最后一条无用的边。也就是说。删除这条边后，还是一个N个节点的有向图。并且图中只能有一个根节点。方法一：花了不到2小时做出来，感觉方法很笨。因为有这样的例子，[[2,1],[3,1],[4,2],[1,4]]这时不能删除[1,4]，而是要删除[2,1]因为4和3会成为2个根节点。如果我们找到了一个点有两个父节点，那么删除的一定是这两条边中的一条。所以此时我没有将其加入到联通图中；另一种情况，没有两个父节点的点时，就像684一样判断是否联通就好了，最后判断，如果所有节点都联通了，我删除第2次遇见的相同父节点的边就行了，如果没有，那么应该删除第一次的边，这里用了一个pare来记录关系。 123456789101112131415161718192021def findRedundantDirectedConnection(self, edges: List[List[int]]) -&gt; List[int]: def union(x, y): uf[find(x)] = find(y) def find(x): if x != uf[x]: uf[x] = find(uf[x]) return uf[x] ans, N, pare = None, len(edges), &#123;&#125; uf = list(range(N+1)) for u, v in edges: if v in pare: ans = (u, v) continue if find(u)==find(v) and not ans: ans = (u, v) union(u, v) pare[v] = u return ans if len(set(map(find, range(1, N+1))))==1 else (pare[ans[1]], ans[1]) 743. Network Delay Time网络延迟，有N个网络节点，给出一个加权有向图，问从K点出发，遍历所有点需要多少时间，如果不可能返回-1。原题12Input: times = [[2,1,1],[2,3,1],[3,4,1]], N = 4, K = 2Output: 2 方法一：bfs。首次AC，960ms。效率不算很高吧，因为可能遍历到重复的节点更新值。 12345678910111213def networkDelayTime(self, times, N, K): seen, ans = &#123;&#125;, 0 g = collections.defaultdict(list) for u, v , w in times: g[u].append((v, w)) q = collections.deque([(K, 0)]) while q: u, t = q.popleft() seen[u] = min(seen.get(u, float('inf')), t) for v, nt in g[u]: if v not in seen or seen[v]&gt;nt+t: q.append((v, t+nt)) return max(seen.values()) if len(seen)==N else -1 方法二：堆实现了一个优先级队列，500ms左右。 1234567891011121314def networkDelayTime(self, times, N, K): seen, t = set(), 0 g = collections.defaultdict(list) for u, v , w in times: g[u].append((v, w)) heap = [(0, K)] while heap: t, u = heapq.heappop(heap) if u in seen: continue seen.add(u) if len(seen) == N: break for v, nt in g[u]: heapq.heappush(heap, (t+nt, v)) return t if len(seen)==N else -1 721. Accounts Merge账号合并，一个人可能有多个账号，将具有相同账号的人合并到一起，返回所有的用户的所有的账号方法一：做的时候想到了union-find，不过以开始的思路用集合暴力也解出来了。只要有一个账号相同，就是一个人。 12345678910111213141516def accountsMerge(self, accounts: List[List[str]]) -&gt; List[List[str]]: users = collections.defaultdict(list) for name, *mails in accounts: old_mails = users[name] mails = set(mails) to_rm = [] n = len(old_mails) j = n - 1 while j &gt;= 0: if old_mails[j] &amp; mails: mails |= old_mails[j] old_mails.pop(j) j -= 1 old_mails.append(mails) return [[name] + sorted(act_lst) for name, acts in users.items() for act_lst in acts] 方法二：dfs，需要遍历两次。先记录一下每个邮箱出现的索引， 12345678910111213141516171819202122def accountsMerge(self, accounts: List[List[str]]) -&gt; List[List[str]]: mail_occurs = collections.defaultdict(list) ans = [] for i, (_, *mails) in enumerate(accounts): for mail in mails: mail_occurs[mail].append(i) visited = [False] * len(accounts) def dfs(i, mails): if visited[i]: return visited[i] = True for other in accounts[i][1:]: mails.add(other) for j in mail_occurs[other]: dfs(j, mails) for i, (name, *mails) in enumerate(accounts): if visited[i]: continue acts = set() dfs(i, acts) ans.append([name] + sorted(acts)) return ans 方法三：Union-FInd，这里要选出一个标准，不如每个首个出现的账号，将其它账号连到这个账号上。第二步需要遍历一遍，把相同的账号放到一个列表中，遍历过程中记录账号对应的姓名，方便我们构建最终的答案。 12345678910111213141516171819202122232425def accountsMerge(self, accounts: List[List[str]]) -&gt; List[List[str]]: uf = &#123;&#125; mail_to_name = &#123;&#125; def union(x, y): uf.setdefault(x, x) uf.setdefault(y, y) uf[find(x)] = find(y) def find(x): if x != uf[x]: uf[x] = find(uf[x]) return uf[x] for name, *mails in accounts: first = mails[0] for mail in mails: union(mail, first) mail_to_name[mail] = name g = collections.defaultdict(list) for mail in uf.keys(): g[find(mail)].append(mail) return [[mail_to_name[first]] + sorted(mails) for first, mails in g.items()] 851. Loud and Rich啰里啰嗦一大堆，就是找到比当前人有钱的所有人中最低调的一个，quiet值最小，quiet没有重复值。1234567Input: richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]Output: [5,5,2,5,4,5,6,7]Explanation: answer[0] = 5.Person 5 has more money than 3, which has more money than 1, which has more money than 0.The only person who is quieter (has lower quiet[x]) is person 7, butit isn&apos;t clear if they have more money than person 0. 方法一：dfs. 首次AC，算比较简单。 123456789101112131415def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -&gt; List[int]: N = len(quiet) rich = collections.defaultdict(list) for a, b in richer: rich[b].append(a) q_to_p = &#123;q: i for i, q in enumerate(quiet)&#125; @lru_cache(None) def dfs(i): q = quiet[i] for j in rich[i]: q = min(q, dfs(j)) return q return [q_to_p[dfs(i)] for i in range(N)] 方法二：Lee的方法，比方法一节省一些空间。 123456789101112131415161718def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -&gt; List[int]: N = len(quiet) rich = collections.defaultdict(list) for a, b in richer: rich[b].append(a) ans = [-1] * N def dfs(i): if ans[i] &gt;= 0: return ans[i] ans[i] = i for j in rich[i]: if quiet[dfs(j)] &lt; quiet[ans[i]]: ans[i] = dfs(j) return ans[i] for i in range(N): dfs(i) return ans]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（哈希篇）hashtable]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%93%88%E5%B8%8C%E7%AF%87%EF%BC%89hashtable%2F</url>
    <content type="text"><![CDATA[1. Two Sum给定一个数组，找出数组两个元素相加为目标值，假定只有唯一解。原题123Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 1234567def two_sum(nums, target): buff_dict = &#123;&#125; for i, num in enumerate(nums): if num not in buff_dict: buff_dict[target-num] = i else: return [buff_dict[num], i] 720. Longest Word in Dictionary字典中的最长单词，找出一个列表中的一个单词，该单词的子单词也必须在字典中。相同长度的单词，返回字典序最前的一个。原题12345Input: words = [&quot;w&quot;,&quot;wo&quot;,&quot;wor&quot;,&quot;worl&quot;, &quot;world&quot;]Output: &quot;world&quot;Explanation: The word &quot;world&quot; can be built one character at a time by &quot;w&quot;, &quot;wo&quot;, &quot;wor&quot;, and &quot;worl&quot;. 方法一：Brute Force. 12345678def longestWord(self, words): res = '' wordset = set(words) for word in words: if len(word)&gt;len(res) or len(word)==len(res) and word&lt;res: if all(word[:k] in wordset for k in range(1, len(word))): res = word return res 方法二：trie. 暂且留坑。 748. Shortest Completing Word最短的完整匹配单词。包含licensePlate中的所有字母，大小写不敏感。假设答案一定存在。原题12345Input: licensePlate = &quot;1s3 PSt&quot;, words = [&quot;step&quot;, &quot;steps&quot;, &quot;stripe&quot;, &quot;stepple&quot;]Output: &quot;steps&quot;Explanation: The smallest length word that contains the letters &quot;S&quot;, &quot;P&quot;, &quot;S&quot;, and &quot;T&quot;.Note that the answer is not &quot;step&quot;, because the letter &quot;s&quot; must occur in the word twice.Also note that we ignored case for the purposes of comparing whether a letter exists in the word. 方法一：先排序。 123456789def shortestCompletingWord(self, licensePlate: 'str', words: 'List[str]') -&gt; 'str': lp = ''.join(x for x in licensePlate.lower() if x.isalpha()) c1 = collections.Counter(lp) words.sort(key=len) words = map(str.lower, words) for word in words: diff = c1 - collections.Counter(word) if not diff: return word 方法二：more elegant. 123456def shortestCompletingWord(self, licensePlate: 'str', words: 'List[str]') -&gt; 'str': lp = ''.join(x for x in licensePlate.lower() if x.isalpha()) c1 = collections.Counter(lp) words = map(str.lower, words) return min((word for word in words if not c1-collections.Counter(word)), key=len) 方法三：most efficient. 认为方法二是在计算-的操作时，涉及一些无关的key导致效率过低。 1234567891011121314def shortestCompletingWord(self, licensePlate: 'str', words: 'List[str]') -&gt; 'str': ans = '' lp = ''.join(x for x in licensePlate.lower() if x.isalpha()) for w in words: temp = list(w.lower()) for l in lp: if l in temp: temp.remove(l) else: break else: if len(w)&lt;len(ans) or ans=='': ans = w return ans 811. Subdomain Visit Count子域名访问量。给定一个三级或二级域名列表，统计所有三级、二级和顶级域名的访问量。原题1234567Example 1:Input: [&quot;9001 discuss.leetcode.com&quot;]Output: [&quot;9001 discuss.leetcode.com&quot;, &quot;9001 leetcode.com&quot;, &quot;9001 com&quot;]Explanation: We only have one website domain: &quot;discuss.leetcode.com&quot;. As discussed above, the subdomain &quot;leetcode.com&quot; and &quot;com&quot; will also be visited. So they will all be visited 9001 times. 方法一：Solution中用了Counter，个人认为defaultdict. 123456789def subdomainVisits(self, cpdomains: 'List[str]') -&gt; 'List[str]': ans = collections.defaultdict(int) for domain in cpdomains: count, d = domain.split() count = int(count) frags = d.split('.') for i in range(len(frags)): ans['.'.join(frags[i:])] += count return ['&#123;&#125; &#123;&#125;'.format(c, d) for d, c in ans.items()] 884. Uncommon Words from Two Sentences求两句话中的单词，在本句中出现一次，并不在另一句中的单词。也就是在两句中出现一次。原题12Input: A = &quot;this apple is sweet&quot;, B = &quot;this apple is sour&quot;Output: [&quot;sweet&quot;,&quot;sour&quot;] 方法一：Counter 1234def uncommonFromSentences(self, A: 'str', B: 'str') -&gt; 'List[str]': from collections import Counter count = Counter((A + ' ' + B).split()) return [word for word, c in count.items() if c == 1] 1010. Pairs of Songs With Total Durations Divisible by 60和能被60整除的为一对，求有多少对。原题123456Input: [30,20,150,100,40]Output: 3Explanation: Three pairs have a total duration divisible by 60:(time[0] = 30, time[2] = 150): total duration 180(time[1] = 20, time[3] = 100): total duration 120(time[1] = 20, time[4] = 40): total duration 60 12345678def numPairsDivisibleBy60(self, time: List[int]) -&gt; int: c = collections.defaultdict(int) ans = 0 for t in time: # ans += c[(60-t%60)%60] ans += c[-t % 60] c[t%60] += 1 return ans 1138. Alphabet Board Path小写字母排列的键盘，要打出目标字母需要移动的操作。原题12Input: target = &quot;leet&quot;Output: &quot;DDR!UURRR!!DDD!&quot; 方法一：此题需要注意z，然后按照一个优先的顺序移动即可。另外使用字典可以快速定位坐标，而不用每个字符做比较 1234567891011121314def alphabetBoardPath(self, target: str) -&gt; str: import string m = &#123;c: (i//5, i%5) for i, c in enumerate(string.ascii_lowercase)&#125; ans = '' x0 = y0 = 0 for c in target: x, y = m[c] if y &lt; y0: ans += 'L' * (y0-y) if x &lt; x0: ans += 'U' * (x0-x) if y &gt; y0: ans += 'R' * (y-y0) if x &gt; x0: ans += 'D' * (x-x0) x0, y0 = x, y ans += '!' return ans 1072. Flip Columns For Maximum Number of Equal Rows二维数组，翻转某几列可以最多使多少行内的元素都相同。原题1234567Input: [[0,1],[1,1]]Output: 1Explanation: After flipping no values, 1 row has all values equal.Input: [[0,0,0],[0,0,1],[1,1,0]]Output: 2Explanation: After flipping values in the first two columns, the last two rows have equal values. 方法一：核心思想在于找到每行的模式，具有相同模式的行，最终可变成同样的数值。 123456def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -&gt; int: c = collections.Counter() for row in matrix: c[tuple([x for x in row])] += 1 c[tuple([1-x for x in row])] += 1 return max(c.values()) 方法二：使用异或。方法一中其实有多余的部分，模式与反模式都求了出来，其实没有必要。 12def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -&gt; int: return max(collections.Counter(tuple(r ^ row[0] for r in row) for row in matrix).values()) 1160. Find Words That Can Be Formed by Characters找出能被目标字符串组成的子串长度和。原题123def countCharacters(self, words: List[str], chars: str) -&gt; int: ma = collections.Counter(chars) return sum(len(w) for w in words if not collections.Counter(w)-ma) 525. Contiguous Array找出二进制数组中拥有相等个数0和1的最长子串的长度。原题123Input: [0,1]Output: 2Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1. 方法一：此题解法类似于买卖股票，维护一个count如果是0减一，如果是1加一，那么当count值相等的时候，说明这个子串中有相等1和0。使用一个字典来记录每次count的最小索引。需要注意的是索引从1开始。 1234567891011121314def findMaxLength(self, nums: List[int]) -&gt; int: count = ans = 0 table = &#123;0: 0&#125; for i, num in enumerate(nums, 1): if num == 0: count -= 1 else: count += 1 if count in table: ans = max(ans, i-table[count]) else: table[count] = i return ans 560. Subarray Sum Equals K子数组和为k的个数。原题12Input:nums = [1,1,1], k = 2Output: 2 方法一：累加一开始想到了，补0也想到了，没想到用哈希，而是用循环去迭代，这样时间超时了。 123456789def subarraySum(self, nums: List[int], k: int) -&gt; int: total = ans = 0 d = collections.defaultdict(int) d[0] = 1 for x in nums: total += x ans += d[total-k] d[total] += 1 return ans 1311. Get Watched Videos by Your Friends找到你的level级别的朋友看的电影，按照频率字母排序。原题123456789Input: watchedVideos = [[&quot;A&quot;,&quot;B&quot;],[&quot;C&quot;],[&quot;B&quot;,&quot;C&quot;],[&quot;D&quot;]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 1Output: [&quot;B&quot;,&quot;C&quot;] Explanation: You have id = 0 (green color in the figure) and your friends are (yellow color in the figure):Person with id = 1 -&gt; watchedVideos = [&quot;C&quot;] Person with id = 2 -&gt; watchedVideos = [&quot;B&quot;,&quot;C&quot;] The frequencies of watchedVideos by your friends are: B -&gt; 1 C -&gt; 2 1234567def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -&gt; List[str]: bfs, seen = &#123;id&#125;, &#123;id&#125; for _ in range(level): bfs = &#123;j for i in bfs for j in friends[i] if j not in seen&#125; seen |= bfs videos=collections.Counter([v for idx in bfs for v in watchedVideos[idx]]) return sorted(videos, key=lambda x: (videos[x], x)) 388. Longest Absolute File Path最长的绝对路径。原题方法一：自己用栈实现的。 12345678910111213def lengthLongestPath(self, input: str) -&gt; int: stack = [] path = input.split('\n') ans = [''] for p in path: t = p.count('\t') p = p[t:] while t &lt; len(stack): stack.pop() stack.append(p) if '.' in p: ans.append('/'.join(stack)) return len(max(ans, key=len)) 方法二：用字典记录深度。 1234567891011def lengthLongestPath(self, input: str) -&gt; int: ans = 0 path_len = &#123;0: 0&#125; for line in input.splitlines(): name = line.lstrip('\t') depth = len(line) - len(name) if '.' in name: ans = max(ans, path_len[depth] + len(name)) else: path_len[depth+1] = path_len[depth] + len(name) + 1 return ans 1224. Maximum Equal Frequency给定一个数组，返回这个数组最长的前缀，前缀中刚好有删除一个元素使其它元素的频率相等。原题123Input: nums = [2,2,1,1,5,3,3,5]Output: 7Explanation: For the subarray [2,2,1,1,5,3,3] of length 7, if we remove nums[4]=5, we will get [2,2,1,1,3,3], so that each number will appear exactly twice. 方法一：Lee215的答案，一共分为两种情况，一种情况是将当前元素删除，那么前面的元素具有相同的频率。如果不删除当前的元素，那么这个元素出现了c次，我们用freq来记录出现i次的有多少个数。那么删除的元素只能是出现c+1次或者1次，并且这个数只有一个。 1234567891011121314def maxEqualFreq(self, A: List[int]) -&gt; int: count = collections.defaultdict(int) freq = [0] * (len(A)+1) res = 0 for n, a in enumerate(A, 1): freq[count[a]+1] += 1 freq[count[a]] -= 1 c = count[a] = count[a] + 1 if freq[c]*c==n and n &lt; len(A): res = n + 1 d = n - freq[c]*c if d in (c+1, 1) and freq[d]==1: res = n return res 957. Prison Cells After N Days有8个监狱，如果两边的监狱是相同的，那么次日这个监狱会有人，否则为空。求N天之后的监狱原题123456789101112Input: cells = [0,1,0,1,1,0,0,1], N = 7Output: [0,0,1,1,0,0,0,0]Explanation: The following table summarizes the state of the prison on each day:Day 0: [0, 1, 0, 1, 1, 0, 0, 1]Day 1: [0, 1, 1, 0, 0, 0, 0, 0]Day 2: [0, 0, 0, 0, 1, 1, 1, 0]Day 3: [0, 1, 1, 0, 0, 1, 0, 0]Day 4: [0, 0, 0, 0, 0, 1, 0, 0]Day 5: [0, 1, 1, 1, 0, 1, 0, 0]Day 6: [0, 0, 1, 0, 1, 1, 0, 0]Day 7: [0, 0, 1, 1, 0, 0, 0, 0] 方法一：看了提示用hash但是还是没想到，总共有8个监狱，首位肯定是0，那么还有6个，6个监狱一共有多少种情况呢，2**6，也就是说最多这些天形成一种循环。 123456789def prisonAfterNDays(self, cells: List[int], N: int) -&gt; List[int]: seen = &#123;str(cells): N&#125; while N: seen[str(cells)] = N N -= 1 cells = [0] + [cells[i - 1] ^ cells[i + 1] ^ 1 for i in range(1, 7)] + [0] if str(cells) in seen: N %= seen[str(cells)] - N return cells 方法二：Lee发现了规律，有三个情况一种是1，7，14的时候循环。那么，每14次进行一次循环。但是不能直接进行取余，因为当过了一天，才会进入14天循环中的一天，所以如果当N能被14整除时，并且首位不为0，那么实际上他需要进行变换，而不是直接返回。 12345def prisonAfterNDays(self, cells: List[int], N: int) -&gt; List[int]: N -= max(N - 1, 0) // 14 * 14 for i in range(N): cells = [0] + [cells[i - 1] ^ cells[i + 1] ^ 1 for i in range(1, 7)] + [0] return cells 1546. Maximum Number of Non-Overlapping Subarrays With Sum Equals Target和为目标值的子数组最多有多少个，子数组不能重复。原题123Input: nums = [1,1,1,1,1], target = 2Output: 2Explanation: There are 2 non-overlapping subarrays [1,1,1,1,1] with sum equals to target(2). 方法一：题目分类为dp。但我感觉更适合哈希，比赛的时候想到了一下TwoSum的思路，但是重置seen为空那步没想到。 1234567891011def maxNonOverlapping(self, nums: List[int], target: int) -&gt; int: acc = [0] + list(itertools.accumulate(nums)) n = len(nums) ans = 0 seen = set() for pre_sum in acc: if pre_sum - target in seen: ans += 1 seen = set() seen.add(pre_sum) return ans 1577. Number of Ways Where Square of Number Is Equal to Product of Two Numbers找到一个数组中两个元素乘积等于另一个数组的平方，求总共的个数。原题12345Input: nums1 = [7,7,8,3], nums2 = [1,2,9,7]Output: 2Explanation: There are 2 valid triplets.Type 1: (3,0,2). nums1[3]^2 = nums2[0] * nums2[2].Type 2: (3,0,1). nums2[3]^2 = nums1[0] * nums1[1]. 方法一：比赛时想复杂了，但还是做出来了。比赛时想的是Counter原数组，根据平方找值。实际上通过combine方法可以反过来算简单。 123456789def numTriplets(self, nums1: List[int], nums2: List[int]) -&gt; int: c1 = Counter(n**2 for n in nums1) c2 = Counter(n**2 for n in nums2) ans = 0 for x, y in itertools.combinations(nums1, 2): ans += c2[x*y] for x, y in itertools.combinations(nums2, 2): ans += c1[x*y] return ans 916. Word Subsets给两个单词列表，返回A中满足这样条件的单词：B中的所有单词都是此单词的子集。原题12Input: A = [&quot;amazon&quot;,&quot;apple&quot;,&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;], B = [&quot;e&quot;,&quot;oo&quot;]Output: [&quot;facebook&quot;,&quot;google&quot;] 方法一：Counter 比较简单。效率不咋高。 1234def wordSubsets(self, A: List[str], B: List[str]) -&gt; List[str]: c_a = [Counter(w) for w in A] c_b = reduce(operator.or_, [Counter(w) for w in B]) return [word for i, word in enumerate(A) if not c_b-c_a[i]] 方法二：一的基础上改进。&amp; 比较貌似快一丢丢？ 123def wordSubsets(self, A: List[str], B: List[str]) -&gt; List[str]: c_b = reduce(operator.or_, (Counter(w) for w in B)) return [a for a in A if c_b &amp; Counter(a) == c_b] 方法三：直接查字符会比较快。快了一倍左右 123456def wordSubsets(self, A: List[str], B: List[str]) -&gt; List[str]: subset = &#123;&#125; for b in B: for char in b: subset[char] = max(subset.get(char, 0), b.count(char)) return [a for a in A if all(a.count(c) &gt;= subset[c] for c in subset.keys())] 974. Subarray Sums Divisible by K连续的子数组的和能被K整除的个数。原题1234Input: A = [4,5,0,-2,-3,1], K = 5Output: 7Explanation: There are 7 subarrays with a sum divisible by K = 5:[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3] 方法一：这道题没有在规定时间内完成，此答案参考了排名第一的大佬，然后使用defaultdict进行了改进。 这里有一个详细的解答。不过那里给出的答案没有这个简单，不过思路大体相同。 假设通过sum(i, j)表示切片[i: j]的总和，如果sum(i, j)能被K整除，则说明sum(0, j) - sum(0, i)也能被K整除，即对sum(0, j) % K == sum(0, i) % K。下面的解法使用一个字典记录了余数的个数。当余数第二次出现的时候，开始计数，但0的时候除外，因为整除了就产生结果了。 然后再看累加的方法以下文第3行log为例，mod又为4，这时它和之前余数为4的的数组都可以产生一个结果即[4, 5, 0] - [4] = [5, 0] 和[4 , 5, 0] - [4, 5] = [0]所以要累加原来的和。 1234567891011121314def subarraysDivByK(self, A, K): from collections import defaultdict m = defaultdict(int) m[0] = 1 total, ans = 0, 0 for i, num in enumerate(A): total += num sum_p = total % K ans += m[sum_p] m[sum_p] += 1 print('sum subarray &#123;&#125; total is &#123;&#125;, mod is &#123;&#125;, ans is &#123;&#125;, &#123;&#125;'.format( A[:i+1], total, sum_p, ans, m )) return ans 123456sum subarray [4] total is 4, mod is 4, ans is 0, defaultdict(&lt;class &apos;int&apos;&gt;, &#123;0: 1, 4: 1&#125;)sum subarray [4, 5] total is 9, mod is 4, ans is 1, defaultdict(&lt;class &apos;int&apos;&gt;, &#123;0: 1, 4: 2&#125;)sum subarray [4, 5, 0] total is 9, mod is 4, ans is 3, defaultdict(&lt;class &apos;int&apos;&gt;, &#123;0: 1, 4: 3&#125;)sum subarray [4, 5, 0, -2] total is 7, mod is 2, ans is 3, defaultdict(&lt;class &apos;int&apos;&gt;, &#123;0: 1, 4: 3, 2: 1&#125;)sum subarray [4, 5, 0, -2, -3] total is 4, mod is 4, ans is 6, defaultdict(&lt;class &apos;int&apos;&gt;, &#123;0: 1, 4: 4, 2: 1&#125;)sum subarray [4, 5, 0, -2, -3, 1] total is 5, mod is 0, ans is 7, defaultdict(&lt;class &apos;int&apos;&gt;, &#123;0: 2, 4: 4, 2: 1&#125;) 1590. Make Sum Divisible by P删除最小的连续子数组，使得整个数组和能被P整除。方法一：此题作为竞赛第三题，比二题简单，但是竞赛的时候没有做。首先可以用总和%p看余几，然后就是找到最小的子数组能让余数等于这个，就把这个删除，这一点很好想。剩下的和974一样。 123456789101112def minSubarray(self, nums: List[int], p: int) -&gt; int: m = sum(nums) % p dp = &#123;0: -1&#125; mod = 0 ans = len(nums) for i, a in enumerate(nums): mod = (mod+a) % p dp[mod] = i want = (mod-m) % p if want in dp: ans = min(ans, i-dp[want]) return ans if ans &lt; len(nums) else -1 692. Top K Frequent Words最高频的K个单词，相同频率，优先返回字符顺序优先。1234Input: [&quot;i&quot;, &quot;love&quot;, &quot;leetcode&quot;, &quot;i&quot;, &quot;love&quot;, &quot;coding&quot;], k = 2Output: [&quot;i&quot;, &quot;love&quot;]Explanation: &quot;i&quot; and &quot;love&quot; are the two most frequent words. Note that &quot;i&quot; comes before &quot;love&quot; due to a lower alphabetical order. 方法一：记录写法，nsmallest 也能接受key函数。 123def topKFrequent(self, words: List[str], k: int) -&gt; List[str]: c = Counter(words) return [w for w in heapq.nsmallest(k, c.keys(), key=lambda x: (-c[x], x))]]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>HashTable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（贪心篇）Greedy]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E8%B4%AA%E5%BF%83%E7%AF%87%EF%BC%89greedy%2F</url>
    <content type="text"><![CDATA[984. String Without AAA or BBB生成字符串没有‘aaa’和’bbb’。原题123Input: A = 1, B = 2Output: &quot;abb&quot;Explanation: &quot;abb&quot;, &quot;bab&quot; and &quot;bba&quot; are all correct answers. 123456789101112131415def strWithout3a3b(self, A, B): ans = '' while A or B: if len(ans) &gt;= 2 and ans[-1]==ans[-2]: writeA = ans[-1]=='b' else: writeA = A&gt;=B if writeA: A -= 1 ans += 'a' else: B -= 1 ans += 'b' return ans 455. Assign Cookies发小饼干，s为若干个饼干的大小，g为每个人需要的大小，没人发的饼干不能比要求的size小，问最多可以满足几个人。原题1234567Input: [1,2], [1,2,3]Output: 2Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. You have 3 cookies and their sizes are big enough to gratify all of the children, You need to output 2. 12345678def findContentChildren(self, g: List[int], s: List[int]) -&gt; int: g.sort() s.sort() i = j = 0 while i &lt; len(g) and j &lt; len(s): i += s[j] &gt;= g[i] j += 1 return i 860. Lemonade Change柠檬找零，每人买一个柠檬，（价值5）可能付5, 10, 20面值的钞票，问零钱是否能找开。原题1234567Input: [5,5,5,10,20]Output: trueExplanation: From the first 3 customers, we collect three $5 bills in order.From the fourth customer, we collect a $10 bill and give back a $5.From the fifth customer, we give a $10 bill and a $5 bill.Since all customers got correct change, we output true. 方法一：defaultdict。 123456789101112131415def lemonadeChange(self, bills: 'List[int]') -&gt; 'bool': c = collections.defaultdict(int) for bill in bills: if bill == 10: c[5] -= 1 elif bill == 20: if c[10] &gt;= 1: c[10] -= 1 c[5] -= 1 else: c[5] -= 3 if c[5] &lt; 0: return False c[bill] += 1 return True 944. Delete Columns to Make Sorted找出并行项中未排序的个数。原题方法一：sorted要比any快，感觉是Cpython的优化导致，理论上来说应该是any快。 1234567def minDeletionSize(self, A: 'List[str]') -&gt; 'int': ans = 0 for col in zip(*A): # if any(col[i]&gt;col[i+1] for i in range(len(col)-1)): if sorted(col) != list(col): ans += 1 return ans 55. Jump Game跳跃游戏，数组中每个元素表示下一步的距离，问是否能跳到最后索引位置。原题123Input: [2,3,1,1,4]Output: trueExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. 方法一：贪心。 123456def canJump(self, nums: List[int]) -&gt; bool: last_pos = len(nums) - 1 for i in range(len(nums)-1, -1, -1): if i + nums[i] &gt;= last_pos: last_pos = i return last_pos == 0 1005. Maximize Sum Of Array After K NegationsK次取负后的数组最大和。原题123Input: A = [3,-1,0,2], K = 3Output: 6Explanation: Choose indices (1, 2, 2) and A becomes [3,1,0,2]. 方法一：竞赛的时候，写得比较麻烦，分了两个数组，还考虑了0，后来看lee神的整理一下。注意最后一步要用一下min，否则获取不了最小值。 1234567def largestSumAfterKNegations(self, A: List[int], K: int) -&gt; int: A.sort() i = 0 while i&lt;len(A) and i&lt;K and A[i]&lt;0: A[i] = -A[i] i += 1 return sum(A) - (K-i)%2*min(A)*2 1029. Two City Scheduling两个城市调度。每个坐标表示，去A和B的花费，使花费最小。原题123456789Input: [[10,20],[30,200],[400,50],[30,20]]Output: 110Explanation: The first person goes to city A for a cost of 10.The second person goes to city A for a cost of 30.The third person goes to city B for a cost of 50.The fourth person goes to city B for a cost of 20.The total minimum cost is 10 + 30 + 50 + 20 = 110 to have half the people interviewing in each city. 方法一：假设左边的人留在A，右边的人留在B，如果不是最优解，那么右边的人r需要移到左边，左边的人l需要移到右边，相当于从l[0]+r[1]变为了l[1]+r[0]，即l[1]-l[0]+r[0]-r[1]&lt;0时需要交换两个城市，推导可得出，l[0]-l[1] &gt; r[0]-r[1]，则得出排序规则。 123def twoCitySchedCost(self, costs: List[List[int]]) -&gt; int: costs.sort(key=lambda x: x[0]-x[1]) return sum(i[0] for i in costs[:len(costs)//2]) + sum(j[1] for j in costs[len(costs)//2:]) 1042. Flower Planting With No Adjacent联通图染色问题，paths表示相邻的花园，相邻的花园中不能种同一种花，一种有四种花。原题方法一： 12345678910def gardenNoAdj(self, N: int, paths: List[List[int]]) -&gt; List[int]: res = [0] * N g = [[] for _ in range(N)] for x, y in paths: g[x-1].append(y-1) g[y-1].append(x-1) for i in range(N): res[i] = (&#123;1, 2, 3, 4&#125;-&#123;res[j] for j in g[i]&#125;).pop() return res 1046. Last Stone Weight最后一块石头的质量。每次从石头堆中拿出两块最重的pk，剩下为二者之差。原题方法一：暴力排序。 12345678def lastStoneWeight(self, stones: List[int]) -&gt; int: stones = sorted(stones) while len(stones) &gt; 1: a, b = stones.pop(), stones.pop() if a != b: stones.append(a - b) stones.sort() return stones[0] if stones else 0 方法二：使用堆。 1234567891011def lastStoneWeight(self, stones: List[int]) -&gt; int: import heapq as hq from operator import neg stones = list(map(neg, stones)) hq.heapify(stones) while len(stones) &gt; 1: a = -hq.heappop(stones) b = -hq.heappop(stones) if a != b: hq.heappush(stones, b - a) return -hq.heappop(stones) if stones else 0 1090. Largest Values From Labels给一个集合，每个元素有一个值values[i]与标签labels[i]。这里要选择一个子集，使得子集的元素个数不超过num_wanted，而且相同标签的元素个数不超过use_limit。求子集的最大和。原题123Input: values = [5,4,3,2,1], labels = [1,1,2,2,3], num_wanted = 3, use_limit = 1Output: 9Explanation: The subset chosen is the first, third, and fifth item. 方法一：此题大部分时间花在理解题意，英文原文非常容易误解。 1234567891011def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -&gt; int: ans = 0 c = collections.defaultdict(int) for v, b in sorted(zip(values, labels), reverse=True): if num_wanted == 0: break if c[b] &lt; use_limit: c[b] += 1 ans += v num_wanted -= 1 return ans 1094. Car Pooling一辆车接旅客，根据旅客的人数，上下车位置，判断是否可以载完所有的旅客。原题12Input: trips = [[2,1,5],[3,3,7]], capacity = 4Output: false 方法一：将旅客上下车地点排序。 123456def carPooling(self, trips: List[List[int]], capacity: int) -&gt; bool: for i, v in sorted(x for n, s, e in trips for x in ((s, n), (e, -n))): capacity -= v if capacity &lt; 0: return False return True 1403. Minimum Subsequence in Non-Increasing Order最小的宽度的和大于剩余数的子序列。原题123Input: nums = [4,3,10,9,8]Output: [10,9] Explanation: The subsequences [10,9] and [10,8] are minimal such that the sum of their elements is strictly greater than the sum of elements not included, however, the subsequence [10,9] has the maximum total sum of its elements. 方法一：排序。 123456789def minSubsequence(self, nums: List[int]) -&gt; List[int]: nums.sort(reverse=True) total = sum(nums) cur = 0 for i, d in enumerate(nums): cur += d if cur * 2 &gt; total: return nums[:i+1] return nums 1400. Construct K Palindrome Strings是否能用给定的字符串够成k个回文串。原题1234Input: s = &quot;annabelle&quot;, k = 2Output: trueExplanation: You can construct two palindromes using all characters in s.Some possible constructions &quot;anna&quot; + &quot;elble&quot;, &quot;anbna&quot; + &quot;elle&quot;, &quot;anellena&quot; + &quot;b&quot; 方法一：能否构成回文串，要看奇数个字符是否小于等于k。1234def canConstruct(self, s: str, k: int) -&gt; bool: from collections import Counter odd_c = sum(cnt&amp;1==1 for cnt in Counter(s).values()) return odd_c &lt;= k &lt;= len(s) 45. Jump Game II跳跃游戏。每个位置写了最远距离。原题1234Input: [2,3,1,1,4]Output: 2Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index. 方法一：使用了与1024题一样的方法。 1234567891011def jump(self, nums: List[int]) -&gt; int: n = len(nums) end, end2, cnt = -1, 0, 0 for i, s in enumerate(nums): if end2 &gt;= n-1: break elif end &lt; i &lt;= end2: cnt += 1 end = end2 end2 = max(end2, i+s) return cnt 方法二：使用两个指针，表示了一个范围，每次增加一步时，在这个范围中找到下一次最右的距离，为了不让范围重叠, 让left=right+1，直到最右点到达末尾。 123456789def jump(self, nums: List[int]) -&gt; int: if len(nums) &lt;= 1: return 0 l, r = 0, nums[0] step = 1 while r &lt; len(nums)-1: step += 1 nxt = max(i+nums[i] for i in range(l, r+1)) l, r = r+1, nxt return step 1296. Divide Array in Sets of K Consecutive Numbers数组能否分成连续的k个元素的子数组。原题123Input: nums = [1,2,3,3,4,4,5,6], k = 4Output: trueExplanation: Array can be divided into [1,2,3,4] and [3,4,5,6]. 方法一：首次ac的方法。每次取最小的key比较耗时。 1234567891011121314def isPossibleDivide(self, nums: List[int], k: int) -&gt; bool: n = len(nums) if n % k != 0: return False c = collections.Counter(nums) for i in range(n//k): s = min(c.keys()) for j in range(k): if s+j not in c: return False c[s+j] -= 1 if c[s+j] == 0: del c[s+j] return True 方法二：排序，每次从中取最小，如果其数量不为1，那么作为它的等差数列一组，另外的k-1个数也得大于等于这个数量。 123456789def isPossibleDivide(self, nums: List[int], k: int) -&gt; bool: c = collections.Counter(nums) for i in sorted(c): if c[i] &gt; 0: for j in range(1, k): c[i+j] -= c[i] if c[i+j] &lt; 0: return False return True 1282. Group the People Given the Group Size They Belong To将元素分组到指定的size中。原题1234Input: groupSizes = [3,3,3,3,3,1,3]Output: [[5],[0,1,2],[3,4,6]]Explanation: Other possible solutions are [[2,1,6],[5],[0,4,3]] and [[5],[0,6,2],[4,3,1]]. 方法一：比赛时用的sort，其实有O(n)的方法。 1234567891011def groupThePeople(self, groupSizes: List[int]) -&gt; List[List[int]]: gs = [(i, s) for i, s in enumerate(groupSizes)] ans = [] last = None for i, s in sorted(gs, key=lambda x: x[1]): if not last or len(ans[-1]) == last: ans.append([i]) else: ans[-1].append(i) last = s return ans 方法二：hash. 12345def groupThePeople(self, groupSizes: List[int]) -&gt; List[List[int]]: count = collections.defaultdict(list) for i, g in enumerate(groupSizes): count[g].append(i) return [l[i:i+s] for s, l in count.items() for i in range(0, len(l), s)] 1253. Reconstruct a 2-Row Binary Matrix两个二进制数组，给出每个累加1的和，和列的和，重建这个二进制数组，答案不唯一。原题123Input: upper = 2, lower = 1, colsum = [1,1,1]Output: [[1,1,0],[0,0,1]]Explanation: [[1,0,1],[0,1,0]], and [[0,1,1],[1,0,0]] are also correct answers. 方法一：竞赛时的方法写的太java。因为在于贪心的条件选择先塞满第一个数。这样会徒增一些没用的判断。 12345678910111213141516171819202122def reconstructMatrix(self, upper: int, lower: int, colsum: List[int]) -&gt; List[List[int]]: n = len(colsum) c1, c2 = colsum.count(1), colsum.count(2) if upper+lower-c2*2 != c1 or min(upper, lower)&lt;c2: return [] a, b, r = [], [], 0 for c in colsum: if c == 2: i = j = 1 elif c == 1: if upper-c2-r &gt; 0: i = 1 j = 0 r += 1 else: i = 0 j = 1 else: i = j = 0 a.append(i) b.append(j) return [a, b] 方法二：可以用大小判断选择放哪个数中。 12345678910111213141516def reconstructMatrix(self, upper: int, lower: int, colsum: List[int]) -&gt; List[List[int]]: n = len(colsum) a1, a2 = [0] * n, [0] * n for i, s in enumerate(colsum): if s == 1: if upper &gt; lower: a1[i] = 1 upper -= 1 else: a2[i] = 1 lower -= 1 elif s == 2: a1[i] = a2[i] = 1 upper -= 1 lower -= 1 return (a1, a2) if lower==upper==0 else [] 1247. Minimum Swaps to Make Strings Equal两个包含x和y的字符串，互换任意两个字符，最小需要多少次才能相等。原题1234567891011Input: s1 = &quot;xx&quot;, s2 = &quot;yy&quot;Output: 1Explanation: Swap s1[0] and s2[1], s1 = &quot;yx&quot;, s2 = &quot;yx&quot;.Input: s1 = &quot;xy&quot;, s2 = &quot;yx&quot;Output: 2Explanation: Swap s1[0] and s2[0], s1 = &quot;yy&quot;, s2 = &quot;xx&quot;.Swap s1[0] and s2[1], s1 = &quot;xy&quot;, s2 = &quot;xy&quot;.Note that you can&apos;t swap s1[0] and s1[1] to make s1 equal to &quot;yx&quot;, cause we can only swap chars in different strings. 方法一：尽量多的匹配,’xx’和’yy’这样只需要一步。ac倒是ac了，写法上看着有点烂。 1234567891011121314151617def minimumSwap(self, s1: str, s2: str) -&gt; int: c_x, c_y = 0, 0 ans = 0 for a, b in zip(s1, s2): if a != b: c_x += (a=='x') c_y += (a=='y') if max(c_x, c_y)==2: if c_x &gt; c_y: c_x -= 2 else: c_y -= 2 ans += 1 if c_x + c_y == 1: return -1 ans += (c_x==1 and c_y==1) * 2 return ans 方法二：优化一下。 1234567891011def minimumSwap(self, s1: str, s2: str) -&gt; int: x1 = y1 = 0 for a, b in zip(s1, s2): if a != b: if a == 'x': x1 += 1 else: y1 += 1 if (x1+y1) &amp; 1 == 1: return -1 return x1//2 + y1//2 + 2*(x1&amp;1) 406. Queue Reconstruction by Height根据没跟人的高度和前面比他高的k个人，重建队列。原题12345Input:[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]Output:[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] 方法一：看了答案，理解起来也不是很难，根据高度来排序，每次选出一个人插入到队列中，因为队列里的人都是比他高的。 123456def reconstructQueue(self, people: List[List[int]]) -&gt; List[List[int]]: people.sort(key=lambda x: (-x[0], x[1])) queue = [] for p in people: queue.insert(p[1], p) return queue 1488. Avoid Flood in The Cityrains表示哪个湖会下雨，0的时候表示可以选择一个湖抽干水，如果有湖水在抽干前又下雨了，那么就会发洪水，返回-1，然后需要返回一个数组，表示每天应该抽干哪个湖的水，答案不唯一。原题 123456789Input: rains = [1,2,0,0,2,1]Output: [-1,-1,2,1,-1,-1]Explanation: After the first day full lakes are [1]After the second day full lakes are [1,2]After the third day, we dry lake 2. Full lakes are [1]After the fourth day, we dry lake 1. There is no full lakes.After the fifth day, full lakes are [2].After the sixth day, full lakes are [1,2].It is easy that this scenario is flood-free. [-1,-1,1,2,-1,-1] is another acceptable scenario. 方法一：竞赛的时候没有做出来，在多次wa后TLE了，使用的方式是二分查找修改要抽哪天的水。没有想到用堆。而且整体的思路有一种滞后性，就是当遇见第二次下雨的时候再去找0的那天抽干哪个湖的水。这个方法遍历了两次数组，第一次将每个湖下雨的天数记录下来。然后可以抽水的时候用一个堆去计算最近的哪个湖会再次下雨，这样优先抽干这个湖的水。to_empty中记录索引。 1234567891011121314151617181920212223242526def avoidFlood(self, rains: List[int]) -&gt; List[int]: n = len(rains) dic = collections.defaultdict(list) ans = [-1] * n full = set() to_empty = [] for i, rain in enumerate(rains): dic[rain].append(i) for i, rain in enumerate(rains): if rain: if rain in full: return [] else: full.add(rain) dic[rain].pop(0) if dic[rain]: heapq.heappush(to_empty, dic[rain][0]) else: if to_empty: j = heapq.heappop(to_empty) ans[i] = rains[j] full.remove(rains[j]) else: ans[i] = 1 return ans 1505. Minimum Possible Integer After at Most K Adjacent Swaps On Digits一个数字最多交换K次相邻的字符，使其表示的数字最小，可以0开头。原题123Input: num = &quot;4321&quot;, k = 4Output: &quot;1342&quot;Explanation: The steps to obtain the minimum integer from 4321 with 4 adjacent swaps are shown. 方法一：据说是字节的面试题。contest时卡在了第三题，此题没有时间看。这个方法是超时的。 123456789101112131415def minInteger(self, num: str, k: int) -&gt; str: num = [*map(int, num)] if k &gt;= (len(num) ** 2) // 2: return ''.join(map(str, sorted(num))) res = [] q = [(v, i) for i, v in enumerate(num)] while k and q: idx, (v, i) = min(enumerate(q[:k + 1]), key=lambda p:p[1]) k -= idx del q[idx] res += v, res += [v for v, _ in q] return ''.join(map(str, res)) 方法二：使用一个FenWick数即二叉索引数记录位移。总体的思路是一样的，每次在可以k的范围内找到一个最小的数移到最左边，这样数字会变为最小，开始的时候记录每个数的原始索引，使用FenWick记录位移索引，如在一个i的位置找到一个最小数移到最左边，那么其原始序列右侧的数下次需要位移为原始做阴-1，因为最左位已经被占用了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class FenWick(object): def __init__(self, n): self.nums = [0] * (1+ n) def update(self, i, delta): while i &lt; len(self.nums): self.nums[i] += delta i += i &amp; -i def query(self, i): ans = 0 while i &gt; 0: ans += self.nums[i] i -= i &amp; -i return ans class Solution: def minInteger(self, num: str, k: int) -&gt; str: n = len(num) pos = [[] for _ in range(10)] for i in range(n-1, -1, -1): pos[ord(num[i])-ord('0')].append(i) def find_min(): for d in range(10): if not pos[d]: continue i = pos[d][-1] cost = i - tree.query(i) if cost &lt;= k: return d, cost return None, None tree = FenWick(n) res = [] removed = [False] * n while k: d, cost = find_min() if d is None: break k -= cost res.append(d) i = pos[d].pop() tree.update(i+1, 1) removed[i] = True lhs = ''.join(map(str, res)) rhs = ''.join(num[i] for i in range(n) if not removed[i]) return lhs + rhs 763. Partition Labels将字符串S尽可能分成多的部分，不同部分不能有相同的字符。原题123456Input: S = &quot;ababcbacadefegdehijhklij&quot;Output: [9,7,8]Explanation:The partition is &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;.This is a partition so that each letter appears in at most one part.A partition like &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; is incorrect, because it splits S into less parts. 方法一：一开始想的方法。每次遇到之前的元素就用栈的方式来合并。 12345678910111213141516def partitionLabels(self, S: str) -&gt; List[int]: n = len(S) last = &#123;&#125; ans = [] for i, c in enumerate(S): last[c] = i hi = -1 while hi != n-1: lo = start = hi + 1 hi = last[S[lo]] while lo &lt; hi: lo += 1 hi = max(hi, last[S[lo]]) ans.append(hi-start+1) return ans 方法二：这个判断条件没有想到，其实只要和最后索引相同，就可以添加一段了。 1234567891011def partitionLabels(self, S: str) -&gt; List[int]: last = &#123;c: i for i, c in enumerate(S)&#125; ans = [] lo = hi = 0 for i, c in enumerate(S): hi = max(hi, last[c]) if i == hi: ans.append(hi-lo+1) lo = i + 1 return ans 方法三：stefan有比较直观的方法。时间复杂度略高 123456789def partitionLabels(self, S: str) -&gt; List[int]: ans = [] while S: i = 1 while set(S[:i]) &amp; set(S[i:]): i += 1 ans.append(i) S = S[i:] return ans 621. Task Scheduler每两个相同任务之间需要有n个时间，不足则需要闲置，问最少的任务调度完成时间是多少。原题12345Input: tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n = 2Output: 8Explanation: A -&gt; B -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; A -&gt; BThere is at least 2 units of time between any two same tasks. 方法一：使用堆。 1234567891011121314151617def leastInterval(self, tasks: List[str], n: int) -&gt; int: c = Counter(tasks).most_common() ans = 0 c = [(-b, a) for a, b in c] heapq.heapify(c) while c: tmp = [heapq.heappop(c)] k = n while k and c: tmp.append(heapq.heappop(c)) k -= 1 for t, l in tmp: if -t &gt; 1: heapq.heappush(c, (t+1, l)) if c: ans += k return ans + len(tasks) 1536. Minimum Swaps to Arrange a Binary Grid二维矩阵，每次换相邻的2行，最小步数使左上右下的对象线上方全是0.原题方法一：贪心。曾经做过一道类似的题，是每次变换十字形，然后最后变成全是0，那道题用了转换的方式，将数组转换成了一个二维数字。受到了那题的影响，比赛时想的是BFS的方法，所以最后超时了。为什么贪心的方法可行，因为每行所需的结尾0的个数是越来越少的，所以每次将所满足的行移到最上，下面的行需要的个数不会超过此行。 123456789101112131415def minSwaps(self, grid: List[List[int]]) -&gt; int: n = len(grid) ans = 0 tail_zero = [len(list(itertools.takewhile(lambda x: x==0, row[::-1]))) for row in grid] for i in range(n): for j in range(i, n): tail_zero[i], tail_zero[j] = tail_zero[j], tail_zero[i] if tail_zero[i] &gt;= n-i-1: ans += j - i break else: return -1 return ans 435. Non-overlapping Intervals删除最少的段，使剩余的不重复。原题123Input: [[1,2],[2,3],[3,4],[1,3]]Output: 1Explanation: [1,3] can be removed and the rest of intervals are non-overlapping. 方法一：排序。一开始没有加key，为什么是这样的条件呢，因为需要每次选取最小的end，才能保证容纳更多的段。 123456789def eraseOverlapIntervals(self, intervals: List[List[int]]) -&gt; int: intervals.sort(key=lambda x: x[1]) end, ans = float('-inf'), 0 for s, e in intervals: if s &lt; end: ans += 1 else: end = e return ans 134. Gas Station说有这么一个加油站，每个加油站能加gas[i]的油量，走到下一个站需要花费cost[i]的油量，这些加油站围绕成一个圈，只有从一个站走才能顺时针走完一圈，问这个站的索引是多少，如果没有，返回-1。原题1234567891011121314Input: gas = [1,2,3,4,5]cost = [3,4,5,1,2]Output: 3Explanation:Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4Travel to station 4. Your tank = 4 - 1 + 5 = 8Travel to station 0. Your tank = 8 - 2 + 1 = 7Travel to station 1. Your tank = 7 - 3 + 2 = 6Travel to station 2. Your tank = 6 - 4 + 3 = 5Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.Therefore, return 3 as the starting index. 方法一：首次ac的方法。找到油量消耗最多的点，然后让其最后经过那里。 123456def canCompleteCircuit(self, gas: List[int], cost: List[int]) -&gt; int: diff = [a-b for a, b in zip(gas, cost)] acc = list(itertools.accumulate(diff)) if sum(diff) &lt; 0: return -1 ans = acc.index(min(acc)) + 1 return ans if ans &lt; len(gas) else 0 方法二：这个方法遍历一次，one-pass，想想原理其实一样。 123456789def canCompleteCircuit(self, gas: List[int], cost: List[int]) -&gt; int: gas_left = gas_needed = start = 0 for i, (g, c) in enumerate(zip(gas, cost)): gas_left += g - c if gas_left &lt; 0: gas_needed -= gas_left start = i + 1 gas_left = 0 return start if gas_left &gt;= gas_needed else -1 1558. Minimum Numbers of Function Calls to Make Target Array最小步骤能将全是0的数组变为目标数组。每步可以选择一个元素+1，或者所有元素*2。原题123456Input: nums = [1,5]Output: 5Explanation: Increment by 1 (second element): [0, 0] to get [0, 1] (1 operation).Double all the elements: [0, 1] -&gt; [0, 2] -&gt; [0, 4] (2 operations).Increment by 1 (both elements) [0, 4] -&gt; [1, 4] -&gt; [1, 5] (2 operations).Total of operations: 1 + 2 + 2 = 5. 方法一：比赛时想到了这个方法，从后往前算，然后尽量/2，但是感觉会超时，所以没有提交。 123456789101112131415def minOperations(self, nums: List[int]) -&gt; int: d = nums.index(max(nums)) ans = 0 while True: for i in range(len(nums)): if nums[i]&amp; 1 == 1: nums[i] -= 1 ans += 1 if nums[d] == 0: break nums = [n//2 for n in nums] ans += 1 # print(nums, ans) return ans 方法二：这个方法差一点想出来，没想到用二进制时可以看到规律，/2的操作可以被共享，这点我也想到了，其实是最大数的二进制长度-1，而-1的操作就是每个数字有多少个1，这点没有想到。 12def minOperations(self, A: List[int]) -&gt; int: return sum(bin(a).count('1') for a in A) + len(format(max(A), 'b')) - 1 1568. Minimum Number of Days to Disconnect Island把刚好存在一个岛屿变成2个或没有，最少需要几步。每步可以沉没一个格子。原题1234Input: grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]Output: 2Explanation: We need at least 2 days to get a disconnected grid.Change land grid[1][1] and grid[0][2] to water and get 2 disconnected island. 方法一：这题需要想明白一件事，对于任意的岛屿，我找一个角沉没它旁边两个，就能将其变成一个单独的岛屿。那么也就是说 最多需要2步就行。 123456789101112131415161718192021def minDays(self, grid: List[List[int]]) -&gt; int: m, n = len(grid), len(grid[0]) def count(g): def sink(i, j): if 0&lt;=i&lt;m and 0&lt;=j&lt;n and g[i][j]: g[i][j] = 0 list(map(sink, (i, i, i+1, i-1), (j+1, j-1, j, j))) return 1 return 0 return sum(sink(i, j) for i in range(m) for j in range(n)) cnt_g = count(copy.deepcopy(grid)) if cnt_g == 0 or cnt_g &gt; 1: return 0 for i in range(m): for j in range(n): tmp_g = copy.deepcopy(grid) tmp_g[i][j] = 0 if count(tmp_g)!=1: return 1 return 2 方法二：不用深拷贝，用集合判断点是否重复。 1234567891011121314151617181920212223242526def minDays(self, grid: List[List[int]]) -&gt; int: m, n = len(grid), len(grid[0]) seen = set() def count(g): def sink(i, j): if 0&lt;=i&lt;m and 0&lt;=j&lt;n and (i, j) not in seen and g[i][j]: seen.add((i, j)) list(map(sink, (i, i, i+1, i-1), (j+1, j-1, j, j))) return 1 return 0 return sum(sink(i, j) for i in range(m) for j in range(n)) cnt_g = count(grid) seen.clear() if cnt_g == 0 or cnt_g &gt; 1: return 0 for i in range(m): for j in range(n): if grid[i][j]: grid[i][j] = 0 if count(grid)!=1: return 1 grid[i][j] = 1 seen.clear() return 2 1567. Maximum Length of Subarray With Positive Product最长的子数组累乘为正数。原题12345Input: nums = [1,-2,-3,4]Output: 4Explanation: The array nums already has a positive product of 24.Input: nums = [0,1,-2,-3,-4]Output: 3 方法一：比赛时的方法。这题作为竞赛第二题有点稍难，但还是完成了。 1234567891011121314151617181920212223242526def getMaxLen(self, nums: List[int]) -&gt; int: # [1, 0, -2, 4, 3, 1] start = ans = 0 flag = 1 q = collections.deque() for end in range(len(nums)): if nums[end] == 0: start = end+1 if flag: ans = max(ans, end-start) else: ans = max(ans, end-q[0]-1) q.clear() flag = 1 continue elif nums[end] &gt; 0: pass else: q.append(end) flag ^= 1 if flag: ans = max(ans, end-start+1) else: ans = max(ans, end-q[0]) return ans 方法二：0这个元素不是很好判断，所以先将数组以0分割。 12345678910111213141516171819202122232425def getMaxLen(self, nums: List[int]) -&gt; int: trip_zeros = [] for num in nums: if num: if trip_zeros: trip_zeros[-1].append(num) else: trip_zeros.append([num]) else: trip_zeros.append([]) def count(arr): start = ans = 0 left_neg = None pos = 1 for end in range(len(arr)): if arr[end] &lt; 0: if left_neg is None: left_neg = end pos ^= 1 if pos: ans = max(ans, end-start+1) else: ans = max(ans, end-left_neg) return ans return max(map(count, trip_zeros)) 方法三：dp方法。这个方法有用，有一道dp的类似题，152号题。 123456789101112131415def getMaxLen(self, nums: List[int]) -&gt; int: n = len(nums) pos, neg = [0] * n, [0] * n if nums[0] &gt; 0: pos[0] = 1 if nums[0] &lt; 0: neg[0] = 1 ans = pos[0] for i in range(1, n): if nums[i] &gt; 0: pos[i] = 1 + pos[i - 1] neg[i] = (1 + neg[i - 1]) * (neg[i - 1] != 0) elif nums[i] &lt; 0: pos[i] = (1 + neg[i - 1]) * (neg[i - 1] != 0) neg[i] = 1 + pos[i - 1] ans = max(ans, pos[i]) return ans 881. Boats to Save People最少需要多少小船救人。小船限重为limit，最多能装俩人。根据人的重量，最少需要多少小船。原题123Input: people = [3,2,2,1], limit = 3Output: 3Explanation: 3 boats (1, 2), (2) and (3) 方法一：抱着超时的心态提交，居然ac了。但是太慢了。 12345678910111213def numRescueBoats(self, people: List[int], limit: int) -&gt; int: c = Counter(people) ans = 0 for i in range(1, limit+1): while c[i]&gt;0: c[i] -= 1 ans += 1 p = limit - i for j in range(p, i-1, -1): if c[j]: c[j] -= 1 break return ans 方法二：要从肥的人考虑，这样简单一些。 123456789def numRescueBoats(self, people: List[int], limit: int) -&gt; int: q = collections.deque(sorted(people, reverse=True)) ans = 0 while q: fat = q.popleft() ans += 1 if q and q[-1] + fat &lt;= limit: q.pop() return ans 方法三：用指针。 1234567891011def numRescueBoats(self, p: List[int], limit: int) -&gt; int: p.sort() ans = 0 i, j = 0, len(p)-1 while i &lt;= j: fat = p[j] j -= 1 ans += 1 if fat+p[i] &lt;= limit: i += 1 return ans 方法四：Lee的方法，用i表示Ans。 12345678def numRescueBoats(self, p: List[int], limit: int) -&gt; int: p.sort(reverse=True) i, j = 0, len(p)-1 while i &lt;= j: if p[j]+p[i] &lt;= limit: j -= 1 i += 1 return i 1405. Longest Happy String最长的欢乐字符串，有’abc’3个字符组成，并且不存在’aaa’这种三连的情况。给定每个字符的个数，问最长可以生成多长的这样的字符串。原题123Input: a = 1, b = 1, c = 7Output: &quot;ccaccbcc&quot;Explanation: &quot;ccbccacc&quot; would also be a correct answer. 方法一：用最大堆实现，注意这里选择第二多元素时要添加一个字符，因为有时候第二个字符可能不够分割。 123456789101112131415161718192021def longestDiverseString(self, a: int, b: int, c: int) -&gt; str: ans = '' lt = [(-a, 'a'), (-b, 'b'), (-c, 'c')] heapq.heapify(lt) while lt: max_d, char = heapq.heappop(lt) if ans[-2:]==char*2: if not lt: break snd_d, char2 = heapq.heappop(lt) ans += char2*min(-snd_d, 1) snd_d += 1 if snd_d &lt; 0: heapq.heappush(lt, (snd_d, char2)) else: ans += char*min(-max_d, 2) max_d += 2 if max_d &lt; 0: heapq.heappush(lt, (max_d, char)) return ans 870. Advantage Shuffle将A重新排序，使得对应位置&gt;B的数尽可能地多。原题12Input: A = [2,7,11,15], B = [1,10,4,11]Output: [2,11,7,15] 方法一：很直观的贪心算法。将AB排序。每次拿出最大的和B最大的比，如果比不过，就拿最小的顶上。类似于田忌赛马。 12345678910def advantageCount(self, A: List[int], B: List[int]) -&gt; List[int]: q = collections.deque(sorted(A)) ans = [0] * len(A) B = reversed(sorted((b, i) for i, b in enumerate(B))) for b, i in B: if q[-1] &lt;= b: ans[i] = q.popleft() else: ans[i] = q.pop() return ans 方法二：这个方法很新颖，把能赢的位置放到take中。然后A会剩下一部分，这部分顺序已经无所谓了，所以当take不到时，就从A随便返回一个就行了 123456def advantageCount(self, A: List[int], B: List[int]) -&gt; List[int]: A.sort() take = collections.defaultdict(list) for b in sorted(B, reverse=True): if b &lt; A[-1]: take[b].append(A.pop()) return [(take[b] or A).pop() for b in B] 861. Score After Flipping Matrix一个二维矩阵，可以按行，列翻转，问最大每行和是多少。原题12345Input: [[0,0,1,1],[1,0,1,0],[1,1,0,0]]Output: 39Explanation:Toggled to [[1,1,1,1],[1,0,0,1],[1,1,1,1]].0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39 方法一：贪心，首先保证行首位是1，然后列翻转时保证多余一半1. 123456789def matrixScore(self, A: 'List[List[int]]') -&gt; 'int': m, n = len(A), len(A[0]) for i in range(m): if A[i][0] == 0: A[i] = [A[i][j]^1 for j in range(n)] ans = 0 for i, cols in enumerate(list(zip(*A))[::-1]): ans += 2**i * max(sum(cols), m-sum(cols)) return ans 方法二：Lee215的方法。首先保证行首是1，但是并没有实际翻过来，后序通过跟行首比较，判断翻过后的值。 1234567def matrixScore(self, A: List[List[int]]) -&gt; int: M, N = len(A), len(A[0]) ans = (1 &lt;&lt; N-1) * M for j in range(1, N): cur = sum(A[i][j]==A[i][0] for i in range(M)) ans += max(cur, M-cur) * (1 &lt;&lt; N-1-j) return ans 452. Minimum Number of Arrows to Burst Balloons有很多个气球绑在了水平线上，给了这些气球的start, end表示和水平线相交的点。问最少需要多少个飞镖才能将所有气球扎坏。12345678Input:[[10,16], [2,8], [1,6], [7,12]]Output:2Explanation:One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons). 方法一：贪心法，尽量扎多点。 123456789def findMinArrowShots(self, points: List[List[int]]) -&gt; int: ans = 0 points.sort(key=lambda x: x[1], reverse=True) while points: ans += 1 s, e = points.pop() while points and points[-1][0]&lt;=e: points.pop() return ans 方法二：for循环也可以。 1234567def findMinArrowShots(self, points: List[List[int]]) -&gt; int: ans, e = 0, float('-inf') for start, end in sorted(points, key=lambda x:x[1]): if start &gt; e: ans += 1 e = end return ans 1589. Maximum Sum Obtained of Any Permutation说要查询某一段，进行n次查询，问将数组如何排列能使线段的总和最大。方法一：这题竞赛时没做出来，心态崩了。不知道怎么构造一个对线段的计数，用Counter超时了。剩下的一小时就是拼命地构造一个不重复的线段tuple，最后也没完成。正确的思路是这样的，在线段的起点+1，结束点后一位-1，这样在累加的时候就会把这段1都算出来。 1234567891011121314def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -&gt; int: n = len(nums) imos = [0] * (n + 1) for l, r in requests: imos[l] += 1 imos[r + 1] -= 1 for i in range(n): imos[i+1] += imos[i] del imos[-1] ans = 0 for i, v in zip(sorted(nums), sorted(imos)): ans += i * v ans %= 10 ** 9 + 7 return ans]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次淘宝接口sign签名破解]]></title>
    <url>%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%B7%98%E5%AE%9D%E6%8E%A5%E5%8F%A3sign%E7%AD%BE%E5%90%8D%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[淘宝H5页面接口Sign签名破解前言：由于公司业务需求，需要显示淘宝商品详情页面的图文详情部分。之前原业务逻辑是根据https://world.taobao.com/item/{num_iid}.htm，在得到html文本后全量通过图片前缀名如https://img.alicdn.com/imgextra进行抓取，返回给客户端。 由于header中的UA传的一个PC端的UA，所以获取的H5数据中，可能含有一些广告，商家之类自己的布局，从而无法在客户端正常展示。另一方面，该接口为高频接口，打开htm页面每次耗时70~80%，严重影响客户端体验，所以对此将接口进行升级。 后来发现手机上打开该页面是不显示一些无关的广告的，而且布局也正常。于是将UA改为了手机端的UA，然后通过抓包分析，返回的页面是一个不包含图片的html，图文详情是根据js接口调用动态渲染。接口为https://h5api.m.taobao.com/h5/mtop.wdetail.getitemdescx/4.9/?jsv=2.4.11&amp;appKey=12574478&amp;t=1544165283634&amp;sign=c691925755f2ff429c950f7b00903a23&amp;api=mtop.wdetail.getItemDescx&amp;v=4.9&amp;type=jsonp&amp;dataType=jsonp&amp;callback=mtopjsonp6&amp;data=%7B%22item_num_id%22%3A%22554401452734%22%7D。看到参数中包含了sign，所以是根据某种规则算出来的签名。 接着就是找到sign的签名算法了，将页面中的js格式化了一下。找到关于sign签名的部分。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107s.prototype.__processRequestUrl = function(n) &#123; &#123;var e = this.params, r = this.options; if (r.hostSetting &amp;&amp; r.hostSetting[t.location.hostname]) &#123; var o = r.hostSetting[t.location.hostname]; o.prefix &amp;&amp; (r.prefix = o.prefix), o.subDomain &amp;&amp; (r.subDomain = o.subDomain), o.mainDomain &amp;&amp; (r.mainDomain = o.mainDomain) &#125; if (!0 === r.H5Request) &#123; var i = "//" + (r.prefix ? r.prefix + ".": "") + (r.subDomain ? r.subDomain + ".": "") + r.mainDomain + "/h5/" + e.api.toLowerCase() + "/" + e.v.toLowerCase() + "/", a = e.appKey || ("waptest" === r.subDomain ? "4272": "12574478"), c = (new Date).getTime(), u = function(t) &#123; function n(t, n) &#123; return t &lt;&lt; n | t &gt;&gt;&gt; 32 - n &#125; function e(t, n) &#123; var e, r, o, i, a; return o = 2147483648 &amp; t, i = 2147483648 &amp; n, a = (1073741823 &amp; t) + (1073741823 &amp; n), (e = 1073741824 &amp; t) &amp; (r = 1073741824 &amp; n) ? 2147483648 ^ a ^ o ^ i: e | r ? 1073741824 &amp; a ? 3221225472 ^ a ^ o ^ i: 1073741824 ^ a ^ o ^ i: a ^ o ^ i &#125; function r(t, r, o, i, a, c, u) &#123; return e(n(t = e(t, e(e(function(t, n, e) &#123; return t &amp; n | ~t &amp; e &#125; (r, o, i), a), u)), c), r) &#125; function o(t, r, o, i, a, c, u) &#123; return e(n(t = e(t, e(e(function(t, n, e) &#123; return t &amp; e | n &amp; ~e &#125; (r, o, i), a), u)), c), r) &#125; function i(t, r, o, i, a, c, u) &#123; return e(n(t = e(t, e(e(function(t, n, e) &#123; return t ^ n ^ e &#125; (r, o, i), a), u)), c), r) &#125; function a(t, r, o, i, a, c, u) &#123; return e(n(t = e(t, e(e(function(t, n, e) &#123; return n ^ (t | ~e) &#125; (r, o, i), a), u)), c), r) &#125; function c(t) &#123; var n, e = "", r = ""; for (n = 0; 3 &gt;= n; n++) e += (r = "0" + (t &gt;&gt;&gt; 8 * n &amp; 255).toString(16)).substr(r.length - 2, 2); return e &#125; var u, s, f, l, p, d, h, v, m, g; for (g = function(t) &#123; for (var n, e = t.length, r = e + 8, o = 16 * ((r - r % 64) / 64 + 1), i = new Array(o - 1), a = 0, c = 0; e &gt; c;) a = c % 4 * 8, i[n = (c - c % 4) / 4] = i[n] | t.charCodeAt(c) &lt;&lt; a, c++; return a = c % 4 * 8, i[n = (c - c % 4) / 4] = i[n] | 128 &lt;&lt; a, i[o - 2] = e &lt;&lt; 3, i[o - 1] = e &gt;&gt;&gt; 29, i &#125; (t = function(t) &#123; t = t.replace(/\r\n/g, "\n"); for (var n = "", e = 0; e &lt; t.length; e++) &#123; var r = t.charCodeAt(e); 128 &gt; r ? n += String.fromCharCode(r) : r &gt; 127 &amp;&amp; 2048 &gt; r ? (n += String.fromCharCode(r &gt;&gt; 6 | 192), n += String.fromCharCode(63 &amp; r | 128)) : (n += String.fromCharCode(r &gt;&gt; 12 | 224), n += String.fromCharCode(r &gt;&gt; 6 &amp; 63 | 128), n += String.fromCharCode(63 &amp; r | 128)) &#125; return n &#125; (t)), d = 1732584193, h = 4023233417, v = 2562383102, m = 271733878, u = 0; u &lt; g.length; u += 16) s = d, f = h, l = v, p = m, h = a(h = a(h = a(h = a(h = i(h = i(h = i(h = i(h = o(h = o(h = o(h = o(h = r(h = r(h = r(h = r(h, v = r(v, m = r(m, d = r(d, h, v, m, g[u + 0], 7, 3614090360), h, v, g[u + 1], 12, 3905402710), d, h, g[u + 2], 17, 606105819), m, d, g[u + 3], 22, 3250441966), v = r(v, m = r(m, d = r(d, h, v, m, g[u + 4], 7, 4118548399), h, v, g[u + 5], 12, 1200080426), d, h, g[u + 6], 17, 2821735955), m, d, g[u + 7], 22, 4249261313), v = r(v, m = r(m, d = r(d, h, v, m, g[u + 8], 7, 1770035416), h, v, g[u + 9], 12, 2336552879), d, h, g[u + 10], 17, 4294925233), m, d, g[u + 11], 22, 2304563134), v = r(v, m = r(m, d = r(d, h, v, m, g[u + 12], 7, 1804603682), h, v, g[u + 13], 12, 4254626195), d, h, g[u + 14], 17, 2792965006), m, d, g[u + 15], 22, 1236535329), v = o(v, m = o(m, d = o(d, h, v, m, g[u + 1], 5, 4129170786), h, v, g[u + 6], 9, 3225465664), d, h, g[u + 11], 14, 643717713), m, d, g[u + 0], 20, 3921069994), v = o(v, m = o(m, d = o(d, h, v, m, g[u + 5], 5, 3593408605), h, v, g[u + 10], 9, 38016083), d, h, g[u + 15], 14, 3634488961), m, d, g[u + 4], 20, 3889429448), v = o(v, m = o(m, d = o(d, h, v, m, g[u + 9], 5, 568446438), h, v, g[u + 14], 9, 3275163606), d, h, g[u + 3], 14, 4107603335), m, d, g[u + 8], 20, 1163531501), v = o(v, m = o(m, d = o(d, h, v, m, g[u + 13], 5, 2850285829), h, v, g[u + 2], 9, 4243563512), d, h, g[u + 7], 14, 1735328473), m, d, g[u + 12], 20, 2368359562), v = i(v, m = i(m, d = i(d, h, v, m, g[u + 5], 4, 4294588738), h, v, g[u + 8], 11, 2272392833), d, h, g[u + 11], 16, 1839030562), m, d, g[u + 14], 23, 4259657740), v = i(v, m = i(m, d = i(d, h, v, m, g[u + 1], 4, 2763975236), h, v, g[u + 4], 11, 1272893353), d, h, g[u + 7], 16, 4139469664), m, d, g[u + 10], 23, 3200236656), v = i(v, m = i(m, d = i(d, h, v, m, g[u + 13], 4, 681279174), h, v, g[u + 0], 11, 3936430074), d, h, g[u + 3], 16, 3572445317), m, d, g[u + 6], 23, 76029189), v = i(v, m = i(m, d = i(d, h, v, m, g[u + 9], 4, 3654602809), h, v, g[u + 12], 11, 3873151461), d, h, g[u + 15], 16, 530742520), m, d, g[u + 2], 23, 3299628645), v = a(v, m = a(m, d = a(d, h, v, m, g[u + 0], 6, 4096336452), h, v, g[u + 7], 10, 1126891415), d, h, g[u + 14], 15, 2878612391), m, d, g[u + 5], 21, 4237533241), v = a(v, m = a(m, d = a(d, h, v, m, g[u + 12], 6, 1700485571), h, v, g[u + 3], 10, 2399980690), d, h, g[u + 10], 15, 4293915773), m, d, g[u + 1], 21, 2240044497), v = a(v, m = a(m, d = a(d, h, v, m, g[u + 8], 6, 1873313359), h, v, g[u + 15], 10, 4264355552), d, h, g[u + 6], 15, 2734768916), m, d, g[u + 13], 21, 1309151649), v = a(v, m = a(m, d = a(d, h, v, m, g[u + 4], 6, 4149444226), h, v, g[u + 11], 10, 3174756917), d, h, g[u + 2], 15, 718787259), m, d, g[u + 9], 21, 3951481745), d = e(d, s), h = e(h, f), v = e(v, l), m = e(m, p); return (c(d) + c(h) + c(v) + c(m)).toLowerCase() &#125; (r.token + "&amp;" + c + "&amp;" + a + "&amp;" + e.data), s = &#123; jsv: "2.4.11", appKey: a, t: c, sign: u &#125;, f = &#123; data: e.data, ua: e.ua &#125;; Object.keys(e).forEach(function(t) &#123; "undefined" == typeof s[t] &amp;&amp; "undefined" == typeof f[t] &amp;&amp; "headers" !== t &amp;&amp; "ext_headers" !== t &amp;&amp; "ext_querys" !== t &amp;&amp; (s[t] = e[t]) &#125;), e.ext_querys &amp;&amp; Object.keys(e.ext_querys).forEach(function(t) &#123; s[t] = e.ext_querys[t] &#125;), r.getJSONP ? s.type = "jsonp": r.getOriginalJSONP ? s.type = "originaljsonp": (r.getJSON || r.postJSON) &amp;&amp; (s.type = "originaljson"), "undefined" != typeof e.valueType &amp;&amp; ("original" === e.valueType ? r.getJSONP || r.getOriginalJSONP ? s.type = "originaljsonp": (r.getJSON || r.postJSON) &amp;&amp; (s.type = "originaljson") : "string" === e.valueType &amp;&amp; (r.getJSONP || r.getOriginalJSONP ? s.type = "jsonp": (r.getJSON || r.postJSON) &amp;&amp; (s.type = "json"))), !0 === r.useJsonpResultType &amp;&amp; "originaljson" === s.type &amp;&amp; delete s.type, r.dangerouslySetProtocol &amp;&amp; (i = r.dangerouslySetProtocol + ":" + i), r.querystring = s, r.postdata = f, r.path = i &#125; n()&#125;,&#125; 看到这里应该是一个加密后的js，后来找到一篇文章。淘宝sign加密算法。根据抓包的参数，按照公式来计算sign，验证算法是否正确。可能由于时间戳没有取整，或者一些其他的原因如编码问题等，导致sign的值没有和正确值对上，又看到文中贴的代码比我找到的js更加简单，以为淘宝更新了算法。再后来一位知友提示说算法没有问题，（在此特别感谢知友Jaho及文章作者小歪）才又抓包试了一次，这次将毫秒时间戳转为了int，并将字符串进行utf8编码，算出来的sign值和抓包中的匹配。后来证实通过js断点调试也可以验证公式的正确性。sign生成公式为：md5Hex(token&amp;t&amp;appKey&amp;data)t表示毫秒时间戳，appKey一般为固定值。data为参数。本文中的例子为6b2310e47a950f1c8c3fe6ec792f356a&amp;1544165283634&amp;12574478&amp;{&quot;item_num_id&quot;:&quot;554401452734&quot;}再进行md5转换。 知道了sign算法，接下来就是token的获取，根据知乎文中作者所说，第一次请求是会设置cookie，于是使用Postman清理cookie后请求，此时sign的值传任何值均无影响，接口会返回 123456mtopjsonp2(&#123; "api": "mtop.wdetail.getItemDescx", "v": "4.9", "ret": ["FAIL_SYS_TOKEN_EXOIRED::令牌过期"], "data": &#123;&#125;&#125;) 并设置两个cookie，一个是_m_h5_tk值为6b2310e47a950f1c8c3fe6ec792f356a_1544173923544，另一个是_m_h5_tk_enc，这个目前用不到，我们要的token就是前者_分割的前部分。这样一来，我们请求两次接口，第一次拿到token，第二次请求拿到数据。 123456789101112131415161718192021222324252627282930313233343536&#123; "api": "mtop.wdetail.getItemDescx", "data": &#123; "pages": [ "&lt;txt&gt;特别提醒：此款收纳箱尺寸测量方法：（盖上盖子测量长宽高）长度=盖子+把手。手工量的，稍许误差，谢谢谅解！ 注意：不要把本店的L数跟超市的比较，本店的L数是网上笼统的叫法，以箱子实际尺寸为主，介意的亲请勿拍！建议：店长推荐拍套装几个套在一起 可以抗摔 。。10L不建议购买只能装一些小东西人工测量会有2cm左右误差属于正常现象温馨提醒：塑料属于易碎品，为了免去亲的麻烦，请亲在收货时先拆开检查后在签收，如有破损请直接拒收&lt;/txt&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i3/2651141793/TB2kQKqbgsSMeJjSspcXXXjFXXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i1/2651141793/TB2UkPszC8mpuFjSZFMXXaxpVXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i3/2651141793/TB2dJSBzstnpuFjSZFKXXalFFXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i4/2651141793/TB2U3i5zxxmpuFjSZFNXXXrRXXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i1/2651141793/TB22qfEzr4npuFjSZFmXXXl4FXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i2/2651141793/TB2_8HcvbJkpuFjy1zcXXa5FFXa_!!2651141793.jpg&lt;/img&gt;", "&lt;img&gt;https://img.alicdn.com/imgextra/i1/2651141793/TB2f7YszC8mpuFjSZFMXXaxpVXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i3/2651141793/TB2B600zrBnpuFjSZFGXXX51pXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i4/2651141793/TB2C.HmvgFkpuFjSspnXXb4qFXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i3/2651141793/TB25AYszC8mpuFjSZFMXXaxpVXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i3/2651141793/TB2Tt1BzstnpuFjSZFKXXalFFXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i3/2651141793/TB2FNPgvgxlpuFjSszbXXcSVpXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i2/2651141793/TB26j40zrBnpuFjSZFGXXX51pXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i4/2651141793/TB2uDGozCVmpuFjSZFFXXcZApXa_!!2651141793.jpg&lt;/img&gt;", "&lt;img&gt;https://img.alicdn.com/imgextra/i1/2651141793/TB2Bx9ntxRDOuFjSZFzXXcIipXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i2/2651141793/TB2nSblvm0jpuFjy0FlXXc0bpXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i2/2651141793/TB2wtaQvbXlpuFjSszfXXcSGXXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i4/2651141793/TB2k1vfvl4lpuFjy1zjXXcAKpXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i1/2651141793/TB26HbQvbFkpuFjy1XcXXclapXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i3/2651141793/TB24miYzypnpuFjSZFIXXXh2VXa_!!2651141793.jpg&lt;/img&gt;&lt;txt&gt;.................welcome20160618152824&lt;/txt&gt;" ], "images": [ "https://img.alicdn.com/imgextra/i3/2651141793/TB2kQKqbgsSMeJjSspcXXXjFXXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i1/2651141793/TB2UkPszC8mpuFjSZFMXXaxpVXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i3/2651141793/TB2dJSBzstnpuFjSZFKXXalFFXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i4/2651141793/TB2U3i5zxxmpuFjSZFNXXXrRXXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i1/2651141793/TB22qfEzr4npuFjSZFmXXXl4FXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i2/2651141793/TB2_8HcvbJkpuFjy1zcXXa5FFXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i1/2651141793/TB2f7YszC8mpuFjSZFMXXaxpVXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i3/2651141793/TB2B600zrBnpuFjSZFGXXX51pXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i4/2651141793/TB2C.HmvgFkpuFjSspnXXb4qFXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i3/2651141793/TB25AYszC8mpuFjSZFMXXaxpVXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i3/2651141793/TB2Tt1BzstnpuFjSZFKXXalFFXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i3/2651141793/TB2FNPgvgxlpuFjSszbXXcSVpXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i2/2651141793/TB26j40zrBnpuFjSZFGXXX51pXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i4/2651141793/TB2uDGozCVmpuFjSZFFXXcZApXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i1/2651141793/TB2Bx9ntxRDOuFjSZFzXXcIipXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i2/2651141793/TB2nSblvm0jpuFjy0FlXXc0bpXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i2/2651141793/TB2wtaQvbXlpuFjSszfXXcSGXXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i4/2651141793/TB2k1vfvl4lpuFjy1zjXXcAKpXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i1/2651141793/TB26HbQvbFkpuFjy1XcXXclapXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i3/2651141793/TB24miYzypnpuFjSZFIXXXh2VXa_!!2651141793.jpg" ] &#125;, "ret": [ "SUCCESS::接口调用成功" ], "v": "4.9"&#125; 其中的images数组就是我想要的数据，这里返回值不是标准的json，套了一层mtopjsonp2({JSON})，于是获取结果后还要根据正则截取一下json的文本。 附上部分相关代码，python版本 123456789101112131415161718192021222324252627282930313233343536def get_images_from_mtop(num_iid): APPKEY = '12574478' DATA = '&#123;"item_num_id":"%s"&#125;' % num_iid URL = 'https://h5api.m.taobao.com/h5/mtop.wdetail.getitemdescx/4.9/' params = &#123;'jsv': '2.4.11', 'appKey': APPKEY, 't': int(time.time()*1000), 'sign': 'FAKE_SIGN_WITH_ANYTHING', 'api': 'mtop.wdetail.getItemDescx', 'v': '4.9', 'type': 'jsonp', 'dataType': 'jsonp', 'callback': 'mtopjsonp2', 'data': DATA&#125; headers = &#123; 'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 9_3_4 like Mac OS X) AppleWebKit/601.1.46 ' + \ '(KHTML, like Gecko) Version/9.0 Mobile/13G35 Safari/601.1', &#125; images = [] try: # get token in first request r1 = requests.get(URL, params=params, headers=headers) token_with_time = r1.cookies.get('_m_h5_tk') token = token_with_time.split('_')[0] enc_token = r1.cookies.get('_m_h5_tk_enc') logger.debug(r1.cookies) # get results in second request t2 = str(int(time.time() * 1000)) c = '&amp;'.join([token, t2, APPKEY, DATA]) m = hashlib.md5() m.update(c.encode('utf-8')) params.update(&#123;'t': t2, 'sign': m.hexdigest()&#125;) cookies = &#123;'_m_h5_tk': token_with_time, '_m_h5_tk_enc': enc_token&#125; r2 = requests.get(URL, params=params, headers=headers, cookies=cookies) logger.debug(r2.text) json_text = re.match(r'(.*\()(.*)(\))', r2.text).group(2) images = dict(json.loads(json_text))['data']['images'] except Exception as e: logger.warning(e) finally: return images 可以看到，接口响应时间有了大幅度提升。]]></content>
      <categories>
        <category>逆向工程</category>
      </categories>
      <tags>
        <tag>Sign签名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Web API 的设计与开发》读后总结]]></title>
    <url>%2F%E3%80%8AWeb-API-%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BB%E5%90%8E%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言此书为[日]水野贵明著，之前已经通读了一遍，收获不少，为了复习与总结，这里便整理一份笔记，以便忘记的时候查找。 第一章：什么是Web APIREST与Web APIREST一词经常以”REST API”的形式出现。一般而言，人们认为它是指”能够通过HTTP协议进行访问，得到XML或JSON格式的返回数据的API”。而REST一词一般是有两种意思： 符合REST架构风格的Web服务系统。 符合RPC风格的XML(or JSON)+HTTP接口的系统（不适用SOAP）。 书中的API设计思想侧重于第2条，旨在API更加亲切易懂，比如搜索操作时，没有在URI中强制使用名词，而是使用search；在URI中添加版本号，而不是Header中。 LSUD vs SSKD LSUD(Large Set of Unknown Developers) SSKD(Small Set of Known Developers)，有时使用REST这种基于资源的思维方式不能完全满足需求，还需要引入策略编排层这样的思维方式。 第二章：端点的设计与请求的形式端点的概念：在Web API的语境里，端点是指用于访问的API的URI。 端点的设计规范： 短小便于输入 http://api.example.com/service/api/search不如http://api.example.com/search，不应该出现重复的词，也不应该使用service这种含义过于广泛的词。 人可以读懂 不要使用缩写，甚至将products缩写为prod，即使是SSKD，也应尽量减少缩写。 合适的语义，使用合适的单词，拼写错误是不应该出现的。 不能大小写混用 修改方便 如/items/12346，明显修改12346就可以查看其它商品信息。 不会暴露服务端的架构 比如，php或jsp结尾。 规则统一 URI采用一致的风格 HTTP方法和端点URI和HTTP的关系可以认为是操作对象和操作方法的关系。如果把URI当做API(HTTP)的“操作对象=资源”，HTTP方法则表示“进行怎样的操作”。 GET 表示获取信息，最为常用。一般不会修改已有资源（已读/未读，最后访问日期等属性属于例外）。 POST 一般认为POST方法用于更新信息，其实这样的理解存在一些偏差。POST方法的初衷是用于向服务器注册新建的资源。信息的更新和删除等操作应使用其他HTTP方法。由于HTML4.0的表单中method属性只支持GET和POST两种方法，因此使用表单从浏览器提交信息时，以及更新删除，都使用POST方法了。虽然在HTML5的草案中加入了表单允许使用PUT以及DELETE方法的规范，但最终还是讲该内容删除了。由于Web API基本不涉及表单通过浏览器进行访问，所以一般使用PUT和DELETE更容易理解。 PUT 和POST方法相同，都可用与对服务端的信息进行更新，但二者URI的指定方式有所不同。POST方法发送的数据“附属”于指定的URI，附属表示从属URI之下。以文件系统为例，把文件放入目录后，文件就成了目录的附属部分。虽然HTTP协议定义了当所指定的资源不存在时，可以通过PUT操作发送数据，生成心得资源，但Web API一般只用PUT方法来更新数据，而一般会使用POST来生成新的资源。PUT会用发送的数据完全替换原有的资源信息，如果只是更新资源的某部分数据，可以使用PATCH方法来实现。 DELETE 删除资源。 PATCH PATCH和PUT相同，用于更新指定的资源。在数据量较高的情况下，会有显著的效果。 X-HTTP-Method-Override由于HTML的表单规范只支持GET和POST，或是其它开发客户端中只能有GET和POST。所以要利用POST方法将真正想要使用的HTTP方法以元数据信息的形式发送给服务器。有两种方式： 通过名为X-HTTP-Method-Override的Header来实现，推荐使用。 123POST /v1/users/123 HTTP/1.1Host: api.example.comX-HTTP-Method-Override: DELETE 通过传递表单参数_method来实现。 user=testuser&amp;_method=PUT使用application/x-www-form-urlencodedMedia Type。 这里看了一下，Django没有支持这种功能，需要自己写中间件或者三方库来实现。django-method-override。而DRF这里的文档说，在3.3.0版本之前是支持的，后来将其从核心功能中移除。DRF文档。 动态相关的端点举例 目的 端点 方法 编辑动态信息 http://api.example.com/v1/updates/:id PUT 删除动态信息 http://api.example.com/v1/updates/:id DELETE 发表动态信息 http://api.example.com/v1/updates POST 获取特定用户的动态信息 http://api.example.com/v1/users/:id/updates GET 获取好友的动态列表 http://api.example.com/v1/users/:id/friends/updates GET 访问资源的端点设计注意事项 使用名词的复数形式 极力避免使用动词，因为HTTP协议原本就是用URI来表示资源，用HTTP方法来表示对资源所进行的操作。 注意所用的单词 多看大公司的开放API范例，查阅ProgrammableWeb，明白那些具有相近意义的单词哪个更加合适。 不适用空格及需要编码的字符 使用连接符-来连接多个单词 相对于驼峰发和蛇形法，这种脊柱法对于SEO更加友好。不过应尽量避免使用多个单词，而是使用路径划分，如popular_users不如users/popular，或者将一部分内容作为查询参数，让URI变得更短。 相对位置获取数据大分页时效率低下使用绝对位置，事先记录下当前已获得的数据里最后一条数据的ID、时间等信息，然后再指定“该ID之前的所有数据”或“该时刻之前的所有数据”。 查询参数还是使用路径？ 是否是表示唯一资源所需的信息，比如用户ID。 是否可以省略，如page等分页参数，一般都会设置默认值。 登录与OAuth2.0什么是OAuth?假设带有用户注册功能的在线服务A（Facebook）对外公开了API，在线服务B便可以使用这些在线服务A的API提供的各种功能。在这种情况下，当某个已在Facebook里注册的用户需要使用你的在线服务时，你的在线服务就回希望访问Facebook来使用该用户在Facebook中注册的信息。这时，判断是否允许你的在线服务使用该用户在Facebook里注册的信息的机制就是OAuth。 OAuth2.0里的4中类型的交互模式用于访问资源的许可，称为Grant Type。 Grant Type 作用 Authorization Code 适用于在服务端进行大量处理的Web应用 Implicit 适用于只能手机应用及使用JavaScript客户端进行大量处理的应用 Resource Owner Password Credentials 适用于不适用服务端（网站B）的应用 Client Credentials 适用于不以用户为单位来进行认证的应用 Resource 的模式能够应用于公司内部所开发的客户端应用中。 SSKD应用尽量减少API调用次数如首页包含“人气商品”，“推荐商品”，“用户信息”等信息，这样需要访问不同的API，效率很低，因此可以把应用主页所需要的显示信息归集到一个API中，提高了客户端的便捷性。为了完成一次任务需要多次访问API，这样的API设计叫“Chatty API”，不但会加大网络流量的消耗，还会增加客户端的处理工序。 HETEOAS和REST LEVEL3 API等级制度 LEVEL0：使用HTTP LEVEL1：引入资源概念 LEVEL2：引入HTTP动词 LEVEL3：引入HATEOAS概念 HETEOAS: (Hypermedia As The Engine Of Application State)，超媒体即应用状态引擎。意思就是在API返回的数据中包含下一步要执行的行为、要获取的数据等URI的链接信息，客户端只要看到这些信息，就能知道接下来需要访问什么端点，比如DRF中的下一页链接。 优点：使URI得更改变得容易。 面向SSKDs的API，需要根据实际需求采用。面向LSUDs的API，这个概念还没有得到广泛的普及。 第三章：响应数据的设计JSONP概念JSONP是一种将JSON传递给浏览器的方式，是JSON with Padding的缩写。一般形式如下： callback({&quot;id&quot;: 123, &quot;name&quot;: &quot;Saeed&quot;}) 留坑… 封装是否必要比如返回的格式为： 123456789&#123; "meta": &#123; "code": 0, "message": 'OK', &#125;, "data": &#123; ... &#125;&#125; 如果结构形式统一，在客户端就更容易抽象化处理。实际上由于封装的做法会显得冗长，并不值得实现。因为Web API基本上都是用HTTP协议，HTTP已经帮你完成了封装的工作。HTTP协议里引入首部的概念，在首部中可以放入各种数据信息，也可以通过状态码来确认无误地判断是否发生了某种错误等，并将更详细的错误信息放入HTTP首部返回。而如果对API数据进行封装，发生错误时，用户所获得的状态依然是200，这就无法通过状态码来判断处理是成功还是失败。这样的做法没有正确地运用好HTTP协议的机制。这可能会导致客户端的处理发生混乱，这种情况是无论如何都要明令禁止的。而且通用的HTTP客户端程序往往会首先根据状态码来判断请求的处理是否成功，如果出错时返回200，客户端就无法利用通用的错误分类，增加处理负担。 扁平化还是层级？Google的JSON Style Guide使用了模棱两可的陈述：“虽然要尽可能使用扁平化方式，但在某些情况下使用层级形式反而更容易理解。” 情景一： 层级 123456789101112&#123; "id": 3342124, "message": "Hi!", "sender": &#123; "id": 3456, "name": "Tom" &#125;, "receiver": &#123; "id": 12877, "name": "Bob" &#125;&#125; 扁平化 12345678&#123; "id": 3342124, "message": "Hi!", "sender_id": 3456, "sender_name": "Tom", "receiver_id": 12877, "receiver_name": "Bob"&#125; 其中”sender”和”receiver”描述了相同的用户这一数据结构，因此层级形式较好，因为客户端可以将各个数据作为用户这一相同的数据来处理。 情景二： 层级 12345678&#123; "id": 2345, "name": "Tom", "profile": &#123; "birthday": 3322, "gender": "male" &#125;&#125; 扁平化 123456&#123; "id": 2345, "name": "Tom", "birthday": 3322, "gender": "male"&#125; 这种情况，层级导致JSON数据尺寸变大，而且两者看起来没有什么区别，所以应该扁平化。 序列与格式比如一个好友列表的URI /friends 序列原封不动返回 12345678910[ &#123; "id": 234, "name": "Tom" &#125;, &#123; "id": 235, "name": "Bob" &#125;] 用对象进行封装 123456789101112&#123; "friends": [ &#123; "id": 234, "name": "Tom" &#125;, &#123; "id": 235, "name": "Bob" &#125; ]&#125; 看上去第二种方式显得有些冗余，因为URI中已经使用了”friends”来表示好友。而且又显得冗长。但是这样写有三个优点： 更容易理解响应数据表示什么 响应数据通过对象封装实现了结构统一 顶层数据不会根据API的不同而不同，客户端无需适配序列或是对象，免除麻烦。 可以避免安全方面的风险 顶层数据中使用JSON序列，可能会导致名为JSON注入的安全隐患，风险很大。 返回数据的个数返回数据的名称 使用多数API中使用的表示相同含义的单词 通过尽可能少的单词来表示 比如注册时间registrationDateTime不如registeredAt 使用多个单词时，整个API中连接单词的方法要统一 一般使用驼峰法 尽可能不用奇怪的缩略语 注意单复数形式 日期的格式 格式名 示例 RFC 822 Sun, 06 Nov 1994 08:49:37 GMT RFC 850 Sunday, 06-Nov-94 08:49:37 GMT ANSI C的asctime()格式 Sun Nov 6 08:49:37 1994 RFC 3339 2015-10-12T11:30:22+09:00 Unix 时间戳（epoch）秒 1396821803 一般采用RFC 3339格式。如果考虑国际化产品，则推荐使用”+00:00”。在RFC 3339中使用UTC时，可以通过”Z”来标记。2015-11-02T13:00:12+00:00 == 2015-11-02T13:00:12Z。如果是”-00:00”，则表示时区不明。 如果面向SSKD，也可使用Unix时间戳，因为其易于保存和比较，不过会调试稍微麻烦。 有时需要在HTTP首部添加时间，这个格式不支持RFC 3339，只支持上表中的前三项。 详细的出错信息状态码属于通用的错误描述，在表示同各个API的内容相关的错误时显得力不从心。所以要返回额外的错误信息。 一种是通过首部返回 123X-MYNAME-ERROR-CODE: 2013X-MYNAME-ERROR-MESSAGE: Bad authentication tokenX-MYNAME-ERROR-INFO: http://docs.example.com/api/vi/authentication 将出错信息放入消息体 1234567&#123; "error": &#123; "code": 2013, "message": "Bad authentication token", "info": "http://docs.example.com/api/vi/authentication" &#125;&#125; 对于客户端来说第二种消息体的方案比较容易处理，所以优先选择后者。错误码一般4位与HTTP状态码区分，1字头表示通用错误，2字头表示用户错误等。有时提示信息里同时包含面向非开发人员和开发人员的信息。 12345678&#123; "error": &#123; "developerMessage": "面向开发人员信息", "userMessage": "面向用户的信息", "code": 2013, "info": "http://docs.example.com/api/vi/authentication" &#125;&#125; 有时程序返回500、503或404等错误时，默认会返回HTML或者是ContentType: text/plain格式的信息，会导致客户端崩溃等问题。所以即使这种情况下，服务端应该努力保证发生错误、负载过高、访问的端点不存在等情况下也能以合适的格式返回数据。 如果服务端不得已进行维护返回503状态码的同时，还应该返回Retry-After来告知客户端重试的时间。 12503 Service Temporarily UnavailableRetry-After Mon, 2 Dec 2013 03:00:00 GMT 需要返回意义不明确的信息时比如用户在登录时需要输入邮箱和密码，如果登录失败，返回邮箱不存在还是返回邮箱存在但密码错误，还是返回用户已冻结？虽然详细信息对于用户而言显得非常友好，但从另一方面来说，也为非法登录和爬虫提供了友好的信息。所以服务端在这种情况下一般只提供非常少量的信息，让无法正常登陆的用户通过重置密码等手段重新登录。不过这样不太方便调试，所以也可将逻辑分开，在开发时返回详尽信息，生产环境返回不明确的信息。 第四章：最大程度地利用HTTP协议使用HTTP协议规范的意义HTTP协议等很多互联网协议都是由名为RFC的规范文档来定义的。 正确使用状态码首位数字大概含义 状态码 含义 1字头 消息 2字头 成功 3字头 重定向 4字头 客户端原因引起的错误 5字头 服务端原因引起的错误 主要的HTTP状态码 状态码 名称 说明 200 OK 请求成功 201 Created 请求成功，新的资源已创建 202 Accepted 请求成功 204 No Content 没有内容 300 Multiple Choices 存在多个资源 301 Moved Permanently 资源被永久转移 302 Found 请求的资源被暂时转移 303 See Other 引用他出 304 Not Modified 自上一次访问后没有发生更新 307 Temporary Redirect 请求的资源被暂时转移 400 Bad Request 请求不正确 401 Unauthorized 需要认证 403 Forbidden 禁止访问 404 Not Found 没有找到指定的资源 405 Method Not Allowed 无法使用指定的方法 406 Not Acceptable 同Accept相关的首部里含有无法处理的内容 408 Request Timeout 请求在规定时间内没有处理结束 409 Conflict 资源存在冲突 410 Gone 指定的资源已不存在 413 Request Entity Too Large 请求消息体太大 414 Request-URI Too Long 请求的URI太长 415 Unsupported Media Type 不支持所指定的媒体类型 429 Too Many Requests 请求次数过多 500 Internal Server Error 服务器端发生错误 503 Service Unavailable 服务器暂时停止运行 状态码详解及使用场景： 2字头 成功 201 “Created” POST请求的场景，表示创建了一个资源，上传了图片，或是添加了用户。 202 “Accepted” 表示“Accepted”，在异步处理客户端请求时，它用来表示服务器端已接收了来自客户端的请求，但处理尚未结束。 通常的使用场景是文件格式转换、处理远程通知耗时的场景中。 以LinkedIn的参与群组讨论的API为例，我们知道如果成功参与讨论并发表意见，服务器通常会返回201；但如果需要得到 群主确认，所发表的意见就无法立即在页面上显示出来，这时服务器就需要返回202状态码。从广义上来看，也属于异步处理，但是与程序里所说的异步不是一个概念。 另外，使用Box的API来下载文件时，如果文件尚未准备好，服务器会返回202，还会在首部中添加Retry-After写入处理完成所需时间。 204 “No Content” 响应消息为空时会返回该状态码。 使用DELETE方法删除数据时。 关于204有一些争论，这里笔者给出的建议是PUT或PATCH请求时，服务端返回200并将数据同时返回，使用DELETE请求时，返回204。这样，无论在何种情况下，都可以从服务器端返回的数据得知修改操作正确执行。病情也能在PUT/PATCH操作后同时获得ETag信息。 这里有个疑问，实际业务中有时需要“假删除”，此时应该返回204还是200？ 3字头 添加必要的处理 常用来描述重定向操作。在定义了HTTP1.1的RFC 2068中，用于重定向的状态码只有301和302。301表示请求内容已从当前位置移动到了其他地方，而302则表示请求内容只是临时移动到了别处，而且使用的HTTP方法不会在访问重定向的URI时发生变化（如使用POST方法的话，在重定向后依然会使用POST方法来访问重定向的地址）。不过大部分浏览器却采用了与协议相反的设计，用GET方法来访问重定向后的地址。由于这个原因，在RFC 2616里，人们又新定义了303和307状态码。303定义了无论在重定向之前使用什么HTTP方法访问，都允许在请求完成后用GET方法继续访问。即便如此，现在依然有很多重定向操作会返回302状态码。另外RFC 7238里还定义了308状态码。307和308输入302和301的修正版，定义更加严密。302和301允许访问方法从POST变更为GET，307和308则不允许任何HTTP方法在访问过程中发生变更。 API中应极力避免返回重定向类状态码。 300 “Multiple Choices” 当有多个分支可供客户端选择时，服务端会返回该状态码。API使用场景可能性很低，在文件存储类服务里，对于客户端请求的某个键值，如果存在多个数据库，有时会返回该状态码。 304 “Not Modified” 表示客户端上次获取的数据至今为止没有发生更新。当服务端返回304时，整个响应消息体为空。 4字头 客户端请求发生问题 服务端无法理解客户端发送的请求，或虽然服务端能理解但请求没有被执行。 400 “Bad Request” 它表示“其他错误”，无法找到其它满足要求的状态码时返回，比如参数错误。 401 “Unauthorized” 表示认证（Authentication）类型的错误，“识别前来访问的是谁”。 403 “Forbidden” 表示授权（Authorization）类型的错误 ，“赋予特定用户执行特定操作的权限”。 404 “Not Found” 有时不明确是URI不存在还是资源不存在，所以一般会额外返回其它详细的说明。 405 “Method Not Allowed” 客户端使用的HTTP方法不被服务器端允许。 406 “Not Acceptable” API不支持客户端指定的数据格式时服务器端所返回的状态码。 408 “Request Timeout” 客户端发送请求至服务端所需的时间过长时，触发服务端的超时处理。 409 “Conflict” 状态码用于表示资源发生冲突时的错误。比如通过指定ID等唯一键值信息来调用注册功能的API，当这样的API创建数据时，倘若已有相同ID的数据存在，就回导致服务端返回409状态码告知客户端该邮箱地址或ID已被使用。 410 “Gone” 和404相同，表示资源不存在。只是410状态码表示资源曾经存在但目前已经消失了，因此服务端常在访问数据被删除时返回该状态码。但是为了该状态码，服务器必须保存数据已被删除的信息，有些邮箱地址搜索用户信息的API中，从保护个人信息的角度来说，返回410状态的做法会受到质疑。 413 “Request Entity Too Large” 和 414 “Request-URI Too Long” 413表示请求消息体过长，如上传文件过大。 414表示请求首部过长而引发的错误，如查询参数过长。 415 “Unsupported Media Type” 和406类似，表示服务器端不支持客户端请求首部Content-Type里指定的数据格式。区别在于，406一般和GET操作一起使用，415和POST、PUT以及PATCH等方法请求的消息体数据格式不被服务器端支持。例如在只接受JSON格式的请求的API里放入XML格式的数据并向服务器发送，或在Content-Type首部里指定application/xml，都会导致该类型的错误。 429 “Too Many Requests” 访问次数超过了所允许的范围。 5字头 服务器端发生问题 500 “Internal Server Error” 服务端代码存在bug，会返回该类型的错误。应该监控错误日志，防止再次发生。 503 “Service Unavailable” 服务端暂时不可用，服务器维护，或者自身负载过高。 缓存与HTTP协议规范HTTP协议中，缓存处于可用的状态时称为fresh（新鲜）状态，而处于不可用的状态时则称为stale（不新鲜）状态。 过期模型预先决定响应数据的保存期限，当到达期限后机会再次访问服务端来重新获得所需的数据。 一个方法是用Cache-Control响应首部，另一个使用Expires响应首部。 12Expires: Fri, 01 Jan 2016 00:00:00 GMTCache-Control: max-age=3600 Expires使用RFC 1123中定义的时间格式。HTTP1.0就存在，Cache-Control是HTTP1.1中定义的。有时需要制定一个遥远的日期，使得缓存始终生效，但HTTP1.1规定，不允许设置超过1年以上的时间。两者同时定义时，Cache-Control优先。max-age是根据首部中的Date算的。根据HTTP协议的规定，除了5字头错误等几个特殊情况以外，所有的HTTP消息都必须添加Date首部。描述日期的HTTP首部信息里，只能使用GMT（格林尼治标准时区）作为时区。 验证模型轮询当前保存的缓存数据是否为最新数据，并只在服务器端进行数据更新时，才重新获取新的数据。 虽然这么做没有减少网络通信的开销，但假设客户端缓存的数据过大，那么此时缓存的作用就体现出来了。这种方式，服务器需要知道“客户端当前保存的信息的状态”，为此需要用到更新日期或实体标签（Entity Tag）作为指标。两者分别填充在Last-Modified和ETag响应消息首部返回给客户端。 12Last-Modified: Tue, 01 Jul 2014 00:00:00 GMTEtag: &quot;jfkeiwjpii189u98jljdfioj822adf&quot; ETag如何生成取决于服务器端的实现。 客户端使用最后更新日期执行附带条件的请求时，会用到Modified-Since首部。使用实体标签时，会用到If-None-Match首部。 12GET /v1/users/12345If-Modified-Since: Tue, 01 Jul 2014 00:00:00 GMT 12GET /v1/users/12345If-None-Match: &quot;jfkeiwjpii189u98jljdfioj822adf&quot; 服务端检查是否有更新，如果有更新，则返回200和更新后的资源，同时添加最后更新日期或实体标签。未更新，则返回304，响应消息体为空。 如果使用验证模型，并且更新的资源是某个特定的资源，则返回资源自身的最后更新日期；如果是列表信息的多个资源的话，则要使用其中最后更新的资源的最后更新日期。Django中的Etag相关。 ETag有强验证和弱验证两个概念。 强验证ETag： Etag: &quot;jfkeiwjpii189u98jljdfioj822adf&quot;，服务端同客户端数据不能有一个字节的差别，必须完全一样。 弱验证ETag：Etag: W/&quot;jfkeiwjpii189u98jljdfioj822adf&quot;，只要从资源意义的角度来看没有发生变化，就可以视为相同的数据。例如Web页面的广告信息，虽然每次看到广告的内容会有所改变，但它们依然是相同的资源。 启发式过期客户端自己寻找服务端资源的规律，所以服务器如果不能返回“将缓存数据保存多久”的信息，那么应该返回Last-Modified等首部信息来告知客户端，努力减少客户端不必要的访问，这一点非常重要。 不希望实施缓存在实时性要求比较高的场景中，不希望客户端进行缓存。使用Cache-Control首部。 1Cache-Control: no-cache 除此之外，如果Expires首部里写入的过去的日期或不正确的日期格式，客户端也不会进行缓存操作。但不同浏览器可能发生不同的行为，所以此方法并不建议。 no-cache严格意义来讲，不是“不缓存”的意思，而是表示至少“需要使用验证模型来验证”。如果不希望含有机密信息的数据在代理服务器上保存，就可以在Cache-Control首部里使用no-store并返回。 使用Vary来指定缓存单位在实施缓存时可能还需要同时指定Vary首部。在实施缓存时，Vary用于指定除URI外使用哪个请求首部项目来确定唯一的数据。因为即使URI相同，获取的数据有时也会因请求首部内容的不同而发生变化。 HTTP里有这样一种机制：根据由Accept开始的一系列请求首部值的不同，响应消息的内容也会发生变化。该机制称为服务器驱动的内容协商。比如API可以通过支持Accept-Language首部指定客户端能接受的自然语言，并据此切换响应数据里包含的语言信息。这时可以使用Vary首部来判断哪个请求首部需要实施缓存操作。 1Vary: Accept-Language 一般而言，Vary首部用于HTTP经由代理服务器进行交互的场景，特别是在代理服务器拥有缓存功能时。但是有时服务器端无法知晓客户端的访问是否经由代理服务器，这种情况下就需要用到服务器驱动的内容协商机制，Vary首部就成了必选项。比如如果希望在查看用户代理（User Agent）信息后对返回的数据内容进行更新，就需要指定User-Agent首部。 1Vary: Accept-Language,User-Agent 在API中，返回的数据信息根据用户代理的不同而变化的情况非常少见，但我们仍需要考虑这样的情况：当使用智能手机对普通的Web页面进行访问时，即使URI相同，网站也需要返回和访问终端相匹配的内容。因此当Google的网络爬虫访问服务器端时，如果服务器端会根据URI以外的信息改变返回的内容，则推荐添加Vary首部。 Cache-Control 首部缓存操作指令及含义 指令名称 含义 public 代理服务器处保存的缓存可以在不同用户之间共享 private 每个用户的缓存数据必须各不相同 no-cache 缓存数据需要通过验证模型来确认 no-store 不需要进行缓存 no-transform 代理服务器不可变更响应数据的媒体类型或其他相关内容 must-revalidate 不管何时都需要向原始服务器进行再次验证 proxy-revalidate 代理服务器需要向原始服务器进行再次验证 max-age 表示缓存数据处于新鲜状态的时间 s-maxage 和max-age一样，但只用于中继服务器 通过stale-while-revalidate=600这样指定秒数，那么即使代理服务器超过了max-age指定的时间，其内部也能异步进行缓存验证，并指定在一定的时间内允许将缓存数据经由响应消息返回。换言之，在指定了max-age=600,stale-while-revalidate=600的情况下，虽然数据维持新鲜状态的时间只有10分钟，但在随后的10分钟内，缓存服务器也能处理来自客户端的请求，并将所保存的缓存数据直接返回给客户端。与此同时，代理服务器还会异步地向原始服务器发起缓存验证的询问。也就是说，客户端最长可以在20分钟内接收到缓存的数据，使得缓存的数据不会因为突然变得到期而不可用。另外，在缓存到期时，这样做还能异步地完成缓存的交互更新，从而更有效率地对客户端的访问做出响应。 由于某种原为无法访问原始服务器时，可以将stale-if-error指令指定为一定的秒数，允许在该段时间内代理服务器直接将所保存的不新鲜缓存返回给客户端。使用该指令的话，万一突发时间导致宕机，直接通过代理服务器和客户端交互，至少还能够在某段时间内不中断客户端的访问。 媒体类型的指定具有代表性的媒体类型，也就是Content-Type 媒体类型 数据格式 text/plain 纯文本 text/html HTML文件 application/xml XML文件 text/css CSS 文件 application/javascript JavaScript application/json JSON文件 application/rss+xml RSS域 application/atom+xml Atom域 application/octet-stream 二进制数据 application/zip zip文件 image/jpeg JPEG图像 image/png PNG图像 image/svg+xml SVG图像 multipart/form-data 多个数据组成的Web表单数据 video/mp4 MP4动画文件 application/vnd.ms-excel Excel文件 顶层类型名称中application和text非常容易混淆。比如XML文件的媒体类型由RFC 3023定义，根据该协议，text/xml媒体类型用于表示（没有XML背景知识的用户）能够理解的XML，而API返回的数据中应该不会存在这样的XML文件，因此使用application/xml更加合理。 除了由于历史原因而一直使用text作为顶层类型的text/css和text/html之外，某数据格式即使能够作为文本数据打开，但如果只有知道该数据格式的人才能理解，那么其媒体类型也依然需要用application作为顶层类型名称，这一方式已成为主流。 以x-开头的媒体类型如application/x-msgpack。表示该媒体类型尚未在IANA里注册。IANA(Internet Assigned Numbers Authority)是管理Internet相关编号的组织，还负责域名的管理、IP地址的分配等，在Internet领域承担了非常重要的职责。 没有在IANA里注册的并且以x-开头的媒体类型 媒体类型 数据格式 application/x-msgpack MessagePack application/x-yaml YAML application/x-plist 属性列表 但是有些媒体类型已在IANA注册，但在过去刚出现时，使用了x-开头。需要去查一下是否存在不以x-开头的替代类型。 这里有一个例外就是发送HTML表单数据时使用的application/x-www-form-urlencoded类型。该类型在RFC 1866中定义，虽然由于历史原因在命名时加上了x-，但确实IANA中正式注册的媒体类型，虽然有了不加x-的替代，但尚未被IANA采用。 自定义媒体类型根据不同的前缀区分 树名 前缀 Standards tree（标准树） 无 Vendor tree（供应商树） vnd Personal(Vanity) tree（个人树） prs. Unregistered tree（未注册树） x. 标准树指RFC进行了规范化后的媒体类型，如text/html那样，没有前缀。 供应商树下的数据格式虽然旨在大范围使用，但却由特定的企业、团体来管理。例如Excel文件由微软公司管理，媒体类型为application/vnd.ms-excel。可以这样定义application/vnd.companyname.awesomeformat，Excel由于名气大，所以省略了公司名。 个人树下的数据格式只在实验性质或未公开的产品等中使用。 未注册树下的数据格式一般用于本地环境和私有环境，一般供应商树和个人树基本涵盖未注册树所涉及的用例，因此不推荐这种类型。 请求数据与媒体类型 Content-Type 首部和相应消息首部一样，表示请求消息体是以怎样的数据格式发送给服务端的。如客户端发送POST请求时，如果以JSON的形式发送数据，就应该在首部里指定application/json；如果是从Web页面发送表单数据，就会使用application/x-www-form-urlencoded。进行表单操作时，如果有添加文件的情况，就要指定multipart/form-data。 Accept 此首部用于客户端向服务端表明能接受怎样的媒体类型。 Accept: text/html,application/xml;q=0.9,*/*;q=0.8 q表示品质因数（Quality Value），指定该媒体类型的优先级。默认为1，表示优先级最高。可以使用*/*表示所有的媒体类型。 在使用服务器驱动的内容协商确定返回的数据格式时，服务器端会在响应消息的Vary首部里指定Accept，根据Accept的值的不同，响应的详细也可能不同。 同源策略和跨域资源共享概念通过XHTTPRequest对不同的域进行访问将无法获取响应数据，这一原则称为同源策略。同源策略主要是出于安全方面的考虑，它只允许从相同的源来获取数据，并通过URI里的schema（http, https等）、主机（api.example.com）、端口号的组合来判断是否同源。由于JSONP有很多安全问题，所以制定了跨域资源共享（Cross-Origin Resource Sharing，CORS）的方式解决跨域访问的问题。 CORS基本的交互当实施CORS时，客户端要先发送一个名为Origin的请求消息首部。如从http://www.example.com/访问http://api/example.com/ 1Origin: http://www.example.com 服务器保存着允许访问的白名单，请求发送过来，会判断是否在白名单中。如果不在，则返回403；如果在，服务端会在Access-Control-Allow-Origin响应消息首部里放入和请求消息的Origin首部相同的源并返回，表示允许访问。 1Access-Control-Allow-Origin: http://www.example.com CORS与用户认证信息CORS中发送用户认证信息时，必须发布追加的HTTP响应消息首部。例如当客户端使用Cookie首部、Authentication首部发送用户认证信息时，服务器端需要像下面这样将Access-Control-Allow-Credentials首部设为true，来告知客户端“已识别所发送的认证信息”。 1Access-Control-Allow-Credentials: true 如果不这么做，浏览器会直接拒绝来自服务器的响应消息。 在各个浏览器的XHTTPRequest中，发送cookie等认证信息时，必须把withCredentials属性设为true，否则客户端将无法向服务器发送用户的认证信息。 私有的HTTP首部定义新的HTTP首部时，一般需要在最前面加X-，接着添加服务、应用、团体等名称。例如GitHub会通过X-GitHub-Request-Id的自定义首部来针对每个请求返回唯一的ID。 RFC 6648中建议不适用X-前缀，即目前的最佳方案，其定义的规则并不具备强制实施的效力。所以，用或不用，统一就好。 第五章：开发方便更改设计的Web API版本迭代： 在URI路径的开头添加形如v1的版本号，如果新API没有向下兼容，则新增版本号；如果是bug，增加build编号，如果向下兼容的变更或废除某些特定的功能，增加次版本号。 第六章：开发牢固的Web API中间人攻击（Man-In-The-Middle Attack, MITM攻击）使用HTTPS加密机制进行通信时，客户端会从服务端获得SSL证书，此时就要求客户端验证该证书的真伪。如果客户端未能执行验证工作，整个通信过程就有可能遭到中间人攻击，导致通信内容被窃取。 有时一些不含机密信息的API，可以直接使用HTTP而不使用HTTPS加密机制。虽然根据不同类别的API采用不同的方式略微有些复杂，但从降低访问延迟、提高响应速度的角度来说，无疑是行之有效的方法。 XSSXSS接收用户的输入内容并将其嵌入页面的HTML代码，当页面在浏览器里显示时，会自动执行用户输入的JavaScript脚本。一旦页面执行了用户输入的JavaScript脚本，攻击者就能够访问会话、cookie等浏览器里保存的信息，或者篡改页面，还能不受同源策略的限制进行跨域访问，从而完成任意操作。 如服务器返回 1&#123;"data": "&lt;script&gt;alert('xss');&lt;/script&gt;"&#125; 在Content-Type首部的值为text/html的情况下，如果浏览器直接访问该JSON数据的URI，该JSON数据会被解释为HTML，导致通过SCRIPT元素加载的JavaScript代码被浏览器执行。所以为了防范，需要让浏览器将JSON格式的数据只识别成JSON，响应首部添加 1Content-Type: application/json 但是IE会有一个Content Sniffering功能，根据实际的数据内容来推测数据格式。所以在返回JSON类型的数据时还应该添加 1X-Content-Type-Options: nosniff 这会使IE8以后的浏览器不再使用Content sniffering功能。 XSRF/CSRF(Cross Site Request Forgery)跨站点请求伪造。通过跨站点发送伪造的请求，让服务器执行用户意愿意外的处理。 常见例子：向公告板任意发帖，攻击站点以造成损失；恶意刷好评或差评。 防范： 禁止通过GET方法来修改服务端的数据，如添加收藏、公告板发帖等。这样一来，就无法用IMG元素等嵌入用于攻击的脚本了。 CSRF 令牌。 如果Web API只存在由XMLHTTPRequest或非浏览器客户端发起的访问，就要求客户端使用某种机制在请求附加一个特殊的首部，如果请求消息中不存在这一特殊的首部，就拒绝访问。如X-Request-With首部 JSON劫持未完待续。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>API</tag>
        <tag>RESTful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作中项目优化小记]]></title>
    <url>%2F%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言博主目前接手了一个项目，该项目代码从某马微店那里买来，社交金融相关。这个项目的代码可以说是逻辑混乱，毫无可重用性，而且又无文档，git message中一堆毫无用处的“update”，PEP8规范？不存在的。使得我每日游走在被代码劝退的边缘。震惊！一次请求1W多条sql。该功能为商品的热销分类表单。之前大概看了一眼，数据是先从redis中取，redis值存的永久有效，没有的话查DB。然后某天清了一下测试数据库的redis，这下好了，接口超时。查了一下silk发现运行了1w多次sql。 万恶之源的代码，难怪查了1W多次，这外键coupon，每次都要查询数据库。而且这里channel也没有用set，这简直基础数据结构都没掌握啊。 123456tbkcoupons = TbkCouponTags.objects.filter(is_hot=True)channel = []for t in tbkcoupons: cc = t.coupon.channel if cc not in channel: channel.append(cc) 使用select_related简单的处理了一下 12345tbkcoupons = TbkCouponTags.objects.select_related('coupon').filter(is_hot=True)channel = set()for t in tbkcoupons: cc = t.coupon.channel channel.add(cc) 快了10倍，冷静一下，思考一下这大哥到底要干嘛，后面看到拿到了tbkcoupons没有再做其他用处。所以这东西完全可以使用反向连接加去重来解决啊，看来sql基础也欠缺。这里改成了values+distinct来处理，因为mysql不支持distinct(‘channel’)这种指定字段的形式。 12tbkcoupons = TbkCoupon.objects.filter(tbkcoupontags__is_hot=True).values('channel').distinct()channels = [c['channel'] for c in tbkcoupons] 后面的逻辑判断，又使用了一堆的ifelse，看着不清晰，将其改为了字典。这些倒不是什么大问题。 最后，修改了一些取值的逻辑。最后将结果保存到了redis中。命中缓存的话大概10+ms。 后来又发现了一个有意思的事情，他好像也知道这个查询挺慢的，所以用celerybeat实现了一个周期任务，定时地更新这个redis。 返回按照当前查询数组顺序的queryset。遇见了这样一个需求 ，收藏列表需要返回按照收藏顺序的商品。而这个顺序保存在java后台。通过Thrift接口调用，返回了一个id列表，而商品保存在我这里。需要根据这个id的顺序返回queryset。django-get-a-queryset-from-array-of-ids-in-specific-order。 123from django.db.models import Case, Whenpreserved = Case(*[When(num_iid=num_iid, then=pos) for pos, num_iid in enumerate(num_iids)])TbkCoupon.objects.filter(num_iid__in=num_iids).order_by(preserved)]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Django-rest-framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（正则篇）regex]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%AD%A3%E5%88%99%E7%AF%87%EF%BC%89regex%2F</url>
    <content type="text"><![CDATA[193. Valid Phone Numbers使用bash命令在一行中提取一个文本中的手机号。原题 12345678910(xxx) xxx-xxxx or xxx-xxx-xxxx. (x means a digit).Assume that file.txt has the following content:987-123-4567123 456 7890(123) 456-7890Your script should output the following valid phone numbers:987-123-4567(123) 456-7890 1awk '/^([0-9]&#123;3&#125;-|\([0-9]&#123;3&#125;\) )[0-9]&#123;3&#125;-[0-9]&#123;4&#125;$/' telephone.txt]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Regex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 并行赋值]]></title>
    <url>%2FPython-%E5%A4%9A%E4%B8%AA%E5%8F%98%E9%87%8F%E5%90%8C%E6%97%B6%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[经常可以在Python看到这样的赋值语句 a, b, c = 1, 2, 3，其执行顺序先执行=右边的表达式，再依次将值赋给左边，Python解释器会将其组成为一个tuple，赋值的时候再unpack。 1234&gt;&gt;&gt; a, b = 2, 0&gt;&gt;&gt; a, b, a = 1, a, 4&gt;&gt;&gt; a, b(4, 2) 可以看到，上面是先把算出右边的值(1, 2, 4)再将其赋值给左边，最后a的值被修改成了4。 如果是可变的对象怎么办，LeetCode有一道经典的题，叫反转一个链表。要求将1-&gt;2-3-&gt;None的链表反转成3-&gt;2-&gt;1-&gt;None。有一个迭代的写法是这样的。 12345678def reverseList(head): prev = None while head: cur = head head = head.next cur.next = prev prev = cur return prev 它的简化写法如下： 12345def reverseList(self, head): prev = None while head: head.next, prev, head = prev, head, head.next return prev 具体的过程是这样的。先执行=右边表达式(None, head, head.next)，然后第一步把head.next=None，此时head变成了1-&gt;None；第二步，执行prev=head，这里为什么head的值时1-&gt;None而不是1-&gt;2-3-&gt;None呢，因为虽然等式先执行的右边，拿到了head，但是上一步的操作是将head修改了，由于head是一个可变对象，prev的值是1-&gt;None，最后再把head=head.next，这里为什么head.next的值又是2-&gt;3-&gt;None了呢，因为，执行右侧的表达式之后，head.next这个对象再前两步中没有被修改，一直都是2-&gt;3-&gt;None，这正是和第二步不同的地方，所以这两个写法是等同的。 参考： Multiple assignment and evaluation order in Python]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[371. Sum of Two Integers - Python]]></title>
    <url>%2F371-Sum-of-Two-Integers-Python%2F</url>
    <content type="text"><![CDATA[不用加减乘除做加法剑指Offer中也出现过此题，此篇文章着重分析一下为什么Python需要做一些多余的操作。 根据书中的分析，大致分为三步： 相加但不进位，使用^ 进位使用&amp;和&lt;&lt; 前两步结果相加 这里不再赘述详细过程。那么我们不难写出代码： 1234567def get_sum(a, b): res, carry = 0, 0 while b != 0: res = a ^ b carry = (a &amp; b) &lt;&lt; 1 a, b = res, carry return res 但是当输入a=-1, b=1时，会发现程序超时。先来看看正常的32位int类型运算时发生了什么，因为进行位运算时要使用补码进行运算，而正数的反码和补码都是本身，负数的反码为除符号位，其它按位取反，负数的补码为反码+1。下面列出了32为整数传入a=-1,b=1时，每次循环中a和b的补码。 a的原码 a的补码 b的补码 a ^ b a &amp; b 10…0001 11…1111 00…0001 11…1110 00…0001 10…0010 11…1110 00…0010 11…1100 00…0010 10…0100 11…1100 00…0100 11…1000 00…0100 ⋮ ⋮ ⋮ ⋮ ⋮ 110…000 110…000 010…000 100…000 010…000 100…000 100…000 100…000 000…000 100…000 000…000 000…000 000…000 ‘break’ ‘break’ 可以看出由于位数的限制，b和a最后都变成了0。因为Python中的int没有范围限制，所以这就是为什么会死循环的原因。 如何解决这个问题呢？我们需要在b的补码变成1000…000(32个0)时终止循环，如何将一个一个无限位的整型转成32位呢，想到了&amp;，所以我们找到一个mask=2**32-1也就是32个1，用一个无限位的值和mask进行与运算，就变成了上述表格中的例子，于是我们将代码改为： 12345678def getSum(self, a, b): res, carry = 0, 0 mask = 0xFFFFFFFF while b != 0: res = (a ^ b) &amp; mask carry = ((a &amp; b) &lt;&lt; 1) &amp; mask a, b = res, carry return res 提交之后还是不能通过测试用例，当a=-12, b=-8时输出了4294967276而不是-20。好，把mask先去掉，传入这两个值，发现可以正常输出-20，那么这里的mask是怎么造成了一些副作用的。再来分析一下这两个参数下，具体的过程是怎样的。 为了方便DEBUG，我们添加一些输出： 1234567891011121314def get_sum(self, a, b): mask = 0xFFFFFFFF res, carry = 0, 0 while b != 0: print('bin(&#123;&#125;) = &#123;&#125;, bin(&#123;&#125;) = &#123;&#125;'.format(a, bin(a), b, bin(b))) res = (a ^ b) &amp; mask # res = (a ^ b) print('\t res = &#123;&#125;, bin(res) = &#123;&#125;'.format(res, bin(res))) carry = ((a &amp; b) &lt;&lt; 1) &amp; mask # carry = ((a &amp; b) &lt;&lt; 1) print('\t \t a&amp;b = &#123;&#125;, (a&amp;b)&lt;&lt;1 = &#123;&#125;, carry = &#123;&#125;'.format((a&amp;b), ((a&amp;b)+1), carry)) a, b = res, carry # return res if res &lt;= MAX else ~(res ^ mask) return res 输出如下： 12345678910111213141516Finished in 20 msbin(-12) = -0b1100, bin(-8) = -0b1000 res = 12, bin(res) = 0b1100 a&amp;b = -16, (a&amp;b)&lt;&lt;1 = -15, carry = -32bin(12) = 0b1100, bin(-32) = -0b100000 res = -20, bin(res) = -0b10100 a&amp;b = 0, (a&amp;b)&lt;&lt;1 = 1, carry = 0-20Finished in 24 msbin(-12) = -0b1100, bin(-8) = -0b1000 res = 12, bin(res) = 0b1100 a&amp;b = -16, (a&amp;b)&lt;&lt;1 = -15, carry = 4294967264bin(12) = 0b1100, bin(4294967264) = 0b11111111111111111111111111100000 res = 4294967276, bin(res) = 0b11111111111111111111111111101100 a&amp;b = 0, (a&amp;b)&lt;&lt;1 = 1, carry = 04294967276 可以看到在进行-15&amp;mask时，carry变成了一个很大的正数，并丢失了符号。此处为个人猜想，当负数与mask进行与运算时，比如-2，此时-2的补码变为11…10，一个33-bit的数字，然后和32位的mask与操作后，变为了一个33位的正数。 有一个公式可以帮我们还原a，如果一个负数n，它的无符号的32位补码是m，那么m=~(n ^ mask) 或者n=~(m ^ mask) 于是代码修改为： 1234567891011121314def getSum(self, a, b): MASK = 0xffffffff # in Python, every integer is associated with its two's complement and its sign. # However, doing bit operation "&amp; mask" loses the track of sign. # Therefore, after the while loop, a is the two's complement of the final result as a 32-bit unsigned integer. while b != 0: a, b = (a ^ b) &amp; MASK, ((a &amp; b) &lt;&lt; 1) &amp; MASK # a is negative if the first bit is 1 if (a &gt;&gt; 31) &amp; 1: return ~(a ^ MASK) else: return a 虽然python进行大数字运算很方便，但是无限制位数往往会对位运算的操作中产生一些陷阱。如果可以直接转成Java中那种32的int，岂不是没有这么多麻烦了，好在numpy为我们提供了这样的方法。 1234567import numpy as npclass Solution(object): def getSum(self, a, b): while b != 0: a, b = np.int32(a ^ b), np.int32((a &amp; b) &lt;&lt; 1) return int(a) 最后要再转回int，否则是没法通过测试用例的。 参考： numpy实现方式 mask实现方式 the-meaning-of-bit-wise-not-in-python stackoverflow]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Bit Manipulation</tag>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[约瑟夫环问题（Josephus problem）]]></title>
    <url>%2F%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98%EF%BC%88Josephus-problem%EF%BC%89%2F</url>
    <content type="text"><![CDATA[问题：0，1，…，n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求这个圆圈里剩下的最后一个数字。 注意到，一开始有 n 个人，报到 m 的人出局后，如果我们从刚才出局的那人的下一位开始重新从 1 开始编号，原问题就转化为了一个 n–1 人的问题。如下表所示： 原始编号(i) 第一个人出局后的编号(j) m 0 m+1 1 m+2 2 … … m-2 n-2 （n为出局前的总人数） m-1 OUT 可以看出老编号i和新编号j的关系为：i = (j+m) % n，于是总结递推公式： f(n) = (f(n-1) + m) % n (n &gt; 1)，其中f(n)为当场上还有n个人时在场的人的编号。当最后只剩下一个人的时候，这个人的编号只能是0，即f(1)=0，现在根据上面的公式反推，推导出当n个人在场时这个最后幸存者的编号。例如：f(2)=(f(1)+m) % 2，所以range范围从2开始，执行n-1次，也就是range(2, n+1) 12345678def LastRemaining_Solution(self, n, m): # write code here if n&lt;=0 or m&lt;=0: return -1 last_num = 0 for i in range(2, n+1): last_num = (last_num+m) % i return last_num]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>algorithm</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[波义尔摩尔投票算法（Boyer-Moore Voting Algorithm）]]></title>
    <url>%2F%E6%B3%A2%E4%B9%89%E5%B0%94%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95%EF%BC%88Boyer-Moore-Voting-Algorithm%EF%BC%89%2F</url>
    <content type="text"><![CDATA[简介 The Boyer–Moore majority vote algorithm is an algorithm for finding the majority of a sequence of elements using linear time and constant space. It is named after Robert S. Boyer and J Strother Moore, who published it in 1981,[1] and is a prototypical example of a streaming algorithm. 波义尔摩尔投票算法是一种使用线性时间复杂度和常数空间复杂度来找到数组的主要元素（出现超过一半次数的元素）。 题目: 169. Majority Element。找出数组中出现超过一半的元素。 Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. 《剑指Offer》中的解释 遍历数组的时候保存两个值：一个是数组中的数字，另一个是次数。当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1；如果下一个数字和我们之前保存的数字不同，则次数减1。如果次数为零，那么需要保存下一个数字，并把次数设为1.由于我们要找的数字出现的次数比其他所有数字出现的次数之和还要多，那么要找的数字肯定是最后一次把次数设为1时的对应数字。 整个过程想象成一次投票选举投票规则：大屏幕上只允许出现一位候选人。如果选举人投的票不是当前候选人，那么让当前候选人票-1，如果是，则+1。OK，我们现在把所有数组的元素当成是选举人举出的号牌。我们先考虑最极端的情况：最后的winner以一票之差险胜。也就是元素出现的次数为n//2+1。这种情况是如何出现的呢，假设数组是这样的： 1[7, 7, 7, 7, 1, 2, 3] 没有投7的选举人假设在一开始知道了最有潜力的winner即7号，那么他们‘同仇敌忾’，将-1的票都投在了7号上，这种情况7号一直处于大屏幕中，没有更换过候选人。但是最后也没能打败7号，因为7号最后还保留一票。 另外一种非极端的情况，没有投7的选举人产生了‘内讧’： 1[7, 1, | 2, 3, | 7, 7, 7] 首先7号得到一票，然后被1号干掉，接着2号称为候选人，被3号干掉。3号的票浪费在了‘自己人’身上，即‘我们中出了一个叛徒’。就算团结起来都干不过7号，所以winner还是7号。 最后附上LeetCode上的Python代码： 1234567891011class Solution: def majorityElement(self, nums): count = 0 candidate = None for num in nums: if count == 0: candidate = num count += (1 if num == candidate else -1) return candidate 参考： 维基百科 LeetCode]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（sql篇）sql]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88sql%E7%AF%87%EF%BC%89sql%2F</url>
    <content type="text"><![CDATA[595. Big Countries查询’大城市’。原题 使用where OR 123select name, population, area from World where area &gt; 3000000 or population &gt; 25000000; 使用UNION 12345678select name, population, area from World where area &gt; 3000000unionselect name, population, areafrom Worldwhere population &gt; 25000000; 补充说明：Solution中解释道，使用UNION会比OR快上一丢丢。 Suppose we are searching population and area, Given that MySQL usually uses one one index per table in a given query, so when it uses the 1st index rather than 2nd index, it would still have to do a table-scan to find rows that fit the 2nd index. 因为前者查询的时候只用到第一个索引，对第二个条件查询时，也就是population，使用的是全表扫描，于是浪费了一些时间。但是想想背后的代价，想必是以空间来换时间。 627. Swap Salary转换性别。原题 使用if 123UPDATE salarySET sex=IF(sex='m', 'f', 'm'); 使用CASE 1234567update salaryset sex = CASE sex when 'm' Then 'f' else 'm' END; 使用XOR 123update salaryset sex = CHAR(ASCII('f') ^ ASCII('m') ^ ASCII(sex)); 620. Not Boring Movies使用MOD替代%。原题12345select *from cinemawhere mod(id, 2) = 1 and description != 'boring'order by rating DESC; 182. Duplicate Emails查询多余的重复值。原题思考：开始陷入了误区，以为要将重复的id也查出来。 1234SELECT emailFROM PersonGROUP BY emailHAVING Count(*) &gt; 1; 175. Combine Two Tables左链接。过于简单。原题123456SELECT p.FirstName, p.LastName, ad.City, ad.StateFROM Person p LEFT JOIN Address ad ON p.PersonId = ad.PersonId; 181. Employees Earning More Than Their Managers自链接。原题123456select e.name Employeefrom Employee e inner join Employee m on e.ManagerId = m.Idwhere e.Salary &gt; m.Salary; 183. Customers Who Never Order没有订单的顾客。原题123456select c.name Customersfrom Customers c left join Orders o on c.id = o.CustomerIdwhere o.CustomerId is Null; 123456select customers.name as 'Customers'from customerswhere customers.id not in( select customerid from orders); 596. Classes More Than 5 Students超过5个学生的班级。原题12345select classfrom coursesgroup by classhaving count(distinct student) &gt;= 5; 197. Rising Temperature这个挺有意思，开始天真地想用id作为条件，测试用例教做人。原题 我的答案 123456SELECT today.IdFROM Weather yest INNER JOIN Weather today ON today.RecordDate = DATE_ADD(yest.RecordDate, INTERVAL 1 day)WHERE today.Temperature &gt; yest.Temperature; 标准答案 12345678SELECT weather.id AS 'Id'FROM weather JOIN weather w ON DATEDIFF(weather.date, w.date) = 1 AND weather.Temperature &gt; w.Temperature; 查看Mysql文档： DATEDIFF(expr1,expr2) DATEDIFF() returns expr1 − expr2 expressed as a value in days from one date to the other. expr1 and expr2 are date or date-and-time expressions. Only the date parts of the values are used in the calculation. 1234mysql&gt; SELECT DATEDIFF('2007-12-31 23:59:59','2007-12-30'); -&gt; 1mysql&gt; SELECT DATEDIFF('2010-11-30 23:59:59','2010-12-31'); -&gt; -31 196. Delete Duplicate Emails删除重复的邮件。原题1234delete p1 from Person p1, Person p2where p1.email=p2.email and p1.Id &gt; p2.Id; 176. Second Highest Salary返回第二高的salary。原题PS：奇怪的题，没有记录非要人返回Null，只能再套一层查询或者使用IFNULL也可以。 12345678SELECT (SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT 1 OFFSET 1) AS SecondHighestSalary; 626. Exchange Seats交换相邻两行的值。原题开始理解错了，以为要update。 CASE 123456789101112SELECT ( CASE WHEN MOD(id, 2) != 0 AND counts != id THEN id + 1 WHEN MOD(id, 2) != 0 AND counts = id THEN id ELSE id - 1 end ) AS id, studentFROM seat, (SELECT Count(*) AS counts FROM seat) AS seat_countsORDER BY id ASC;; COALESCE() 第一步：使用XOR，但是不能直接使用排序因为id为5的被换成了6。 1SELECT id, (id+1)^1-1, student FROM seat; 123456789+------+------+----------+------------+---------+| id | id+1 | (id+1)^1 | (id+1)^1-1 | student |+------+------+----------+------------+---------+| 1 | 2 | 3 | 2 | Abbot || 2 | 3 | 2 | 1 | Doris || 3 | 4 | 5 | 4 | Emerson || 4 | 5 | 4 | 3 | Green || 5 | 6 | 7 | 6 | Jeame |+------+------+----------+------------+---------+ 第二步：使用LEFT JOIN链接。 12345SELECT *FROM seat s1 LEFT JOIN seat s2 ON ( s1.id + 1 )^1 - 1 = s2.idORDER BY s1.id; 123456789+------+---------+------+---------+| id | student | id | student |+------+---------+------+---------+| 1 | Abbot | 2 | Doris || 2 | Doris | 1 | Abbot || 3 | Emerson | 4 | Green || 4 | Green | 3 | Emerson || 5 | Jeame | NULL | NULL |+------+---------+------+---------+ 第三步：使用COALESCE() 1234567SELECT s1.id, Coalesce(s2.student, s1.student) as studentFROM seat s1 LEFT JOIN seat s2 ON ( s1.id + 1 )^1 - 1 = s2.idORDER BY s1.id; 参考：Mysql文档 Returns the first non-NULL value in the list, or NULL if there are no non-NULL values.The return type of COALESCE() is the aggregated type of the argument types. 178. Rank Scores]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（位运算篇）Bit Manipulation]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AF%87%EF%BC%89Bit-Manipulation%2F</url>
    <content type="text"><![CDATA[191. Number of 1 Bits计算数字的二进制中有多少个1。原题123Input: 11Output: 3Explanation: Integer 11 has binary representation 00000000000000000000000000001011 方法一：常规解法，使用1与n作与运算，如果不是0说明，含有一个1。 1234567def hamming_weight(n): bits, mask = 0, 1 for _ in range(32): if n&amp;mask != 0: bits += 1 mask &lt;&lt;= 1 return bits 方法二：关键点是，一个数n和n-1的与运算操作，相当于去掉了最右面的1。 123456def hamming_weigth(n): bits = 0 while n: bits += 1 n = (n-1) &amp; n return bits 136. Single Number找出数组中不重复的元素。其它元素出现两次。原题12Input: [4,1,2,1,2]Output: 4 12def single_num(nums): return reduce(lambda x, y: x ^ y, nums) 137. Single Number II找出数组中出现一次的元素，其它元素出现三次。原题12Input: [2,2,3,2]Output: 3 方法一：找出单独元素每一位的值。如果把所有数字的二进制每一位加起来，如果某一位可以被3整除，则表示单独元素的该位为0，否则为1。以下使用count来表示每一位1的个数。假设count%3!=0为True，说明该元素i位为1，然后是用|=更新ans在第i个位置的值，这里也可以使用+=，但是效率稍慢。convert的作用是因为python中的int是个对象，且没有最大限制，不是在第32位使用1来表示负数。 1234567891011121314def singleNumber(self, nums, n=3): ans = 0 for i in range(32): count = 0 for num in nums: if ((num &gt;&gt; i) &amp; 1): count += 1 ans |= ((count%n!=0) &lt;&lt; i) return self.convert(ans)def convert(self, x): if x &gt;= 2**31: x -= 2**32 return x 这里有个状态机的解法，不明觉厉，留坑。讨论1和讨论2 123456def singleNumber(self, nums): ones, twos = 0, 0; for i in range(len(nums)): ones = (ones ^ nums[i]) &amp; ~twos twos = (twos ^ nums[i]) &amp; ~ones return ones 260. Single Number III找出数组中两个唯一出现一次的元素，其余元素均出现两次。原题12Input: [1,2,1,3,2,5]Output: [3,5] 思想：将这两个元素分到两个组，由于这两个数不相等，所以亦或结果不为0，也就是说二进制中至少有一位1，记为第n位。我们以第n位是否为1，把数组分为两个子数组。 123456789101112def singleNumber(self, nums): total_xor = self.get_xor(nums) mask = 1 while total_xor&amp;mask == 0: mask &lt;&lt;= 1 p1 = [num for num in nums if num&amp;mask==0] p2 = [num for num in nums if num&amp;mask!=0] return [self.get_xor(p1), self.get_xor(p2)] def get_xor(self, nums): from functools import reduce return reduce(lambda x, y: x ^ y, nums) 371. Sum of Two Integers不用加减乘除做加法。原题解析为何Python位运算有些不同 实际上加法分为三个步骤 相加但不进位，1^0=1，1^1=0，0^0=0，所以第一步用异或。 只求进位的结果，只有两个1才会进位，所以用&amp;，然后左移1位，表示要进的位。 把前两步的结果再重复1，2步，直到没有进位产生，即b=0。 12345678910111213def getSum(self, a, b): # 32 bits integer max MAX = 0x7FFFFFFF # 2**31-1 # 32 bits interger min MIN = 0x80000000 # -2**31 # mask to get last 32 bits mask = 0xFFFFFFFF # 2*32-1 while b != 0: # ^ get different bits and &amp; gets double 1s, &lt;&lt; moves carry a, b = (a ^ b) &amp; mask, ((a &amp; b) &lt;&lt; 1) &amp; mask # if a is negative, get a's 32 bits complement positive first # then get 32-bit positive's Python complement negative return a if a &lt;= MAX else ~(a ^ mask) 190. Reverse Bits返回一个数的二进制的倒序的十进制。原题1234Input: 43261596Output: 964176192Explanation: 43261596 represented in binary as 00000010100101000001111010011100, return 964176192 represented in binary as 00111001011110000010100101000000. 方法一：使用原生库。ljust表示在右侧补’0’。或者使用format来补0。 123def reverseBits(self, n): return int(bin(n)[:1:-1].ljust(32, '0'), 2) # return int('&#123;:0&lt;32s&#125;'.format(bin(n)[:1:-1]), 2) 方法二：自己实现进制转换，使用位运算优化。 123456def reverseBits(self, n): code = '' for _ in range(32): code += str(n &amp; 1) n &gt;&gt;= 1 return sum([int(bit) &lt;&lt; i for i, bit in enumerate(code[::-1])]) 方法二改进：这里有个误区，为什么非要将整个二进制完整体现出来，再去遍历它转成int，而不是直接构建这个int。 123456def reverseBits(self, n): code = 0 for _ in range(32): code = (code&lt;&lt;1) + (n&amp;1) n &gt;&gt;= 1 return code 389. Find the Differences和t两个由小写字母组成的字符串，t是由s打乱顺序并再随机添加一个小写字母组成。原题方法一：使用Collection。 123def findTheDifference(self, s, t): from collections import Counter return next((Counter(t) - Counter(s)).elements()) 方法二：使用异或。 1234def findTheDifference(self, s, t): from operator import xor from functools import reduce return chr(reduce(xor, map(ord, s+t))) 401. Binary Watch有这样一个二进制的手表，输入一个n，表示有几个亮着的灯，返回所有可能出现的时间。时间范围为12小时制，即hours(0-11)，minutes(0-59)。原题 12Input: n = 1Return: [&quot;1:00&quot;, &quot;2:00&quot;, &quot;4:00&quot;, &quot;8:00&quot;, &quot;0:01&quot;, &quot;0:02&quot;, &quot;0:04&quot;, &quot;0:08&quot;, &quot;0:16&quot;, &quot;0:32&quot;] 一开始的思路：这是个错误的解法，因为分钟的灯不应该超过60分钟，因为要进位。类似的4和8的小时灯也不能同时亮起。 1234567def readBinaryWatch(self, num): from itertools import combinations # transform hours to minutes minutes = list(map(lambda x: x * 60, (1, 2, 4, 8))) + [32, 16, 8, 4, 2, 1] minutes_groups = combinations(minutes, num) res = ['&#123;:d&#125;:&#123;:0&gt;2d&#125;'.format(sum(g)//60, sum(g)%60) for g in minutes_groups] return res 方法二：正确的写法。需要分开判断小时和分钟，然后再合并。 123456789101112def readBinaryWatch(self, num): from itertools import combinations # transform hours to minutes hours = list(map(lambda x: x*60, (1, 2, 4, 8))) minutes = (1, 2, 4, 8, 16, 32) res = [] for i in range(num+1): get_hours = [x for x in list(combinations(hours, i)) if sum(x) &lt; 12 * 60] get_minutes = [x for x in list(combinations(minutes, num-i)) if sum(x) &lt; 60] minutes_groups = [h+m for h in get_hours for m in get_minutes] res += ['&#123;:d&#125;:&#123;:0&gt;2d&#125;'.format(sum(g)//60, sum(g)%60) for g in minutes_groups] return res 方法三：遍历所有可能的时间，找到符合条件的。因为表中的数组都是二进制，所以’1’的个数就是亮灯的个数。 1234def readBinaryWatch(self, num): return ['&#123;:d&#125;:&#123;:0&gt;2d&#125;'.format(h, m) for h in range(12) for m in range(60) if (bin(h)+bin(m)).count('1') == num] 405. Convert a Number to Hexadecimal把一个32位有符号的整数转换成16进制。原题123456789Input:26Output:&quot;1a&quot;Input:-1Output:&quot;ffffffff&quot; 123def toHex(self, num): return ''.join(['0123456789abcdef'[(num &gt;&gt; 4 * i) &amp; 15] for i in range(8)])[::-1].lstrip('0') or '0' 461. Hamming Distance求两个正数的原码中不同位的个数。原题1234567Input: x = 1, y = 4Output: 2Explanation:1 (0 0 0 1)4 (0 1 0 0) ↑ ↑The above arrows point to positions where the corresponding bits are different. 12def hammingDistance(self, x, y): return bin(x ^ y).count('1') 476. Number Complement给定一个正数，求其原码的按位取反后的数。原题123Input: 5Output: 2Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2. 方法一：暴力的方法。 12def findComplement(self, num): return int(''.join([str(1 ^ int(d)) for d in bin(num)[2:]]), 2) 方法二：其实就是求101和111的异或。所以先找到111。 12345def findComplement(self, num): i = 1 while i &lt;= num: i &lt;&lt;= 1 return (i-1) ^ num 方法三：更少的位移。核心思想还是找到111。比如一个8位数，最高代表符号：1000000，先将其右移1位，使得左边两位都变成1。然后再右移2位，使得左边四位变成1，以此类推，8位数最多移动3次就可以得到1111111，32位则还需要再移动2次。 12345def findComplement(self, num): mask = num for i in range(5): mask |= mask &gt;&gt; (2**i) return num ^ mask 693. Binary Number with Alternating Bits二进制是否是交替的0和1。原题1234Input: 5Output: TrueExplanation:The binary representation of 5 is: 101 方法一：字符串法。 12def hasAlternatingBits(self, n): return '00' not in bin(n) and '11' not in bin(n) 方法二：除2法。 1234567def hasAlternatingBits(self, n): n, cur = divmod(n, 2) while n: if cur == n % 2: return False n, cur = divmod(n, 2) return True 方法三：异或。 12345def hasAlternatingBits(self, n): if not n: return False num = n ^ (n &gt;&gt; 1) return not (num &amp; num+1) 762. Prime Number of Set Bits in Binary Representation求某范围的所有自然数中，二进制中1的个数是质数的个数。原题123456789Input: L = 10, R = 15Output: 5Explanation:10 -&gt; 1010 (2 set bits, 2 is prime)11 -&gt; 1011 (3 set bits, 3 is prime)12 -&gt; 1100 (2 set bits, 2 is prime)13 -&gt; 1101 (3 set bits, 3 is prime)14 -&gt; 1110 (3 set bits, 3 is prime)15 -&gt; 1111 (4 set bits, 4 is not prime) 方法一：direct. 12345678def countPrimeSetBits(self, L: 'int', R: 'int') -&gt; 'int': primes = &#123;2, 3, 5, 7, 11, 13, 17, 19&#125; # ans = 0 # for num in range(L, R+1): # if bin(num)[2:].count('1') in primes: # ans += 1 # return ans return sum(bin(n)[2:].count('1') in primes for n in range(L, R+1)) 方法二：位运算。p 的2，3，5，7。。位是1，其余是0，这样在右移后，可&amp;1就可以判断这个数是否是质数。 123def countPrimeSetBits(self, L: 'int', R: 'int') -&gt; 'int': p = int('10100010100010101100', 2) return sum(p &gt;&gt; bin(i).count('1') &amp; 1 for i in range(L, R+1)) 868. Binary Gap二进制两个1的最大距离。原题12345678Input: 22Output: 2Explanation: 22 in binary is 0b10110.In the binary representation of 22, there are three ones, and two consecutive pairs of 1&apos;s.The first consecutive pair of 1&apos;s have distance 2.The second consecutive pair of 1&apos;s have distance 1.The answer is the largest of these two distances, which is 2. 方法一：字符串或是位运算都可以。 12345678910def binaryGap(self, N: 'int') -&gt; 'int': ans, last = 0, None # for i, b in enumerate(bin(N)[2:]): for i in range(32): # if b == '1': if (N &gt;&gt; i) &amp; 1: if last is not None: ans = max(ans, i - last) last = i return ans 方法二：列表生成式。 1234def binaryGap(self, N: 'int') -&gt; 'int': one = [i for i, v in enumerate(bin(N)) if v == '1'] # return max([one[i+1] - one[i] for i in range(len(one)-1)] or [0]) return max([b-a for a, b in zip(one, one[1:])] or [0]) 268. Missing Number0~n中缺失的数字。原题方法一：数学公式。 12345def missingNumber(self, nums): n = len(nums) expected_sum = n*(n+1) // 2 actual_sum = sum(nums) return expected_sum - actual_sum 方法二：XOR. index 0 1 2 value 3 0 1 12345def missingNumber(self, nums: 'List[int]') -&gt; 'int': missing = len(nums) for i, num in enumerate(nums): missing ^= i ^ num return missing 1012. Complement of Base 10 Integer非负数的反码。原题123456def bitwiseComplement(self, N: int) -&gt; int: mask = 1 while mask &lt; N: mask = (mask &lt;&lt; 1) + 1 # return mask - N return N ^ mask 1404. Number of Steps to Reduce a Number in Binary Representation to One几下操作可以将其变为1。偶数除以2，奇数+1.原题123456789Input: s = &quot;1101&quot;Output: 6Explanation: &quot;1101&quot; corressponds to number 13 in their decimal representation.Step 1) 13 is odd, add 1 and obtain 14. Step 2) 14 is even, divide by 2 and obtain 7.Step 3) 7 is odd, add 1 and obtain 8.Step 4) 8 is even, divide by 2 and obtain 4. Step 5) 4 is even, divide by 2 and obtain 2. Step 6) 2 is even, divide by 2 and obtain 1. 方法一：将其转为数字最简单，但是失去了此题的意义。评论区看到的一个解法 110010 -&gt; 110100 -&gt; 111000 -&gt; 1000000 takes 2(which is count of mid zeros) + 1 moves.1000000 -&gt; 1 takes 6 moves because length of s increases 1. 12345678def numSteps(self, s: str) -&gt; int: i, mid_0 = 0, 0 for j in range(1, len(s)): if s[j] == '1': mid_0 += j - i - 1 i = j if i == 0: return len(s) - 1 return mid_0 + 1 + len(s) 201. Bitwise AND of Numbers Range范围内的数字求与运算和。原题12Input: [5,7]Output: 4 1234567def rangeBitwiseAnd(self, m: int, n: int) -&gt; int: i = 0 while m != n: m &gt;&gt;= 1 n &gt;&gt;= 1 i += 1 return n &lt;&lt; i 1442. Count Triplets That Can Form Two Arrays of Equal XOR数组中找出两段的异或和相等。原题方法一：此题在竞赛中做出来了，需要找到规律。 12345678def countTriplets(self, arr: List[int]) -&gt; int: m = list(itertools.accumulate([0] + arr, operator.xor)) count = 0 for i in range(len(m)): for j in range(i+1, len(m)): if m[i] == m[j]: count += j-i-1 return count 1238. Circular Permutation in Binary Representation返回指定为位数的二进制环，每两个数的二进制只有1位不同。原题1234Input: n = 2, start = 3Output: [3,2,0,1]Explanation: The binary representation of the permutation is (11,10,00,01). All the adjacent element differ by one bit. Another valid permutation is [3,1,0,2] 方法一：我想了半天这道题，以为和二进制无关，是个数学题，没想到最后还得用异或来解决。这是个 gray code的问题，有一个公式。 12def circularPermutation(self, n, start): return [start ^ i ^ i &gt;&gt; 1 for i in range(1 &lt;&lt; n)] 393. UTF-8 Validation题目描述非常之难懂，母语的人看着都看不明白。此题在Leetcode-cn上看的中文描述。针对一些数，它的二进制必须满足几种形式，如果是0开头，就是一个1字节的字符；如果110开头，说明是2字节的字符，其后面的二进制形式必须是10开头；如果1110开头，说明是3字节字符，后面必须跟两个10开头的字符。原题1234data = [197, 130, 1], which represents the octet sequence: 11000101 10000010 00000001.Return true.It is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character. 方法一：字符串方法。 12345678910111213141516def validUtf8(self, data: List[int]) -&gt; bool: b = 0 for d in data: s = '&#123;:0&gt;8b&#125;'.format(d)[-8:] if b: if not s.startswith('10'): return False else: b -= 1 continue if s.startswith('0'): continue head = re.match(r'(^1&#123;2,4&#125;0)*', s).groups()[0] if not head: return False b = len(head) - 1 return b == 0 方法二：位运算。 1234567891011121314151617def validUtf8(self, data: List[int]) -&gt; bool: b = 0 for d in data: mask1, mask2 = 1&lt;&lt;7, 1&lt;&lt;6 if b: if not((d&amp;mask1) and (not d&amp;mask2)): return False else: b -= 1 continue while d&amp;mask1: b += 1 mask1 &gt;&gt;= 1 if b==0: continue if b==1 or b&gt;4: return False b -= 1 return b == 0 318. Maximum Product of Word Lengths给你一个单词列表，返回最大的两个没有相同字符的单词长度乘积。原题123Input: [&quot;abcw&quot;,&quot;baz&quot;,&quot;foo&quot;,&quot;bar&quot;,&quot;xtfn&quot;,&quot;abcdef&quot;]Output: 16 Explanation: The two words can be &quot;abcw&quot;, &quot;xtfn&quot;. 方法一：直观解法。 12345678def maxProduct(self, words: List[str]) -&gt; int: ws = [(len(word), set(word)) for word in words] ans = 0 for i in range(len(ws)): for j in range(i+1, len(ws)): if not ws[j][1] &amp; ws[i][1]: ans = max(ans, ws[i][0]*ws[j][0]) return ans 方法二：位运算。评论区看到的答案，怎么想的呢，单词只包含26个小写字母，又有相同字符判断，从而可以想出这样的解法。 12345678def maxProduct(self, words: List[str]) -&gt; int: d = &#123;&#125; for w in words: mask = 0 for c in set(w): mask |= 1&lt;&lt;(ord(c)-ord('a')) d[mask] = max(d.get(mask, 0), len(w)) return max([d[i]*d[j] for i in d for j in d if not i&amp;j] or [0]) 1177. Can Make Palindrome from Substring给定一个 字符串s，进行一些查询，针对s的切片内容能否将其打乱然后重新排列，在替换k个字符内将其变成回文的。返回这些查询结果。原题12345678Input: s = &quot;abcda&quot;, queries = [[3,3,0],[1,2,0],[0,3,1],[0,3,2],[0,4,1]]Output: [true,false,false,true,true]Explanation:queries[0] : substring = &quot;d&quot;, is palidrome.queries[1] : substring = &quot;bc&quot;, is not palidrome.queries[2] : substring = &quot;abcd&quot;, is not palidrome after replacing only 1 character.queries[3] : substring = &quot;abcd&quot;, could be changed to &quot;abba&quot; which is palidrome. Also this can be changed to &quot;baab&quot; first rearrange it &quot;bacd&quot; then replace &quot;cd&quot; with &quot;ab&quot;.queries[4] : substring = &quot;abcda&quot;, could be changed to &quot;abcba&quot; which is palidrome. 方法一：bit mask。我学会了，开始的时候想用Counter来计算，虽然通过了但是效率很慢。这样只包含字母的题可以用位运算异或来进行。思路和榜一大神不谋而合。 123456789101112def canMakePaliQueries(self, s: str, queries: List[List[int]]) -&gt; List[bool]: d = [0] for c in s: d.append(d[-1] ^ (1 &lt;&lt; (ord(c)-ord('a')))) ans = [] for i, j, k in queries: cur = d[j+1] ^ d[i] # print(count_one(cur), i, j, format(cur, 'b')) ans.append(format(cur, 'b').count('1')//2 &lt;= k) return ans 方法二：整理一下方法一。 12345def canMakePaliQueries(self, s: str, queries: List[List[int]]) -&gt; List[bool]: d = [0] for c in s: d.append(d[-1] ^ (1 &lt;&lt; (ord(c)-ord('a')))) return [bin(d[j+1] ^ d[i]).count('1')//2 &lt;= k for i, j, k in queries] 421. Maximum XOR of Two Numbers in an Array数组中两个数最大的异或值时多少。线性时间复杂度实现。12345Input: [3, 10, 5, 25, 2, 8]Output: 28Explanation: The maximum result is 5 ^ 25 = 28. 方法一：Stefan的方法研究了半天。改成循环其实更容易理解。 1234567def findMaximumXOR(self, nums: List[int]) -&gt; int: ans = 0 for i in range(32)[::-1]: ans &lt;&lt;= 1 prefixes = &#123;num&gt;&gt;i for num in nums&#125; ans += any(ans^1^p in prefixes for p in prefixes) return ans 如何实现的呢？首先我们1位1位来更新ans，从最高位开始，尽可能让它为1，那么ans就会越大。 改成循环容易观察。每次我们想尽量获得nxt，然后找是否有另一个q，满足q ^ p = nxt。所以看到ans^1就是nxt。 1234567891011def findMaximumXOR(self, nums: List[int]) -&gt; int: ans = 0 for i in range(32)[::-1]: ans &lt;&lt;= 1 prefixes = &#123;num&gt;&gt;i for num in nums&#125; nxt = ans + 1 for p in prefixes: if p ^ nxt in prefixes: ans = nxt break return ans]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Bit Manipulation</tag>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（二分法篇）Binary Search]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%E5%88%86%E6%B3%95%E7%AF%87%EF%BC%89Binary-Search%2F</url>
    <content type="text"><![CDATA[704. Binary Search二分法在有序数组中查找元素。原题123Input: nums = [-1,0,3,5,9,12], target = 9Output: 4Explanation: 9 exists in nums and its index is 4 方法一：实现原理。 1234567891011def binary_search(nums, target): l, r = 0, len(nums)-1 while l &lt;= r: mid = (l+r) // 2 if nums[mid] &gt; target: r = mid - 1 elif nums[mid] &lt; target: l = mid + 1 else: return mid return -1 方法二：使用标准库。 1234def search(self, nums, target): from bisect import bisect_left index = bisect_left(nums, target) return index if index &lt; len(nums) and nums[index] == target else -1 35. Search Insert Position给定一个target，插入到一个有序数组中，假定数组中无重复元素。原题12Input: [1,3,5,6], 5Output: 2 方法一：实现原理。 1234567891011def binary_insert(nums, target): l, r = 0, len(nums)-1 while l &lt;= r: mid = (l+r) // 2 if nums[mid] &gt; target: r = mid - 1 elif nums[mid] &lt; target: l = mid + 1 else: return mid return l 方法二：使用标准库。 123def searchInsert(self, nums, target): from bisect import bisect_left return bisect_left(nums, target) 153. Find Minimum in Rotated Sorted Array通过一个排序数组旋转后的结果，找出最小元素。原题12Input: [3,4,5,1,2] Output: 1 思路：通过二分法不断缩小范围，由于mid是整除，最后l==mid，并且nums[mid] &gt; nums[r]的。 123456789101112def find_min(nums): l, r = 0, len(nums)-1 if nums[l] &lt; nums[r]: return nums[l] while l &lt;= r: mid = (l+r) // 2 if nums[mid] &gt; nums[l]: l = mid elif nums[mid] &lt; nums[r]: r = mid else: return nums[r] 34. Find First and Last Position of Element in Sorted Array有序数组中查找数组，返回数字的索引范围。原题1234Input: nums = [5,7,7,8,8,10], target = 8Output: [3,4]Input: nums = [5,7,7,8,8,10], target = 6Output: [-1,-1] 12345678910111213141516def searchRange(self, nums, target): left_idx = self.search_edge(nums, target, True) if left_idx == len(nums) or nums[left_idx] != target: return [-1, -1] return [left_idx, self.search_edge(nums, target, False)-1] def search_edge(self, nums, target, left): l, r = 0, len(nums) while l &lt; r: mid = (l+r) // 2 if nums[mid] &gt; target or (left and nums[mid]==target): r = mid else: l = mid + 1 return l 278. First Bad Version找出提交版本中的bad version。原题1234567Given n = 5, and version = 4 is the first bad version.call isBadVersion(3) -&gt; falsecall isBadVersion(5) -&gt; truecall isBadVersion(4) -&gt; trueThen 4 is the first bad version. 123456789def firstBadVersion(self, n): l, r = 1, n while l &lt;= r: mid = (l+r) // 2 if isBadVersion(mid): r = mid - 1 else: l = mid + 1 return l 374. Guess Number Higher or Lower猜数游戏1~n，每猜一次会告诉你答案是更小还是更大。原题12345678def guess(num): return -1 : My number is lower 1 : My number is higher 0 : Congrats! You got it! Input: n = 10, pick = 6Output: 6 方法一：实现原理。 12345678910def guessNumber(self, n): l, r = 1, n while l &lt;= r: mid = (l+r) // 2 if guess(mid) == -1: r = mid - 1 elif guess(mid) == 1: l = mid + 1 else: return mid 方法二：使用标准库。此答案受stefan大神启发。核心思想为将guess返回的结果转为一个数组，然后使用二分法查找。 1234567def guessNumber(self, n): from bisect import bisect, bisect_left class C: def __getitem__(self, x): return -guess(x) # return bisect(C(), -1, 1, n) return bisect_left(C(), 0, 1, n) 解析：以n=10, pick=6为例。实际上C class相当于: 1234ary = map(lambda x: -guess(x), range(1, n+1))ary.insert(0, None)# ary = [None, -1, -1, -1, -1, -1, 0, 1, 1, 1, 1]return bisect(ary, -1, 1, n) 而索引又是从1开始，所以这里在前面添加了一个None，实际上将题转为了查找ary的0，问题便迎刃而解。值得注意的是，如果使用了map，会导致空间，时间复杂度增加，而使用class的方法，并没有求出整个的list，所以效率更高。 744. Find Smallest Letter Greater Than Target找出比目标大的最小字母，没有的返回首字母。原题1234567891011121314Input:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target = &quot;d&quot;Output: &quot;f&quot;Input:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target = &quot;g&quot;Output: &quot;j&quot;Input:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target = &quot;j&quot;Output: &quot;c&quot; 方法一：二分法实现。 123456789def nextGreatestLetter(self, letters: 'List[str]', target: 'str') -&gt; 'str': lo, hi = 0, len(letters)-1 while lo &lt;= hi: mid = (lo + hi) // 2 if letters[mid] &gt; target: hi = mid -1 elif letters[mid] &lt;= target: lo = mid + 1 return letters[lo % len(letters)] 方法二：使用库。 123def nextGreatestLetter(self, letters: 'List[str]', target: 'str') -&gt; 'str': index = bisect.bisect(letters, target) return letters[index % len(letters)] 852. Peak Index in a Mountain Array找到数组中的峰值。假设峰值一定存在。原题12Input: [0,2,1,0]Output: 1 方法一：Linear Scan. Time: O(N) 1234def peakIndexInMountainArray(self, A: 'List[int]') -&gt; 'int': for i in range(1, len(A)-1): if A[i] &gt; A[i+1]: return i 方法二：one-line. 12def peakIndexInMountainArray(self, A: 'List[int]') -&gt; 'int': return A.index(max(A)) 方法三：看到Solution才想到二分法。 123456789def peakIndexInMountainArray(self, A: 'List[int]') -&gt; 'int': lo, hi = 0, len(A)-1 while lo &lt; hi: mid = (lo + hi) // 2 if A[mid] &gt; A[mid+1]: hi = mid else: lo = mid + 1 return lo 方法四：黄金分割法，应用在单峰函数求极值，速度比二分法要快。 12345678910111213141516171819def peakIndexInMountainArray(self, A: 'List[int]') -&gt; 'int': def gold1(i, j): return i + int(round((j-i) * 0.382)) def gold2(i, j): return i + int(round((j-i) * 0.618)) l, r = 0, len(A) - 1 x1, x2 = gold1(l, r), gold2(l, r) while x1 &lt; x2: if A[x1] &lt; A[x2]: l = x1 x1 = x2 x2 = gold1(x1, r) else: r = x2 x2 = x1 x1 = gold2(l, x2) return x1 1014. Capacity To Ship Packages Within D Daysn天内轮船运送的最小容量。原题1234567891011Input: weights = [1,2,3,4,5,6,7,8,9,10], D = 5Output: 15Explanation: A ship capacity of 15 is the minimum to ship all the packages in 5 days like this:1st day: 1, 2, 3, 4, 52nd day: 6, 73rd day: 84th day: 95th day: 10Note that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed. 贴一下竞赛时AC的丑陋写法。 123456789101112131415161718192021222324def shipWithinDays(self, weights: List[int], D: int) -&gt; int: def can_ship(capacity, D): l = 0 for _ in range(D): each = 0 for r in range(l, len(weights)): if weights[r]+each &lt;= capacity: each += weights[r] else: l = r break else: return True return False lo, hi = max(weights), sum(weights) while lo &lt;= hi: mid = (lo + hi) // 2 if can_ship(mid, D): hi = mid - 1 else: lo = mid + 1 return lo 优化。遇见一个诡异的现象，同样的代码用python比python3快了60ms，和3MB的内存。这解法也没涉及两者的区别。 123456789101112131415def shipWithinDays(self, weights: List[int], D: int) -&gt; int: lo, hi = max(weights), sum(weights) while lo &lt;= hi: mid, days, cur = (lo + hi) // 2, 1, 0 for w in weights: if cur+w &gt; mid: days += 1 cur = 0 cur += w if days &gt; D: lo = mid + 1 else: hi = mid - 1 # print(lo, mid, hi) return lo 875. Koko Eating Bananas这道题思路和1014一样。不同的是，如果当前堆的香蕉小于吃的速度，那么也不能吃下一堆。原题12Input: piles = [3,6,7,11], H = 8Output: 4 方法一：写习惯了Python3，老是想写//，注意是p/mid。 1234567891011def minEatingSpeed(self, piles: List[int], H: int) -&gt; int: lo, hi = 1, max(piles) while lo &lt;= hi: mid = (lo + hi ) &gt;&gt; 1 # needs = sum(math.ceil(p/mid) for p in piles) # slower needs = sum((p-1)//mid+1 for p in piles) if needs &gt; H: lo = mid + 1 else: hi = mid - 1 return lo 1145. Binary Tree Coloring Game二叉树染色游戏。两个人轮流给二叉树染色，每次只能染相邻位的节点，给定第一个人染色的位置，问第二个人是否能够必胜。原题方法一：关键的一点需要想明白，从第一个人染色的地方，有三个分支，如果有一个分支可以大于整个节点的一半，那么第二个人选择这个分支，就能赢得比赛 123456789101112131415def btreeGameWinningMove(self, root: TreeNode, n: int, x: int) -&gt; bool: count = [0, 0] def dfs(node): if not node: return 0 left = dfs(node.left) right = dfs(node.right) if node.val == x: count[0] = left count[1] = right return left + right + 1 dfs(root) return max(max(count), n - sum(count) - 1) &gt; n // 2 33. Search in Rotated Sorted Array在有序数组旋转后查找目标索引。原题12Input: nums = [4,5,6,7,0,1,2], target = 0Output: 4 方法一：这个题开始的时候结合两个题，一个是旋转数组中的最小值，然后重组成一个原数组，最后在二分搜索加上原来偏移的索引值。但是这样使用了两次二分法，所以效率不高。看了stefan的答案后明白了，需要找到另一个比较的值就是nums[0]。这里分了两种情况，一种是当nums[0]&lt;=nums[mid]，这种情况说明了nums[:mid]是有序的；另一种是nums[mid]&lt;nums[0]，说明nums[:mid]中存在一个下落点，然后又根据target在下落点的左右分为两种情况。 123456789101112def search(self, nums: List[int], target: int) -&gt; int: lo, hi = 0, len(nums)-1 while lo &lt;= hi: mid = (lo+hi) // 2 if nums[mid] == target: return mid elif nums[0]&lt;=target&lt;nums[mid] or nums[mid]&lt;nums[0]&lt;=target or target&lt;nums[mid]&lt;nums[0]: hi = mid - 1 else: lo = mid + 1 return -1 1283. Find the Smallest Divisor Given a Threshold找到一个除数，用数组所有元素除它得到的天花板数和刚好小于等于阈值。求这个数最小是多少。原题1234Input: nums = [1,2,5,9], threshold = 6Output: 5Explanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1. If the divisor is 4 we can get a sum to 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2). 方法一：这道题和大佬的解法差不多。区别在于我用了math的库，而他用了一个式子来求的天花板数。知识点(a + b - 1) // b == math.ceil(a/b) 1234567891011def smallestDivisor(self, nums: List[int], threshold: int) -&gt; int: lo, hi = 1, max(nums) while lo &lt;= hi: mid = (lo + hi) // 2 # if sum(math.ceil(i/mid) for i in nums) &lt;= threshold: if sum((i+mid-1) // mid for i in nums) &lt;= threshold: hi = mid - 1 else: lo = mid + 1 return lo 1268. Search Suggestions System单词推荐系统。原题1234567891011Input: products = [&quot;mobile&quot;,&quot;mouse&quot;,&quot;moneypot&quot;,&quot;monitor&quot;,&quot;mousepad&quot;], searchWord = &quot;mouse&quot;Output: [[&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;],[&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;],[&quot;mouse&quot;,&quot;mousepad&quot;],[&quot;mouse&quot;,&quot;mousepad&quot;],[&quot;mouse&quot;,&quot;mousepad&quot;]]Explanation: products sorted lexicographically = [&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;,&quot;mouse&quot;,&quot;mousepad&quot;]After typing m and mo all products match and we show user [&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;]After typing mou, mous and mouse the system suggests [&quot;mouse&quot;,&quot;mousepad&quot;] 方法一：二分法。此题暴力法求解也能过。更好的方法还是二分或者Trie，但是Trie的方式实现过于复杂。 12345678def suggestedProducts(self, p: List[str], w: str) -&gt; List[List[str]]: p.sort() ans, prefix, i = [], '', 0 for c in w: prefix += c i = bisect.bisect_left(p, prefix, i) ans.append([d for d in p[i:i+3] if d.startswith(prefix)]) return ans 392. Is Subsequence判断一个字符串是否是另一个的子序列。原题12Input: s = &quot;abc&quot;, t = &quot;ahbgdc&quot;Output: true 方法一：生成器。 123def isSubsequence(self, s: str, t: str) -&gt; bool: t = iter(t) return all(c in t for c in s) 方法二：二分法。将每个字符的索引用列表记录下来，每次用二分法找后序出现的匹配的字符。 12345678910def isSubsequence(self, s: str, t: str) -&gt; bool: idx = defaultdict(list) for i, c in enumerate(t): idx[c].append(i) prev = 0 for i, c in enumerate(s): j = bisect.bisect_left(idx[c], prev) if j == len(idx[c]): return False prev = idx[c][j] + 1 return True 1482. Minimum Number of Days to Make m Bouquets花圃里有若干的花束记录了第几天会开花。最小的天数，可以做出m束花，必须使用连续的花才能做成一朵花束。需要k束花。原题1234567Input: bloomDay = [1,10,3,10,2], m = 3, k = 1Output: 3Explanation: Let&apos;s see what happened in the first three days. x means flower bloomed and _ means flower didn&apos;t bloom in the garden.We need 3 bouquets each should contain 1 flower.After day 1: [x, _, _, _, _] // we can only make one bouquet.After day 2: [x, _, _, _, x] // we can only make two bouquets.After day 3: [x, _, x, _, x] // we can make 3 bouquets. The answer is 3. 方法一：比赛的时候真是一点都没往二分法想、这个是Lee的答案。 123456789101112131415161718def minDays(self, A: List[int], m: int, k: int) -&gt; int: if m * k &gt; len(A): return -1 lo, hi = 1, max(A) while lo &lt; hi: mid = (lo + hi) // 2 flow = bouq = 0 for a in A: flow = 0 if a &gt; mid else flow + 1 if flow &gt;= k: bouq += 1 flow = 0 if bouq == m: break if bouq == m: hi = mid else: lo = mid + 1 return lo 1201. Ugly Number III找到第n个能被a或b或c整除的数。原题123Input: n = 3, a = 2, b = 3, c = 5Output: 4Explanation: The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3rd is 4. 方法一：这题和 丑数2的题不一样，那道题是只能被2，3，5整除的数。这题一开始也是没想到用二分法。 1234567891011121314def nthUglyNumber(self, n: int, a: int, b: int, c: int) -&gt; int: lo, hi = 1, 2 * 10**9 ab = a*b // math.gcd(a, b) ac = a*c // math.gcd(a, c) bc = b*c // math.gcd(b, c) abc = a*bc // math.gcd(a, bc) while lo &lt;= hi: mid = (lo+hi) // 2 total = mid//a + mid//b + mid//c - mid//ab - mid//ac - mid//bc + mid//abc if total &gt;= n: hi = mid - 1 else: lo = mid + 1 return lo 287. Find the Duplicate Number找到重复的数字，在1~n中有一个数至少重复了一次，但是其它数可能没有，找到这个重复的数字。原题方法一：用过这个方法，但是没想到能用在这道题上，方法是解环形链表中入口节点的那道题。因为数组中存在重复的数字，所以这样延伸下去一定是有环。 1234567891011def findDuplicate(self, nums: List[int]) -&gt; int: slow = nums[0] fast = nums[slow] while slow != fast: slow = nums[slow] fast = nums[nums[fast]] head = 0 while head != fast: fast = nums[fast] head = nums[head] return head 方法二：二分法。比较的是数字的多少。 123456789def findDuplicate(self, nums: List[int]) -&gt; int: lo, hi = 1, len(nums)-1 while lo &lt; hi: mid = (lo + hi) // 2 if sum(i&lt;=mid for i in nums) &lt;= mid: lo = mid + 1 else: hi = mid return lo 154. Find Minimum in Rotated Sorted Array II旋转数组找到最小值，与1不同的是，这里有重复的值。原题方法一：由于重复值的原因，[10, 1, 10, 10, 10]，[10, 10, 10, 1, 10] 12345678910111213def findMin(self, nums: List[int]) -&gt; int: lo, hi = 0, len(nums)-1 if nums[lo] &lt; nums[hi]: return nums[0] while lo &lt; hi: mid = (lo + hi) // 2 if nums[mid] &gt; nums[hi]: lo = mid + 1 elif nums[mid] &lt; nums[hi]: hi = mid else: hi -= 1 return nums[lo] 1539. Kth Missing Positive Number找到第k个缺失的正数，数组可能会被耗尽。原题123Input: arr = [2,3,4,7,11], k = 5Output: 9Explanation: The missing positive integers are [1,5,6,8,9,10,12,13,...]. The 5th missing positive integer is 9. 方法一：用了集合。 12345678def findKthPositive(self, arr: List[int], k: int) -&gt; int: s = set(arr) for i in range(1, 2002): if i not in s: k -= 1 if k == 0: return i return i 方法二：二分法by@lee215。lo是什么？是最后的结果里面存在了多少数，那么结果就是lo+k。对于数组[2,3,4,7,11] A[m]-1-m表示缺失了几个数。 123456789def findKthPositive(self, A: List[int], k: int) -&gt; int: l, r = 0, len(A) while l &lt; r: m = (l + r) // 2 if A[m] - 1 - m &lt; k: l = m + 1 else: r = m return l + k 1552. Magnetic Force Between Two Balls在若干的指定的位置可以放置球，问如何使球之间最小的距离最大化。原题123Input: position = [1,2,3,4,7], m = 3Output: 3Explanation: Distributing the 3 balls into baskets 1, 4 and 7 will make the magnetic force between ball pairs [3, 3, 6]. The minimum magnetic force is 3. We cannot achieve a larger minimum magnetic force than 3. 方法一：比赛的时候想了一下二分法，但是没多想。这里只要想明白这个辅助方法就能实现了。count方法表示距离为d时最多可以放几个球。 123456789101112131415161718192021def maxDistance(self, position: List[int], m: int) -&gt; int: position.sort() n = len(position) def count(d): cnt, cur = 0, float('-inf') for p in position: if p - cur &gt;= d: cnt += 1 cur = p return cnt lo, hi = 0, position[-1]-position[0] while lo &lt;= hi: mid = (lo+hi) // 2 if count(mid) &gt;= m: lo = mid + 1 else: hi = mid - 1 return hi 162. Find Peak Element找到数组中的峰值，数组中元素两个挨着的元素不重复。可能存在多个值，返回任意一个即可。原题1234Input: nums = [1,2,1,3,5,6,4]Output: 1 or 5 Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6. 方法一：因为挨着的元素不重复，所以可以用二分法。比较两个相邻的元素，如果做左小于右说明峰值在右侧。 12345678910def findPeakElement(self, nums: List[int]) -&gt; int: lo, hi = 0, len(nums)-1 while lo &lt; hi: mid = (lo+hi) // 2 mid2 = mid + 1 if nums[mid] &lt; nums[mid2]: lo = mid2 else: hi = mid return lo 1095. Find in Mountain Array查找山峰数组中的元素，优先返回左侧的索引，如果都没有返回-1。原题123Input: array = [1,2,3,4,5,3,1], target = 3Output: 2Explanation: 3 exists in the array, at index=2 and index=5. Return the minimum index, which is 2. 方法一：三次二分法，想到了这个方式，犹豫了一下，因为觉得这种方式在最坏的情况下取值会超过100次。 第一次找到峰值，和162一样。 1234567891011121314151617181920212223242526272829303132def findInMountainArray(self, target: int, A: 'MountainArray') -&gt; int: lo, hi = 0, A.length()-1 while lo &lt; hi: mid = (lo+hi) // 2 mid2 = mid + 1 if A.get(mid) &lt; A.get(mid2): lo = mid2 else: hi = mid peak = lo lo, hi = 0, peak while lo &lt;= hi: mid = (lo+hi) // 2 mid_val = A.get(mid) if mid_val &gt; target: hi = mid - 1 elif mid_val &lt; target: lo = mid + 1 else: return mid lo, hi = peak, A.length()-1 while lo &lt;= hi: mid = (lo+hi) // 2 mid_val = A.get(mid) if mid_val &gt; target: lo = mid + 1 elif mid_val &lt; target: hi = mid - 1 else: return mid return -1 74. Search a 2D Matrix在2d数组中搜索目标，把数组抻成一维的也是有序数组。原题12345678Input:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 3Output: true 方法一：一开始没想到这个方法，而是先bisect_right找行，然后再在行里二分。 1234567891011121314def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool: if not matrix or not matrix[0]: return False n = len(matrix[0]) lo, hi = 0, n*len(matrix)-1 while lo &lt;= hi: mid = (lo+hi) // 2 if matrix[mid//n][mid%n] &gt; target: hi = mid - 1 elif matrix[mid//n][mid%n] &lt; target: lo = mid + 1 else: return True return False 436. Find Right Interval找到每个段的右侧的段的索引，右侧的段意味着起始点大于等于该段结尾点的并且最近的段。原题123456789Input: [ [3,4], [2,3], [1,2] ]Output: [-1, 0, 1]Explanation: There is no satisfied &quot;right&quot; interval for [3,4].For [2,3], the interval [3,4] has minimum-&quot;right&quot; start point;For [1,2], the interval [2,3] has minimum-&quot;right&quot; start point.[ [3,4], [6,9], [5,8] ][2,-1,-1] 方法一：二分法。理清题意后挺简单的。 123456789def findRightInterval(self, intervals: 'List[Interval]') -&gt; List[int]: starts = [(start, i) for i, (start, _) in enumerate(intervals)] starts.append((float('inf'), -1)) starts.sort() ans = [] for _, end in intervals: i = bisect.bisect_left(starts, (end, )) ans.append(starts[i][-1]) return ans 方法二：压缩一下。 1234def findRightInterval(self, intervals: 'List[Interval]') -&gt; List[int]: starts = [(start, i) for i, (start, _) in enumerate(intervals)] + [(float('inf'), -1)] starts.sort() return [starts[bisect.bisect_left(starts, (end, ))][-1] for _, end in intervals] 911. Online Election找到某一时间的选举票最多的人。1234567Input: [&quot;TopVotedCandidate&quot;,&quot;q&quot;,&quot;q&quot;,&quot;q&quot;,&quot;q&quot;,&quot;q&quot;,&quot;q&quot;], [[[0,1,1,0,0,1,0],[0,5,10,15,20,25,30]],[3],[12],[25],[15],[24],[8]]Output: [null,0,1,1,0,0,1]Explanation: At time 3, the votes are [0], and 0 is leading.At time 12, the votes are [0,1,1], and 1 is leading.At time 25, the votes are [0,1,1,0,0,1], and 1 is leading (as ties go to the most recent vote.)This continues for 3 more queries at time 15, 24, and 8. 方法一：二分法，挺简单的。 12345678910111213141516class TopVotedCandidate: def __init__(self, persons: List[int], times: List[int]): self.leading = [] tickets = collections.defaultdict(int) max_votes, candidate = 0, 0 for p, t in zip(persons, times): tickets[p] += 1 if tickets[p] &gt;= max_votes: candidate = p max_votes = tickets[p] self.leading.append((t, candidate)) def q(self, t: int) -&gt; int: i = bisect.bisect(self.leading, (t, float('inf'))) return self.leading[i-1][1] 方法二：Lee的方法，写法上改进，时间并不需要绑定在一起，可以通过二分时间索引找选举人。 12345678910111213141516class TopVotedCandidate: def __init__(self, persons: List[int], times: List[int]): self.leading = [] self.times = times tickets = collections.defaultdict(int) lead = -1 for p in persons: tickets[p] += 1 if tickets[p] &gt;= tickets[lead]: lead = p self.leading.append(lead) def q(self, t: int) -&gt; int: i = bisect.bisect(self.times, t) return self.leading[i-1]]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer]]></title>
    <url>%2F%E5%89%91%E6%8C%87Offer%2F</url>
    <content type="text"><![CDATA[2. 实现Singleton模式使用__new__控制实例创建过程123456789class Singleton: _instance = None def __new__(cls, *args, **kw): if not cls._instance: cls._instance = super().__new__(cls) return cls._instanceclass MyClass(Singleton): pass 使用decorator12345678910111213from functools import wrapsdef singleton(cls): instances = &#123;&#125; @wraps(cls) def get_instance(*args, **kw): if cls not in instances: instances[cls] = cls(*args, **kw) return instances[cls] return get_instance@singletonclass Myclass: pass 使用元类123456789101112131415class Singleton(type): def __init__(self, *args, **kwargs): self.__instance = None super().__init__(*args, **kwargs) def __call__(self, *args, **kwargs): if self.__instance is None: self.__instance = super().__call__(*args, **kwargs) return self.__instance else: return self.__instance# Exampleclass Spam(metaclass=Singleton): def __init__(self): print('Creating Spam') 3 数组中重复的数字牛客网传送门书中参数还传了一个数组用来保存重复的数字，身为一个Pythoner，直接返回tuple。 123456789def duplicate(nums: list) -&gt; int: for i, num in enumerate(nums): while i != num: if num == nums[num]: return True, num else: nums[i], nums[num] = nums[num], nums[i] num = nums[i] return False, None 3_1 数组中重复的数字，不能修改数组AcWing传送门元素范围变成了1~n。此方法有缺陷，不能找出所有的重复的数字，因为在1~2的范围里有1和2两个数字，这个范围的数字也出现两次，不能确定是每个数字各出现一次还是某个数字出现了两次。 12345678910111213141516171819def find_duplicate(nums: list) -&gt; int: def count_range(i, j): return sum(i&lt;=num&lt;=j for num in nums) lo = 1 hi = len(nums) - 1 # n为范围 while lo &lt;= hi: mid = (lo + hi) // 2 count = count_range(lo, mid) if lo == hi: if count &gt; 1: return lo else: break if count &gt; mid-lo+1: hi = mid else: lo = mid + 1 return -1 4. 二维数组中的查找牛客网传送门AcWing传送门LeetCode传送门选取右上角为起始点。 1234567891011def find(target, array): row = 0 col = len(array[0]) - 1 while col &gt;= 0 and row &lt;= len(array)-1: if array[row][col] &gt; target: col -= 1 elif array[row][col] &lt; target: row += 1 else: return True return False 更为优雅的方法。 12345678def searchMatrix(self, matrix, target): j = -1 for row in matrix: while j + len(row) and row[j] &gt; target: j -= 1 if row[j] == target: return True return False 5.替换空格牛客网传送门AcWing传送门12def replaceSpace(self, s): return ''.join(c if c!=' ' else '%20' for c in s) 6.从尾到头打印链表AcWing传送门123456def printListFromTailToHead(self, listNode): stack, h = [], listNode while h: stack.append(h.val) h = h.next return stack[::-1] 7.重建二叉树LeetCode传送门说明：根据前序遍历和中序遍历重建二叉树，假设遍历结果中不包含重复的数字。123456789def buildTree(preorder, inorder): if preorder == []: return None root_val = preorder[0] root = TreeNode(root_val) cut = inorder.index(root_val) root.left = buildTree(preorder[1:cut+1], inorder[:cut]) root.right = buildTree(preorder[cut+1:], inorder[cut+1:]) return root 方法二：空间复杂度更低的解法。 1234567891011def buildTree(self, preorder: 'List[int]', inorder: 'List[int]') -&gt; 'TreeNode': def build(stop): if inorder and inorder[-1] != stop: root = TreeNode(preorder.pop()) root.left = build(root.val) inorder.pop() root.right = build(stop) return root preorder.reverse() inorder.reverse() return build(None) 8 二叉树的下一个节点牛客网传送门AcWing传送门如果节点有右子树，那么下一个节点为右子树中的最左节点； 如果节点是父节点的左子节点，那么父节点就是下一个节点； 如果节点是父节点的右子节点，沿着父节点向上遍历找到祖先节点中，为父节点左子节点的点，这个左子节点的父节点就是下一个节点。 12345678910111213141516def GetNext(self, pNode): # write code here if not pNode: return None # 有右子树，右子树中最左节点 if pNode.right: pre = pNode.right while pre.left: pre = pre.left return pre while pNode.next: parent = pNode.next if parent.left == pNode: return parent pNode = parent return None 9.用两个栈实现队列LeetCode传送门123456789101112131415161718192021class MyQueue: def __init__(self): self.s1 = [] self.s2 = [] def push(self, x: int) -&gt; None: while self.s1: self.s2.append(self.s1.pop()) self.s1.append(x) while self.s2: self.s1.append(self.s2.pop()) def pop(self) -&gt; int: return self.s1.pop() def peek(self) -&gt; int: return self.s1[-1] def empty(self) -&gt; bool: return self.s1 == [] 9.1用两个队列实现栈LeetCode传送门两个队列1234567891011121314151617181920class MyStack: def __init__(self): from collections import deque self.q1, self.q2 = deque(), deque() def push(self, x: int) -&gt; None: self.q2.append(x) while self.q1: self.q2.append(self.q1.popleft()) self.q1, self.q2 = self.q2, self.q1 def pop(self) -&gt; int: return self.q1.popleft() def top(self) -&gt; int: return self.q1[0] def empty(self) -&gt; bool: return not self.q1 单队列旋转123456789101112131415161718192021class MyStack: def __init__(self): from collections import deque self.q = deque() def push(self, x: int) -&gt; None: self.q.append(x) # self.q.rotate(1) 这里是用了双端队列的特性 # self.q.rotate(1-len(self.q)) 这里和下面循环是一样的效果 for _ in range(len(self.q)-1): self.q.append(self.q.popleft()) def pop(self) -&gt; int: return self.q.popleft() def top(self) -&gt; int: return self.q[0] def empty(self) -&gt; bool: return not self.q 10.斐波那契数列LeetCode传送门12345def fibonacci(n): a = b = 1 for _ in range(n-1): a, b = b, a+b return b 11.旋转数组的最小数字LeetCode传送门思路：通过二分法不断缩小范围，由于mid是整除，最后l==mid，并且nums[mid] &gt; nums[r]的。123456789101112def find_min(nums): l, r = 0, len(nums)-1 if nums[l] &lt; nums[r]: return nums[l] while l &lt;= r: mid = (l+r) // 2 if nums[mid] &gt; nums[l]: l = mid elif nums[mid] &lt; nums[r]: r = mid else: return nums[r] 12.矩阵中的路径LeetCode传送门123456789101112131415161718192021def exist(self, g: List[List[str]], word: str) -&gt; bool: R, C = len(g), len(g[0]) def spread(i, j, w): if not w: return True original, g[i][j] = g[i][j], '-' spreaded = False for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)): if (0&lt;=x&lt;R and 0&lt;=y&lt;C and w[0]==g[x][y] and spread(x, y, w[1:])): spreaded = True break g[i][j] = original return spreaded for i in range(R): for j in range(C): if g[i][j] == word[0] and spread(i, j, word[1:]): return True return False 13. 机器人的运动范围AcWing传送门1234567891011121314def movingCount(self, threshold, rows, cols): visited = [[False]*cols for _ in range(rows)] def get_sum(x, y): return sum(map(int, str(x)+str(y))) def movingCore(threshold, rows, cols, i, j): if get_sum(i, j) &lt;= threshold: visited[i][j] = True for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)): if 0&lt;=x&lt;rows and 0&lt;=y&lt;cols and not visited[x][y]: movingCore(threshold, rows, cols, x, y) movingCore(threshold, rows, cols, 0, 0) return sum(sum(visited, [])) 14.剪绳子AcWing传送门说明：数学思想，当n&gt;=5时，2(n-2)&gt;n并且3(n-3)&gt;n，而且3(n-3) &gt;= 2(n-2)，所以尽可能多剪长度为3的绳子。如果长度为4的时候，2*2&gt;3*1，所以4的时候就剪成2*2的两段。 123456789101112131415def cut_rope(length): if length &lt; 2: return 0 if length == 2: return 1 if length == 3: return 2 # 尽可能剪出3 timesOf3 = length // 3 # 如果最后余1，则留一段4分成两半 if length-timesOf3*3 == 1: timeOf3 -= 1 timesOf2 = (length-timesOf3*3) // 2 return (3**timesOf3) * (2**timesOf2) 15.二进制中1的个数LeetCode传送门方法一：常规解法，使用1与n作与运算，如果不是0说明，含有一个1。123456def hamming_weight(n): count = 0 for _ in range(32): count += (n&amp;1==1) n &gt;&gt;= 1 return count 方法二：关键点是，一个数n和n-1的与运算操作，相当于去掉了最右面的1。123456def hamming_weigth(n): bits = 0 while n: bits += 1 n = (n-1) &amp; n return bits 16.数值的整数次方LeetCode传送门1234567891011121314151617def myPow(self, x: float, n: int) -&gt; float: def pow_with_unsigned(x, n): if n == 0: return 1 if n == 1: return x ans = pow_with_unsigned(x, n&gt;&gt;1) ans *= ans if n &amp; 1 == 1: ans *= x return ans if n &lt; 0: return 1 / pow_with_unsigned(x, -n) else: return pow_with_unsigned(x, n) 17 打印从1到最大的n位数404.打印呗，反正Python的int没有长度限制。 1234def print_n(n: int): n = 10 ** (n) for i in range(1, n): print(i) 18.删除链表中的节点LeetCode传送门开始看到这题的思路是，要是能拿到父节点就好了，然后这道题需要别的思路，其关键在于复制123def deleteNode(self, node): node.val = node.next.val # 4-&gt;1-&gt;1-&gt;9 node.next = node.next.next # 4-&gt;1-&gt;9 19.正则表达式LeetCode传送门先考虑没有*的情况，通过一个递归逐个字符判断 1234def match(text, pattern): if not pattern: return not text first_match = bool(text) and pattern[0] in &#123;text[0], '.'&#125; return first_match and match(text[1:], pattern[1:]) 当*出现时，一定会在前面跟一个其他字符，所以一定会出现在pattern[1]的位置。一种情况是我们忽略这对pattern，因为可以出现0次；另一种情况是匹配上这个字符，用递归的方式匹配下一个。 一定要用f_match = bool(s)，否则结果可能输出&#39;&#39; 12345678def match(self, s, pattern): if not pattern: return not s f_match = bool(s) and pattern[0] in &#123;s[0], '.'&#125; if len(pattern) &gt; 1 and pattern[1] == '*': return (self.match(s, pattern[2:]) or (f_match and self.match(s[1:], pattern))) else: return f_match and self.match(s[1:], pattern[1:]) 20. 表示数值的字符串65. Valid Number此处留坑，排名第一的python答案暂时没有理解。 21.调整数组顺序使奇数位于偶数前面AcWing传送门时间：O(n), 空间O(1) 123456789def reOrderArray(self, array): # write code here l, r = 0, len(array)-1 while l &lt; r: while l &lt; r and array[l]&amp;1 == 1: l += 1 while l &lt; r and array[r]&amp;1 == 0: r -= 1 array[l], array[r] = array[r], array[l] 看了一下没有通过牛客网的测试用例，因为题目有些不同，牛客网要求奇数和奇数，偶数和偶数之前的相对位置不变。 12def reOrderArray(array): return sorted(array, key=lambda x:x&amp;1==0) 不使用sort 1234567891011def reOrderArray(self, array): # write code here from collections import deque q = deque() n = len(array) for i in range(n): if array[-i-1] &amp; 1 == 1: # 从后找奇数 q.appendleft(array[-i-1]) if array[i] &amp; 1 == 0: #从前找偶数 q.append(array[i]) return q 22.链表中倒数第k个节点AcWing传送门思路：两个指针，快指针先走k-1步，然后两个一起走，快指针走到尾节点时，慢指针在倒数第k个节点。需考虑k=0时和fast已经走到尾节点的情况。 12345678910def FindKthToTail(self, head, k): fast = slow = head for _ in range(k): if fast: fast = fast.next else: return None while fast: slow, fast = slow.next, fast.next return slow 23.链表中环的入口节点LeetCode传送门 首先判断此链表是否有环。 然后再相交点和头结点一起走，一定会在入口相遇。 12345678910111213def detectCycle(self, head): fast = slow = head # 检测是否有环 while fast and fast.next: slow, fast = slow.next, fast.next.next if slow is fast: break else: return None # 找出入口节点 while head is not slow: head, slow = head.next, slow.next return head 24.反转链表LeetCode传送门12345def reverseList(self, head): prev = None while head: head.next, prev, head = prev, head, head.next return prev 25.合并两个有序链表LeetCode传送门方法1：iteratively 迭代 12345678910def mergeTwoLists(l1, l2): l = head = ListNode(0) while l1 and l2: if l1.val &lt;= l2.val: l.next, l1 = l1, l1.next else: l.next, l2 = l2, l2.next l = l.next l.next = l1 or l2 return head.next 方法2：recursively 递归 12345678910def mergeTwoLists(l1, l2): # 判断是否存在None if not l1 or not l2: return l1 or l2 if l1.val &lt; l2.val: l1.next = mergeTwoLists(l1.next, l2) return l1 else: l2.next = mergeTwoLists(l1, l2.next) return l2 26.树的子结构572. Subtree of Another Tree 二刷的时候突然发现，此题和LeetCode中不同。LeetCode中子树4-1-2返回False因为2下边还有节点，所以不一样；而书中认为True，不考虑2下边的节点。 1234567 3 / \ 4 5 / \1 2 / 0 12345678910111213141516171819202122def is_subtree(s: 'TreeNode', t: 'TreeNode') -&gt; 'bool': def is_same(s, t): if s and t: equal = s.val==t.val if not t.left and not t.right: return equal else: return (equal and is_same(s.left, t.left) and is_same(s.right, t.right)) else: return s is t stack = s and [s] while stack: node = stack.pop() if node: res = is_same(node, t) if res: return True stack.append(node.right) stack.append(node.left) return False 27.二叉树的镜像AcWing传送门12345def Mirror(self, root): if root: root.left, root.right = root.right, root.left self.Mirror(root.left) self.Mirror(root.right) 迭代 1234567def Mirror(self, root): stack = root and [root] while stack: n = stack.pop() if n: n.left, n.right = n.right, n.left stack += n.right, n.left 28.对称的二叉树LeetCode传送门12345 1 / \ 2 2 / \ / \3 4 4 3 方法一：recursively. 123456789101112def isSymmetric(self, root: 'TreeNode') -&gt; 'bool': def symmetric(p1, p2): if p1 and p2: return (p1.val == p2.val and symmetric(p1.left, p2.right) and symmetric(p1.right, p2.left)) else: return p1 is p2 if not root: return True return symmetric(root.left, root.right) 方法二：iteratively. 12345678910def isSymmetric(self, root: 'TreeNode') -&gt; 'bool': stack = root and [(root.left, root.right)] while stack: p1, p2 = stack.pop() if not p1 and not p2: continue if not p1 or not p2: return False if p1.val != p2.val: return False stack.append((p1.left, p2.right)) stack.append((p1.right, p2.left)) return True 29.顺时针打印矩阵LeetCode传送门这里注意一点matrix.pop(0)需要转成list，因为zip函数中的每个元素是一个tuple，如果不转变成了一个tuple+list，会抛出异常。 123def spiralOrder(self, matrix): return (matrix and list(matrix.pop(0)) + self.spiralOrder(list(zip(*matrix))[::-1])) 此题有个变形，如果逆时针该如何打印。这样的话情况稍微复杂一些。 1234567def anti_clock_wise(self, matrix) if not matrix: return [] clock_wise = list(zip(*(matrix[::-1]))) a = list(clock_wise.pop(0))[::-1] b = self.anti_clock_wise(clock_wise) return a + b 30.包含min函数的栈LeetCode传送门12345678910111213141516171819202122232425class MinStack: def __init__(self): self._stack = [] def push(self, x: int) -&gt; None: cur_min = self.getMin() if x &lt; cur_min: cur_min = x self._stack.append((x, cur_min)) def pop(self) -&gt; None: self._stack.pop() def top(self) -&gt; int: if not self._stack: return None else: return self._stack[-1][0] def getMin(self) -&gt; int: if not self._stack: return float('inf') else: return self._stack[-1][1] 31.栈的压入、弹出序列LeetCode传送门123456789def validateStackSequences(self, pushed: 'List[int]', popped: 'List[int]') -&gt; 'bool': stack = [] j = 0 for num in pushed: stack.append(num) while stack and stack[-1] == popped[j]: stack.pop() j += 1 return j == len(popped) 32.从上到下打印二叉树AcWing传送门双端队列 1234567891011def PrintFromTopToBottom(self, root): from collections import deque queue = deque([root]) res = [] while queue: cur = queue.popleft() if cur: res.append(cur.val) queue.append(cur.left) queue.append(cur.right) return res 32.1分层从上到下打印二叉树LeetCode传送门123456def levelOrder(self, root: 'TreeNode') -&gt; 'List[List[int]]': ans, level = [], root and [root] while level: ans.append([n.val for n in level]) level = [k for n in level for k in (n.left, n.right) if k] return ans 32.2之字形打印二叉树LeetCode传送门1234567def zigzagLevelOrder(self, root: 'TreeNode') -&gt; 'List[List[int]]': ans, level, order = [], root and [root], 1 while level: ans.append([n.val for n in level][::order]) order *= -1 level = [kid for n in level for kid in (n.left, n.right) if kid] return ans 33.是否是二叉树的后序遍历AcWing传送门123456789101112131415def VerifySquenceOfBST(self, seq): from itertools import takewhile if not seq: return False p = seq[-1] left_sub = list(takewhile(lambda x: x &lt; p, seq[:-1])) right_sub = seq[len(left_sub):-1] if not all(x&gt;p for x in right_sub): return False left = right = True if left_sub: left = self.VerifySquenceOfBST(left_sub) if right_sub: right = self.VerifySquenceOfBST(right_sub) return left and right 34.二叉树和为某一值的路径LeetCode传送门12345678910111213sum = 22 5 / \ 4 8 / / \ 11 13 4 / \ / \7 2 5 1[ [5,4,11,2], [5,8,4,5]] 方法一：iteratively. 举一反三。 123456789101112def pathSum(self, root: 'TreeNode', total: 'int') -&gt; 'List[List[int]]': stack = root and [(root, [root.val], total)] ans = [] while stack: n, v, t = stack.pop() if not n.left and not n.right and n.val==t: ans.append(v) if n.right: stack.append((n.right, v+[n.right.val], t-n.val)) if n.left: stack.append((n.left, v+[n.left.val], t-n.val)) return ans recursively. 先找出所有路径，再过滤，实际上和257题一样。不过这并没有把这道题的特性涵盖进去。 12345678910def pathSum(self, root, sum_val): paths = self.all_paths(root) return [path for path in paths if sum(path)==sum_val] def all_paths(self, root): if not root: return [] return [[root.val]+path for kid in (root.left, root.right) if kid for path in self.all_paths(kid)] or [[root.val]] 方法三：recursively. 123456789def pathSum(self, root, sum): if not root: return [] val, *kids = root.val, root.left, root.right if any(kids): return [[val] + path for kid in kids if kid for path in self.pathSum(kid, sum-val)] return [[val]] if val==sum else [] 35.复杂链表的复制LeetCode传送门方法一：遍历两次。 1234567891011def copyRandomList(self, head: 'Node') -&gt; 'Node': cp = &#123;None: None&#125; m = n = head while m: cp[m] = Node(m.val, None, None) m = m.next while n: cp[n].next = cp[n.next] cp[n].random = cp[n.random] n = n.next return cp[head] Time-O(n), Memory-O(n). 这种方式是相当于把第一次迭代的过程委托给了defaultdict，通过创建一个默认的对象，再去修改它的label值。 12345678910def copyRandomList(self, head: 'Node') -&gt; 'Node': cp = collections.defaultdict(lambda: Node(0, None, None)) cp[None] = None h = head while h: cp[h].val = h.val cp[h].next = cp[h.next] cp[h].random = cp[h.random] h = h.next return cp[head] 36.二叉搜索树与双向链表LeetCode有此题，但是不是免费的。AcWing传送门方法一：中序遍历，再构造链表。 1234567891011121314def convert(self, root): from itertools import tee def dfs(node): if node: yield from dfs(node.left) yield node yield from dfs(node.right) a, b = tee(dfs(root)) ans = next(b, None) for f, s in zip(a, b): f.right = s s.left = f return ans 方法二：分别递归处理左子树和右子树。 12345678910111213141516171819202122232425def Convert(self, root): def convert_tree(node): if not node: return None if node.left: left = convert_tree(node.left) while left.right: left = left.right left.right = node node.left = left if node.right: right = convert_tree(node.right) while right.left: right = right.left right.left = node node.right = right return node if not root: return root root = convert_tree(root) while root.left: root = root.left return root 方法三：Morris Traversal. 1234567891011121314151617def Convert(self, root): cur = root pre = ans = None while cur: while cur.left: q = cur.left while q.right: q = q.right q.right = cur # 补齐右指针 cur.left, cur = None, cur.left # 拆掉左指针 cur.left = pre if pre is None: ans = cur # 这里是为了找到链表的头，只执行一次 else: pre.right = cur pre, cur = cur, cur.right return ans 37.序列化二叉树LeetCode传送门12345678910111213141516171819class Codec: def serialize(self, root): if not root: return '$' return str(root.val) + ',' + self.serialize(root.left) + ',' + self.serialize(root.right) def deserialize(self, data): def deserialize_tree(nodes): val = next(nodes) if val == '$': return None root = TreeNode(val) root.left = deserialize_tree(nodes) root.right = deserialize_tree(nodes) return root nodes = iter(data.split(',')) return deserialize_tree(nodes) 38.字符串的排列46. Permutations II LeetCode传送门使用itertools 123456def Permutation(self, ss): # write code here from itertools import permutations if not ss: return [] return sorted(list(set([''.join(x) for x in permutations(ss)]))) 这里注意几点： 为什么要判断if not ss，是因为如果ss=&#39;&#39;的时时候，返回了[&#39;&#39;]而不是[]。因为这里返回了一个空的tuple，所以在列表推导式中是有一个元素的。 12&gt;&gt;&gt; list(permutations('', 0))[()] 为什么使用set去重，因为当ss=&#39;aa&#39;的时候，牛客网的测试用例要求返回一个元素，即[&#39;aa&#39;]。 排序也是为了满足测试用例。 自己实现。这里拆成两个方法的原因还是因为ss=&#39;&#39;的时候会影响递归循环。 12345678910def Permutation(self, ss): if not ss: return [] return self.permute(ss)def permute(self, ss): return sorted(list(set([h + p for i, h in enumerate(ss) for p in self.permute(ss[:i]+ss[i+1:]) ]))) or [""] 方法二：迭代。 123456def Permutation(self, ss): ans = [''] for s in ss: ans = [p[:i] + s + p[i:] for p in ans for i in range((p+s).index(s)+1)] return sorted(ans) if ss else [] 39.数组中出现次数超过一半的数字LeetCode传送门方法一：排序. Time-O(nlogn), Space-O(n) 12def majority_element(nums): return sorted(nums)[len(nums)//2] 方法二：Counter Time-O(n), Space-O(n) 12345def majority_element(nums): from collections import Counter c = Counter(nums) # return max(c.keys(), key=c.get) return c.most_common(1)[0][0] 方法三：Boyer-Moore Voting Algorithm. 书中的算法说的就是这个，这详情请看波义尔摩尔投票。 12345678def majorityElement(self, nums): count = 0 candidate = None for num in nums: if count == 0: candidate = num count += (1 if num == candidate else -1) return candidate 40.最小的k个数相似题目，但是求最大的k个数LeetCode传送门牛客网传送门12345678910111213141516171819202122def GetLeastNumbers_Solution(self, tinput, k): # write code here l, r = 0, len(tinput)-1 if k &gt; len(tinput) or k &lt; 1: return [] # for passing the damn testcase while True: pos = self.partition(tinput, l, r) if pos &lt; k-1: l = pos + 1 elif pos &gt; k-1: r = pos - 1 else: return sorted(tinput[:pos+1]) # sorted for passing the damn testcase def partition(self, nums, l, r): from random import randint p = randint(l, r) nums[r], nums[p] = nums[p], nums[r] for i, v in enumerate(nums[l:r+1], l): if nums[i] &lt;= nums[r]: nums[l], nums[i] = nums[i], nums[l] l += 1 return l-1 # the pivot index 使用堆，不改变原数组 123456789def GetLeastNumbers_Solution(self, tinput, k): import heapq as hq if k &gt; len(tinput) or k &lt;= 0: return [] heap = [-x for x in tinput[:k]] hq.heapify(heap) for num in tinput[k:]: if -heap[0] &gt; num: hq.heapreplace(heap, -num) return sorted(-x for x in heap) 41.数据流中的中位数LeetCode传送门思路：使用两个堆，最大堆存储较小的数据，最小堆存储较大的数据。添加数字时，先添加到最大堆，然后最大堆返回一个最大的数字给最小堆，最后为了平衡，可能需要最小堆还给最大堆一个最小值，以保证最大堆的长度&gt;=最小堆的长度。由于headpq是最小堆，所以使用取反实现最大堆。添加数字：Time-O(logn)，取出中位数：Time-O(1)。 1234567891011121314151617181920212223242526272829Adding number 41MaxHeap lo: [41] // MaxHeap stores the largest value at the top (index 0)MinHeap hi: [] // MinHeap stores the smallest value at the top (index 0)Median is 41=======================Adding number 35MaxHeap lo: [35]MinHeap hi: [41]Median is 38=======================Adding number 62MaxHeap lo: [41, 35]MinHeap hi: [62]Median is 41=======================Adding number 4MaxHeap lo: [35, 4]MinHeap hi: [41, 62]Median is 38=======================Adding number 97MaxHeap lo: [41, 35, 4]MinHeap hi: [62, 97]Median is 41=======================Adding number 108MaxHeap lo: [41, 35, 4]MinHeap hi: [62, 97, 108]Median is 51.5 12345678910111213141516171819import heapq as hqclass MedianFinder: def __init__(self): self.lo, self.hi = [], [] # lo is max_heap, hi is min_heap def addNum(self, num): hq.heappush(self.lo, -num) hq.heappush(self.hi, -hq.heappop(self.lo)) if len(self.lo) &lt; len(self.hi): hq.heappush(self.lo, -hq.heappop(self.hi)) def findMedian(self): if len(self.lo) == len(self.hi): return (-self.lo[0]+self.hi[0]) / 2.0 else: return float(-self.lo[0]) 42.连续子数组的最大和LeetCode传送门方法一：书中的思想。 123456def maxSubArray(self, nums): cp_nums = nums[:] for i in range(1, len(nums)): if cp_nums[i-1] &gt; 0: cp_nums[i] += cp_nums[i-1] return max(cp_nums) 方法二：one-liner。注意accumulate是把函数放到后面的。 123def maxSubArray(self, nums): from itertools import accumulate return max(accumulate(nums, lambda x, y: x+y if x &gt; 0 else y)) 43.1~n整数中1出现的次数LeetCode传送门1234567def countDigitOne(self, n): countr, i = 0, 1 while i &lt;= n: divider = i * 10 countr += (n // divider) * i + min(max(n % divider - i + 1, 0), i) i *= 10 return countr 45.把数组排成最小的数字AcWing传送门python2的写法。 123def PrintMinNumber(self, numbers): return ''.join(sorted(map(str, numbers), lambda x, y: cmp(x+y, y+x))) 匿名函数作为sort的参数，在python2中有这个参数。 cmp specifies a custom comparison function of two arguments (iterable elements) which should return a negative, zero or positive number depending on whether the first argument is considered smaller than, equal to, or larger than the second argument: cmp=lambda x,y: cmp(x.lower(), y.lower()). The default value is None. 作为sort的参数，cmp提供了一个自定义的比较两个元素的方法，如果返回-1表示前者小于后者。python3中取消了这个参数，但是提供了一种key的转换。而内置函数可以通过运算符实现。 1cmp(a, b) 等同于 1(a&gt;b) - (a&lt;b) 所以python3的写法如下： 123456from functools import cmp_to_keydef PrintMinNumber(self, numbers): # write code here nums = list(map(str, numbers)) nums.sort(key=cmp_to_key(lambda x, y: ((x+y)&gt;(y+x)) - ((y+x)&gt;(x+y)))) return ''.join(nums) 46 把数字翻译成字符串LeetCode传送门123456789def numDecodings(self, s: str) -&gt; int: # w tells the number of ways # v tells the previous number of ways # d is the current digit # p is the previous digit v, w, p = 0, int(s&gt;''), '' for d in s: v, w, p = w, int(d&gt;'0')*w + (9&lt;int(p+d)&lt;27)*v, d return w 47 礼物的最大价值LeetCode传送门。相似题目，求的是最小。Acwing传送门这个是原题。对首行使用初始化，然后消除了i的判断。 12345678910def get_max_value(g: 'List[List[int]]') -&gt; int: R, C = len(g), len(g[0]) cur = list(itertools.accumulate(g[0])) for i in range(1, R): tmp = [] for j in range(C): left = tmp[-1] if j &gt; 0 else float('-inf') tmp.append(max(cur[j], left) + g[i][j]) cur = tmp return cur[-1] 48.最长不含重复字符的子字符串LeetCode传送门方法二：找到重复值时，更新start的值，为什么使用max，因为start有可能大于dic[s[end]]+1，比如当s=&#39;abba&#39;，end走到最后的时候，上一次start因为b做了更新变为了2。 123456789def lengthOfLongestSubstring(self, s): ans = start = 0 pos = &#123;&#125; # last index of element for end, c in enumerate(s): if c in pos: start = max(start, pos[c]+1) pos[c] = end ans = max(ans, end-start+1) return ans 49.丑数LeetCode传送门1234567891011121314def nthUglyNumber(self, n: int) -&gt; int: q = [1] t2 = t3 = t5 = 0 for _ in range(n-1): a2, a3, a5 = q[t2]*2, q[t3]*3, q[t5]*5 to_add = min(a2, a3, a5) q.append(to_add) if a2 == to_add: t2 += 1 if a3 == to_add: t3 += 1 if a5 == to_add: t5 += 1 return q[-1] 50.第一个只出现一次的字符LeetCode传送门有一点小区别，LeetCode输出索引，书中输出值。1234s = &quot;leetcode&quot;return 0.s = &quot;loveleetcode&quot;,return 2. Time-O(N), Space-O(N)。暂时没发现更快的算法了。 1234567def firstUniqChar(self, s): from collections import Counter c = Counter(s) for i, ch in enumerate(s): if c[ch] == 1: return i return -1 51.数组中的逆序对牛客网传送门AcWing传送门这里使用了双端队列感觉不太合适，因为还要显式地转成list，否则没法对剩余的left或right做切片。也试了将其改为stack，但是stack来回reverse又太麻烦。 123456789101112131415161718192021222324252627def InversePairs(self, data): self.count = 0 def merge(left, right): q = deque() l, r = len(left)-1, len(right)-1 while l &gt;= 0 and r &gt;= 0: if left[l] &gt; right[r]: self.count += r + 1 q.appendleft(left[l]) l -= 1 else: q.appendleft(right[r]) r -= 1 # q.extendleft(left[l:-1:-1] or right[r:-1:-1]) q = left[:l+1] + right[:r+1] + list(q) return q def merge_sort(ary): if len(ary) &lt;= 1: return ary mid = len(ary) // 2 left = merge_sort(ary[:mid]) right = merge_sort(ary[mid:]) return merge(left, right) merge_sort(data) return self.count % 1000000007 52.两个链表的第一个公共节点LeetCode传送门123456def getIntersectionNode(self, headA, headB): p1, p2 = headA, headB while p1 is not p2: p1 = p1.next if p1 else headB p2 = p2.next if p2 else headA return p1 53.在排序数组中查找数字相似题目，LeetCode是求出数字的索引，书中返回个数。 LeetCode传送门。相似题目，LeetCode要返回两个索引，书中求个数。1234Input: nums = [5,7,7,8,8,10], target = 8Output: [3,4]Input: nums = [5,7,7,8,8,10], target = 6Output: [-1,-1] 方法一：标准库写法。这里不需要target去整个nums中判断。 1234567def searchRange(self, nums: List[int], target: int) -&gt; List[int]: from bisect import bisect, bisect_left lo = bisect_left(nums, target) if target in nums[lo:lo+1]: return lo, bisect(nums, target)-1 else: return -1, -1 方法二：自己实现。bisect_right的方式采用+1的形式。 12345678910111213141516def searchRange(self, nums: List[int], target: int) -&gt; List[int]: def search(n): lo, hi = 0, len(nums) while lo &lt; hi: mid = (lo + hi) // 2 if nums[mid] &gt;= n: hi = mid else: lo = mid + 1 return lo lo = search(target) if target in nums[lo:lo+1]: return lo, search(target+1)-1 else: return -1, -1 53.0~n-1中缺失的数字LeetCode传送门相似题目，LeetCode是未排序，书中是已排序。所以可以利用排序的特性使时间复杂度小于O(n)。即找出第一个下标与值不相等的元素，再-1就是缺失的元素。 AcWing传送门方法一：数学公式。 12345def missingNumber(self, nums): n = len(nums) expected_sum = n*(n+1) // 2 actual_sum = sum(nums) return expected_sum - actual_sum 方法二：XOR. index 0 1 2 value 3 0 1 12345def missingNumber(self, nums: 'List[int]') -&gt; 'int': missing = len(nums) for i, num in enumerate(nums): missing ^= i ^ num return missing 方法三：利用书中已排序的特性。 1234567891011def getMissingNumber(self, nums): lo, hi = 0, len(nums)-1 while lo &lt;= hi: mid = (lo + hi) &gt;&gt; 1 if nums[mid] != mid: if mid==0 or nums[mid-1]==mid-1: return mid hi = mid - 1 else: lo = mid + 1 return lo 53 数组中数值和下标相等的元素AcWing传送门1234567891011def getNumberSameAsIndex(self, nums): lo, hi = 0, len(nums)-1 while lo &lt;= hi: mid = (lo + hi) &gt;&gt; 1 if nums[mid] &lt; mid: lo = mid + 1 elif nums[mid] &gt; mid: hi = mid - 1 else: return mid return -1 54.二叉搜索树的第k大节点AcWing传送门注意：牛客网上是求第k小节点，这里被坑了一次，然后返回值居然要求返回节点对象，而不是节点值，这里的答案按书中返回。如果是牛客网上需要把节点添加到res中，然后return res[k-1] 123456789101112def kth_largest(self, root: TreeNode, k: int) -&gt; int: stack, ans = [], None while stack or root: while root: stack.append(root) root = root.right root = stack.pop() k -= 1 ans = root root = root.left if k == 0: return ans 55.二叉树的深度LeetCode传送门123456 3 / \ 9 20 / \ 15 7return 3 方法一：recursively 12345def max_depth(root): if not root: return 0 # return max(max_depth(root.left), max_depth(root.right)) + 1 return max(map(max_depth, (root.left, root.right))) + 1 方法二：iteratively. BFS with deque 12345678910def maxDepth(self, root: 'TreeNode') -&gt; 'int': q = root and collections.deque([(root, 1)]) d = 0 while q: node, d = q.popleft() if node.right: q.append((node.right, d+1)) if node.left: q.append((node.left, d+1)) return d 55.1平衡二叉树LeetCode传送门方法一：递归+递归。 12345678910def isBalanced(self, root): if not root: return True return self.isBalanced(root.left) and self.isBalanced(root.right) and \ abs(self.max_depth(root.left)-self.max_depth(root.right)) &lt;= 1 def max_depth(self, root): if not root: return 0 return max(self.max_depth(root.left), self.max_depth(root.right)) + 1 方法二：上诉两种方法中都包含了一些无意义的重复遍历。这里采用后序遍历，边遍历边判断，不会重复节点。受此思想启发，添加一种后序遍历二叉树的方法。 12345678910111213141516171819def isBalanced(self, root): stack, node, last = [], root, None depths = collections.defaultdict(int) while stack or node: if node: stack.append(node) node = node.left else: node = stack[-1] if not node.right or last == node.right: node = stack.pop() left, right = depths[node.left], depths[node.right] if abs(left - right) &gt; 1: return False depths[node] = 1 + max(left, right) last, node = node, None else: node = node.right return True 方法三：dfs. 算深度的时候判断左右是否深度超过1. 这里变量不能把self去掉，否则[1,2,2,3,3,null,null,4,4]会错误的返回True而不是False。也可以使用nonlocal 1234567891011121314def isBalanced(self, root: 'TreeNode') -&gt; 'bool': self.balanced = True def dfs(node): if not node: return 0 left = dfs(node.left) right = dfs(node.right) if abs(left-right) &gt; 1 and self.balanced: self.balanced = False return max(left, right) + 1 dfs(root) return self.balanced 56 数组中只出现一次的两个数字。找出数组中两个唯一出现一次的元素，其余元素均出现两次。LeetCode传送门12Input: [1,2,1,3,2,5]Output: [3,5] 思想：将这两个元素分到两个组，由于这两个数不相等，所以亦或结果不为0，也就是说二进制中至少有一位1，记为第n位。我们以第n位是否为1，把数组分为两个子数组。 123456789101112def singleNumber(self, nums: List[int]) -&gt; List[int]: from functools import reduce def get_single(nums): return reduce(operator.xor, nums) total_xor = get_single(nums) mask = 1 while total_xor&amp;mask == 0: mask &lt;&lt;= 1 n1 = [num for num in nums if num&amp;mask==0] n2 = [num for num in nums if num&amp;mask!=0] return get_single(n1), get_single(n2) 56.1数组中出现一次的数字，其余元素出现三次。LeetCode传送门12Input: [2,2,3,2]Output: 3 方法一：找出单独元素每一位的值。如果把所有数字的二进制每一位加起来，如果某一位可以被3整除，则表示单独元素的该位为0，否则为1。以下使用count来表示每一位1的个数。假设count%3!=0为True，说明该元素i位为1，然后是用|=更新ans在第i个位置的值，这里也可以使用+=，但是效率稍慢。convert的作用是因为python中的int是个对象，且没有最大限制，不是在第32位使用1来表示负数。 1234567891011121314def singleNumber(self, nums, n=3): ans = 0 for i in range(32): count = 0 for num in nums: if ((num &gt;&gt; i) &amp; 1): count += 1 ans |= ((count%n!=0) &lt;&lt; i) return self.convert(ans)def convert(self, x): if x &gt;= 2**31: x -= 2**32 return x 这里有个状态机的解法，不明觉厉，留坑。讨论1和讨论2 123456def singleNumber(self, nums): ones, twos = 0, 0; for i in range(len(nums)): ones = (ones ^ nums[i]) &amp; ~twos twos = (twos ^ nums[i]) &amp; ~ones return ones 57.和为s的数字牛客网传送门AcWing传送门看牛客网上的描述，如果有多对数字和为s，要求返回乘积最小的一对。乍一看以为牛客网又乱改题，但是仔细一想，如果两个和为s的数，而且是在递增数组中很明显，边缘的数字乘积要小，例如8X8&gt;1X15。所以还是和书中解法一样。 12345678910def FindNumbersWithSum(self, array, tsum): l, r = 0, len(array)-1 while l &lt; r: if array[l] + array[r] &lt; tsum: l += 1 elif array[l]+array[r] &gt; tsum: r -= 1 else: return array[l], array[r] return [] 57_1 和为s的连续正数序列牛客网传送门AcWing传送门1234567891011121314def findContinuousSequence(self, tsum): end = (tsum + 1) // 2 lo, hi, cur_sum = 1, 2, 3 ans = [] while lo &lt; end: if cur_sum &lt; tsum: hi += 1 cur_sum += hi else: if cur_sum == tsum: ans.append(list(range(lo, hi+1))) cur_sum -= lo lo += 1 return ans 58.翻转字符串。LeetCode传送门12Input: "the sky is blue",Output: "blue is sky the". 方法一：如果面试官是一个Pythoner，那么就让你过了。 12def reverse_words(s): return ' '.join(reversed(s.split())) 如果你的面试官是一个只写Java或者C，看见代码就不平衡了，凭啥可以写到一行，非要你实现reverse。 12345678910def reverseWords(self, s: str) -&gt; str: def hp_reversed(s): s = list(s) for i in range(len(s)//2): # s[i], s[-i-1] = s[-i-1], s[i] s[i], s[~i] = s[~i], s[i] return ''.join(s) s = hp_reversed(s) return ' '.join(hp_reversed(word) for word in s.split()) 实现split，hp_reverse， 1234567891011121314151617def reverseWords(self, s: str) -&gt; str: def hp_reversed(s): s = list(s) for i in range(len(s)//2): s[i], s[~i] = s[~i], s[i] return ''.join(s) s = hp_reversed(s) ans = word = '' for r, c in enumerate(s): if c != ' ': word += c if (c== ' ' or r==len(s)-1) and word: ans += hp_reversed(word) + ' ' word = '' return ans[:-1] 58_1 左旋转字符串牛客网传送门AcWing传送门切片，书中的方法个人觉得Python并不适用。 12345def LeftRotateString(self, s, n): if not s: return '' n = n % len(s) return s[n:] + s[:n] 59.滑动窗口的最大值。LeetCode传送门得益于python的切片。Time: O(n*k). k=n-size 123def maxInWindows(self, nums, size): return [max(nums[i:i+size]) for i in range(len(nums)-size+1) if size!=0 ] 方法二：队列保存索引。 123456789101112def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]: q = collections.deque() ans = [] for i, d in enumerate(nums): while q and nums[q[-1]] &lt; d: q.pop() q.append(i) if q[0] == i-k: q.popleft() if i &gt;= k-1: ans.append(nums[q[0]]) return ans 60.n个骰子的点数AcWing传送门1[[1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1]] dp[0][j]==1表示第一个骰子和为j+1的次数为1，因为数组下标从0开始。 12345678910111213141516def dice_probability(n, val=6): dp = [[0]*val*n for _ in range(n)] dp[0][:val] = [1] * val # 初始化第一个骰子 for i in range(n-1): # 根据第i个骰子更新第i+1个骰子 for j in range(i, len(dp[i+1])): # 第i+1个骰子和为j（实际为j+1，因为数组下标从0开始）的次数，等于第i个 # 骰子j-1 ~ j-6次数的总和 dp[i+1][j] = sum([dp[i][j-k] for k in range(1, val+1)]) # 整理数据成为dict，key表示和，value表示出现的次数 # count = &#123;i+1: times for i, times in enumerate(dp[-1])&#125; # 计算概率 count = &#123;i+1: round(float(times / (val**n)), 5) for i, times in enumerate(dp[-1]) if times!=0&#125; return count 感觉用dict来表示更加明确，没有数组下标从0开始的混淆。按照AcWing中的返回写出一种解法。 12345678910111213from collections import defaultdictfrom itertools import repeatdef numberOfDice(self, n): last_p = defaultdict(int) last_p.update(dict(zip(range(1, 7), repeat(1)))) for i in range(2, n+1): new_p = defaultdict(int) for j in range(i, i*6+1): new_p[j] = sum(last_p[j-k] for k in range(1, 7)) # print(new_p) last_p = new_p return list(last_p.values()) 61.扑克牌中的顺子牛客网传送门AcWing传送门开始以为还要用个dict来映射值，后来发现直接传得卡牌的值。思想就是先排序，然后查joker的数量，看剩下牌的差值加起来能不能用已有的joker连起来。 1234567891011def IsContinuous(self, numbers): if not numbers: return False joker_count = numbers.count(0) left_cards = sorted(numbers)[joker_count:] need_joker = 0 for i in range(len(left_cards)-1): if left_cards[i+1] == left_cards[i]: return False need_joker += (left_cards[i+1]-left_cards[i]-1) return need_joker &lt;= joker_count 使用标准库，更加优雅，原理相同。 123456789101112131415from itertools import teedef IsContinuous(self, numbers): if not numbers: return False joker_count = numbers.count(0) left_cards = sorted(numbers)[joker_count:] need_joker = 0 c1, c2 = tee(left_cards) next(c2, None) for s, g in zip(c1, c2): if g == s: return False need_joker += g - 1 - s return need_joker &lt;= joker_count 62.圆圈中最后剩下的数字AcWing传送门方法一：其实不需要环形链表，使用一个list足矣，每次将其旋转rot位，一开始想将要把第m个数旋转到list首部，然后再pop(0)，后来想到直接可以通过切片取出来，节省了pop(0)的O(n)复杂度。 123456789def LastRemaining_Solution(self, n, m): # write code here if n&lt;=0 or m&lt;=0: return -1 seats = range(n) while seats: rot = (m-1) % len(seats) seats, last = seats[rot+1:] + seats[:rot], seats[rot] return last 方法二：书中的推导过程过于复杂，这里学到了一个稍微简单的推导过程。参考约瑟夫环问题。 解析Josephus-problem 1234567def LastRemaining_Solution(self, n, m): if n&lt;=0 or m&lt;=0: return -1 last_num = 0 for i in range(2, n+1): last_num = (last_num+m) % i return last_num 63.股票的最大利润LeetCode传送门方法一：Brute Force.其实就是求最高峰点和前面最低谷点的差。 123456def maxProfit(self, prices: List[int]) -&gt; int: profit, min_buy = 0, float('inf') for p in prices: min_buy = min(min_buy, p) profit = max(profit, p-min_buy) return profit 方法二：标准的卡登算法。此题为53.连续数组最大和的变形，如果价格比之前小，则舍弃，否则一起计算连续子数组的和。 1234567def maxProfit(self, prices: List[int]) -&gt; int: cur = sofar = 0 for i in range(1, len(prices)): cur += prices[i] - prices[i-1] cur = max(0, cur) sofar = max(cur, sofar) return sofar 方法三：使用标准库的卡登算法。 12345678910def maxProfit(self, prices: List[int]) -&gt; int: from itertools import tee cur = profit = 0 a, b = tee(prices) next(b, None) for before, today in zip(a, b): cur += today - before cur = max(0, cur) profit = max(profit, cur) return profit 64.求1+2+···+nAcWing传送门这题对python不是很友好，感觉and也属于条件判断语句。reduce`sum`之类的属于作弊行为，这里就不贴了。 123def Sum_Solution(self, n): # write code here return n and (n+self.Sum_Solution(n-1)) 65.不用加减乘除做加法LeetCode传送门此题由于Python中的int没有长度限制，在负数出现的情况，会导致结果与预期不同。详情见Python负数位运算 12345678910111213def getSum(self, a, b): # 32 bits integer max MAX = 0x7FFFFFFF # 2**31-1 # 32 bits interger min MIN = 0x80000000 # -2**31 # mask to get last 32 bits mask = 0xFFFFFFFF # 2*32-1 while b != 0: # ^ get different bits and &amp; gets double 1s, &lt;&lt; moves carry a, b = (a ^ b) &amp; mask, ((a &amp; b) &lt;&lt; 1) &amp; mask # if a is negative, get a's 32 bits complement positive first # then get 32-bit positive's Python complement negative return a if a &lt;= MAX else ~(a ^ mask) 或者可以将其转成32位整数。 1234567import numpy as npclass Solution(object): def getSum(self, a, b): while b != 0: a, b = np.int32(a ^ b), np.int32((a &amp; b) &lt;&lt; 1) return int(a) 66 构建乘积数组LeetCode传送门思路：不能使用除法。如书中所说，以i为分割点，将B拆成C，D两部分，左边是A[0] x A[1] x...x A[i-1]右边则为A[i+1] x ...x A[n-1] ，C[i] = C[i-1] * A[i-1] 方法一：这里生成器没法直接使用reversed，否则能达到O(1)的空间复杂度。 1234567def productExceptSelf(self, nums: List[int]) -&gt; List[int]: from itertools import accumulate, chain from operator import mul C = chain([1], accumulate(nums[:-1], mul)) # D = chain([1], accumulate(nums[:0:-1], mul)) D = [1] + list(accumulate(nums[:0:-1], mul)) return [c*d for c, d in zip(C, reversed(D))] 方法二： 不使用标准库的方法。 123456789def multiply(self, A): C = [1] # 第一个元素相当于没有 for i in range(len(A)-1): C.append(C[-1] * A[i]) D = [1] for j in range(len(A)-1, 0, -1): D.append(D[-1] * A[j]) D.reverse() return [C[i] * D[i] for i in range(len(A))] 方法三：O(n)时间，O(1)空间。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python排序算法]]></title>
    <url>%2FPython%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[快速排序 快排算是应用中广泛的排序算法了。由于实现简单，适用于不同的输入数据且在一般应用中比其他排序算法要快。快排的一个特点是原地排序，内循环比大多数排序算法要短小。它的主要缺点是非常脆弱，在实现中要非常小心才能避免低劣的性能。 快排是一种分治的排序算法。它将一个数组分成两个子数组，将两部分独立地排序。快排和归并排序是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组排序，递归调用发生在处理整个数组之前；而快排将数组排序的方式则是当两个子数组都有序时整个数组自然也就有序了，递归调用发生在处理整个数组之后。 按照《算法第4版》中的例子，实现一个标准的python解法。 12345678910111213141516171819202122232425262728import randomdef quick_sort(a): random.shuffle(a) # 消除输入依赖，保持随机性，也可使用随机选取切分元素 quick_sort_divide(a, 0, len(a)-1) def quick_sort_divide(a, lo, hi): if hi &lt;= lo: return j = partition(a, lo, hi) quick_sort_divide(a, lo, j-1) quick_sort_divide(a, j+1, hi) def partition(a, lo, hi): i, j = lo+1, hi pivot = a[lo] # 选取第一个元素作为切分元素 while True: while a[i]&lt;pivot and i&lt;hi: # 遇到大于等于pivot时停止，某些情况可以避免算法运行时间变为平方级别 i += 1 while a[j]&gt;pivot and j&gt;lo: j -= 1 if i &gt;= j: break a[i], a[j] = a[j], a[i] i += 1 j -= 1 a[lo], a[j] = a[j], a[lo] return j 性能分析： 内循环使用一个递增的索引将数组元素和一个定值比较，相对于归并和希尔的在内循环中移动数据的方法更快，更简洁。 比较的次数很少。排序效率依赖切分数组的效果。 基于Dijkstra-三路快排实现：当数组中包含大量重复的元素时，上述快排做出了一些无意义的切分。从左到右遍历数组，维护一个指针lt使a[lo..lt-1]中的元素都小于p，一个指针gt使得a[gt+1..hi]中的元素都大于p，一个指针i使得a[lt..i-1]中的元素都等于p，由于Python可以返回元组，所以改写成三路非常简单。 123456789101112131415161718192021222324252627import randomdef q3_sort(a): random.shuffle(a) q_divide(a, 0, len(a)-1) def q_divide(a, lo, hi): if lo &gt;= hi: return i, j = partition(a, lo, hi) q_divide(a, lo, i) q_divide(a, j, hi) def partition(a, lo, hi): lt, i, gt = lo, lo+1, hi p = a[lo] while i &lt;= gt: if a[i] &lt; p: a[i], a[lt] = a[lt], a[i] lt += 1 i += 1 elif a[i] &gt; p: a[i], a[gt] = a[gt], a[i] gt -= 1 else: i += 1 return lt-1, gt+1 冒泡排序12345678910def bubble_sort(nums): n = len(nums) for i in range(n-1, 0, -1): flag = True for j in range(0, i): if nums[j] &gt; nums[j+1]: nums[j+1], nums[j] = nums[j], nums[j+1] flag = False if flag: return 选择排序12345678def select_sort(nums: list) -&gt; list: n = len(nums) for i in range(n-1): min_i = i for j in range(i+1, n): if nums[min_i] &gt; nums[j]: min_i = j nums[min_i], nums[i] = nums[i], nums[min_i] 插入排序 12345678910def insertion(ary: list) -&gt; list: for i in range(1, len(ary)): val, index = ary[i], i for j in range(i-1, -1, -1): if ary[j] &gt; val: ary[j+1] = ary[j] index = j else: break ary[index] = val 希尔排序使用切片的方式实现了一个简单的希尔排序，但是希尔排序应该是不产生空间的。 123456789def shell_sorted(nums): res = list(nums) n = len(res) step = round(n/2) while step &gt; 0: for i in range(step): res[i:n:step] = insert_sorted(res[i:n:step]) step = round(step/2) return res 归并排序 原地归并 12345678910111213141516171819202122232425def merge_sort(nums: list): _merge_divide(nums, 0, len(nums)-1)def _merge_divide(a, l, r): if l &gt;= r: return mid = (l + r) // 2 _merge_divide(a, l, mid) _merge_divide(a, mid+1, r) _merge(a, l, mid, r) def _merge(a, l, mid, r): aux = [] i, j = l, mid + 1 if a[mid] &lt;= a[mid+1]: # 有序则跳出 return while i&lt;=mid and j&lt;=r: if a[i] &lt;= a[j]: aux.append(a[i]) i += 1 else: aux.append(a[j]) j += 1 aux += a[i:mid+1] or a[j:r+1] a[l:r+1] = aux 自底向上的归并排序。_merge方法都是一样的。 12345678910111213141516171819202122def merge_sort_bu(nums: list): sz, n = 1, len(nums) while sz &lt;= n: for i in range(0, n-sz, sz*2): # sz 表示子数组大小 # 把两个大小为sz的数组归并成一个 _merge(nums, i, i+sz-1, min(i+sz*2-1, n-1)) sz *= 2 def _merge(a, l, mid, r): aux = [] i, j = l, mid + 1 if a[mid] &lt;= a[mid+1]: return while i&lt;=mid and j&lt;=r: if a[i] &lt;= a[j]: aux.append(a[i]) i += 1 else: aux.append(a[j]) j += 1 aux += a[i:mid+1] or a[j:r+1] a[l:r+1] = aux 堆排序将数组构建成堆，从最后一个叶子节点(n-1)//2对每个节点进行sink操作，完成heapify。 从堆顶最大的元素，和末尾互换，然后将堆顶元素下沉。 1234567891011121314151617181920def heap_sort(ary): n = len(ary) # heapify array for i in range((n-1)//2, -1, -1): __sink(ary, n, i) # move maximum to the end, then sink first for j in range(n-1, 0, -1): ary[j], ary[0] = ary[0], ary[j] __sink(ary, j, 0) def __sink(ary, n, p): while p * 2 + 1 &lt; n: j = p * 2 + 1 # sink swap with j if j + 1 &lt; n and ary[j+1] &gt; ary[j]: j += 1 if ary[p] &gt;= ary[j]: break ary[p], ary[j] = ary[j], ary[p] p = j]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（设计篇）Design]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E8%AE%BE%E8%AE%A1%E7%AF%87%EF%BC%89Design%2F</url>
    <content type="text"><![CDATA[155. Min Stack设计一个栈，要求在常数时间复杂度取出最小值。原题 12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; Returns -3.minStack.pop();minStack.top(); --&gt; Returns 0.minStack.getMin(); --&gt; Returns -2. 12345678910111213141516171819202122232425class MinStack: def __init__(self): self._stack = [] def push(self, x: int) -&gt; None: cur_min = self.getMin() if x &lt; cur_min: cur_min = x self._stack.append((x, cur_min)) def pop(self) -&gt; None: self._stack.pop() def top(self) -&gt; int: if not self._stack: return None else: return self._stack[-1][0] def getMin(self) -&gt; int: if not self._stack: return float('inf') else: return self._stack[-1][1] 232. Implement Queue using Stacks使用两个栈实现一个队列。原题1234567MyQueue queue = new MyQueue();queue.push(1);queue.push(2); queue.peek(); // returns 1queue.pop(); // returns 1queue.empty(); // returns false 方法一：push-O(1), pop-O(N). 1234567891011121314151617181920212223class MyQueue: def __init__(self): self.in_stack, self.out_stack = [], [] def push(self, x: int) -&gt; None: self.in_stack.append(x) def move(self) -&gt; None: if self.out_stack == []: while self.in_stack: self.out_stack.append(self.in_stack.pop()) def pop(self) -&gt; int: self.move() return self.out_stack.pop() def peek(self) -&gt; int: self.move() return self.out_stack[-1] def empty(self) -&gt; bool: return self.in_stack==self.out_stack==[] 方法二：push-O(N), pop-O(1). 123456789101112131415161718192021class MyQueue: def __init__(self): self.s1 = [] self.s2 = [] def push(self, x: int) -&gt; None: while self.s1: self.s2.append(self.s1.pop()) self.s1.append(x) while self.s2: self.s1.append(self.s2.pop()) def pop(self) -&gt; int: return self.s1.pop() def peek(self) -&gt; int: return self.s1[-1] def empty(self) -&gt; bool: return self.s1 == [] 225. Implement Stack using Queues使用队列实现栈。原题方法一：两个队列，push-O(1), pop/top O(n). 思想在于q2就是一个临时队列，无论是是top还是pop都是保持q1剩一个元素，然后再交换q1, q2. 1234567891011121314151617181920212223242526class MyStack: def __init__(self): from collections import deque self.q1, self.q2 = deque(), deque() def push(self, x: int) -&gt; None: self.q1.append(x) def pop(self) -&gt; int: while len(self.q1) != 1: self.q2.append(self.q1.popleft()) pop_val = self.q1.popleft() self.q1, self.q2 = self.q2, self.q1 return pop_val def top(self) -&gt; int: while len(self.q1) != 1: self.q2.append(self.q1.popleft()) val = self.q1[0] self.q2.append(self.q1.popleft()) self.q1, self.q2 = self.q2, self.q1 return val def empty(self) -&gt; bool: return not self.q1 方法二：两个队列，push-O(n), pop/top-O(1). 1234567891011121314151617181920class MyStack: def __init__(self): from collections import deque self.q1, self.q2 = deque(), deque() def push(self, x: int) -&gt; None: self.q2.append(x) while self.q1: self.q2.append(self.q1.popleft()) self.q1, self.q2 = self.q2, self.q1 def pop(self) -&gt; int: return self.q1.popleft() def top(self) -&gt; int: return self.q1[0] def empty(self) -&gt; bool: return not self.q1 方法三：一个队列旋转。 123456789101112131415161718192021class MyStack: def __init__(self): from collections import deque self.q = deque() def push(self, x: int) -&gt; None: self.q.append(x) # self.q.rotate(1) 这里是用了双端队列的特性 # self.q.rotate(1-len(self.q)) 这里和下面循环是一样的效果 for _ in range(len(self.q)-1): self.q.append(self.q.popleft()) def pop(self) -&gt; int: return self.q.popleft() def top(self) -&gt; int: return self.q[0] def empty(self) -&gt; bool: return not self.q 295. Find Median from Data Stream找出数据流中的中位数。原题思路：使用两个堆，最大堆存储较小的数据，最小堆存储较大的数据。添加数字时，先添加到最大堆，然后最大堆返回一个最大的数字给最小堆，最后为了平衡，可能需要最小堆还给最大堆一个最小值，以保证最大堆的长度&gt;=最小堆的长度。由于headpq是最小堆，所以使用取反实现最大堆。添加数字：Time-O(logn)，取出中位数：Time-O(1)。 1234567891011121314151617181920212223242526272829Adding number 41MaxHeap lo: [41] // MaxHeap stores the largest value at the top (index 0)MinHeap hi: [] // MinHeap stores the smallest value at the top (index 0)Median is 41=======================Adding number 35MaxHeap lo: [35]MinHeap hi: [41]Median is 38=======================Adding number 62MaxHeap lo: [41, 35]MinHeap hi: [62]Median is 41=======================Adding number 4MaxHeap lo: [35, 4]MinHeap hi: [41, 62]Median is 38=======================Adding number 97MaxHeap lo: [41, 35, 4]MinHeap hi: [62, 97]Median is 41=======================Adding number 108MaxHeap lo: [41, 35, 4]MinHeap hi: [62, 97, 108]Median is 51.5 12345678910111213141516171819import heapq as hqclass MedianFinder: def __init__(self): self.lo, self.hi = [], [] # lo is max_heap, hi is min_heap def addNum(self, num): hq.heappush(self.lo, -num) hq.heappush(self.hi, -hq.heappop(self.lo)) if len(self.lo) &lt; len(self.hi): hq.heappush(self.lo, -hq.heappop(self.hi)) def findMedian(self): if len(self.lo) == len(self.hi): return (-self.lo[0]+self.hi[0]) / 2.0 else: return float(-self.lo[0]) 480. Sliding Window Median滑动窗口中的中位数。这题基于295的思想，但是要比其难处理的多。12345678Window position Median--------------- -----[1 3 -1] -3 5 3 6 7 1 1 [3 -1 -3] 5 3 6 7 -1 1 3 [-1 -3 5] 3 6 7 -1 1 3 -1 [-3 5 3] 6 7 3 1 3 -1 -3 [5 3 6] 7 5 1 3 -1 -3 5 [3 6 7] 6 方法一：我自己的思路是到了最大堆最小堆，不知道如何删除左侧窗口废弃的元素。看了讨论区知道了，要把索引加进去，但是当一个废弃的索引， 不在堆首无法将其剔除时，就是影响两个堆的长度，那么从而影响中位数的判断。这是这段代码的核心。首先，不能够像295那样，通过两个堆的长度来平衡，因为堆中可能含有废弃的元素，这里使用的是懒删除。然后尽量保证hi 即最小堆的长度较大，当要删除一个数时，判断这个数是在最大堆还是最小堆。如果是在lo中，则从hi补齐一个元素到lo中，因为平衡两个堆时不考虑将来要被删除的元素。20~27行是这段代码能正常运作的核心。 1234567891011121314151617181920212223242526272829303132333435def medianSlidingWindow(self, nums: List[int], k: int) -&gt; List[float]: lo, hi = [], [(n, i) for i, n in enumerate(nums[:k])] # lo is maxheap, hi is minheap heapq.heapify(hi) ans = [] def get_med(odd=True): if odd: return hi[0][0] else: return (-lo[0][0] + hi[0][0]) / 2 def move(h1, h2): x, i = heapq.heappop(h1) heapq.heappush(h2, (-x, i)) for _ in range(k//2): move(hi, lo) # print(lo, hi) ans.append(get_med(k&amp;1)) for i, n in enumerate(nums[k:], k): if n &gt;= hi[0][0]: heapq.heappush(hi, (n, i)) if nums[i-k] &lt;= hi[0][0]: move(hi, lo) else: heapq.heappush(lo, (-n, i)) if nums[i-k] &gt;= hi[0][0]: move(lo, hi) while lo and lo[0][1] &lt;= i-k: heapq.heappop(lo) while hi and hi[0][1] &lt;= i-k: heapq.heappop(hi) # print(lo, hi) ans.append(get_med(k&amp;1)) return ans 方法二：还是stefan的方法好，比赛能做出来起码。 12345678def medianSlidingWindow(self, nums: List[int], k: int) -&gt; List[float]: window = sorted(nums[:k]) ans = [] for a, b in zip(nums, nums[k:] + [0]): ans.append((window[k//2]+window[~k//2]) / 2) window.remove(a) bisect.insort(window, b) return ans 535. Encode and Decode TinyURL设计一个短链接。原题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Codec: BASE = 62 UPPERCASE_OFFSET = 55 LOWERCASE_OFFSET = 61 DIGIT_OFFSET = 48 num_sender = 0 url = &#123;&#125; def encode(self, longUrl): """Encodes a URL to a shortened URL. :type longUrl: str :rtype: str """ if Codec.num_sender == 0: Codec.url[Codec.num_sender] = longUrl return '0' s_url = '' while Codec.num_sender &gt; 0: tail = Codec.num_sender % Codec.BASE s_url = self.parse_chr(tail) + s_url Codec.num_sender //= Codec.BASE Codec.url[Codec.num_sender] = longUrl Codec.num_sender += 1 return s_url def decode(self, shortUrl): """Decodes a shortened URL to its original URL. :type shortUrl: str :rtype: str """ num = 0 for i, char in enumerate(reversed(shortUrl)): num += self.parse_ord(char) * (Codec.BASE**i) return Codec.url[num] def parse_ord(self, char): if char.isdigit(): return ord(char) - Codec.DIGIT_OFFSET elif char.islower(): return ord(char) - Codec.LOWERCASE_OFFSET elif char.isupper(): return ord(char) - Codec.UPPERCASE_OFFSET else: raise ValueError('%s is not a valid character' % char) def parse_chr(self, integer): if integer &lt; 10: return chr(integer + DIGIT_OFFSET) elif 10 &lt;= integer &lt;= 35: return chr(integer + UPPERCASE_OFFSET) elif 36 &lt;= integer &lt; 62: return chr(integer + LOWERCASE_OFFSET) else: raise ValueError('%d is not a valid integer in the range of base %d' % (integer, Codec.BASE)) 方法二：使用字典保存。 123456789101112131415161718192021222324class Codec: BASE = 62 num_sender = 0 ALNUM = string.ascii_letters + '0123456789' d_map = &#123;c: i for i, c in enumerate(ALNUM)&#125; url = &#123;&#125; def encode(self, longUrl): pk = Codec.num_sender s_url = '' while pk &gt; 0: pk, tail = divmod(pk, Codec.BASE) s_url = Codec.ALNUM[tail] + s_url Codec.url[pk] = longUrl Codec.num_sender += 1 if pk == 0: s_url = Codec.ALNUM[0] return s_url def decode(self, shortUrl): pk = sum(Codec.d_map[c]*Codec.BASE**i for i, c in enumerate(reversed(shortUrl))) return Codec.url[pk] 707. Design Linked List设计一个链表。原题1234567MyLinkedList linkedList = new MyLinkedList();linkedList.addAtHead(1);linkedList.addAtTail(3);linkedList.addAtIndex(1, 2); // linked list becomes 1-&gt;2-&gt;3linkedList.get(1); // returns 2linkedList.deleteAtIndex(1); // now the linked list is 1-&gt;3linkedList.get(1); // returns 3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class ListNode: def __init__(self, val): self.val = val self.next = None class MyLinkedList: def __init__(self): self.head = None self.size = 0 def get(self, index: 'int') -&gt; 'int': if index &lt; 0 or index &gt;= self.size or \ self.head is None: return -1 return self.findIndex(index).val def addAtHead(self, val: 'int') -&gt; 'None': self.addAtIndex(0, val) def addAtTail(self, val: 'int') -&gt; 'None': self.addAtIndex(self.size, val) def addAtIndex(self, index: 'int', val: 'int') -&gt; 'None': if index &gt; self.size: return -1 elif index == 0: head = ListNode(val) head.next, self.head = self.head, head else: pre = self.findIndex(index-1) cur = ListNode(val) cur.next, pre.next = pre.next, cur self.size += 1 def deleteAtIndex(self, index: 'int') -&gt; 'None': if index &lt; 0 or index &gt;= self.size: return -1 cur = self.findIndex(index-1) cur.next = cur.next.next self.size -= 1 def findIndex(self, index: 'int') -&gt; 'None': cur = self.head for _ in range(index): cur = cur.next return cur 146. LRU Cache1234567891011LRUCache cache = new LRUCache( 2 /* capacity */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // returns 1cache.put(3, 3); // evicts key 2cache.get(2); // returns -1 (not found)cache.put(4, 4); // evicts key 1cache.get(1); // returns -1 (not found)cache.get(3); // returns 3cache.get(4); // returns 4 方法一：使用OrderedDict. 开始有两个testcase没过，一个是{2: 3, 1: 1}更新2时，和{1: 1, 2: 3}更新2时，二者都可以使用先pop再更新的方式。remain的方式是从discuss学来的，之前还用len或额外的size来保存。 1234567891011121314151617181920class LRUCache: def __init__(self, capacity: 'int'): self.cache = collections.OrderedDict() self.remain = capacity def get(self, key: 'int') -&gt; 'int': if key not in self.cache: return -1 self.cache.move_to_end(key) return self.cache.get(key) def put(self, key: 'int', value: 'int') -&gt; 'None': if key not in self.cache: if self.remain &gt; 0: self.remain -= 1 else: self.cache.popitem(last=False) else: self.cache.pop(key) self.cache[key] = value 方法二：不使用OrderedDict 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class DLinkedNode: def __init__(self, key=0, value=0): self.key = key self.value = value self.next, self.prev = None, None class LRUCache: def __init__(self, capacity: int): self.cache = &#123;&#125; self.remain = capacity self.head = DLinkedNode() self.tail = DLinkedNode() self.head.next = self.tail self.tail.prev = self.head def _add_node(self, node): node.prev = self.head node.next = self.head.next self.head.next.prev = node self.head.next = node def _remove_node(self, node): node.prev.next = node.next node.next.prev = node.prev def _move_to_head(self, node): self._remove_node(node) self._add_node(node) def get(self, key: int) -&gt; int: node = self.cache.get(key, None) if not node: return -1 self._move_to_head(node) return node.value def put(self, key: int, value: int) -&gt; None: node = self.cache.get(key, None) if not node: if self.remain &gt; 0: self.remain -= 1 else: del self.cache[self.tail.prev.key] self._remove_node(self.tail.prev) new_node = DLinkedNode(key, value) self.cache[key] = new_node self._add_node(new_node) else: self._move_to_head(node) node.value = value 1381. Design a Stack With Increment Operation设计一个栈，实现一个将k个栈底元素全部增加val的方法。原题12345678910111213141516171819Input[&quot;CustomStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;pop&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;increment&quot;,&quot;increment&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;][[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]Output[null,null,null,2,null,null,null,null,null,103,202,201,-1]ExplanationCustomStack customStack = new CustomStack(3); // Stack is Empty []customStack.push(1); // stack becomes [1]customStack.push(2); // stack becomes [1, 2]customStack.pop(); // return 2 --&gt; Return top of the stack 2, stack becomes [1]customStack.push(2); // stack becomes [1, 2]customStack.push(3); // stack becomes [1, 2, 3]customStack.push(4); // stack still [1, 2, 3], Don&apos;t add another elements as size is 4customStack.increment(5, 100); // stack becomes [101, 102, 103]customStack.increment(2, 100); // stack becomes [201, 202, 103]customStack.pop(); // return 103 --&gt; Return top of the stack 103, stack becomes [201, 202]customStack.pop(); // return 202 --&gt; Return top of the stack 102, stack becomes [201]customStack.pop(); // return 201 --&gt; Return top of the stack 101, stack becomes []customStack.pop(); // return -1 --&gt; Stack is empty return -1. 方法一：普通的方法不记录了，这里学到一个延迟增加的方法。因为值的增加只有在pop的时候才会体现，所以维护了一个inc用来累加增加的值。 123456789101112131415161718192021class CustomStack: def __init__(self, maxSize: int): self.stack = [] self.max_size = maxSize self.inc = [] def push(self, x: int) -&gt; None: if len(self.stack) &lt; self.max_size: self.stack.append(x) self.inc.append(0) def pop(self) -&gt; int: if not self.stack: return -1 if len(self.inc) &gt; 1: self.inc[-2] += self.inc[-1] return self.inc.pop() + self.stack.pop() def increment(self, k: int, val: int) -&gt; None: if self.inc: self.inc[min(k, len(self.inc))-1] += val 208. Implement Trie (Prefix Tree)实现一个单词查找树。原题12345678Trie trie = new Trie();trie.insert(&quot;apple&quot;);trie.search(&quot;apple&quot;); // returns truetrie.search(&quot;app&quot;); // returns falsetrie.startsWith(&quot;app&quot;); // returns truetrie.insert(&quot;app&quot;); trie.search(&quot;app&quot;); // returns true 方法一：我的常规节点方法。 1234567891011121314151617181920212223242526272829303132class TrieNode: def __init__(self): self.child = collections.defaultdict(TrieNode) self.is_word = Falseclass Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -&gt; None: cur = self.root for letter in word: cur = cur.child[letter] cur.is_word = True def search(self, word: str) -&gt; bool: cur = self.root for letter in word: cur = cur.child.get(letter) if not cur: return False return cur.is_word def startsWith(self, prefix: str) -&gt; bool: cur = self.root for letter in prefix: cur = cur.child.get(letter) if not cur: return False return True 方法二：reduce的妙用。 1234567891011121314class Trie(object): def __init__(self): T = lambda: collections.defaultdict(T) self.root = T() def insert(self, word): reduce(dict.__getitem__, word, self.root)['#'] = True def search(self, word): return '#' in reduce(lambda cur, c: cur.get(c, &#123;&#125;), word, self.root) def startsWith(self, prefix): return bool(reduce(lambda cur, c: cur.get(c, &#123;&#125;), prefix, self.root)) 380. Insert Delete GetRandom O(1)设计一个类，插入删除，随机都是O(1)。原题1234567891011121314151617181920212223// Init an empty set.RandomizedSet randomSet = new RandomizedSet();// Inserts 1 to the set. Returns true as 1 was inserted successfully.randomSet.insert(1);// Returns false as 2 does not exist in the set.randomSet.remove(2);// Inserts 2 to the set, returns true. Set now contains [1,2].randomSet.insert(2);// getRandom should return either 1 or 2 randomly.randomSet.getRandom();// Removes 1 from the set, returns true. Set now contains [2].randomSet.remove(1);// 2 was already in the set, so return false.randomSet.insert(2);// Since 2 is the only number in the set, getRandom always return 2.randomSet.getRandom(); 方法一：解法的思想有点像删除链表，是一种覆盖的思想。主要是删除时用最后的元素将其覆盖，然后再将末尾的元素删除。 1234567891011121314151617181920212223class RandomizedSet: def __init__(self): self.nums, self.pos = [], &#123;&#125; def insert(self, val: int) -&gt; bool: if val not in self.pos: self.nums.append(val) self.pos[val] = len(self.nums)-1 return True return False def remove(self, val: int) -&gt; bool: if val in self.pos: idx, last = self.pos[val], self.nums[-1] self.nums[idx], self.pos[last] = last, idx self.nums.pop() self.pos.pop(val) return True return False def getRandom(self) -&gt; int: return random.choice(self.nums) 341. Flatten Nested List Iterator扁平化一个嵌套的List迭代器，NestedInteger是一个类。原题1234Input: [[1,1],2,[1,1]]Output: [1,1,2,1,1]Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1]. 方法一：这里设计时考虑了，next之前可能不会调用hasNext。因为正常来说一个生成器就是这样的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#class NestedInteger:# def isInteger(self) -&gt; bool:# """# @return True if this NestedInteger holds a single integer, rather than a nested list.# """## def getInteger(self) -&gt; int:# """# @return the single integer that this NestedInteger holds, if it holds a single integer# Return None if this NestedInteger holds a nested list# """## def getList(self) -&gt; [NestedInteger]:# """# @return the nested list that this NestedInteger holds, if it holds a nested list# Return None if this NestedInteger holds a single integer# """class NestedIterator: def __init__(self, nestedList: [NestedInteger]): def flatten(items): for x in items: if x.getInteger() is not None: yield x.getInteger() else: yield from flatten(x.getList()) self.g = flatten(nestedList) self.buff = None def next(self) -&gt; int: if self.buff is not None: ans = self.buff self.buff = None return ans else: return next(self.g) def hasNext(self) -&gt; bool: if self.buff is not None: return True try: self.buff = next(self.g) return True except StopIteration: return False# Your NestedIterator object will be instantiated and called as such:# i, v = NestedIterator(nestedList), []# while i.hasNext(): v.append(i.next())]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（二叉树篇）Tree]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AF%87%EF%BC%89Tree%2F</url>
    <content type="text"><![CDATA[树的定义12345class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None 144. Binary Tree Preorder Traversal二叉树前序遍历12345678Input: [1,null,2,3] 1 \ 2 / 3Output: [1,2,3] 方法一：iteratively 123456789def preorderTraversal(self, root: 'TreeNode') -&gt; 'List[int]': ans, stack = [], root and [root] while stack: node = stack.pop() if node: ans.append(node.val) stack.append(node.right) stack.append(node.left) return ans 方法二：recursively 12345def preorder_traversal(root): if not root: return [] return [root.val] + self.preorderTraversal(root.left) + \ self.preorderTraversal(root.right) 589. N-ary Tree Preorder TraversalN-叉树的前序遍历。N叉树和二叉树有个区别，就是N叉树不需要考虑子节点知否为空，做单独的判断。原题方法一：recursively. 1234567def preorder(self, root): if not root: return [] res = [root.val] for child in root.children: res += self.preorder(child) return res 方法二：iteratively. 1234567def preorder(self, root): res, stack = [], root and [root] while stack: node = stack.pop() res.append(node.val) stack.extend(reversed(node.children)) return res 94. Binary Tree Inorder Traversal中序遍历二叉树12345678Input: [1,null,2,3] 1 \ 2 / 3Output: [1,3,2] 方法一：使用栈迭代。 12345678910def inorderTraversal(self, root: TreeNode) -&gt; List[int]: stack, ans = [], [] while stack or root: while root: stack.append(root) root = root.left root = stack.pop() ans.append(root.val) root = root.right return ans 方法二：Morris Traversal. 1234567891011121314151617181920212223def inorderTraversal(self, root: TreeNode) -&gt; List[int]: cur, ans = root, [] while cur: if not cur.left: ans.append(cur.val) cur = cur.right else: pre = cur.left # 找到当前节点左子树中最右的右节点 while pre.right and pre.right != cur: pre = pre.right if not pre.right: # 找到最右的节点，连接到根节点 pre.right = cur cur = cur.left # 恢复节点 else: pre.right = None ans.append(cur.val) cur = cur.right return ans 145. Binary Tree Postorder Traversal后序遍历二叉树12345678Input: [1,null,2,3] 1 \ 2 / 3Output: [3,2,1] 方法一：根右左，再倒序。 123456789def postorder_traversal(root): res, stack = [], [root] while stack: node = stack.pop() if node: res.append(node.val) stack.append(node.left) stack.append(node.right) return res[::-1] 方法二：思想: 使用last作为判断是否该节点的右子树完成遍历，如果一个node.right已经刚刚遍历完毕，那么将last==node.right，否则将会寻找node.right。 123456789101112131415def postorderTraversal(self, root): res, stack, node, last = [], [], root, None while stack or node: if node: stack.append(node) node = node.left else: node = stack[-1] if not node.right or last == node.right: node = stack.pop() res.append(node.val) last, node = node, None else: node = node.right return res 方法三：使用boolean判断一个节点是否被遍历过 123456789101112def postorderTraversal(self, root): res, stack = [], [(root, False)] while stack: node, visited = stack.pop() if node: if visited: res.append(node.val) else: stack.append((node, True)) stack.append((node.right, False)) stack.append((node.left, False)) return res 方法四：dfs. 123456789101112def postorderTraversal(self, root: 'TreeNode') -&gt; 'List[int]': ans = [] def dfs(node): if not node: return dfs(node.left) dfs(node.right) ans.append(node.val) dfs(root) return ans 590. N-ary Tree Postorder TraversalN-叉树的后序遍历。原题方法一：recursively. 1234def postorder(self, root): if not root: return [] return sum([self.postorder(child) for child in root.children], []) + [root.val] 方法二：iteratively and reversed. 1234567def postorder(self, root): res, stack = [], root and [root] while stack: node = stack.pop() res.append(node.val) stack.extend(node.children) return res[::-1] 方法三：iteratively and flag. 12345678910def postorder(self, root): res, stack = [], root and [(root, False)] while stack: node, visited = stack.pop() if visited: res.append(node.val) else: stack.append((node, True)) stack.extend((n, False) for n in reversed(node.children)) return res 100. Same Tree判断相同的二叉树。原题1234567Input: 1 1 / \ / \ 2 3 2 3 [1,2,3], [1,2,3]Output: true 方法一：recursively 123456def isSameTree(self, p: 'TreeNode', q: 'TreeNode') -&gt; 'bool': if p and q: return (p.val==q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)) else: return p is q 方法二：recursively, tuple 1234def is_same_tree(p, q): def t(n): return n and (n.val, t(n.left), t(n.right)) return t(p) == t(q) 方法三：iteratively. 12345678910111213def isSameTree(self, p: 'TreeNode', q: 'TreeNode') -&gt; 'bool': stack = [(p, q)] while stack: p1, p2 = stack.pop() if not p1 and not p2: continue if not p1 or not p2: return False if p1.val != p2.val: return False stack.append((p1.left, p2.left)) stack.append((p1.right, p2.right)) return True 101. Symmetric Tree判断二叉树是否对称。原题12345 1 / \ 2 2 / \ / \3 4 4 3 方法一：recursively. 123456789101112def isSymmetric(self, root: 'TreeNode') -&gt; 'bool': def symmetric(p1, p2): if p1 and p2: return (p1.val == p2.val and symmetric(p1.left, p2.right) and symmetric(p1.right, p2.left)) else: return p1 is p2 if not root: return True return symmetric(root.left, root.right) 方法二：iteratively. 12345678910def isSymmetric(self, root: 'TreeNode') -&gt; 'bool': stack = root and [(root.left, root.right)] while stack: p1, p2 = stack.pop() if not p1 and not p2: continue if not p1 or not p2: return False if p1.val != p2.val: return False stack.append((p1.left, p2.right)) stack.append((p1.right, p2.left)) return True 104. Maximum Depth of Binary Tree二叉树最大深度。原题123456 3 / \ 9 20 / \ 15 7return 3 方法一：recursively 1234def max_depth(root): if not root: return 0 return max(max_depth(root.left), max_depth(root.right)) + 1 方法二：iteratively. BFS with deque 12345678910def maxDepth(self, root: 'TreeNode') -&gt; 'int': q = root and collections.deque([(root, 1)]) d = 0 while q: node, d = q.popleft() if node.right: q.append((node.right, d+1)) if node.left: q.append((node.left, d+1)) return d 可以参考102分层遍历写法，最后求长度。 559. Maximum Depth of N-ary TreeN-叉树的最大深度。原题方法一：BFS with deque.同上题一样。 12345678def maxDepth(self, root: 'Node') -&gt; 'int': q = root and collections.deque([(root, 1)]) d = 0 while q: node, d = q.popleft() for child in node.children: q.append((child, d + 1)) return d 方法二：BFS. 12345def maxDepth(self, root): q, level = root and [root], 0 while q: q, level = [child for node in q for child in node.children], level+1 return level 方法三：recursively. 1234def maxDepth(self, root: 'Node') -&gt; 'int': if not root: return 0 return max(list(map(self.maxDepth, root.children)) or [0]) + 1 111. Minimum Depth of Binary Tree求根节点到叶子节点的最小深度。原题方法一：recursively 1234567def minDepth(self, root): if not root: return 0 if root.left and root.right: return min(self.minDepth(root.left), self.minDepth(root.right)) + 1 else: return self.minDepth(root.left) + self.minDepth(root.right) + 1 方法二：对上述方法修改，更加Pythonic. 注意一点，Python3中要加list,否则max因为空值报错。 1234def minDepth(self, root: 'TreeNode') -&gt; 'int': if not root: return 0 d = list(map(self.minDepth, (root.left, root.right))) return 1 + (min(d) or max(d)) 方法三：迭代法，BFS 123456789101112def minDepth(self, root: 'TreeNode') -&gt; 'int': q = root and collections.deque([(root, 1)]) d = 0 while q: node, d = q.popleft() if not node.left and not node.right: return d if node.left: q.append((node.left, d+1)) if node.right: q.append((node.right, d+1)) return d 105. Construct Binary Tree from Preorder and Inorder Traversal根据前序遍历和中序遍历重建二叉树。原题12preorder = [3,9,20,15,7]inorder = [9,3,15,20,7] 方法一：切片。 123456789def buildTree(preorder, inorder): if preorder == []: return None root_val = preorder[0] root = TreeNode(root_val) cut = inorder.index(root_val) root.left = buildTree(preorder[1:cut+1], inorder[:cut]) root.right = buildTree(preorder[cut+1:], inorder[cut+1:]) return root 方法二：上述方法在极端情况下，如只有左子树的情况，由于index会将时间复杂度上升到O(n²)，而且切片产生了一些不必要的内存。这个方法是setefan大神的方法，pop和reverse是为了增加效率。 1234567891011def buildTree(self, preorder: 'List[int]', inorder: 'List[int]') -&gt; 'TreeNode': def build(stop): if inorder and inorder[-1] != stop: root = TreeNode(preorder.pop()) root.left = build(root.val) inorder.pop() root.right = build(stop) return root preorder.reverse() inorder.reverse() return build(None) 106. Construct Binary Tree from Inorder and Postorder Traversal根据中序遍历和后序遍历重建二叉树。原题方法一：切片、 123456789def buildTree(self, inorder: List[int], postorder: List[int]) -&gt; TreeNode: if not postorder: return None root_val = postorder[-1] root = TreeNode(root_val) cut = inorder.index(root_val) root.left = self.buildTree(inorder[:cut], postorder[:cut]) root.right = self.buildTree(inorder[cut+1:], postorder[cut: -1]) return root 方法二：stop pop的方式。甚至都不用reverse 12345678910def buildTree(self, inorder: List[int], postorder: List[int]) -&gt; TreeNode: def build(stop): if inorder and inorder[-1]!=stop: root = TreeNode(postorder.pop()) root.right = build(root.val) inorder.pop() root.left = build(stop) return root return build(None) 889. Construct Binary Tree from Preorder and Postorder Traversal根据前序和后序重建二叉树。原题12Input: pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]Output: [1,2,3,4,5,6,7] 方法一：index的方式、、 12345678910def constructFromPrePost(self, pre: List[int], post: List[int]) -&gt; TreeNode: if not post: return None root = TreeNode(post.pop()) if len(pre) &gt; 1: cut = post.index(pre[1]) root.left = self.constructFromPrePost(pre[1:cut+2], post[:cut+1]) root.right = self.constructFromPrePost(pre[cut+2:], post[cut+1:]) return root 方法二：使用index递归 . by@lee215 1234567891011class Solution: preIndex, posIndex = 0, 0 def constructFromPrePost(self, pre, post): root = TreeNode(pre[self.preIndex]) self.preIndex += 1 if (root.val != post[self.posIndex]): root.left = self.constructFromPrePost(pre, post) if (root.val != post[self.posIndex]): root.right = self.constructFromPrePost(pre, post) self.posIndex += 1 return root 572. Subtree of Another Tree判断是否是树的子结构。原题思路：这道题是遍历加判断相同树的结合。这里采用前序遍历和递归判断相同树。 123456789101112131415161718def isSubtree(self, s: 'TreeNode', t: 'TreeNode') -&gt; 'bool': def is_same(s, t): if s and t: return (s.val==t.val and is_same(s.left, t.left) and is_same(s.right, t.right)) else: return s is t stack = s and [s] while stack: node = stack.pop() if node: if is_same(node, t): return True stack.append(node.right) stack.append(node.left) return False 102. Binary Tree Level Order Traversal分层遍历二叉树。原题注意：循环条件要加上root，以防止root is None 123456def levelOrder(self, root: 'TreeNode') -&gt; 'List[List[int]]': ans, level = [], root and [root] while level: ans.append([n.val for n in level]) level = [k for n in level for k in (n.left, n.right) if k] return ans 103. Binary Tree Zigzag Level Order Traversal之字形打印二叉树。原题1234567def zigzagLevelOrder(self, root: 'TreeNode') -&gt; 'List[List[int]]': ans, level, order = [], root and [root], 1 while level: ans.append([n.val for n in level][::order]) order *= -1 level = [kid for n in level for kid in (n.left, n.right) if kid] return ans 107. Binary Tree Level Order Traversal II和102题不同的是，从下到上分层打印。原题方法一：将结果倒序输出。 123456def levelOrderBottom(self, root): res, level = [], [root] while root and level: res.append([n.val for n in level]) level = [kid for n in level for kid in (n.left, n.right) if kid] return res[::-1] 方法二：也可以从前面插入元素。 123456def levelOrderBottom(self, root): res, level = [], [root] while root and level: res.insert(0, [n.val for n in level]) level = [kid for n in level for kid in (n.left, n.right) if kid] return res 429. N-ary Tree Level Order Traversal分层打印N叉树。原题123456def levelOrder(self, root: 'Node') -&gt; 'List[List[int]]': ans, level = [], root and [root] while level: ans.append([n.val for n in level]) level = [k for n in level for k in n.children if k] return ans 637. Average of Levels in Binary Tree遍历一个二叉树，求每层节点的平均值，按照节点不为空的个数。原题123456789Input: 3 / \ 9 20 / \ 15 7Output: [3, 14.5, 11]Explanation:The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11]. 123456def averageOfLevels(self, root: 'TreeNode') -&gt; 'List[float]': ans, level = [], root and [root] while level: ans.append(sum(n.val for n in level) / len(level)) level = [k for n in level for k in (n.left, n.right) if k] return ans 515. Find Largest Value in Each Tree Row找到树每层的最大值。原题方法一：BFS. 此解法秒。 123456def largestValues(self, root: TreeNode) -&gt; List[int]: ans, levels = [], root and [root] while levels: ans.append(max(x.val for x in levels)) levels = [k for n in levels for k in (n.left, n.right) if k] return ans 987. Vertical Order Traversal of a Binary Tree垂直遍历二叉树，从左到右，从上到下，如果节点具有相同位置，按照值从小到大。原题 12345Input: [1,2,3,4,5,6,7]Output: [[4],[2],[1,5,6],[3],[7]]Explanation: The node with value 5 and the node with value 6 have the same position according to the given scheme.However, in the report &quot;[1,5,6]&quot;, the node value of 5 comes first since 5 is smaller than 6. 方法一：dfs. 通过建立一个字典数组，将对应的节点使用深度优先遍历初始化数组。然后按照x, y, val三个优先级进行排序。 12345678910111213141516171819def verticalTraversal(self, root: 'TreeNode') -&gt; 'List[List[int]]': seen = collections.defaultdict( lambda: collections.defaultdict(list) ) def dfs(node, x=0, y=0): if node: seen[x][y].append(node.val) dfs(node.left, x-1, y+1) dfs(node.right, x+1, y+1) dfs(root) ans = [] for x in sorted(seen): inner = [] for y in sorted(seen[x]): inner.extend(sorted(n for n in seen[x][y])) ans.append(inner) return ans 257. Binary Tree Paths打印二叉树从根节点到叶子节点全部路径。原题1234567891011Input: 1 / \2 3 \ 5Output: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]Explanation: All root-to-leaf paths are: 1-&gt;2-&gt;5, 1-&gt;3 iteratively。思路：采用前序遍历二叉树，使用tuple保存节点当前路径，如果是叶子节点，则添加到结果中。开始老是想着用&#39;-&gt;&#39;.join()，这样反而麻烦，直接使用字符串保存就好。 1234567891011def binaryTreePaths(self, root: 'TreeNode') -&gt; 'List[str]': ans, stack = [], root and [(root, str(root.val))] while stack: n, p = stack.pop() if not n.left and not n.right: ans.append(p) if n.right: stack.append((n.right, p+'-&gt;'+str(n.right.val))) if n.left: stack.append((n.left, p+'-&gt;'+str(n.left.val))) return ans 方法二：dfs. 123456789101112def binaryTreePaths(self, root: 'TreeNode') -&gt; 'List[str]': ans = [] def dfs(n, path): if n: path.append(str(n.val)) if not n.left and not n.right: ans.append('-&gt;'.join(path)) dfs(n.left, path) dfs(n.right, path) path.pop() dfs(root, []) return ans recursively。参考了StefanPochmann大神的方法。最开始想到一半，中间那层循环想到了，但没想到用递归。 123456def binaryTreePaths(self, root): if not root: return [] return [str(root.val) + '-&gt;' + path for kid in (root.left, root.right) if kid for path in self.binaryTreePaths(kid)] or [str(root.val)] 988. Smallest String Starting From Leaf求字典顺序最小的路径，路径指叶子节点到根节点的路径。0对应a，1对应b。原题12Input: [0,1,2,3,4,3,4]Output: &quot;dba&quot; 方法一：先列出所有根到叶子的路径，再reverse求最小值。 12345678910111213def smallestFromLeaf(self, root: 'TreeNode') -&gt; 'str': OFFSET = ord('a') stack = root and [(root, chr(root.val+OFFSET))] ans = '~' while stack: n, p = stack.pop() if not n.left and not n.right: ans = min(ans, p[::-1]) if n.right: stack.append((n.right, p+chr(n.right.val+OFFSET))) if n.left: stack.append((n.left, p+chr(n.left.val+OFFSET))) return ans 方法二：dfs. 递归计算完左右节点，然后再将根节点pop掉。 1234567891011121314def smallestFromLeaf(self, root: 'TreeNode') -&gt; 'str': self.ans = '~' def dfs(node, A): if node: A.append(chr(node.val + ord('a'))) if not node.left and not node.right: self.ans = min(self.ans, ''.join(reversed(A))) dfs(node.left, A) dfs(node.right, A) A.pop() dfs(root, []) return self.ans 112. Path Sum判断是否具有从根节点到叶子节点上的值和为sum。原题方法一：recursively 123456789def hasPathSum(self, root: 'TreeNode', total: 'int') -&gt; 'bool': if not root: return False elif (not root.left and not root.right and root.val==total): return True else: return (self.hasPathSum(root.left, total-root.val) or self.hasPathSum(root.right, total-root.val)) 方法二：iteratively 1234567891011def hasPathSum(self, root: 'TreeNode', total: 'int') -&gt; 'bool': stack = root and [(root, total)] while stack: n, t = stack.pop() if not n.left and not n.right and n.val==t: return True if n.right: stack.append((n.right, t-n.val)) if n.left: stack.append((n.left, t-n.val)) return False 113. Path Sum II上题的升级版，要求二维数组返回所有路径。原题123456789sum = 22 5 / \ 4 8 / / \ 11 13 4 / \ / \7 2 5 1 1234[ [5,4,11,2], [5,8,4,5]] 方法一：iteratively. 举一反三。 123456789101112def pathSum(self, root: 'TreeNode', total: 'int') -&gt; 'List[List[int]]': stack = root and [(root, [root.val], total)] ans = [] while stack: n, v, t = stack.pop() if not n.left and not n.right and n.val==t: ans.append(v) if n.right: stack.append((n.right, v+[n.right.val], t-n.val)) if n.left: stack.append((n.left, v+[n.left.val], t-n.val)) return ans recursively. 先找出所有路径，再过滤，实际上和257题一样。不过这并没有把这道题的特性涵盖进去。 12345678910def pathSum(self, root, sum_val): paths = self.all_paths(root) return [path for path in paths if sum(path)==sum_val] def all_paths(self, root): if not root: return [] return [[root.val]+path for kid in (root.left, root.right) if kid for path in self.all_paths(kid)] or [[root.val]] 方法三：recursively. 123456789def pathSum(self, root, sum): if not root: return [] val, *kids = root.val, root.left, root.right if any(kids): return [[val] + path for kid in kids if kid for path in self.pathSum(kid, sum-val)] return [[val]] if val==sum else [] 297. Serialize and Deserialize Binary Tree序列化反序列化二叉树。原题1234567891011121314151617181920class Codec: def serialize(self, root): if not root: return '$' return (str(root.val) + ',' + self.serialize(root.left) + ',' + self.serialize(root.right)) def deserialize(self, data): nodes = data.split(',')[::-1] return self.deserialize_tree(nodes) def deserialize_tree(self, nodes): val = nodes.pop() if val == '$': return None root = TreeNode(val) root.left = self.deserialize_tree(nodes) root.right = self.deserialize_tree(nodes) return root 110. Balanced Binary Tree判断是否是平衡二叉树。原题方法一：递归+递归。 12345678910def isBalanced(self, root): if not root: return True return self.isBalanced(root.left) and self.isBalanced(root.right) and \ abs(self.max_depth(root.left)-self.max_depth(root.right)) &lt;= 1 def max_depth(self, root): if not root: return 0 return max(self.max_depth(root.left), self.max_depth(root.right)) + 1 方法二：上诉两种方法中都包含了一些无意义的重复遍历。这里采用后序遍历，边遍历边判断，不会重复节点。受此思想启发，添加一种后序遍历二叉树的方法。 12345678910111213141516171819def isBalanced(self, root): stack, node = [], root last, depths = None, collections.defaultdict(int) while stack or node: if node: stack.append(node) node = node.left else: node = stack[-1] if not node.right or last == node.right: node = stack.pop() left, right = depths[node.left], depths[node.right] if abs(left - right) &gt; 1: return False depths[node] = 1 + max(left, right) last, node = node, None else: node = node.right return True 方法三：dfs. 算深度的时候判断左右是否深度超过1. 这里变量不能把self去掉，否则[1,2,2,3,3,null,null,4,4]会错误的返回True而不是False。 1234567891011121314def isBalanced(self, root: 'TreeNode') -&gt; 'bool': self.balanced = True def dfs(node): if not node: return 0 left = dfs(node.left) right = dfs(node.right) if not self.balanced or abs(left - right) &gt; 1: self.balanced = False return max(left, right) + 1 dfs(root) return self.balanced 108. Convert Sorted Array to Binary Search Tree将有序数组转换成二叉搜索树。原题12345678Given the sorted array: [-10,-3,0,5,9],One possible answer is: [0,-3,9,-10,null,5], 0 / \ -3 9 / / -10 5 方法一：答案不唯一，居然一次就通过了。递归的思想还是简单一些的。 12345678def sortedArrayToBST(self, nums): if not nums: return None mid = len(nums) // 2 root = TreeNode(nums[mid]) root.left = self.sortedArrayToBST(nums[:mid]) root.right = self.sortedArrayToBST(nums[mid+1:]) return root 方法二：不使用切片。 123456789101112def sortedArrayToBST(self, nums: 'List[int]') -&gt; 'TreeNode': def convert(lo, hi): if lo &gt; hi: return None mid = (lo+hi) // 2 root = TreeNode(nums[mid]) root.left = convert(lo, mid-1) root.right = convert(mid+1, hi) return root return convert(0, len(nums)-1) 235. Lowest Common Ancestor of a Binary Search Tree寻找二叉搜索树的最小公共祖先。原题方法一：iteratively. 1234def lowestCommonAncestor(self, root, p, q): while (root.val-p.val) * (root.val-q.val) &gt; 0: root = (root.left, root.right)[root.val &lt; p.val] return root 方法二：recursively. 12345def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode': if (root.val-p.val) * (root.val-q.val) &lt;= 0: return root return self.lowestCommonAncestor( (root.left, root.right)[root.val &lt; p.val], p, q) 404. Sum of Left Leaves求一个二叉树所有左叶子节点的和。原题方法一：iteratively.这里使用了tuple记录是否为左叶子节点。 12345678910def sumOfLeftLeaves(self, root: 'TreeNode') -&gt; 'int': ans, stack = 0, root and [(root, False)] while stack: n, isleft = stack.pop() if n: if not n.left and not n.right and isleft: ans += n.val stack.append((n.right, False)) stack.append((n.left, True)) return ans 方法二：recursively. 12345678def sumOfLeftLeaves(self, root: 'TreeNode') -&gt; 'int': if not root: return 0 if (root.left and not root.left.left and not root.left.right): return root.left.val + self.sumOfLeftLeaves(root.right) else: return (self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)) 938. Range Sum of BST给两个节点的值，求二叉搜索树在这两个值之间的节点和。每个节点的值唯一。原题1234Input: root = [10,5,15,3,7,null,18], L = 7, R = 15Output: 32Input: root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10Output: 23 方法一：因为是竞赛题，所以没追求效率，所以这里先前序遍历了一下，再根据条件求和。 1234567891011def rangeSumBST(self, root, L, R): traverse, stack = [], [root] while stack: node = stack.pop() if node: traverse.append(node.val) if node.right: stack.append(node.right) if node.left: stack.append(node.left) return sum([x for x in traverse if L &lt;= x &lt;= R]) 方法二：利用二叉搜索树的特性。 1234567891011def rangeSumBST(self, root: 'TreeNode', L: 'int', R: 'int') -&gt; 'int': ans, stack = 0, root and [root] while stack: node = stack.pop() if node.val &gt; L and node.left: stack.append(node.left) if node.val &lt; R and node.right: stack.append(node.right) if L &lt;= node.val &lt;= R: ans += node.val return ans 530. Minimum Absolute Difference in BST求二叉搜索树任意两个节点的最小差。原题12345678910111213Input: 1 \ 3 / 2Output:1Explanation:The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3). 12345678910def getMinimumDifference(self, root: 'TreeNode') -&gt; 'int': def inorder(n): if not n: return [] return inorder(n.left) + [n.val] + inorder(n.right) nums = inorder(root) # return min(nums[i+1]-nums[i] for i in range(len(nums)-1)) return min(b-a for a, b in zip(nums, nums[1:])) 783. Minimum Distance Between BST Nodes二叉搜索树两个节点的最小值。和530是一道题。原题1234567891011121314Input: root = [4,2,6,1,3,null,null]Output: 1Explanation:Note that root is a TreeNode object, not an array.The given tree [4,2,6,1,3,null,null] is represented by the following diagram: 4 / \ 2 6 / \ 1 3 while the minimum difference in this tree is 1, it occurs between node 1 and node 2, also between node 3 and node 2. 方法一：递归 + 生成器， 遍历了两次。 123456789def minDiffInBST(self, root: 'TreeNode') -&gt; 'int': def inorder(node): if not node: return [] return inorder(node.left) + [node.val] + inorder(node.right) t = inorder(root) return min(t[x]-t[x-1] for x in range(1, len(t))) 方法二：一次遍历，没有保存整个遍历数组，效率高。 12345678910def minDiffInBST(self, root: TreeNode) -&gt; int: ans, last, stack = float('inf'), float('-inf'), [] while stack or root: while root: stack.append(root) root = root.left root = stack.pop() ans, last = min(ans, root.val-last), root.val root = root.right return ans 方法三：一次递归。 123456789101112class Solution: pre = float('-inf') ans = float('inf') def minDiffInBST(self, root: 'TreeNode') -&gt; 'int': if root.left: self.minDiffInBST(root.left) self.ans = min(self.ans, root.val-self.pre) self.pre = root.val if root.right: self.minDiffInBST(root.right) return self.ans 538. Convert BST to Greater Tree二叉搜索树转换。使得节点的值等于所有比它大的节点的和。原题123456789Input: The root of a Binary Search Tree like this: 5 / \ 2 13Output: The root of a Greater Tree like this: 18 / \ 20 13 方法一：recursively。这里使用了一个变量来保存当前的累加和，然后递归中采用先右后左的方式。 123456789101112def convertBST(self, root: TreeNode) -&gt; TreeNode: self.val = 0 def dfs(node): if node: dfs(node.right) self.val += node.val node.val = self.val dfs(node.left) dfs(root) return root 方法二：iteratively。 123456789101112def convertBST(self, root: TreeNode) -&gt; TreeNode: head = root stack, val = [], 0 while stack or root: while root: stack.append(root) root = root.right root = stack.pop() val += root.val root.val = val root = root.left return head 方法三：生成器写法。 123456789101112def convertBST(self, root: TreeNode) -&gt; TreeNode: def dfs(node): if node: yield from dfs(node.right) yield node yield from dfs(node.left) val = 0 for node in dfs(root): val += node.val node.val = val return root 958. Check Completeness of a Binary Tree判断二叉树是否是完整二叉树。完整二叉树为：除了最后一层所有节点不能为空，最后一层节点全部去靠左。原题Example 1: 123Input: [1,2,3,4,5,6]Output: trueExplanation: Every level before the last is full (ie. levels with node-values &#123;1&#125; and &#123;2, 3&#125;), and all nodes in the last level (&#123;4, 5, 6&#125;) are as far left as possible. Example 2: 123Input: [1,2,3,4,5,null,7]Output: falseExplanation: The node with value 7 isn&apos;t as far left as possible. 方法一：采用分层遍历的方式，判断每层的节点是否是2**level。最后一层采用切片的方式判断最左原则。 123456789101112131415161718192021class Solution: def isCompleteTree(self, root): if not root: return True levels = [root] last_full = True level = 0 while levels: value_nodes = [n for n in levels if n] if value_nodes != levels[:len(value_nodes)]: return False else: print(len(levels), 2**level) if len(levels) != 2**level: if not last_full: return False last_full = False levels = [kid for n in levels if n for kid in (n.left, n.right)] level += 1 return True 方法二：Lee神的写法，想明白一件事就是，遇见第一个None时，后面如果再有非None的值就不是玩整树了。 1234567def isCompleteTree(self, root: 'TreeNode') -&gt; 'bool': i, bfs = 0, [root] while bfs[i]: bfs.append(bfs[i].left) bfs.append(bfs[i].right) i += 1 return not any(bfs[i:]) 543. Diameter of Binary Tree求二叉树的最大直径，即任意两节点的长度。原题123456 1 / \ 2 3 / \ 4 5 Return **3**, which is the length of the path [4,2,1,3] or [5,2,1,3]. 方法一： recursively, 使用一个实例变量计算了最大值。 12345678910111213def diameterOfBinaryTree(self, root: 'TreeNode') -&gt; 'int': self.diameter = 0 def dfs(node): if not node: return 0 left = dfs(node.left) right = dfs(node.right) self.diameter = max(self.diameter, left+right) return max(left, right) + 1 dfs(root) return self.diameter 965. Univalued Binary Tree判断一个二叉树是否所有节点具有相同的值。原题方法一：recursively。 12345def isUnivalTree(self, root: 'TreeNode') -&gt; 'bool': def dfs(node): return (not node or root.val==node.val and dfs(node.left) and dfs(node.right)) return dfs(root) 方法二：iteratively.常规写法。 12345678910def isUnivalTree(self, root: 'TreeNode') -&gt; 'bool': r_val, stack = root.val, [root] while stack: n = stack.pop() if n: if n.val != r_val: return False stack.append(n.right) stack.append(n.left) return True 方法二：前序遍历，生成器方法。 1234567891011121314def isUnivalTree(self, root: 'TreeNode') -&gt; 'bool': def bfs(node): if node: yield node.val yield from bfs(node.left) yield from bfs(node.right) it = bfs(root) root_val = next(it) for val in it: if val != root_val: return False return True 563. Binary Tree Tilt返回一个二叉树整个树的倾斜度。所有节点倾斜度的总和。节点的倾斜度等于左子树和右子树所有和差的绝对值。原题12345678910Input: 1 / \ 2 3Output: 1Explanation: Tilt of node 2 : 0Tilt of node 3 : 0Tilt of node 1 : |2-3| = 1Tilt of binary tree : 0 + 0 + 1 = 1 方法一：recursively. 这里用tuple记录了节点总和和倾斜度总和。 12345678910111213def findTilt(self, root): self.res = 0 _, top_res = self.sum_and_diff(root) return self.res + top_resdef sum_and_diff(self, node): if not node: return 0, 0 l_sum, l_diff = self.sum_and_diff(node.left) r_sum, r_diff = self.sum_and_diff(node.right) self.res += l_diff + r_diff # print(node.val, node.val+l_sum+r_sum, abs(l_sum-r_sum)) return node.val+l_sum+r_sum, abs(l_sum-r_sum) 方法二: 想了一会后序遍历的迭代法，没想出来，貌似需要维护很多的变量。这里还是优化一下方法一。 1234567891011def findTilt(self, root: 'TreeNode') -&gt; 'int': def dfs(node): if not node: return 0, 0 l_sum, l_diff = dfs(node.left) r_sum, r_diff = dfs(node.right) return (node.val + l_sum + r_sum, abs(l_sum-r_sum) + l_diff + r_diff) return dfs(root)[1] 606. Construct String from Binary Tree根据二叉树重建字符串，使用()表示嵌套关系。原题123456789101112131415Input: Binary tree: [1,2,3,4] 1 / \ 2 3 / 4 Output: &quot;1(2(4))(3)&quot;Input: Binary tree: [1,2,3,null,4] 1 / \ 2 3 \ 4 Output: &quot;1(2()(4))(3)&quot; 方法一：recursively. 左右节点有一点区别，在于如果左节点为空，右节点不为空，要保留左节点的括号。 12345def tree2str(self, t): if not t: return '' left = '(&#123;&#125;)'.format(self.tree2str(t.left)) if (t.left or t.right) else '' right = '(&#123;&#125;)'.format(self.tree2str(t.right)) if t.right else '' return '&#123;&#125;&#123;&#125;&#123;&#125;'.format(t.val, left, right) 617. Merge Two Binary Trees合并两个二叉树，相同位置的节点值相加，空节点算0.原题方法一：recursively. 虽然这个方法AC了，但是感觉有点问题，返回的TreeNode中某个子节点可能包含原来的t1或t2的引用。 123456789def mergeTrees(self, t1, t2): if not t1: return t2 if not t2: return t1 t = TreeNode(t1.val+t2.val) t.left = self.mergeTrees(t1.left, t2.left) t.right = self.mergeTrees(t1.right, t2.right) return t 方法二：iteratively. 12345678910111213141516def mergeTrees(self, t1, t2): if not t1 and not t2: return [] t = TreeNode(0) stack = [(t, t1, t2)] while stack: n, n1, n2 = stack.pop() if n1 or n2: n.val = (n1.val if n1 else 0) + (n2.val if n2 else 0) if (n1 and n1.right) or (n2 and n2.right): n.right = TreeNode(None) stack.append((n.right, n1.right if n1 else None, n2.right if n2 else None)) if (n1 and n1.left) or (n2 and n2.left): n.left = TreeNode(None) stack.append((n.left, n1.left if n1 else None, n2.left if n2 else None)) return t 653. Two Sum IV - Input is a BST判断二叉树中是否有两个节点相加为k。原题12345678910Input: 5 / \ 3 6 / \ \2 4 7Target = 9Output: True 方法一：preorder + set. 1234567891011def findTarget(self, root, k): seen, stack = set(), root and [root] while stack: node = stack.pop() if node: if k-node.val in seen: return True seen.add(node.val) stack.append(node.right) stack.append(node.left) return False 669. Trim a Binary Search Tree根据范围修剪二叉搜索树，注意是二叉搜索树，不是普通的二叉树。原题123456789101112Input: 1 / \ 0 2 L = 1 R = 2Output: 1 \ 2 方法一：recursively. 12345678910111213def trimBST(self, root, L, R): def trim_node(node): if not node: return None elif node.val &gt; R: return trim_node(node.left) elif node.val &lt; L: return trim_node(node.right) else: node.left = trim_node(node.left) node.right = trim_node(node.right) return node return trim_node(root) 671. Second Minimum Node In a Binary Tree找出二叉树中第二小的节点值。左右子节点同时存在或同时不存在，根节点小于等于任意子节点。原题123456789Input: 2 / \ 2 5 / \ 5 7Output: 5Explanation: The smallest value is 2, the second smallest value is 5. 方法一：先放到set里. 123456789101112131415def findSecondMinimumValue(self, root: 'TreeNode') -&gt; 'int': self.uniques = set() def dfs(node): if node: self.uniques.add(node.val) dfs(node.left) dfs(node.right) dfs(root) min1, ans = root.val, float('inf') for v in self.uniques: if min1 &lt; v &lt; ans: ans = v return ans if ans &lt; float('inf') else -1 方法二： iteratively. 1234567891011def findSecondMinimumValue(self, root): min1 = root.val if root else -1 res = float('inf') stack = root and [root] while stack: node = stack.pop() if node: if min1 &lt; node.val &lt; res: res = node.val stack.extend([node.right, node.left]) return res if res &lt; float('inf') else -1 方法三：还没想出来，以上两种都没有利用到一些题中已知条件，我看Solution中给出的及一些Discuss中的答案也忽略了这个条件。想了想无论是哪个顺序遍历，或者深度广度优先，都没能很好的利用这个条件。 687. Longest Univalue Path相同节点最长路径，路径长度按照两个节点之间的边距，也就是节点数-1。原题123456 5 / \ 4 5 / \ \ 1 1 5output: 2 123456789101112def longestUnivaluePath(self, root): self.res = 0 def traverse(node): if not node: return 0 left_len, right_len = traverse(node.left), traverse(node.right) left = (left_len+1) if node.left and node.left.val==node.val else 0 right = (right_len+1) if node.right and node.right.val==node.val else 0 self.res = max(self.res, left + right) return max(left, right) traverse(root) return self.res 700. Search in a Binary Search Tree在二叉搜索树中搜索节点。原题12345678Given the tree: 4 / \ 2 7 / \ 1 3And the value to search: 2 方法一：recursively. 123456def searchBST(self, root: 'TreeNode', val: 'int') -&gt; 'TreeNode': if root: if val == root.val: return root return self.searchBST( (root.left, root.right)[root.val &lt; val], val) 方法二：iteratively. 12345def searchBST(self, root: 'TreeNode', val: 'int') -&gt; 'TreeNode': node = root while node and node.val != val: node = (node.left, node.right)[node.val &lt; val] return node 872. Leaf-Similar Trees叶子相近的树，只从左到右遍历叶子节点的顺序相同的两棵树。原题方法一：前序遍历+生成器。空间复杂度过高，beats 1%。 12345678910111213141516def leafSimilar(self, root1: 'TreeNode', root2: 'TreeNode') -&gt; 'bool': def leaves(root): stack = root and [root] while stack: node = stack.pop() if node: if not node.right and not node.left: yield node.val stack.append(node.right) stack.append(node.left) leaves1 = leaves(root1) leaves2 = leaves(root2) return all( a==b for a, b in itertools.zip_longest(leaves1, leaves2)) 方法二：dfs. 1234567891011def leafSimilar(self, root1: 'TreeNode', root2: 'TreeNode') -&gt; 'bool': def dfs(node): if node: if not node.left and not node.right: yield node.val yield from dfs(node.left) yield from dfs(node.right) return all( a==b for a, b in itertools.zip_longest(dfs(root1), dfs(root2))) 897. Increasing Order Search Tree根据中序遍历建立一个只有右子树的二叉树。要求在原树上修改。原题1234567891011121314151617181920Example 1:Input: [5,3,6,2,4,null,8,1,null,null,null,7,9] 5 / \ 3 6 / \ \ 2 4 8 / / \ 1 7 9Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9] 1 \ 2 \ 3 \ 4 方法一：iteratively. 1234567891011def increasingBST(self, root: TreeNode) -&gt; TreeNode: ans = head = TreeNode(0) stack = [] while stack or root: while root: stack.append(root) root = root.left root = stack.pop() head.right = TreeNode(root.val) root, head = root.right, head.right return ans.right 方法二：生成器。 12345678910111213def increasingBST(self, root: 'TreeNode') -&gt; 'TreeNode': def inorder(node): if node: yield from inorder(node.left) yield node.val yield from inorder(node.right) ans = head = TreeNode(0) for v in inorder(root): head.right = TreeNode(v) head = head.right return ans.right 方法三：题中有个要求在原树上修改，所以以上两种方法其实不符合要求，这里使用递归实现。 此答案由lee大神提供，非常巧妙。 123456def increasingBST(self, root: 'TreeNode', tail=None) -&gt; 'TreeNode': if not root: return tail res = self.increasingBST(root.left, root) root.left = None root.right = self.increasingBST(root.right, tail) return res 993. Cousins in Binary Tree表弟节点指两个节点在同一深度，并且父节点不同。判断两个节点是否是表弟节点。树中节点值唯一。原题方法一：用dict记录。 123456789101112def isCousins(self, root: 'TreeNode', x: 'int', y: 'int') -&gt; 'bool': parent, depth = &#123;&#125;, &#123;&#125; def dfs(node, par=None): if node: parent[node.val] = par depth[node.val] = depth[par] + 1 if par else 0 dfs(node.left, node.val) dfs(node.right, node.val) dfs(root) return depth[x] == depth[y] and parent[x] != parent[y] 230. Kth Smallest Element in a BST二叉搜索树的第K小节点值。原题1234567Input: root = [3,1,4,null,2], k = 1 3 / \ 1 4 \ 2Output: 1 方法一：生成器前序遍历。 12345678910111213def kthSmallest(self, root: TreeNode, k: int) -&gt; int: def inorder(node): if node: yield from inorder(node.left) yield node.val yield from inorder(node.right) for n in inorder(root): if k == 1: return n else: k -= 1 方法二：迭代。 1234567891011def kthSmallest(self, root: TreeNode, k: int) -&gt; int: stack = [] while root or stack: while root: stack.append(root) root = root.left root = stack.pop() k -= 1 if k == 0: return root.val root = root.right 98. Validate Binary Search Tree验证一个树是否是二叉搜索树。原题12345678 5 / \ 1 4 / \ 3 6Output: falseExplanation: The input is: [5,1,4,null,null,3,6]. The root node&apos;s value is 5 but its right child&apos;s value is 4. 方法一：中序遍历即可。 123456789101112def isValidBST(self, root: TreeNode) -&gt; bool: stack, last = [], float('-inf') while stack or root: while root: stack.append(root) root = root.left root = stack.pop() if root.val &lt;= last: return False last = root.val root = root.right return True 109. Convert Sorted List to Binary Search Tree将有序链表转成平衡二叉搜索树。原题123456789Given the sorted linked list: [-10,-3,0,5,9],One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \ -3 9 / / -10 5 方法一：先遍历链表，再二分递归创建树。 1234567891011121314151617def sortedListToBST(self, head: ListNode) -&gt; TreeNode: inorder = [] while head: inorder.append(head.val) head = head.next lo, hi = 0, len(inorder)-1 def build_tree(lo, hi): if lo &gt; hi: return None mid = (lo + hi) // 2 root = TreeNode(inorder[mid]) root.left = build_tree(lo, mid-1) root.right = build_tree(mid+1, hi) return root return build_tree(lo, hi) 方法二：这个方法很棒。先遍历一遍找到链表的长度；然后递归去构建树，共享一个head可变对象。 123456789101112131415161718192021222324def sortedListToBST(self, head: ListNode) -&gt; TreeNode: def find_size(head): h, count = head, 0 while h: h = h.next count += 1 return count lo, hi = 0, find_size(head) def form_bst(lo, hi): nonlocal head if lo &gt; hi: return None mid = (lo + hi) // 2 left = form_bst(lo, mid-1) root = TreeNode(head.val) head = head.next root.left = left right = form_bst(mid+1, hi) root.right = right return root return form_bst(lo, hi-1) 1008. Construct Binary Search Tree from Preorder Traversal根据前序遍历重建二叉搜索树。原题12Input: [8,5,1,7,10,12]Output: [8,5,10,1,7,null,12] 方法一：recursively. 1234567def bstFromPreorder(self, preorder: List[int]) -&gt; TreeNode: if not preorder: return None root = TreeNode(preorder[0]) i = bisect.bisect(preorder, root.val) root.left = self.bstFromPreorder(preorder[1:i]) root.right = self.bstFromPreorder(preorder[i:]) return root 236. Lowest Common Ancestor of a Binary Tree二叉树两个节点的最小公共祖先。原题方法一: 递归，是用mid表示当前节点是否是其中的一个。 1234567891011121314def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode': self.ans = None def dfs(node): if not node: return False left = dfs(node.left) right = dfs(node.right) mid = node in (p, q) if mid + left + right &gt;= 2: self.ans = node return mid or left or right dfs(root) return self.ans 方法二：递归，思想如果是两个节点中的一个，就返回这个节点。 123456def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode': if root in (None, p, q): return root left = self.lowestCommonAncestor(root.left, p, q) right = self.lowestCommonAncestor(root.right, p, q) return root if left and right else left or right 方法三：参考了257的dfs解法。需要注意的是一定要加list(path)，否则由于可变对象的问题，会导致最后结果为[]。 1234567891011121314def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode': ans = [] def dfs(n, path): if n: path.append(n) if n in (p, q): ans.append(list(path)) # must use list, or you will get [] if len(ans) == 2: # optimized return dfs(n.left, path) dfs(n.right, path) path.pop() dfs(root, []) return next(a for a, b in list(zip(*ans))[::-1] if a==b) 654. Maximum Binary Tree根据数组建立一个树，要求根节点为数组最大的树。原题方法一：此题秒，不过感觉还有更优解，查了一圈没找到。 123456789def constructMaximumBinaryTree(self, nums: List[int]) -&gt; TreeNode: if not nums: return None v = max(nums) root = TreeNode(v) i = nums.index(v) root.left = self.constructMaximumBinaryTree(nums[:i]) root.right = self.constructMaximumBinaryTree(nums[i+1:]) return root 513. Find Bottom Left Tree Value寻找二叉树最底层的最左节点。原题方法一：根据分层遍历改编。 123456def findBottomLeftValue(self, root: TreeNode) -&gt; int: ans, levels = None, root and [root] while levels: ans = levels[0].val levels = [k for n in levels for k in (n.left, n.right) if k] return ans 方法二：双端队列，BFS. 123456789def findBottomLeftValue(self, root: TreeNode) -&gt; int: q = collections.deque([root]) while q: node = q.pop() if node.right: q.appendleft(node.right) if node.left: q.appendleft(node.left) return node.val 方法三：循环时改变迭代对象，这种方式个人觉得不好。不过好在是在遍历之前添加到末端。 12345def findBottomLeftValue(self, root: TreeNode) -&gt; int: queue = [root] for node in queue: queue += (x for x in (node.right, node.left) if x) return node.val 814. Binary Tree Pruning剪掉树中不包含1的子树。原题方法一：递归。 123456789101112131415def pruneTree(self, root: TreeNode) -&gt; TreeNode: def dfs(node): if not node: return True left = dfs(node.left) right = dfs(node.right) if left: node.left = None if right: node.right = None return node.val==0 and left and right dfs(root) return root 199. Binary Tree Right Side View二叉树从右向左看时，从上到下的节点。原题方法一：和分层遍历思想相同。 123456def rightSideView(self, root: TreeNode) -&gt; List[int]: ans, levels = [], root and [root] while levels: ans.append(levels[-1].val) levels = [k for n in levels for k in (n.left, n.right) if k] return ans 方法二：dfs. 从右到左深度遍历，用一个深度变量控制是否是第一个最右节点。 12345678910def rightSideView(self, root: TreeNode) -&gt; List[int]: ans = [] def dfs(n, depth): if n: if depth == len(ans): ans.append(n.val) dfs(n.right, depth+1) dfs(n.left, depth+1) dfs(root, 0) return ans 662. Maximum Width of Binary Tree二叉树的最大宽度。原题方法一：常规队列写法。需要注意的是，每层遍历要用最右边的减去最左边的才是宽度。 123456789101112def widthOfBinaryTree(self, root: TreeNode) -&gt; int: queue = [(root, 0, 0)] ans = cur_depth = left = 0 for node, depth, pos in queue: if node: queue.append((node.left, depth+1, pos*2)) queue.append((node.right, depth+1, pos*2+1)) if cur_depth != depth: cur_depth = depth left = pos ans = max(pos-left+1, ans) return ans 方法二：按照分层顺序将所有节点编号，从1开始，enumerate其实就是计算2*pos, 2*pos+1。 12345678910def widthOfBinaryTree(self, root: TreeNode) -&gt; int: levels = [(1, root)] width = 0 while levels: width = max(levels[-1][0] - levels[0][0] + 1, width) levels = [k for pos, n in levels for k in enumerate((n.left, n.right), 2 * pos) if k[1]] return width 222. Count Complete Tree Nodes统计完整树的节点个数。原题方法一：二分法。比较左子树的深度和右子树的深度，如果相同则表明左子树为满树，右子树为完整树。如果不同则表明左子树为完整树，右子树为满树。 12345678910111213def countNodes(self, root: TreeNode) -&gt; int: if not root: return 0 left, right = self.depth(root.left), self.depth(root.right) if left == right: return 2 ** left + self.countNodes(root.right) else: return 2 ** right + self.countNodes(root.left) def depth(self, node): if not node: return 0 return 1 + self.depth(node.left) 1022. Sum of Root To Leaf Binary Numbers计算所有根到叶子节点路径二进制数表示的的和。原题123Input: [1,0,1,0,1,0,1]Output: 22Explanation: (100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22 思路和 257.Binary Tree Paths一样。 12345678910111213def sumRootToLeaf(self, root: TreeNode) -&gt; int: self.ans = 0 def dfs(n, path): if n: path.append(str(n.val)) if not n.left and not n.right: self.ans += int(''.join(path), 2) dfs(n.left, path) dfs(n.right, path) path.pop() dfs(root, []) return self.ans % (10**9 + 7) 1026. Maximum Difference Between Node and Ancestor祖先和其子节点的最大差绝对值。原题方法一：周赛时写的dfs. 380ms. 瓶颈在于每次都求一次最大值和最小值。 123456789101112131415def maxAncestorDiff(self, root: TreeNode) -&gt; int: self.ans = float('-inf') def dfs(n, p): if n: if p: max_diff = max(abs(max(p)-n.val), abs(min(p)-n.val)) self.ans = max(self.ans, max_diff) p.append(n.val) dfs(n.left, p) dfs(n.right, p) p.pop() dfs(root, []) return self.ans 方法二：改良了一下，使用p记录一个当前的最大值和最小值。52ms. 12345678910111213141516def maxAncestorDiff(self, root: TreeNode) -&gt; int: self.ans = float('-inf') def dfs(n, p): if n: if p: mx, mn = p[-1] self.ans = max(self.ans, max(mx-n.val, n.val-mn)) p.append((max(mx, n.val), min(mn, n.val))) else: p.append((n.val, n.val)) dfs(n.left, p) dfs(n.right, p) p.pop() dfs(root, []) return self.ans 1038. Binary Search Tree to Greater Sum Tree二叉搜索树转成一颗规则的树，从右根左的顺序累加节点值。原题方法一：使用栈。 123456789101112def bstToGst(self, root: TreeNode) -&gt; TreeNode: head = root stack, total = [], 0 while stack or root: while root: stack.append(root) root = root.right root = stack.pop() total += root.val root.val = total root = root.left return head 方法二：Lee神的递归方式。 1234567class Solution: val = 0 def bstToGst(self, root: TreeNode) -&gt; TreeNode: if root.right: self.bstToGst(root.right) root.val = self.val = self.val + root.val if root.left: self.bstToGst(root.left) return root 1080. Insufficient Nodes in Root to Leaf Paths计算所有的根到叶子节点的路径，如果路径和小于给定值，则剪掉这个树枝。原题方法一：递归。 12345678def sufficientSubset(self, root: TreeNode, limit: int) -&gt; TreeNode: if not root: return None if not root.left and not root.right: return root if root.val &gt;= limit else None root.left = self.sufficientSubset(root.left, limit-root.val) root.right = self.sufficientSubset(root.right, limit-root.val) return root if root.left or root.right else None 1161. Maximum Level Sum of a Binary Tree求最节点和最大层的层数。原题方法一：分层遍历 1234567def maxLevelSum(self, root: TreeNode) -&gt; int: lvsum = [] level = [root] while level: lvsum.append(sum(n.val for n in level)) level = [k for n in level for k in (n.left, n.right) if k] return lvsum.index(max(lvsum)) + 1 1104. Path In Zigzag Labelled Binary Tree之字形树的目标节点路径。原题方法一：迭代，此题纯粹是数学题，这里先假设非之字形的树，找到规律，然后知道每层的节点数再相减。 12345678910111213def pathInZigZagTree(self, label: int) -&gt; List[int]: ans = [] n = 0 while 2 ** n &lt;= label: n += 1 while n &gt; 0 and label &gt;= 1: ans.append(label) org_lable = label // 2 label = 2**(n-1)-1-org_lable+2**(n-2) n -= 1 return ans[::-1] 方法二：Lee神的递归。原理一样，层数n是通过查2的幂求的。 12def pathInZigZagTree(self, x): return self.pathInZigZagTree(3 * 2 ** (len(bin(x)) - 4) - 1 - x / 2) + [x] if x &gt; 1 else [1] 1110. Delete Nodes And Return Forest给定一个树，删除指定的一些节点，然后删除的节点的左右子树成为单独的根节点。返回所有的树。原题12Input: root = [1,2,3,4,5,6,7], to_delete = [3,5]Output: [[1,2,null,4],[6],[7]] 方法一：递归。做着题的时候有个误区：在当前节点被删除后，找到其在父节点对应的位置，然后置为空。实际上应该讲根节点删除的状态保留，在下一层处理。 1234567891011121314151617def delNodes(self, root: TreeNode, to_delete: List[int]) -&gt; List[TreeNode]: ans = [] to_del = set(to_delete) def helper(root, is_root): if not root: return None is_del = root.val in to_del root.left = helper(root.left, is_del) root.right = helper(root.right, is_del) if not is_del and is_root: ans.append(root) return None if is_del else root helper(root, True) return ans 1123. Lowest Common Ancestor of Deepest Leaves最深的叶子节点的最小公共祖先。原题123456Input: root = [1,2,3]Output: [1,2,3]Explanation: The deepest leaves are the nodes with values 2 and 3.The lowest common ancestor of these leaves is the node with value 1.The answer returned is a TreeNode object (not an array) with serialization &quot;[1,2,3]&quot;. 方法一：Lee神的方法比我的好太多，我借鉴了之前的dfs的方式遍历所有的path，然后再清洗比较。其实直接递归即可。 123456789101112131415def lcaDeepestLeaves(self, root: TreeNode) -&gt; TreeNode: def helper(root): if not root: return 0, None d1, n1 = helper(root.left) d2, n2 = helper(root.right) if d1 &lt; d2: return d2 + 1, n2 elif d1 &gt; d2: return d1 + 1, n1 else: return d1 + 1, root return helper(root)[1] 1382. Balance a Binary Search Tree将一个二叉搜索树转为平衡二叉搜索树。原题方法一：想到二叉搜索树首先想到中序遍历，所以一共分为2步，一步是遍历出所有节点，再根据节点重建一个平衡的二叉搜索树。 12345678910111213141516171819202122class Solution: def balanceBST(self, root: TreeNode) -&gt; TreeNode: def dfs(node): if node: yield from dfs(node.left) yield node.val yield from dfs(node.right) inorder = list(dfs(root)) def build(inorder): if not inorder: return None n = len(inorder) index = n // 2 root = TreeNode(inorder[index]) root.left = build(inorder[:index]) root.right = build(inorder[index+1:]) return root return build(inorder) 1372. Longest ZigZag Path in a Binary Tree二叉树中最长的z字形路径。原题方法一：用了不少变量来控制走位。 1234567891011121314151617def longestZigZag(self, root: TreeNode) -&gt; int: self.ans = 0 def dfs(node, left, right, last_left=True): if node: self.ans = max(self.ans, left, right) # if last_left: # dfs(node.right, 0, left+1, False) # dfs(node.left, 1, 0, True) # else: # dfs(node.right, 0, 1, False) # dfs(node.left, right+1, 0, True) dfs(node.right, 0, last_left*left+1, False) dfs(node.left, (1-last_left)*right+1, 0, True) dfs(root, 0, 0) return self.ans 方法二：-1的妙用。 12345678def longestZigZag(self, root: TreeNode) -&gt; int: def dfs(node): if not node: return (-1, -1, -1) left, right = dfs(node.left), dfs(node.right) return (left[1]+1, right[0]+1, max(left[1]+1, right[0]+1, left[-1], right[-1])) return dfs(root)[-1] 1367. Linked List in Binary Tree判断一个链表是否在二叉树的路径中。原题方法一：递归。 12345678910def isSubPath(self, head: ListNode, root: TreeNode) -&gt; bool: def dfs(head, root): if not head: return True if not root: return False return head.val==root.val and (dfs(head.next, root.left) or dfs(head.next, root.right)) if not head: return True if not root: return False return dfs(head, root) or self.isSubPath(head, root.left) or self.isSubPath(head, root.right) 124. Binary Tree Maximum Path Sum二叉树的最大路径和，可以不经过根节点。原题123456789Input: [-10,9,20,null,null,15,7] -10 / \ 9 20 / \ 15 7Output: 42 方法一：递归。开始有一点没想明白，对于任意节点来说，都有左右两条path, 包括根节点。 1234567891011121314def maxPathSum(self, root: TreeNode) -&gt; int: self.ans = float('-inf') def maxend(node): if not node: return 0 left = maxend(node.left) right = maxend(node.right) self.ans = max(self.ans, left+right+node.val) return max(node.val + max(left, right), 0) maxend(root) return self.ans 1443. Minimum Time to Collect All Apples in a Tree收集苹果的最小路径。原题123Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]Output: 8 Explanation: The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows. 方法一：每个苹果的路径都是节点到根的两倍距离。 123456789101112131415def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -&gt; int: t = collections.defaultdict(int) for a, b in edges: t[b] = a used = set() @functools.lru_cache def dfs(node): if node == 0: return 0 used.add((node, t[node])) return dfs(t[node]) + 1 list(map(dfs, (i for i, f in enumerate(hasApple) if f))) return len(used) * 2 1339. Maximum Product of Splitted Binary Tree将一个树砍成两颗树，使两个节点和乘积最大。原题方法一：需要遍历2次，一次求出所有节点和。 123456789101112def maxProduct(self, root: TreeNode) -&gt; int: self.ans = total = 0 def s(node): if not node: return 0 left, right = s(node.left), s(node.right) self.ans = max(self.ans, (total-left)*left, right*(total-right)) return left+right+node.val total = s(root) s(root) return self.ans % (10**9+7) 1315. Sum of Nodes with Even-Valued Grandparent祖父节点为偶数的节点和。原题1234def sumEvenGrandparent(self, root: TreeNode, p=1, gp=1) -&gt; int: return self.sumEvenGrandparent(root.left, root.val, p) + \ self.sumEvenGrandparent(root.right, root.val, p) + \ root.val * (gp&amp;1==0) if root else 0 1457. Pseudo-Palindromic Paths in a Binary Tree伪回文路径的个数。指排列能够成为回文的路径。原题123Input: root = [2,3,1,3,1,null,1]Output: 2 Explanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the red path [2,3,3], the green path [2,1,1], and the path [2,3,1]. Among these paths only red path and green path are pseudo-palindromic paths since the red path [2,3,3] can be rearranged in [3,2,3] (palindrome) and the green path [2,1,1] can be rearranged in [1,2,1] (palindrome). 方法一：竞赛时的答案。 1234567891011121314151617def pseudoPalindromicPaths (self, root: TreeNode) -&gt; int: c = collections.defaultdict(int) self.count = 0 def dfs(node, odd=True): if node: c[node.val] ^= 1 if not node.left and not node.right: single = sum(v for v in c.values() if v==1) self.count += (single==int(odd)) dfs(node.left, not odd) dfs(node.right, not odd) c[node.val] ^= 1 dfs(root) return self.count 方法二：因为node的值时1~9，所以这里用一个计位器count 123456789101112def pseudoPalindromicPaths (self, root: TreeNode) -&gt; int: def dfs(node, count=0): if not node: return 0 count ^= 1 &lt;&lt; (node.val-1) ans = dfs(node.left, count) + dfs(node.right, count) if node.left == node.right: if count &amp; (count-1) == 0: ans += 1 return ans return dfs(root) 129. Sum Root to Leaf Numbers根到叶子节点组成的数字和。原题123456789Input: [1,2,3] 1 / \ 2 3Output: 25Explanation:The root-to-leaf path 1-&gt;2 represents the number 12.The root-to-leaf path 1-&gt;3 represents the number 13.Therefore, sum = 12 + 13 = 25. 方法一：dfs 写法上迟疑了一下，还是要判断是否为根节点的，避免和累加了2次。 1234567891011121314def sumNumbers(self, root: TreeNode) -&gt; int: self.ans = 0 def dfs(node, cur): if not node: return cur += node.val if not node.left and not node.right: self.ans += cur dfs(node.left, cur*10) dfs(node.right, cur*10) dfs(root, 0) return self.ans 114. Flatten Binary Tree to Linked List将一个二叉树变成一个链表，要求在原节点上操作。原题1234567891011121314151617 1 / \ 2 5 / \ \3 4 61 \ 2 \ 3 \ 4 \ 5 \ 6 方法一：变成左子树操作直观一点，所以先将它变成左子树，然后再镜像。 1234567891011121314151617181920212223def flatten(self, root: TreeNode) -&gt; None: def dfs(node, p=[], par=None): p.append(node) if len(p) &gt; 1: p[-2].left = p[-1] if par: par.right = None if node.left: dfs(node.left, p) if node.right: dfs(node.right, p, node) def sym(node): if node: node.left, node.right = node.right, node.left sym(node.left) sym(node.right) if not root: return dfs(root) sym(root) 方法二：先把俩节点左右互换。 1234567891011121314151617def flatten(self, root: TreeNode) -&gt; None: def dfs(node, p=[], par=None): node.left, node.right = node.right, node.left p.append(node) if len(p) &gt; 1: p[-2].right = p[-1] if par: par.left = None if node.right: dfs(node.right, p) if node.left: dfs(node.left, p, node if not root: return dfs(root) 123456789101112131415161718192021222324252627282930def countPairs(self, root: TreeNode, distance: int) -&gt; int: paths = [] def dfs(node, p): if node: p.append(node) if not node.left and not node.right: paths.append(list(p)) dfs(node.left, p) dfs(node.right, p) p.pop() dfs(root, []) ans = 0 n = len(paths) for i in range(n): for j in range(i+1, n): p1 = list(paths[i]) p2 = list(paths[j]) k = distance + 1 while k: if p1[-1] == p2[-1]: ans += 1 break if len(p1) &gt;= len(p2): p1.pop() else: p2.pop() k -= 1 return ans 方法二：后序遍历 12345678910111213141516def countPairs(self, root: TreeNode, distance: int) -&gt; int: count = 0 def dfs(node): nonlocal count if not node: return [] if not node.left and not node.right: return [1] left = dfs(node.left) right = dfs(node.right) count += sum(l+r&lt;=distance for l in left for r in right) return [k+1 for k in left+right if k+1&lt;distance] dfs(root) return count 450. Delete Node in a BST删除二叉搜索树的一个节点。原题方法一：递归，好久没做二叉树有点生疏，想了半天。 123456789101112131415161718def deleteNode(self, root: TreeNode, key: int) -&gt; TreeNode: if not root: return if root.val &gt; key: root.left = self.deleteNode(root.left, key) elif root.val &lt; key: root.right = self.deleteNode(root.right, key) else: if not root.right: return root.left elif not root.left: return root.right else: cur = root.right while cur.left: cur = cur.left cur.left = root.left return root.right return root 971. Flip Binary Tree To Match Preorder Traversal给你一个二叉树和一个前序遍历，判断二叉树否通过互换左右子树来达到前序遍历的顺序，返回这样的节点编号，没有则返回-1。原题12Input: root = [1,2], voyage = [2,1]Output: [-1] 方法一：递归。第一次ac的方法。 123456789101112131415161718192021def flipMatchVoyage(self, root: TreeNode, v: List[int]) -&gt; List[int]: ans = [] v = v[::-1] def flip(node): val = node.val if node else None if val != v[-1]: nonlocal ans ans = [-1] return v.pop() if not v: return if node.left and node.left.val != v[-1]: node.left, node.right = node.right, node.left ans.append(node.val) if node.left: flip(node.left) if node.right: flip(node.right) flip(root) return ans 方法二：lee的写法。思路是一样的。 1234567891011121314def flipMatchVoyage(self, root: TreeNode, v: List[int]) -&gt; List[int]: ans = [] v = v[::-1] def dfs(node): if not node: return True if node.val != v[-1]: return False v.pop() if node.left and node.left.val != v[-1]: node.left, node.right = node.right, node.left ans.append(node.val) return dfs(node.left) and dfs(node.right) return ans if dfs(root) else [-1] 951. Flip Equivalent Binary Trees和971差不多，比较的是两棵树。原题方法一：第一次提交时少考虑了一个case就是左右节点都相同。这种情况下可翻转也可不翻转。然后想or的关系，担心会超时。好在树的节点并没有很多。而且用时也不高beats了90%。 12345678910111213141516171819def flipEquiv(self, root1: TreeNode, root2: TreeNode) -&gt; bool: if not root1 or not root2: return root1 is root2 if root1.val != root2.val: return False left_1 = root1.left.val if root1.left else None left_2 = root2.left.val if root2.left else None ans = False if left_1 != left_2: root1.left, root1.right = root1.right, root1.left else: right_1 = root1.right.val if root1.right else None right_2 = root2.right.val if root2.right else None if left_1 == right_1 == right_2: ans |= (self.flipEquiv(root1.left, root2.right) and self.flipEquiv(root1.right, root2.left)) ans |= (self.flipEquiv(root1.left, root2.left) and self.flipEquiv(root1.right, root2.right)) return ans 方法二：理论上来说是方法一快，但是可以忽略不计。 12345678def flipEquiv(self, root1: TreeNode, root2: TreeNode) -&gt; bool: if not root1 or not root2: return root1 is root2 return (root1.val == root2.val and (self.flipEquiv(root1.left, root2.right) and self.flipEquiv(root1.right, root2.left)) | (self.flipEquiv(root1.left, root2.left) and self.flipEquiv(root1.right, root2.right))) 863. All Nodes Distance K in Binary Tree找出树中距离目标节点为K的节点值。原题1234567Input: root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2Output: [7,4,1]Explanation: The nodes that are a distance 2 from the target node (with value 5)have values 7, 4, and 1. 方法一：这个方法想了一下，没敢往下细想。先把他变成那种无向图。然后bfs。 12345678910111213141516171819202122def distanceK(self, root: TreeNode, target: TreeNode, K: int) -&gt; List[int]: g = collections.defaultdict(list) def connect(parent, child): if parent and child: g[parent.val].append(child.val) g[child.val].append(parent.val) if child.left: connect(child, child.left) if child.right: connect(child, child.right) connect(None, root) bfs = [target.val] seen = set(bfs) for _ in range(K): new_level = [] for q_val in bfs: for j in g[q_val]: if j not in seen: new_level.append(j) bfs = new_level seen |= set(bfs) return bfs 865. Smallest Subtree with all the Deepest Nodes带有最深节点的最小子树。也就是求最底层叶子节点的最小公共祖先。原题方法一：用最小公共祖先的求法可以得到。 12345678910111213141516def subtreeWithAllDeepest(self, root: TreeNode) -&gt; TreeNode: paths = [] def dfs(n, p): if n: p.append(n) if not n.left and not n.right: paths.append(list(p)) dfs(n.left, p) dfs(n.right, p) p.pop() dfs(root, []) max_len = max(len(p) for p in paths) paths = [p for p in paths if len(p)==max_len] return next(nodes[0] for nodes in list(zip(*paths))[::-1] if len(set(nodes))==1) 方法二：Lee215的方法。如果对于一个子树节点来说，左边深度&gt;右边则说明我们要找的点在左侧。反之亦然。如果相等，则该节点就是我们要找的节点。返回一个tuple一层层将要找的点递归上去。 12345678def subtreeWithAllDeepest(self, root: TreeNode) -&gt; TreeNode: def deep(root): if not root: return 0, None l, r = deep(root.left), deep(root.right) if l[0] &gt; r[0]: return l[0] + 1, l[1] elif l[0] &lt; r[0]: return r[0] + 1, r[1] else: return l[0] + 1, root return deep(root)[1] 1373. Maximum Sum BST in Binary Tree找到二叉树中，最大的一个二叉搜索子树所有节点的和。原题方法一：虽然是个hard题，但是思路很清晰。一个dfs返回时记录这个子树中的最小值，最大值，总和。首次ac的方法。 123456789101112131415161718192021222324def maxSumBST(self, root: TreeNode) -&gt; int: self.ans = 0 def helper(node): if not node.left and not node.right: self.ans = max(self.ans, node.val) return node.val, node.val, node.val if node.left: small_left, big_left, total_left = helper(node.left) else: small_left, big_left, total_left = float('inf'), float('-inf'), 0 if node.right: small_right, big_right, total_right = helper(node.right) else: small_right, big_right, total_right = float('inf'), float('-inf'), 0 if node.val &gt; big_left and node.val &lt; small_right: total = total_left + total_right + node.val small = min(small_left, small_right, node.val) big = max(big_left, big_right, node.val) else: small, big, total = float('-inf'), float('inf'), 0 self.ans = max(self.ans, total) return small, big, total 方法二：方法一多了很多多余的比较。 123456789101112131415def maxSumBST(self, root: TreeNode) -&gt; int: self.ans = 0 def helper(node): if not node: return float('inf'), float('-inf'), 0 small_left, big_left, total_left = helper(node.left) small_right, big_right, total_right = helper(node.right) if big_left &lt; node.val &lt; small_right: self.ans = max(self.ans, total_left+total_right+node.val) return min(small_left, node.val), max(big_right, node.val), total_left+total_right+node.val return float('-inf'), float('inf'), 0 helper(root) return self.ans 501. Find Mode in Binary Search Tree找到二叉搜索树中的众数，可能有多个值。这个树左子树节点是《=当前节点。方法一：中序遍历改的。将所有节点值按序输出就好找了。 12345678910111213141516171819202122def findMode(self, root): def inorder(node): if node: yield from inorder(node.left) yield node.val yield from inorder(node.right) prev, ans = None, [] cnt = max_cnt = 0 for d in inorder(root): if prev == d: cnt += 1 else: cnt = 1 if cnt &gt; max_cnt: ans = [d] elif cnt == max_cnt: ans.append(d) max_cnt = max(max_cnt, cnt) prev = d return ans 968. Binary Tree Cameras要对一颗二叉树进行监控，一个摄像头可以监控父节点，自身以及子节点。问最少需要多少个摄像头能监控所有节点。方法一：这题看了题解，实际上有个贪心的解法，通过状态来表示节点是否需要监控。通过后序遍历，子节点的装填判断附近点状态。有时候看到标签上是dp，就被标签上的解法限制住了。 12345678910111213141516171819def minCameraCover(self, root: TreeNode) -&gt; int: # 0：未被监控；1：已监控，2：摄像头 self.ans = 0 def dfs(node): if not node: return 1 left = dfs(node.left) right = dfs(node.right) if left==0 or right==0: self.ans += 1 return 2 if left==1 and right==1: return 0 return 1 if dfs(root) == 0: self.ans += 1 return self.ans]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（动态规划篇）Danymic Programming]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AF%87%EF%BC%89Danymic-Programming%2F</url>
    <content type="text"><![CDATA[70. Climbing Stairs爬楼梯，一次可以爬一阶或两阶楼梯，爬上n阶楼梯有多少种方法？原题 斐波那契问题 12345def fibonacci(n): a = b = 1 for _ in range(n-1): a, b = b, a+b return b 746. Min Cost Climbing Stairs楼梯上每层写了到达该层的卡路里，求上到顶层消耗的最小卡路里。原题1234567Input: cost = [10, 15, 20]Output: 15Explanation: Cheapest is start on cost[1], pay that cost and go to the top.Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]Output: 6Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3]. 方法一：the final cost f[i] to climb the staircase from some step iis f[i] = cost[i] + min(f[i+1], f[i+2])。到达一层有两种选择，一种是上一层，一种是上两层。 12345def minCostClimbingStairs(self, cost: List[int]) -&gt; int: f1 = f2 = 0 for x in reversed(cost): f1, f2 = min(f1, f2) + x, f1 return min(f1, f2) 121. Best Time to Buy and Sell Stock买入卖出最大收益。原题1234Input: [7,1,5,3,6,4]Output: 5Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price. 方法一：Brute Force.其实就是求最高峰点和前面最低谷点的差。 12345678def maxProfit(self, prices: List[int]) -&gt; int: ans, min_buy = 0, float('inf') for price in prices: if price &lt; min_buy: min_buy = price elif price-min_buy &gt; ans: ans = price - min_buy return ans 方法二：标准的卡登算法。此题为53.连续数组最大和的变形，如果价格比之前小，则舍弃，否则一起计算连续子数组的和。 1234567def maxProfit(self, prices: List[int]) -&gt; int: cur = sofar = 0 for i in range(1, len(prices)): cur += prices[i] - prices[i-1] cur = max(0, cur) sofar = max(cur, sofar) return sofar 122. Best Time to Buy and Sell Stock II买入卖出，允许多次交易。原题1234Input: [7,1,5,3,6,4]Output: 7Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3. 思路：比较每两天的价格，如果是涨价了，那就把收益计算进去，否则不出手交易。 123456def max_profit(prices): profit = 0 for i in range(1, len(prices)): if prices[i] &gt; prices[i-1]: profit += prices[i] - prices[i-1] return profit 方法二：pairwise. 12345678def maxProfit(self, prices: List[int]) -&gt; int: t, y = itertools.tee(prices) next(t, None) profit = 0 for p1, p2 in zip(t, y): if p1 &gt; p2: profit += p1-p2 return profit Best Time to Buy and Sell Stock III最多允许交易两次。原题先从左到右按照一次交易计算每天的利润。然后按照从右到左，判断如果进行第二次交易，最大的利润。 1234567891011121314151617def maxProfit(self, prices: List[int]) -&gt; int: min_buy = float('inf') profits = [] max_profit = 0 for p in prices: min_buy = min(min_buy, p) max_profit = max(max_profit, p-min_buy) profits.append(max_profit) max_profit = 0 total_profit = 0 max_sell = float('-inf') for i in range(len(prices)-1, -1, -1): max_sell = max(max_sell, prices[i]) max_profit = max(max_profit, max_sell-prices[i]) total_profit = max(total_profit, max_profit+profits[i]) return total_profit 309. Best Time to Buy and Sell Stock with Cooldown每次买卖股票后有一天的冷却期什么也不能干。原题方法一：3个状态，5中状态转换。 12345678910def maxProfit(self, prices: List[int]) -&gt; int: # hold -&gt; do_nothing -&gt; hold # hold -&gt; sell -&gt; not_hold_cd # not_hold -&gt; do_nothing -&gt; not_hold # not_hold -&gt; buy -&gt; hold # not_hold_cd -&gt; do_nothing -&gt; not_hold not_hold, hold, not_hold_cd = 0, float('-inf'), float('-inf') for price in prices: hold, not_hold, not_hold_cd = max(hold, not_hold-price), max(not_hold, not_hold_cd), hold+price return max(not_hold, not_hold_cd) LCP 19. 秋叶收藏集杯赛里的题，说将字符串替换成r*y*r*的形式，最少需要多少步。原题方法一：和309非常相似，记录3种状态。 123456789def minimumOperations(self, leaves: str) -&gt; int: # r 代表当前位置是 r* 型的替换次数 # ry 代表当前位置是 r*y* 型的替换次数 # ryr 分别代表当前位置是 r*y*r* 型的替换次数 r, ry, ryr = int(leaves[0] == 'y'), float('inf'), float('inf') for i in range(1, len(leaves)): x = int(leaves[i] == 'y') r, ry, ryr = r+x, min(r, ry)+(1-x), min(ry, ryr)+x return ryr 198. House Robber抢劫房子问题。不能连续抢劫两个挨着的房间。原题1234Input: [2,7,9,3,1]Output: 12Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12. 123f(0) = nums[0]f(1) = max(num[0], num[1])f(k) = max( f(k-2) + nums[k], f(k-1) ) 方法一：递归，超时。 1234567def rob(self, nums): if not nums: return 0 if len(nums) &lt;= 1: return nums[0] return max(nums[0]+self.rob(nums[2:]), self.rob(nums[1:])) 方法二： 12345def rob(self, nums): last, now = 0, 0 for num in nums: last, now = now, max(last+num, now) return now 213. House Robber II与上题不同的是，所有的房子连成一个环。原题1234nput: [2,3,2]Output: 3Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses. 方法一：注意nums长度为1的情况。 12345678def rob(self, nums: List[int]) -&gt; int: def robber(nums): last = now = 0 for num in nums: last, now = now, max(last+num, now) return now return max(robber(nums[:-1]), robber(nums[len(nums)!=1:])) 303. Range Sum Query - Immutable给定一个数组，计算索引i, j之间的和。原题12345Given nums = [-2, 0, 3, -5, 2, -1]sumRange(0, 2) -&gt; 1sumRange(2, 5) -&gt; -1sumRange(0, 5) -&gt; -3 思路：如果单纯采用切片计算，效率过低，题中要求sumRange调用多次。所以这里采用动态规划。 12345678910111213class NumArray: def __init__(self, nums): # self.sum_item = [0] # for num in nums: # self.sum_item.append(self.sum_item[-1] + num) from itertools import accumulate from operator import add self.sum_item = list(accumulate(nums, add)) def sumRange(self, i, j): # return self.sum_item[j+1] - self.sum_item[i] return self.sum_item[j] - self.sum_item[i-1] if i &gt; 0 else self.sum_item[j] 91. Decode Ways将数字翻译成字母有多少种方式。原题123Input: &quot;226&quot;Output: 3Explanation: It could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6). 123456789def numDecodings(self, s: str) -&gt; int: # w tells the number of ways # v tells the previous number of ways # d is the current digit # p is the previous digit v, w, p = 0, int(s&gt;''), '' for d in s: v, w, p = w, int(d&gt;'0')*w + (9&lt;int(p+d)&lt;27)*v, d return w 62. Unique Paths一个矩阵中，从左上走到右下有多少种不同走法，每次只能向右或向下移动。原题 方法一：构建二维矩阵。 12345678910def uniquePaths(self, m: int, n: int) -&gt; int: g = [[0] * m for _ in range(n)] for i in range(n): for j in range(m): if i==0 or j==0: g[i][j] = 1 else: g[i][j] = g[i-1][j] + g[i][j-1] return g[-1][-1] 方法二：二维数组时没有必要的，仔细观察发现每层都是累计的关系，accumulate为此而生。 123[1, 1, 1, 1, 1, 1, 1][1, 2, 3, 4, 5, 6, 7][1, 3, 6, 10, 15, 21, 28] 12345def uniquePaths(self, m: int, n: int) -&gt; int: row = [1] * m for _ in range(n-1): row = itertools.accumulate(row) return list(row)[-1] 63. Unique Paths II和62一样，不同的是中间加了障碍1。原题1234567Input:[ [0,0,0], [0,1,0], [0,0,0]]Output: 2 方法一：首次AC的方法，这里采用先遍历一次记录障碍，然后初始化首行和首列，最后再求解的过程。 123456789101112131415161718192021222324252627282930def uniquePathsWithObstacles(self, g: List[List[int]]) -&gt; int: R, C = len(g), len(g[0]) for i in range(R): for j in range(C): if g[i][j] == 1: g[i][j] = -1 for i in range(R): if g[i][0] != -1: g[i][0] = 1 else: break for j in range(C): if g[0][j] != -1: g[0][j] = 1 else: break for i in range(1, R): for j in range(1, C): if g[i][j] == -1: continue else: up = g[i-1][j] if g[i-1][j]!=-1 else 0 left = g[i][j-1] if g[i][j-1]!=-1 else 0 g[i][j] = up + left # print(g) return g[-1][-1] if g[-1][-1] != -1 else 0 方法二：想错了一件事情，我根本不需要去单独的设置障碍值，在遍历的时候就可以根据0来判断。 123456789101112131415161718def uniquePathsWithObstacles(self, g: List[List[int]]) -&gt; int: R, C = len(g), len(g[0]) if g[0][0] == 1: return 0 g[0][0] = 1 for i in range(1, C): g[0][i] = int(g[0][i-1]==1 and g[0][i]==0) for j in range(1, R): g[j][0] = int(g[j-1][0]==1 and g[j][0]==0) for i in range(1, R): for j in range(1, C): if g[i][j] == 0: g[i][j] = g[i-1][j] + g[i][j-1] else: g[i][j] = 0 return g[-1][-1] 120. Triangle三角形从上到下最小路径。原题1234567[ [2], [3,4], [6,5,7], [4,1,8,3]]i.e., 2 + 3 + 5 + 1 = 11 方法一：我这里使用了一个嵌套的字典保存每一行的累计最小值。 12345678910def minimumTotal(self, t: List[List[int]]) -&gt; int: if not t: return 0 from collections import defaultdict dp = defaultdict(lambda: defaultdict(lambda: float('inf'))) dp[0][0] = t[0][0] for i, row in enumerate(t[1:], 1): for j, num in enumerate(row): dp[i][j] = min(dp[i-1][j-1], dp[i-1][j]) + t[i][j] return min(dp[len(t)-1].values()) 方法二：在原数组上修改，空间复杂度O(1). 1234567891011121314def minimumTotal(self, t: List[List[int]]) -&gt; int: if not t: return 0 for i, row in enumerate(t[1:], 1): for j, num in enumerate(row): # if j == 0: # t[i][j] = t[i-1][j] + t[i][j] # elif j == len(row)-1: # t[i][j] = t[i-1][j-1] + t[i][j] # else: # t[i][j] = min(t[i-1][j-1], t[i-1][j]) + t[i][j] path = slice(max(0, j-1), min(len(t[i-1]), j+1)) t[i][j] += min(t[i-1][path]) return min(t[-1]) 方法三：错位相加大法。 1234567def minimumTotal(self, triangle: List[List[int]]) -&gt; int: from functools import reduce def combine_rows(lower_row, upper_row): return [upper + min(lower_left, lower_right) for upper, lower_left, lower_right in zip(upper_row, lower_row, lower_row[1:])] return reduce(combine_rows, triangle[::-1])[0] 931. Minimum Falling Path Sum和120相似，不过形状变成了矩形。原题1234Input: [[1,2,3],[4,5,6],[7,8,9]]Output: 12Explanation: The possible falling paths are: 方法一：常规写法。 1234567def minFallingPathSum(self, A: List[List[int]]) -&gt; int: R, C = len(A), len(A[0]) for i in range(R-2, -1, -1): for j in range(C): path = slice(max(0, j-1), min(C, j+2)) A[i][j] += min(A[i+1][path]) return min(A[0]) 方法二：错位计算的方式，这个比120三角形的要复杂一点。需要填充无穷大来使生效。 12345678def minFallingPathSum(self, A: List[List[int]]) -&gt; int: from functools import reduce padding = [float('inf')] def combine_rows(lower_row, upper_row): return [upper + min(lower_left, lower_mid, lower_right) for upper, lower_left, lower_mid, lower_right in zip(upper_row, lower_row[1:]+padding, lower_row, padding+lower_row[:-1])] return min(reduce(combine_rows, A[::-1])) 1289. Minimum Falling Path Sum II上题变形，每行找到非自己那列的元素。原题方法一：用堆记录2个最小的值。 1234567def minFallingPathSum(self, arr: List[List[int]]) -&gt; int: m, n = len(arr), len(arr[0]) for i in range(1, m): r = heapq.nsmallest(2, arr[i-1]) for j in range(n): arr[i][j] += r[1] if arr[i-1][j]==r[0] else r[0] return min(arr[-1]) 279. Perfect Squares完美平方，找出n的最少的能被几个平方数相加。原题123Input: n = 13Output: 2Explanation: 13 = 4 + 9. f(n)表示n最少的个数。f(n)=min(f(n-1²), f(n-2²)...f(0)) + 1 12345678class Solution: _dp = [0] def numSquares(self, n: int) -&gt; int: dp = self._dp while len(dp) &lt;= n: # dp.append(min(dp[len(dp)-i*i] for i in range(1, int(len(dp)**0.5+1))) + 1) dp.append(min(dp[-i*i] for i in range(1, int(len(dp)**0.5+1))) + 1) return dp[n] 5. Longest Palindromic Substring最长回文子字符串。原题123Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer. 方法一：O(n²)的方法。非常低效的一个做法。 123456789101112131415161718def longestPalindrome(self, s: str) -&gt; str: def helper(i, j): while i &gt;=0 and j &lt; len(s) and s[i]==s[j]: i -= 1 j += 1 return s[i+1:j] # 因为i, j是不相等的。 # ans = '' # for i, c in enumerate(s): # tmp = helper(i, i) # if len(tmp) &gt; len(ans): # ans = tmp # tmp = helper(i, i+1) # if len(tmp) &gt; len(ans): # ans = tmp # return ans return s and max((a for i in range(len(s)) for a in (helper(i, i), helper(i, i+1))), key=len) or '' 方法二：这个方法很好。从前到后遍历字符，一种是奇数长度的回文串，是增加两个长度，另一种是偶数长度的回文串，是增加一个长度。每次从当前字符向前做切片，并根据当前的最大长度控制切片长度。 12345678910111213141516def longestPalindrome(self, s: str) -&gt; str: if not s: return '' maxLen = 1 start = 0 for i in range(len(s)): if i-maxLen&gt;=1 and s[i-maxLen-1:i+1]==s[i-maxLen-1:i+1][::-1]: start = i - maxLen - 1 maxLen += 2 continue if i-maxLen&gt;=0 and s[i-maxLen:i+1]==s[i-maxLen:i+1][::-1]: # print(s[i-maxLen:i+1], s[i-maxLen:i+1][::-1]) start = i - maxLen maxLen += 1 return s[start:start+maxLen] 方法三：马拉车算法。Time: O(n). 算法详解。这里是把一些情况做了整合。整个代码非常优雅。 12345678910111213141516171819202122def longestPalindrome(self, s: str) -&gt; str: # Transform S into T. # For example, S = "abba", T = "^#a#b#b#a#$". # ^ and $ signs are sentinels appended to each end to avoid bounds checking T = '#'.join('^&#123;&#125;$'.format(s)) n = len(T) P = [0] * n C = R = 0 for i in range (1, n-1): P[i] = (R &gt; i) and min(R - i, P[2*C - i]) # equals to i' = C - (i-C) # Attempt to expand palindrome centered at i while T[i + 1 + P[i]] == T[i - 1 - P[i]]: P[i] += 1 # If palindrome centered at i expand past R, # adjust center based on expanded palindrome. if i + P[i] &gt; R: C, R = i, i + P[i] # Find the maximum element in P. maxLen, centerIndex = max((n, i) for i, n in enumerate(P)) return s[(centerIndex - maxLen)//2: (centerIndex + maxLen)//2] 1024. Video Stitching影片剪辑，给定n组影片段，求能够拼出0~T完整影片所使用的最小段数。原题1234567Input: clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10Output: 3Explanation: We take the clips [0,2], [8,10], [1,9]; a total of 3 clips.Then, we can reconstruct the sporting event as follows:We cut [1,9] into segments [1,2] + [2,8] + [8,9].Now we have segments [0,2] + [2,8] + [8,10] which cover the sporting event [0, 10]. 方法一：此题竞赛时没有完成，想了字典的方法，老是纠结于怎么消除题中的[1, 5]段，其实根本没必要，迭代的时候维护两个变量，一个是已经能组成的最大时长，另一个是当前可以延长到的最大时长。看了Lee神的答案。 12345678910def videoStitching(self, clips: List[List[int]], T: int) -&gt; int: end, end2, cnt = -1, 0, 0 # end 表示上一段最后截止点，end2表示当前可以最大延伸的最远地点。 for s, e in sorted(clips): if end2 &gt;= T or s &gt; end2: # 完成或者接不上了 break elif end &lt; s &lt;= end2: # 续1s cnt += 1 end = end2 end2 = max(end2, e) return cnt if end2 &gt;= T else -1 1048. Longest String Chain每个字符添加任意一个字符，可以组成一个字符串链。原题12345678910111213def longestStrChain(self, words: List[str]) -&gt; int: words2 = &#123;i:set() for i in range(1, 17)&#125; for word in words: words2[len(word)].add(word) dp = collections.defaultdict(lambda : 1) for k in range(2, 17): for w in words2[k]: for i in range(k): prev = w[:i] + w[i+1:] if prev in words2[k-1]: # dp[w] = max(dp[w], dp[prev]+1) dp[w] = dp[prev] + 1 return max(dp.values() or [1]) 1143. Longest Common Subsequence最长公共子串的长度。原题123Input: text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; Output: 3 Explanation: The longest common subsequence is &quot;ace&quot; and its length is 3. 方法一：递归 1234567891011import functoolsclass Solution: def longestCommonSubsequence(self, text1: str, text2: str) -&gt; int: @functools.lru_cache(None) def helper(i,j): if i&lt;0 or j&lt;0: return 0 if text1[i]==text2[j]: return helper(i-1,j-1)+1 return max(helper(i-1,j),helper(i,j-1)) return helper(len(text1)-1,len(text2)-1) 方法二：迭代。dp(i,j) means the longest common subsequence of text1[:i] and text2[:j]. 12345678910def longestCommonSubsequence(self, text1: str, text2: str) -&gt; int: n1, n2 = len(text1), len(text2) dp = [[0]*(n2+1) for i in range(n1+1)] for i in range(n1): for j in range(n2): if text1[i] == text2[j]: dp[i+1][j+1] = dp[i][j] + 1 else: dp[i+1][j+1] = max(dp[i][j+1], dp[i+1][j]) return dp[-1][-1] 583. Delete Operation for Two Strings最少删除多少次可以让两个字符串相等。原题123Input: &quot;sea&quot;, &quot;eat&quot;Output: 2Explanation: You need one step to make &quot;sea&quot; to &quot;ea&quot; and another step to make &quot;eat&quot; to &quot;ea&quot;. 方法一：dp。这题一上来就发现和1143. Longest Common Subsequence一样。 1234567def minDistance(self, word1: str, word2: str) -&gt; int: n1, n2 = len(word1), len(word2) dp = [[0]*(n2+1) for _ in range(n1+1)] for i in range(n1): for j in range(n2): dp[i+1][j+1] = max(dp[i][j+1], dp[i+1][j], dp[i][j]+(word1[i]==word2[j])) return n1+n2-dp[-1][-1]*2 712. Minimum ASCII Delete Sum for Two Strings删除最小的ascii码的字符，使剩下的两个字符串相等。方法一：同583. 12345678910def minimumDeleteSum(self, s1: str, s2: str) -&gt; int: n1, n2 = len(s1), len(s2) dp = [[0] * (n2+1) for _ in range(n1+1)] for i in range(n1): for j in range(n2): if s1[i]==s2[j]: dp[i+1][j+1] = dp[i][j] + ord(s1[i]) else: dp[i+1][j+1] = max(dp[i+1][j], dp[i][j+1]) return sum(map(ord, s1+s2)) - dp[-1][-1]*2 1312. Minimum Insertion Steps to Make a String Palindrome将一个字符串变为回文串，最小插入字母步数。原题123456Input: s = &quot;zzazz&quot;Output: 0Explanation: The string &quot;zzazz&quot; is already palindrome we don&apos;t need any insertions.Input: s = &quot;leetcode&quot;Output: 5Explanation: Inserting 5 characters the string becomes &quot;leetcodocteel&quot;. 方法一：和1134，Longest Common Subsequence一样，当这个字符串和他倒序的公共子串越多，需要添加的字母就越少。 1234567def minInsertions(self, s: str) -&gt; int: n = len(s) dp = [[0] * (n+1) for _ in range(n+1)] for i in range(n): for j in range(n): dp[i+1][j+1] = dp[i][j] + 1 if s[i] == s[~j] else max(dp[i+1][j], dp[i][j+1]) return n - dp[n][n] 221. Maximal Square最大的正方形岛屿面积。原题12345678Input: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0Output: 4 方法一：此题看似和最大岛屿面积相似，但解法完全不同。 123456789101112def maximalSquare(self, matrix: List[List[str]]) -&gt; int: if not matrix: return 0 m, n = len(matrix), len(matrix[0]) dp = [[0] * (n+1) for _ in range(m+1)] max_side = 0 for i in range(m): for j in range(n): if matrix[i][j] == '1': dp[i+1][j+1] = min(dp[i][j], dp[i+1][j], dp[i][j+1]) + 1 max_side = max(max_side, dp[i+1][j+1]) return max_side**2 1340. Jump Game V跳跃游戏，可以向左右d范围内矮的地方跳下。原题12345Input: arr = [6,4,14,6,8,13,9,7,10,6,12], d = 2Output: 4Explanation: You can start at index 10. You can jump 10 --&gt; 8 --&gt; 6 --&gt; 7 as shown.Note that if you start at index 6 you can only jump to index 7. You cannot jump to index 5 because 13 &gt; 9. You cannot jump to index 4 because index 5 is between index 4 and 6 and 13 &gt; 9.Similarly You cannot jump from index 3 to index 2 or index 1. 123456789101112def maxJumps(self, arr: List[int], d: int) -&gt; int: n = len(arr) ans = [0] * n def jump(i): if ans[i]: return ans[i] ans[i] = 1 for di in (-1, 1): for j in range(i+di, i+d*di+di, di): if not (0&lt;=j&lt;n and arr[j]&lt;arr[i]): break ans[i] = max(ans[i], jump(j)+1) return ans[i] 1301. Number of Paths with Max Score左上到右下，最大值，路径中存在障碍，并且需要返回路径的个数。原题12Input: board = [&quot;E23&quot;,&quot;2X2&quot;,&quot;12S&quot;]Output: [7,1] 方法一：初次AC的方法。此题与剑指offer中礼物的最大值有点像，多了一个障碍，多了一种走法，多返回一个数量。这种解法对于带有障碍的问题来说 不太适合。但是速度上比方法二快了一点。 1234567891011121314151617181920212223242526def pathsWithMaxScore(self, board: List[str]) -&gt; List[int]: R, C = len(board), len(board[0]) board[0] = '0' + board[0][1:] board[-1] = board[-1][:-1] + '0' b = [[float('-inf') if d=='X' else int(d) for d in row] for row in board] ways = [[0] * C for _ in range(R)] first_row = list(itertools.takewhile(lambda x: x&gt;=0, ways[0])) ways[0] = len(first_row) * [1] + (C-len(first_row)) * [0] cur = list(itertools.accumulate(b[0])) for i in range(1, R): tmp = [] for j in range(C): left = tmp[-1] if j&gt;0 else float('-inf') dia = cur[j-1] if j&gt;0 else float('-inf') max_pre = max(cur[j], dia, left) tmp.append(max_pre + b[i][j]) left_way = ways[i][j-1] if j&gt;0 else 0 up_way = ways[i-1][j] dia_way = ways[i-1][j-1] if i&gt;0 and j&gt;0 else 0 if max_pre != float('-inf') and b[i][j]!=float('-inf'): ways[i][j] += up_way * (cur[j]==max_pre) ways[i][j] += left_way * (left==max_pre) ways[i][j] += dia_way * (dia==max_pre) cur = tmp return (cur[-1] if cur[-1]!=float('-inf') else 0, ways[-1][-1] % (10**9+7)) 方法二：优化。构造一个+1的dp。lee215的解法。3个方向的延伸放到了循环中，同时记录最大的路径个数。 1234567891011121314def pathsWithMaxScore(self, board: List[str]) -&gt; List[int]: n, mod = len(board), 10**9+7 dp = [[[float('-inf'), 0] for j in range(n+1)] for i in range(n+1)] dp[n-1][n-1] = [0, 1] for x in range(n)[::-1]: for y in range(n)[::-1]: if board[x][y] in 'XS': continue for i, j in ((0, 1), (1, 0), (1, 1)): if dp[x][y][0] &lt; dp[x+i][y+j][0]: dp[x][y] = [dp[x+i][y+j][0], 0] if dp[x][y][0] == dp[x+i][y+j][0]: dp[x][y][1] += dp[x+i][y+j][1] dp[x][y][0] += int(board[x][y]) if x or y else 0 return [dp[0][0][0] if dp[0][0][1] else 0, dp[0][0][1] % mod] 1277. Count Square Submatrices with All Ones矩阵中最多有多少个1构成的正方形。原题123456789101112Input: matrix =[ [0,1,1,1], [1,1,1,1], [0,1,1,1]]Output: 15Explanation: There are 10 squares of side 1.There are 4 squares of side 2.There is 1 square of side 3.Total number of squares = 10 + 4 + 1 = 15. 123456789def countSquares(self, mat: List[List[int]]) -&gt; int: m, n = len(mat), len(mat[0]) # dp[i][j] 表示以i, j为右下点时，正方形的个数。 dp = [[0] * (n) for i in range(m)] for i in range(m): for j in range(n): if mat[i][j] == 1: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 return sum(map(sum, dp)) 1269. Number of Ways to Stay in the Same Place After Some Steps回到原点的走法一共有多少种，一次只能向右，向左或者停留，要求始终保持在数组范围。原题1234567Input: steps = 3, arrLen = 2Output: 4Explanation: There are 4 differents ways to stay at index 0 after 3 steps.Right, Left, StayStay, Right, LeftRight, Stay, LeftStay, Stay, Stay 方法一：找到状态转移方程，dp[p][s] = dp[p-1][s-1] + dp[p][s-1] + dp[p+1, s-1]p代表位置，s代表步数。首部添加0方便求和。注意t+3这个范围。 123456def numWays(self, steps: int, n: int) -&gt; int: mod = 10**9 + 7 A = [0, 1] for t in range(steps): A[1:] = [sum(A[i - 1:i + 2]) % mod for i in range(1, min(n + 1, t + 3))] return A[1] % mod 338. Counting Bits返回从0到num的数中，每个数二进制中含有1的个数。原题12Input: 5Output: [0,1,1,2,1,2] 方法一：此解法用了191的暴力解法。 123456789def countBits(self, num: int) -&gt; List[int]: ans = [] def count(a): c = 0 while a != 0: a &amp;= a-1 c += 1 return c return map(count, range(0, num+1)) 方法二：dp 。dp[i]=dp[i//2]+i&amp;1 12345def countBits(self, num: int) -&gt; List[int]: dp = [0] for i in range(1, num+1): dp.append(dp[i&gt;&gt;1] + (i&amp;1)) return dp 1262. Greatest Sum Divisible by Three最多的元素和能被3整除。原题123Input: nums = [3,6,5,1,8]Output: 18Explanation: Pick numbers 3, 6, 1 and 8 their sum is 18 (maximum sum divisible by 3). 方法一：数学方法，累加所有的数，和可能有三种情况： 余 0 ，刚好整除。 余1， 需要减去一个余1的数，或者两个余2的数。 余2，减去一个余2的数，或者两个余1的数。 需要注意数字是否够用。 12345678910def maxSumDivThree(self, nums: List[int]) -&gt; int: total = sum(nums) mod_1 = [n for n in nums if n%3==1] mod_2 = [n for n in nums if n%3==2] if total % 3 == 1: return total - min(min(mod_1), sum(heapq.nsmallest(2, mod_2) if len(mod_2)&gt;=2 else [float('inf')])) elif total % 3 == 2: return total - min(min(mod_2), sum(heapq.nsmallest(2, mod_1) if len(mod_1)&gt;=2 else [float('inf')])) else: return total 方法二：dp. 12345678910111213def maxSumDivThree(self, nums: List[int]) -&gt; int: # dp[pos][mod] # # 0 1 2 # 0 3 0 0 # 1 9 0 0 # 2 9 0 14 # 3 15 10 14 # 4 18 22 23 dp = [0] * 3 for a in nums: for j in dp[:]: dp[(j+a) % 3] = max(dp[(j+a) % 3], j+a) return dp[0] 72. Edit Distance两个单词，将a变成b的最小步数，可以添加、删除，替换一个字母。原题123456Input: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;Output: 3Explanation: horse -&gt; rorse (replace &apos;h&apos; with &apos;r&apos;)rorse -&gt; rose (remove &apos;r&apos;)rose -&gt; ros (remove &apos;e&apos;) 方法一：真是后悔没早点做这个题，这题解法下有一个方法将dp的问题从记忆化搜索的递归到实现的过程讲解的非常详细。这里从这样的一个递归开始演变。 123456789101112131415class Solution: def minDistance(self, word1, word2): """Naive recursive solution""" if not word1 and not word2: return 0 if not word1: return len(word2) if not word2: return len(word1) if word1[0] == word2[0]: return self.minDistance(word1[1:], word2[1:]) insert = 1 + self.minDistance(word1, word2[1:]) delete = 1 + self.minDistance(word1[1:], word2) replace = 1 + self.minDistance(word1[1:], word2[1:]) return min(insert, replace, delete) 到最终的形态。 12345678910111213141516def minDistance(self, word1: str, word2: str) -&gt; int: m, n = len(word1), len(word2) dp = [[0] * (n+1) for _ in range(m+1)] for i in range(m+1): dp[i][0] = i for j in range(n+1): dp[0][j] = j for i in range(m): for j in range(n): if word1[i] == word2[j]: dp[i+1][j+1] = dp[i][j] else: dp[i+1][j+1] = min(dp[i+1][j], dp[i][j+1], dp[i][j]) + 1 return dp[-1][-1] 322. Coin Change找零问题，给你几种面值的硬币，不限制每种硬币的个数，问组成多少钱最少需要几个硬币。原题123Input: coins = [1, 2, 5], amount = 11Output: 3 Explanation: 11 = 5 + 5 + 1 方法一：自己想的方法。 12345def coinChange(self, coins: List[int], amount: int) -&gt; int: dp = [0] + [float('inf')] * amount for i in range(1, amount+1): dp[i] = min(dp[i-coin]+1 if i&gt;=coin else float('inf') for coin in coins) return dp[-1] if dp[-1]!=float('inf') else -1 518. Coin Change 2找钱问题，给你几种面值的硬币，不限制每种硬币的个数，问组成多少钱有多少种方法。原题1234567Input: amount = 5, coins = [1, 2, 5]Output: 4Explanation: there are four ways to make up the amount:5=55=2+2+15=2+1+1+15=1+1+1+1+1 方法一：背包问题，看了答案。 dp[i - 1][j]: 完全不用当前硬币组成j有多少种组合dp[i][j - coins[i - 1]] :使用至少一个当前硬币（与上面一条是互斥事件）组成组成j有多少组合 12345678def change(self, amount: int, coins: List[int]) -&gt; int: dp = [0] * (amount + 1) dp[0] = 1 for i in coins: for j in range(1, amount + 1): if j &gt;= i: dp[j] += dp[j - i] return dp[amount] 1220. Count Vowels Permutation元音字母的全排列，根据指定规则的，求全排列的个数。原题123Input: n = 2Output: 10Explanation: All possible strings are: &quot;ae&quot;, &quot;ea&quot;, &quot;ei&quot;, &quot;ia&quot;, &quot;ie&quot;, &quot;io&quot;, &quot;iu&quot;, &quot;oi&quot;, &quot;ou&quot; and &quot;ua&quot;. 方法一：没想到居然做出来了。dp分别代表了以这些字母开头的个数。 1234567891011def countVowelPermutation(self, n: int) -&gt; int: dp = [1] * 5 for _ in range(n-1): tmp = [[0] for _ in range(5)] tmp[0] = dp[1] tmp[1] = dp[0] + dp[2] tmp[2] = dp[0] + dp[1] + dp[3] + dp[4] tmp[3] = dp[2] + dp[4] tmp[4] = dp[0] dp = tmp return sum(dp) % (10**9+7) 方法二：一整得有点复杂了。 12345def countVowelPermutation(self, n: int) -&gt; int: a = e = i = o = u = 1 for _ in range(n-1): a, e, i, o, u = e, a+i, a+e+o+u, i+u, a return (a+e+i+o+u) % (10**9+7) 368. Largest Divisible Subset最大的整除子集。原题12Input: [1,2,3]Output: [1,2] (of course, [1,3] will also be ok) 方法一：stefan的解法。自己没想出来。 12345def largestDivisibleSubset(self, nums: List[int]) -&gt; List[int]: S = &#123;-1: set()&#125; for x in sorted(nums): S[x] = max((S[d] for d in S if x % d == 0), key=len) | &#123;x&#125; return list(max(S.values(), key=len)) 5456. Kth Ancestor of a Tree Node找出一个树节点的k个祖先。原题12345678910111213Input:[&quot;TreeAncestor&quot;,&quot;getKthAncestor&quot;,&quot;getKthAncestor&quot;,&quot;getKthAncestor&quot;][[7,[-1,0,0,1,1,2,2]],[3,1],[5,2],[6,3]]Output:[null,1,0,-1]Explanation:TreeAncestor treeAncestor = new TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2]);treeAncestor.getKthAncestor(3, 1); // returns 1 which is the parent of 3treeAncestor.getKthAncestor(5, 2); // returns 0 which is the grandparent of 5treeAncestor.getKthAncestor(6, 3); // returns -1 because there is no such ancestor 方法一：这道题没有做出来，Lee的答案。用的倍增法，binary lifting. 12345678910111213141516171819202122232425class TreeAncestor: step = 15 def __init__(self, n, A): A = dict(enumerate(A)) jump = [A] for s in range(self.step): B = &#123;&#125; for i in A: if A[i] in A: B[i] = A[A[i]] jump.append(B) A = B self.jump = jump print(jump) def getKthAncestor(self, x: int, k: int) -&gt; int: step = self.step while k &gt; 0 and x &gt; -1: if k &gt;= 1 &lt;&lt; step: x = self.jump[step].get(x, -1) k -= 1 &lt;&lt; step else: step -= 1 return x 1477. Find Two Non-overlapping Sub-arrays Each With Target Sum找到数组中等于目标值的两个不重叠子数组的最小长度和。原题123Input: arr = [3,2,2,4,3], target = 3Output: 2Explanation: Only two sub-arrays have sum = 3 ([3] and [3]). The sum of their lengths is 2. 方法一：看了提示后使用了前后遍历法做出来的。其实有一次遍历的方式。这个方法看了挺长时间，才明白，实际上记录了一个以end为结尾的前面的所有元素最好的长度是多少。 123456789101112131415def minSumOfLengths(self, arr: List[int], target: int) -&gt; int: prefix = &#123;0: -1&#125; best_till = [math.inf] * len(arr) ans = best = math.inf for i, curr in enumerate(itertools.accumulate(arr)): # print(i, curr) if curr - target in prefix: end = prefix[curr - target] if end &gt; -1: ans = min(ans, i - end + best_till[end]) best = min(best, i - end) # print('\t', best, i-end, best_till, ans) best_till[i] = best prefix[curr] = i return -1 if ans == math.inf else ans 494. Target Sum给你一组数，用+或-连接起来最后等于target，问有多少种填法。原题123456789Input: nums is [1, 1, 1, 1, 1], S is 3. Output: 5Explanation: -1+1+1+1+1 = 3+1-1+1+1+1 = 3+1+1-1+1+1 = 3+1+1+1-1+1 = 3+1+1+1+1-1 = 3 方法一：记忆化搜索。 1234567891011def findTargetSumWays(self, nums: List[int], S: int) -&gt; int: n = len(nums) @lru_cache(None) def dfs(i, total): if i == n: return total==S ans = dfs(i+1, total+nums[i]) + dfs(i+1, total-nums[i]) return ans return dfs(0, 0) 174. Dungeon Game地牢游戏，从左上走到右下，每次只能像右或者向下，格子里会扣血和加血，问最少需要多少血，全程保持血量为1以上。原题方法一：这道题曾经面试某公司的时候做过，只是那道题还要求返回路径，当时做的时候以为做对了。再次遇见此题时想了一晚上发现想简单了。一开始想保留两个变量，一个是最少血量，一个是累加和。然后根据最少血量判断选择走哪条路，结果一个case证明了想法是错的。还是评论区找的写法。 1234567891011121314def calculateMinimumHP(self, dungeon: List[List[int]]) -&gt; int: R, C = len(dungeon), len(dungeon[0]) dp = [[0] * C for _ in range(R)] for i in range(R-1, -1, -1): for j in range(C-1, -1, -1): if i == R-1 and j == C-1: dp[i][j] = max(1, 1 - dungeon[i][j]) elif i == R-1: dp[i][j] = max(1, dp[i][j+1] - dungeon[i][j]) elif j == C-1: dp[i][j] = max(1, dp[i+1][j] - dungeon[i][j]) else: dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j]) return dp[0][0] 96. Unique Binary Search Trees不重复的二叉搜索树，1~n节点。原题12345678910Input: 3Output: 5Explanation:Given n = 3, there are a total of 5 unique BST&apos;s: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 方法一：这题看了答案，状态转移方程式这样的G(n)表示n个节点能组成的二叉搜索树节点个数。F(i, n)表示有n个节点时，以i为root的个数。G(n) = F(1, n) + F(2, n) + ... + F(n, n). F(3, 7)=G(2)*G(4)即F(i, n) = G(i-1) * G(n-i), 所以最后G(n) = G(0) * G(n-1) + G(1) * G(n-2) + … + G(n-1) * G(0) 1234567def numTrees(self, n: int) -&gt; int: G = [0] * (n+1) G[0] = G[1] = 1 for i in range(2, n+1): for j in range(1, i+1): G[i] += G[j-1]*G[i-j] return G[n] 95. Unique Binary Search Trees II这题和96一样，要求将所有的树找出来。原题方法一：第一次AC的方法。 12345678910111213141516171819202122def generateTrees(self, n: int) -&gt; List[TreeNode]: memo = &#123;&#125; def build(lo, hi): if (lo, hi) in memo: return memo[(lo, hi)] ans = [] if lo &gt; hi: return [None] elif lo == hi: return [TreeNode(lo)] for i in range(lo, hi+1): root = TreeNode(i) for left in build(lo, i-1): root.left = left for right in build(i+1, hi): root.right = right ans.append(copy.deepcopy(root)) memo[(lo, hi)] = ans return ans return build(1, n) if n&gt;0 else [] 方法二：看了stefan的答案，更正一下自己的方法，lo==hi是没必要的，之前因为先考虑这个因素，没有删掉。deepcopy可以写成别的形式，在内循环生成root节点，而不是在外层生成一个再去拷贝。记忆化搜索也是没有必要的。用时比原来快了3倍。1234567891011121314def generateTrees(self, n: int) -&gt; List[TreeNode]: def build(lo, hi): ans = [] for i in range(lo, hi+1): for left in build(lo, i-1): for right in build(i+1, hi): root = TreeNode(i) root.left = left root.right = right ans.append(root) return ans or [None] return build(1, n) if n&gt;0 else [] 337. House Robber III抢劫房子，房子是二叉树结构，不能抢两个挨着的节点，问最多可以抢多少。原题方法一：看了讨论区才解出来。对于一个节点来说，只有两种case：抢与不抢。将这个条件利用起来代入到递归判断中 12345678910111213def rob(self, root: 'TreeNode') -&gt; 'int': def dfs(node): if not node: return 0, 0 left = dfs(node.left) right = dfs(node.right) not_rob = max(left[0], left[1]) + max(right[0], right[1]) robbed = node.val + left[0] + right[0] return not_rob, robbed a, b = dfs(root) return max(a, b) 1504. Count Submatrices With All Ones查找有多少个由1组成的子矩阵。原题1234567891011Input: mat = [[1,0,1], [1,1,0], [1,1,0]]Output: 13Explanation:There are 6 rectangles of side 1x1.There are 2 rectangles of side 1x2.There are 3 rectangles of side 2x1.There is 1 rectangle of side 2x2. There is 1 rectangle of side 3x1.Total number of rectangles = 6 + 2 + 3 + 1 + 1 = 13. 方法一：竞赛时未做出来，有道类似的题是求正方形的，所以思路被限制了，找到一个状态转移方程，但是case1跑不过，未注意变量的范围，其实O(MMN)的时间复杂度也是允许的。从1D扩展的2D，然后h表示当前列k的top到down是否都是1。 12345678910111213141516171819def numSubmat(self, mat: List[List[int]]) -&gt; int: R, C = len(mat), len(mat[0]) ans = 0 def count_row(a): ans = l = 0 for num in a: l = 0 if num==0 else l+1 ans += l return ans for top in range(R): h = [1] * C for bottom in range(top, R): for k in range(C): h[k] &amp;= mat[bottom][k] ans += count_row(h) return ans 1140. Stone Game II和1不一样，这回的规则是这样的，每次拿前m &lt;= x &lt;= 2m个堆，问最后Alex可以拿多少最多。原题123Input: piles = [2,7,9,4,4]Output: 10Explanation: If Alex takes one pile at the beginning, Lee takes two piles, then Alex takes 2 piles again. Alex can get 2 + 4 + 4 = 10 piles in total. If Alex takes two piles at the beginning, then Lee can take all three piles left. In this case, Alex get 2 + 7 = 9 piles in total. So we return 10 since it&apos;s larger. 方法一：没做出来，Lee的答案看了半天，退出条件开始很难想出来。就是如果能够全拿，就退出。转移方程式这样的，A变成了一个从后累加的数组，当前的人拿i~i+x另外的人就是dp[i+x, max(m, x)] 1234567891011def stoneGameII(self, A: List[int]) -&gt; int: N = len(A) for i in range(N - 2, -1, -1): A[i] += A[i + 1] from functools import lru_cache @lru_cache(None) def dp(i, m): if i + 2 * m &gt;= N: return A[i] return A[i] - min(dp(i + x, max(m, x)) for x in range(1, 2 * m + 1)) return dp(0, 1) 1524. Number of Sub-arrays With Odd Sum求一个数组的和为奇数的子数组的个数。原题12345Input: arr = [1,3,5]Output: 4Explanation: All sub-arrays are [[1],[1,3],[1,3,5],[3],[3,5],[5]]All sub-arrays sum are [1,4,9,3,8,5].Odd sums are [1,9,3,5] so the answer is 4. 方法一：这题作为竞赛2题没做上，导致周赛排名降了不少。odd表示前i个数包含i的子数组奇数的个数。even则是偶数个数。那么当i+1为偶数时，even+1，奇数不变；当i+1为奇数时，even=odd，even=odd+1 12345678def numOfSubarrays(self, arr: List[int]) -&gt; int: ans = odd = even = 0 for x in arr: even += 1 if x % 2: odd, even = even, odd ans = (ans + odd) % (10**9+7) return ans 139. Word Break问s是否能拆成words里的单词，单词可以重复使用。原题1234Input: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]Output: trueExplanation: Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;. Note that you are allowed to reuse a dictionary word. 方法一：还是想不到dp的解法。此题需要逆向思维。 1234567def wordBreak(self, s: str, words: List[str]) -&gt; bool: dp = [True] + [False] * len(s) for i in range(1, len(s)+1): for w in words: if s[:i].endswith(w): dp[i] |= dp[i-len(w)] return dp[-1] 140. Word Break II和上题一样，不过要求返回所有拆分的结果。原题12345678Input:s = &quot;catsanddog&quot;wordDict = [&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;]Output:[ &quot;cats and dog&quot;, &quot;cat sand dog&quot;] 方法一：回溯法，这里有个case会超时，所以判断了一下s是否有单独的字符出现。 123456789101112131415def wordBreak(self, s: str, words: List[str]) -&gt; List[str]: words = set(words) if set(s)-set(c for w in words for c in w): return [] def backtrack(s, p): if not s: ans.append(' '.join(p)) for i in range(1, len(s)+1): if s[:i] in words: backtrack(s[i:], p+[s[:i]]) ans = [] backtrack(s, []) return ans 方法二：记忆化搜索。需要用索引作key来完成。不能用s是因为，s可能是前后有重复值。 1234567891011121314def wordBreak(self, s: str, words: List[str]) -&gt; List[str]: words = set(words) memo = &#123;len(s): ['']&#125; def sentences(i): if i not in memo: memo[i] = [s[i:j] + (tail and ' ' + tail) for j in range(i+1, len(s)+1) if s[i:j] in words for tail in sentences(j)] return memo[i] return sentences(0) 1416. Restore The Array字符串s是有1~k个数非0开头组成的，问有多少种组成的方式。原题1234567891011Input: s = &quot;1000&quot;, k = 10000Output: 1Explanation: The only possible array is [1000]Input: s = &quot;1000&quot;, k = 10Output: 0Explanation: There cannot be an array that was printed this way and has all integer &gt;= 1 and &lt;= 10.Input: s = &quot;1317&quot;, k = 2000Output: 8Explanation: Possible arrays are [1317],[131,7],[13,17],[1,317],[13,1,7],[1,31,7],[1,3,17],[1,3,1,7] 方法一：首次ac的方法。第10行如果不取余，时间慢了一倍，空间多了好几倍。这个思路和Word Break有点像，dp[i]表示s[:i]总共的组成方式。 123456789101112def numberOfArrays(self, s: str, k: int) -&gt; int: mod = 10 ** 9 + 7 dp = [0] * (len(s) + 1) dp[0] = 1 for i in range(1, len(s)+1): j = i-1 while j&gt;=0 and len(s[j:i])&lt;=len(str(k)) and int(s[j:i]) &lt;= k: if s[j] != '0': dp[i] += dp[j] % mod j -= 1 return dp[-1] % mod 方法二：针对方法一优化，while循环看着有点乱。 1234567891011def numberOfArrays(self, s: str, k: int) -&gt; int: mod = 10 ** 9 + 7 k_len = len(str(k)) dp = [0] * (len(s) + 1) dp[0] = 1 for i in range(1, len(s)+1): for j in range(max(0, i-k_len), i): if s[j] != '0' and int(s[j:i]) &lt;=k: dp[i] += dp[j] % mod return dp[-1] % mod 方法三：用dp[i]表示[i:]总共的组成数量，从后向前计算，这样有一个好处，可以用数值来判断而不是字符串。此方法在时间上比上述快了一倍。为此作了很多实验，时间的消耗正是在s的反复切片中。 12345678910111213141516def numberOfArrays(self, s: str, k: int) -&gt; int: mod = 10 ** 9 + 7 n = len(s) s = [*map(int, s)] + [math.inf] dp = [0] * n + [1] for i in range(n-1, -1, -1): num = s[i] for j in range(i+1, n+1): if 1 &lt;= num &lt;= k: dp[i] = (dp[i] + dp[j]) % mod num = 10 * num + s[j] else: break return dp[0] 1537. Get the Maximum Score两个不重复数字的数组，从某个数组从左向右找一条路径，使值最大，如果和另一个数组有重复的数字则可以跳到另一个数组上。原题方法一：竞赛时没有时间想，不过做起来比第3题简单。 1234567891011121314151617181920def maxSum(self, nums1: List[int], nums2: List[int]) -&gt; int: def get_cross(arr1, arr2): a = [0] p = False s2 = set(arr2) for n in arr1: if not p: a.append(a.pop()+n) else: a.append(n) p = n in s2 return a a1, a2 = get_cross(nums1, nums2), get_cross(nums2, nums1) ans = 0 for a, b in itertools.zip_longest(a1, a2, fillvalue=0): ans = (ans + max(a, b)) % (10**9+7) return ans 方法二：忽略了一个条件，两个数组时有序的，所以可以使用双指针，O(1)的空间来实现。by@lee215. 123456789101112131415def maxSum(self, A: List[int], B: List[int]) -&gt; int: i, j, n, m = 0, 0, len(A), len(B) a, b, mod = 0, 0, 10**9+7 while i&lt;n or j&lt;m: if i&lt;n and (j==m or A[i]&lt;B[j]): a += A[i] i += 1 elif j&lt;m and (i==n or A[i]&gt;B[j]): b += B[j] j += 1 else: a = b = max(a, b) + A[i] i += 1 j += 1 return max(a, b) % mod 1553. Minimum Number of Days to Eat N Oranges每天可以吃一个橙子；或者被2整除时吃一半；或者被3整除时吃3分之2。问最少几天可以吃完原题12345678Input: n = 10Output: 4Explanation: You have 10 oranges.Day 1: Eat 1 orange, 10 - 1 = 9. Day 2: Eat 6 oranges, 9 - 2*(9/3) = 9 - 6 = 3. (Since 9 is divisible by 3)Day 3: Eat 2 oranges, 3 - 2*(3/3) = 3 - 2 = 1. Day 4: Eat the last orange 1 - 1 = 0.You need at least 4 days to eat the 10 oranges. 方法一：比赛时未做出来，想初始化一个2*10**9的数组，结果内存溢出。而且取余也没想出来。 123456class Solution: @functools.lru_cache() def minDays(self, n: int) -&gt; int: if n &lt;= 1: return n return 1 + min(self.minDays(n//2)+n%2, self.minDays(n//3)+n%3) 方法二：bfs，这个方法完全没有想到，就是将3种吃法放到队列中去。这种时间效率比方法一低很多。 12345678910111213def minDays(self, n: int) -&gt; int: q = collections.deque([(n, 0)]) seen = set() while q: cur, step = q.popleft() if cur == 0: return step seen.add(cur) if cur-1 not in seen: q.append((cur-1, step+1)) if cur&amp;1==0 and cur//2 not in seen: q.append((cur//2, step+1)) if cur%3==0 and cur//3 not in seen: q.append((cur//3, step+1)) 801. Minimum Swaps To Make Sequences Increasing最少多少次对应位置的交换可以使两个数组都严格地单调递增。原题1234567Example:Input: A = [1,3,5,4], B = [1,2,3,7]Output: 1Explanation: Swap A[3] and B[3]. Then the sequences are:A = [1, 3, 5, 7] and B = [1, 2, 3, 4]which are both strictly increasing. 方法一：在提交错一次get新case后做了出来。首次AC的方法。 1234567891011121314def minSwap(self, A: List[int], B: List[int]) -&gt; int: last_swap = last_not_swap = 0 A = [float('-inf')] + A B = [float('-inf')] + B for i in range(1, len(A)): cur_swap = cur_not_swap = float('inf') if A[i] &gt; A[i-1] and B[i] &gt; B[i-1]: cur_swap = last_swap + 1 cur_not_swap = last_not_swap if A[i] &gt; B[i-1] and B[i] &gt; A[i-1]: cur_swap = min(cur_swap, last_not_swap+1) cur_not_swap = min(cur_not_swap, last_swap) last_swap, last_not_swap = cur_swap, cur_not_swap return min(last_swap, last_not_swap) 方法二：看了lee的答案，改了一下初始化的值，补负无穷是没必要的 123456789101112def minSwap(self, A: List[int], B: List[int]) -&gt; int: last_swap, last_not_swap = 1, 0 for i in range(1, len(A)): cur_swap = cur_not_swap = len(A) if A[i] &gt; A[i-1] and B[i] &gt; B[i-1]: cur_swap = last_swap + 1 cur_not_swap = last_not_swap if A[i] &gt; B[i-1] and B[i] &gt; A[i-1]: cur_swap = min(cur_swap, last_not_swap+1) cur_not_swap = min(cur_not_swap, last_swap) last_swap, last_not_swap = cur_swap, cur_not_swap return min(last_swap, last_not_swap) 837. New 21 Game新的21点游戏，有个W面的骰子，少于K的时候要一直掷骰子，直到和超过K，问最后结果小于等于N的概率。原题1234567Input: N = 6, K = 1, W = 10Output: 0.60000Explanation: Alice gets a single card, then stops.In 6 out of W = 10 possibilities, she is at or below N = 6 points.Input: N = 21, K = 17, W = 10Output: 0.73278 方法一：超时，这道题让我联想到剑指offer中的骰子题，但是不太一样，所以这个方法和那个有点类似，但是超时了。此题的时间要求很高。 12345678910111213141516def new21Game(self, N: int, K: int, W: int) -&gt; float: if K == 0: return 1 last_p = collections.defaultdict(int) last_p[0] = 1 ans = 0 for i in range(K): new_p = collections.defaultdict(int) for j in range(i+1, N+1): if j &gt;= K: ans += sum(last_p[j-m] for m in range(1, W+1) if j-m&lt;K) / W else: new_p[j] = sum(last_p[j-m] for m in range(1, W+1) if j-m&lt;K) / W last_p = new_p # print(i, last_p) return ans 方法二：这是Lee的答案，这题也是Lee贡献的，想了半天才想明白。想通了原理就不难理解，方法一就是没转过来弯。p(K) = p(K-1) / W + p(K-2) / W + p(K-3) / W + ... p(K-W) / W ，然后Wsum其实就是p(K-1)+p(K-2)+...p(K-W)，想象成一个W长度的滑动窗口，然后i&lt;K是因为如果i达到了K，就已经截止了，所以概率不再累加了。 12345678910def new21Game(self, N: int, K: int, W: int) -&gt; float: from fractions import Fraction if K == 0 or N &gt;= K + W: return 1 dp = [1.0] + [0.0] * N Wsum = 1.0 for i in range(1, N + 1): dp[i] = Wsum / W if i &lt; K: Wsum += dp[i] if i - W &gt;= 0: Wsum -= dp[i - W] return sum(dp[K:]) 808. Soup Servings有两种汤，有四种上法，如果一种汤不够，那都全都上了。问A汤先卖完的概率加上一起卖完的概率的一半，和是多少。原题12345Example:Input: N = 50Output: 0.625Explanation: If we choose the first two operations, A will become empty first. For the third operation, A and B will become empty at the same time. For the fourth operation, B will become empty first. So the total probability of A becoming empty first plus half the probability that A and B become empty at the same time, is 0.25 * (1 + 1 + 0.5 + 0) = 0.625. 方法一：递归，爆栈了，因为N最大为10^9。 123456789101112131415161718192021def soupServings(self, N: int) -&gt; float: @functools.lru_cache() def get_p(a, b): if a &lt;= 0: if b &lt;= 0: return 0, 1 else: return 1, 0 if b &lt;= 0: return 0, 0 a_0 = two_0 = 0 for i in range(0, 100, 25): p1, p2 = get_p(a-100+i, b-i) a_0 += p1 / 4 two_0 += p2 / 4 # print(a, b, a_0, ' - ', two_0) return a_0, two_0 p1, p2 = get_p(N, N) return p1 + 0.5*p2 方法二：Lee的方法。同时为0的情况，可以直接将概率减半，因为后序不会再此概率上再做计算。但就这样的话还是无法解决爆栈的问题。然后寻找规律，A汤4种情况平均下来，消耗地比B多，那么N越大，B先卖完的概率就越小，结果就越大。答案在5位小数精度内都算正确，所以找到一个阈值，概率变为1。然后对于25ml这个条件，可以将其看作一勺单位，这样计算起来比较简单。 12345678910111213class Solution(object): memo = &#123;&#125; def soupServings(self, N): if N &gt; 4800: return 1 def f(a, b): if (a, b) in self.memo: return self.memo[a, b] if a &lt;= 0 and b &lt;= 0: return 0.5 if a &lt;= 0: return 1 if b &lt;= 0: return 0 self.memo[(a, b)] = 0.25 * (f(a - 4, b) + f(a - 3, b - 1) + f(a - 2, b - 2) + f(a - 1, b - 3)) return self.memo[(a, b)] N = math.ceil(N / 25.0) return f(N, N) 983. Minimum Cost For Tickets最小花费的票钱，有三种通票，分别能旅行1，7，30天，对应三种价格，要在一年中的旅行日花费最少，需要多少钱。原题12345678Input: days = [1,4,6,7,8,20], costs = [2,7,15]Output: 11Explanation: For example, here is one way to buy passes that lets you travel your travel plan:On day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1.On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9.On day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.In total you spent $11 and covered all the days of your travel. 方法一：想了一会儿就做出来了，需要注意如果不是旅行日，要等于前一天的花费。 12345678def mincostTickets(self, days: List[int], costs: List[int]) -&gt; int: dp = [0] + [float('inf')] * days[-1] for i in range(1, days[-1]+1): if i not in set(days): dp[i] = dp[i-1] continue dp[i] = min((dp[i-d] if i-d&gt;=0 else 0) + cost for d, cost in zip([1, 7, 30], costs)) return dp[-1] 473. Matchsticks to Square将长度列表的火柴棍拼成正方形。不能折断某个火柴，但可以连接。原题123456789Input: [1,1,2,2,2]Output: trueExplanation: You can form a square with length 2, one side of the square came two sticks with length 1.Input: [3,3,3,3,4]Output: falseExplanation: You cannot find a way to form a square with all the matchsticks. 方法一：dfs ，效率不是很高。sort很重要，如果优先拿的不是最大的，那么将会超时。 1234567891011121314151617181920def makesquare(self, nums: List[int]) -&gt; bool: if len(nums)&lt;4 or sum(nums) % 4: return False target = sum(nums) // 4 if max(nums) &gt; target: return False nums.sort() def dfs(edges): # if all(d==target for d in edges): return True if not nums: return True cur = nums.pop() for i in range(4): if edges[i] + cur &lt;= target: edges[i] += cur if dfs(edges): return True edges[i] -= cur nums.append(cur) return False return dfs([0]*4) 方法二：bitmask+ dp。这个方法研究了很长时间，忽略了A[bit]&gt;cur下的break，让我对输出疑惑了很久，mask是一个N长度的都是1的二进制数，每次从右到左数第[i]位设为0 表示A[i]已经使用了，cur表示当前边剩下的长度，如果为0，表示一个边已经准备好，重新再设为T。原答案用的A排序是正序，我改成了倒序，又快了一倍，但是感觉这个跟cases是密切相关的，这个方法非常快，最快仅用40ms。比方法一快得多。 123456789101112131415161718192021222324252627282930def makesquare(self, A: List[int]) -&gt; bool: if len(A) &lt; 4 or sum(A) % 4 or max(A) &gt; sum(A) / 4: return False T = sum(A) // 4 N = len(A) A.sort(reverse=True) memo = &#123;&#125; def dp(mask, cur = T): # print(format(mask, 'b').rjust(N, '0'), cur) if (mask, cur) in memo: return memo[mask, cur] if mask == 0: return cur == 0 if cur == 0: return dp(mask, T) ans = False for bit in range(N): if mask &amp; (1 &lt;&lt; bit): if A[bit] &gt; cur: break # print('\t', format(mask, 'b').rjust(N, '0'), cur, bit) if dp(mask ^ (1 &lt;&lt; bit), cur - A[bit]): ans = True break memo[mask, cur] = ans return ans ans = dp(2**N - 1) return ans 799. Champagne Tower这题蛮有意思，说一个香槟塔，从塔尖倒酒，倒指定杯数的酒，然后问第几行第几个杯子是有多少酒。原题 方法一：想象每行前后多两个空杯，方便计算。 123456789def champagneTower(self, poured: int, query_row: int, query_glass: int) -&gt; float: row = [poured] for r in range(1, query_row+1): tmp_row = [0] + row + [0] a, b = itertools.tee(iter(tmp_row)) next(b, None) row = [max((l-1)*0.5, 0) + max((r-1)*0.5, 0) for l, r in zip(a, b)] return min(row[query_glass], 1) 方法二：Lee的方法和我的差不多，但是空间上比较小。 123456def champagneTower(self, poured: int, query_row: int, query_glass: int) -&gt; float: res = [poured] + [0] * query_row for row in range(1, query_row + 1): for i in range(row, -1, -1): res[i] = max(res[i] - 1, 0) / 2.0 + max(res[i - 1] - 1, 0) / 2.0 return min(res[query_glass], 1) 486. Predict the Winner两个选手每次从一堆球的两边拿，每人都是最优解，问最后A是否能赢。原题123456Input: [1, 5, 2]Output: FalseExplanation: Initially, player 1 can choose between 1 and 2. If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). So, final score of player 1 is 1 + 2 = 3, and player 2 is 5. Hence, player 1 will never be the winner and you need to return False. 方法一：主要找到公式。递归。dp[i][j]表示从i~j最大能赢多少分。 1234567891011def PredictTheWinner(self, nums: List[int]) -&gt; bool: memo = &#123;&#125; def pick(i, j): if (i, j) not in memo: if i == j: return nums[i] memo[(i, j)] = max(nums[i]-pick(i+1, j), nums[j]-pick(i, j-1)) return memo[(i, j)] return pick(0, len(nums)-1) &gt;= 0 方法二：迭代的方法更新顺序不太好想，s表示长度。 12345678910def PredictTheWinner(self, nums: List[int]) -&gt; bool: dp = [[0] * len(nums) for _ in range(len(nums))] for s in range(len(nums)): for i in range(len(nums)-s): j = i + s if i == j: dp[i][i] = nums[i] else: dp[i][j] = max(nums[j] - dp[i][j-1], nums[i] - dp[i+1][j]) return dp[0][-1] &gt;= 0 576. Out of Boundary Paths将球踢出边界的路径数量，步数在N步之内。原题方法一：比较直观的方法。 12345678910111213141516171819202122232425def findPaths(self, m: int, n: int, N: int, i: int, j: int) -&gt; int: mod = 10**9 + 7 g = [[0] * n for _ in range(m)] g[i][j] = 1 def count(): total = 0 total += sum(g[0][j] for j in range(n)) total += sum(g[m-1][j] for j in range(n)) total += sum(g[i][0] for i in range(m)) total += sum(g[i][n-1] for i in range(m)) return total ans = 0 for k in range(N): ans = (ans + count()) % mod new_g = [[0] * n for _ in range(m)] for i in range(m): for j in range(n): new_g[i][j] += g[i-1][j] if i else 0 new_g[i][j] += g[i+1][j] if i&lt;m-1 else 0 new_g[i][j] += g[i][j-1] if j else 0 new_g[i][j] += g[i][j+1] if j&lt;n-1 else 0 g = new_g return ans 方法二：从边界到目标点。这个要这样想比如例子2，一步的时候是[3,2,3]，第二步是[5,8,5]，第3步是[11,12,11]，当从2加到3步时，两边的点1~2步的结果，加了一步，可以从四周到达这个节点，两边+了一步变成2~3步的个数。然后再加上和下边界1步的个数 12345678910111213def findPaths(self, m: int, n: int, N: int, i: int, j: int) -&gt; int: dp = [[0]*n for _ in range(m)] for _ in range(N): # deep copy of dp t = [s[:] for s in dp] for x in range(m): for y in range(n): a = t[x-1][y] if x &gt; 0 else 1 b = t[x+1][y] if x + 1 &lt; m else 1 c = t[x][y-1] if y &gt; 0 else 1 d = t[x][y+1] if y + 1 &lt; n else 1 dp[x][y] = a + b + c + d return dp[i][j] % (10**9+7) 688. Knight Probability in Chessboard中国象棋的马，在棋盘上走K步，问还在棋盘上的概率。原题方法一：和576一样。区别在于刚好K步，走法不同。 1234567891011121314def knightProbability(self, N: int, K: int, r: int, c: int) -&gt; float: directions = ((-1, -2), (-2, -1), (-2, 1), (-1, 2), (1, -2), (2, -1), (2, 1), (1, 2)) dp = [[0]*N for _ in range(N)] dp[r][c] = 1 for k in range(K): new_dp = [[0]*N for _ in range(N)] for i in range(N): for j in range(N): new_dp[i][j] = sum(dp[i+di][j+dj] for di, dj in directions if 0&lt;=i+di&lt;N and 0&lt;=j+dj&lt;N) dp = new_dp return sum(sum(dp, [])) / (8**K) 方法二：少了最后一步求和的过程。 1234567891011121314151617def knightProbability(self, N: int, K: int, r: int, c: int) -&gt; float: directions = ((-1, -2), (-2, -1), (-2, 1), (-1, 2), (1, -2), (2, -1), (2, 1), (1, 2)) dp = [[0]*N for _ in range(N)] dp[r][c], out = 1, 0 for k in range(K): new_dp = [[0]*N for _ in range(N)] for i in range(N): for j in range(N): for di, dj in directions: if 0&lt;=i+di&lt;N and 0&lt;=j+dj&lt;N: new_dp[i+di][j+dj] += dp[i][j] / 8 else: out += dp[i][j] / 8 dp = new_dp return 1 - out 132. Palindrome Partitioning II最少需要多少次分割，可以将s切成的每段都是回文串。原题123Input: s = &quot;aab&quot;Output: 1Explanation: The palindrome partitioning [&quot;aa&quot;,&quot;b&quot;] could be produced using 1 cut. 方法一：比较暴力的方法。 123456789def minCut(self, s: str) -&gt; int: n = len(s) cut = list(range(n)) for i in range(1, n): if s[:i+1] == s[:i+1][::-1]: cut[i] = 0 continue cut[i] = min(cut[j]+1 for j in range(i) if s[j+1:i+1]==s[j+1:i+1][::-1]) return cut[-1] 1043. Partition Array for Maximum Sum将一个数组切分， 每段可以把所有的值变成当前段最大值。每段最长不能超过k。求切分后所有数的最大的和。原题123Input: arr = [1,15,7,9,2,5,10], k = 3Output: 84Explanation: arr becomes [15,15,15,9,10,10,10] 方法一：稍微想一想就想到了dp。这个AC的方法将近3s了。不过也beats了20%。索引那里需要注意是从1开始的，切片的时候得减去。 12345678def maxSumAfterPartitioning(self, A: List[int], K: int) -&gt; int: n = len(A) dp = [0] * (n+1) for i, a in enumerate(A, 1): for j in range(1, K+1): if i-j &gt;= 0: dp[i] = max(dp[i], dp[i-j] + max(A[i-j:i])*j) return dp[-1] 方法二：优化一下，768ms, beats 50%了。最大值可以不用每次都算，索引改从0开始了，从1开始某些地方太让人困惑。 123456789101112def maxSumAfterPartitioning(self, A: List[int], K: int) -&gt; int: n = len(A) dp = [0] * (n+1) for i, a in enumerate(A): r = a for j in range(1, K+1): r = max(r, A[i-j+1] if i-j+1&gt;=0 else 0) if i-j+1 &gt;= 0: dp[i+1] = max(dp[i+1], dp[i-j+1] + r*j) else: break return dp[-1] 方法三：Lee的方法和我一样，在循环边界上更加整洁。 123456789def maxSumAfterPartitioning(self, A: List[int], K: int) -&gt; int: n = len(A) dp = [0] * (n+1) for i, a in enumerate(A): r = a for j in range(1, min(i+1, K)+1): r = max(r, A[i-j+1]) dp[i+1] = max(dp[i+1], dp[i-j+1] + r*j) return dp[-1] 790. Domino and Tromino Tiling在2*N的平台上摆放两种多米诺骨牌，一共有多少种摆法。原题1234567Example:Input: 3Output: 5Explanation: The five different ways are listed below, different letters indicates different tiles:XYZ XXZ XYY XXY XYYXYZ YYZ XZZ XYY XXY 方法一：这题看了答案，自己推的状态方程不太对。没考虑第2种骨牌的多种摆法。引用一张高票的手写推导图。 12345dp[n]=dp[n-1]+dp[n-2]+ 2*(dp[n-3]+...+d[0])=dp[n-1]+dp[n-2]+dp[n-3]+dp[n-3]+2*(dp[n-4]+...+d[0])=dp[n-1]+dp[n-3]+(dp[n-2]+dp[n-3]+2*(dp[n-4]+...+d[0]))=dp[n-1]+dp[n-3]+dp[n-1]=2*dp[n-1]+dp[n-3] 123456def numTilings(self, N: int) -&gt; int: mod = 10**9 + 7 dp = [0, 1, 2, 5] for i in range(4, N+1): dp.append(2*dp[i-1] + dp[i-3]) return dp[-1]%mod if N&gt;3 else dp[N] 329. Longest Increasing Path in a Matrix矩阵中最长的递增路径。原题12345678Input: nums = [ [9,9,4], [6,6,8], [2,1,1]] Output: 4 Explanation: The longest increasing path is [1, 2, 6, 9]. 方法一：回溯+记忆化搜索。这题做的时候状态不太好，导致好几次WA和超时。首先要明白几点。因为是递增，不包含重复的，所以不需要对已遍历的节点进行重复判断。对于每个点来说，它所能延长到最长的路径是一定的。所以当得到这个值之后，后续再到这个节点就无需再计算了。使用一个字典来记录它的值。 123456789101112131415161718192021222324def longestIncreasingPath(self, g: List[List[int]]) -&gt; int: if not g: return 0 m, n = len(g), len(g[0]) seen = &#123;&#125; def spread(i, j, p): if (i, j) in seen: return seen[(i, j)] p.append(g[i][j]) nxt = 0 for x, y in ((i+1, j), (i, j+1), (i-1, j), (i, j-1)): if 0&lt;=x&lt;m and 0&lt;=y&lt;n: if g[x][y] &gt; p[-1]: nxt = max(nxt, spread(x, y, p)) ans = 1 + nxt seen[(i, j)] = ans p.pop() return ans for i in range(m): for j in range(n): spread(i, j, []) return max(seen.values()) 方法二：这题先入为主了，矩阵中的路径老想着回溯。其实dfs就行了，参数p除了比较根本没用。 123456789101112131415def longestIncreasingPath(self, g: List[List[int]]) -&gt; int: if not g: return 0 m, n = len(g), len(g[0]) def dfs(i, j): if not dp[i][j]: val, ans = g[i][j], 0 for x, y in ((i+1, j), (i, j+1), (i-1, j), (i, j-1)): if 0&lt;=x&lt;m and 0&lt;=y&lt;n and val &lt; g[x][y]: ans = max(ans, dfs(x, y)) dp[i][j] = 1 + ans return dp[i][j] dp = [[0] * n for _ in range(m)] return max(dfs(i, j) for i in range(m) for j in range(n)) 638. Shopping Offers这题和329差不多的方法。说商店有东西打折。一些商品打包打折卖。给定每种东西的数量，问最少需要多少钱。最多只有6个商品，每样不超过6个。你不能多买，即便需要的钱更少。原题1234567Input: [2,5], [[3,0,5],[1,2,10]], [3,2]Output: 14Explanation: There are two kinds of items, A and B. Their prices are $2 and $5 respectively. In special offer 1, you can pay $5 for 3A and 0BIn special offer 2, you can pay $10 for 1A and 2B. You need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A. 方法一：思路还算清晰，但是这里因为自作聪明加了两行代码，导致最后严重超时。方法还是dfs + 记忆化。因为加了注释中的代码，这里原本想的是，索性将原价商品页当做打包卖，只不过价格不一样而已。但是这样会增加dfs中的m。最后导致了超时。 1234567891011121314151617181920def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -&gt; int: n = len(price) # for i in range(n): # special.append([int(i==j) for j in range(n)] + [price[i]]) m = len(special) memo = &#123;&#125; def dfs(*needs): if needs in memo: return memo[needs] if all(need==0 for need in needs): return 0 ans = sum(need*p for need, p in zip(needs, price)) for j in range(m): left = [cn-a for cn, a in zip(needs, special[j][:-1])] if all(l&gt;=0 for l in left) and ans &gt; special[j][-1]: ans = min(ans, special[j][-1] + dfs(*left)) memo[needs] = ans return ans return dfs(*needs) 方法二：优化方法一，删除一些没用的变量。 1234567891011121314def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -&gt; int: memo = &#123;&#125; def dfs(*needs): if needs in memo: return memo[needs] ans = sum(need*p for need, p in zip(needs, price)) for spec in special: left = [cn-a for cn, a in zip(needs, spec[:-1])] if min(left)&gt;=0 and ans &gt; spec[-1]: ans = min(ans, spec[-1] + dfs(*left)) memo[needs] = ans return ans return dfs(*needs) 152. Maximum Product Subarray最大的子数组乘积。和1567题目类似，那题是求长度，可以贪心，这题没有。原题123Input: [2,3,-2,4]Output: 6Explanation: [2,3] has the largest product 6. 方法一：dp写法和1567dp解法相似。[-2]的例子只需要在前面判断一下长度是否为1即可。 12345678910111213def maxProduct(self, nums: List[int]) -&gt; int: ans, n = float('-inf'), len(nums) if n == 1: return nums[0] pos, neg = [0]*n, [0]*n for i, num in enumerate(nums): if num &gt; 0: pos[i] = num * (pos[i-1] if pos[i-1]!=0 else 1) neg[i] = num * (neg[i-1]) elif num &lt; 0: pos[i] = num * (neg[i-1]) neg[i] = num * (pos[i-1] if pos[i-1]!=0 else 1) ans = max(ans, pos[i], neg[i]) return ans 方法二：本来方法一也是和lee的1567解法写的。寻思这回不能差太多吧。啊这。。不知道怎么证明，但是看着答案就能想明白，最大值一定存在于这两个数组中。 123456def maxProduct(self, A: List[int]) -&gt; int: B = A[::-1] for i in range(1, len(A)): A[i] *= A[i - 1] or 1 B[i] *= B[i - 1] or 1 return max(A + B) 方法三：改了一个生成器写法。 12345def maxProduct(self, A: List[int]) -&gt; int: def count(x, y): return (x or 1) * y A, B = itertools.accumulate(A, count), itertools.accumulate(A[::-1], count) return max(itertools.chain(A, B)) LCP 20. 快速公交有这么个站点，每次从站点网下走需要inc时间，往回走需要dec时间，可以通过乘坐i公交车从移动到jum[i]*x站点，耗时为cost[i]，问到达target站点最少需要多少时间。123456789101112输入：target = 612, inc = 4, dec = 5, jump = [3,6,8,11,5,10,4], cost = [4,7,6,3,7,6,4]输出：26解释：小扣步行至 1 号站点，花费时间为 4；小扣从 1 号站台搭乘 0 号公交至 3 * 1 = 3 站台，花费时间为 4；小扣从 3 号站台搭乘 3 号公交至 11 * 3 = 33 站台，花费时间为 3；小扣从 33 号站台步行至 34 站台，花费时间为 4；小扣从 34 号站台搭乘 0 号公交至 3 * 34 = 102 站台，花费时间为 4；小扣从 102 号站台搭乘 1 号公交至 6 * 102 = 612 站台，花费时间为 7；最终小扣花费总时间为 26。 方法一：记忆化搜索了。杯赛时没做出来。不好想的地方在12行，往回退的时候。 123456789101112131415def busRapidTransit(self, target: int, inc: int, dec: int, jump: List[int], cost: List[int]) -&gt; int: @lru_cache(None) def dp(i): if i == 0: return 0 if i == 1: return inc ans = i * inc for bus, times in enumerate(jump): j, mod = divmod(i, times) ans = min(ans, mod*inc + cost[bus] + dp(j)) if mod: ans = min(ans, (times-mod)*dec + cost[bus] + dp(j+1)) return ans return dp(target) % (10**9+7) 877. Stone Game石头游戏，一共有偶数堆，并且总数为奇数。每次拿左或者右的一堆，每次拿都是最优解，问Alex先拿能否赢。原题12345678Input: piles = [5,3,4,5]Output: trueExplanation: Alex starts first, and can only take the first 5 or the last 5.Say he takes the first 5, so that the row becomes [3, 4, 5].If Lee takes 3, then the board is [4, 5], and Alex takes 5 to win with 10 points.If Lee takes the last 5, then the board is [3, 4], and Alex takes 4 to win with 9 points.This demonstrated that taking the first 5 was a winning move for Alex, so we return true. 方法一：还算简单的一个dp，488ms, beats40%。内存有点多120多M。思路是从两边到中间。 12345678def stoneGame(self, piles: List[int]) -&gt; bool: @lru_cache(None) def dp(i, j): if i == j: return 0 return max(piles[i] + dp(i+1, j), piles[j] + dp(i, j-1)) return dp(0, len(piles)-1) 方法二：迭代，不会用那么多的空间20M。不过过程不好想，从哪里开始，d表示段的长度，从最小的段开始。这里用了减法表示dp[i][j] 在piles[i]~piles[j]之间能领先多少。 123456789def stoneGame(self, p: List[int]) -&gt; bool: n = len(p) dp = [[0]*n for _ in range(n)] for i in range(n): dp[i][i] = p[i] for d in range(1, n): for i in range(n - d): dp[i][i+d] = max(p[i]-dp[i+1][i+d], p[i+d]-dp[i][i+d-1]) return dp[0][-1] &gt; 0 方法三：一维空间实现。这个方法好难想，dp[i] 表示以i为起点d为长度堆 也就是piles[i:i+d]最多能赢对手多少。 12345678def stoneGame(self, p: List[int]) -&gt; bool: n = len(p) dp = p[:] for d in range(1, n): for i in range(n - d): # print(i, d, dp, p[i]-dp[i+1], p[i+d]-dp[i]) dp[i] = max(p[i] - dp[i + 1], p[i + d] - dp[i]) return dp[0] &gt; 0 以[5,3,4,5]输出i, d ，dp是这样的。 1234560 1 [5, 3, 4, 5] 2 -21 1 [2, 3, 4, 5] -1 12 1 [2, 1, 4, 5] -1 10 2 [2, 1, 1, 5] 4 21 2 [4, 1, 1, 5] 2 40 3 [4, 4, 1, 5] 1 1 方法四：对于此题来说，堆为偶数个，和为奇数。那么将其分为两组，奇数索引组合偶数索引组，假设这两个人都按照这个拿，Alex先手总能拿到多的那个。因为Alex可以保证拿到多的那组，比如[5,3,4,5]奇数组的5+4&gt;5+3，那么在拿走第一个5，对手只能从两个偶数组选，而无论对手选哪个偶数，Alex总有下一个奇数组的数可选。这题曾经在知乎上看到过uwi在比赛中思考了1分多钟就写出了这样的答案，不愧为常年霸榜的选手。 12def stoneGame(self, p: List[int]) -&gt; bool: return True 300. Longest Increasing Subsequence最长的递增子序列长度。123Input: [10,9,2,5,3,7,101,18]Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. 方法一：首次AC的方法，时间O(n^2)。 123456789def lengthOfLIS(self, nums: List[int]) -&gt; int: # dp[i] means the ans of nums[:i] n = len(nums) dp = [1] * (n+1) for i in range(1, n): for j in range(i)[::-1]: if nums[j] &lt; nums[i]: dp[i] = max(dp[i], dp[j] + 1) return nums and max(dp) or 0 方法二：看了follow up: 有N*(logN)的方法，那么就往二分法和堆上想。这个二分法太难想了，创了一个缓冲数组用来记录当前的子序列。 123456789101112131415def lengthOfLIS(self, nums: List[int]) -&gt; int: tails = [0] * len(nums) size = 0 for num in nums: print(tails) lo, hi = 0, size while lo &lt; hi: mid = (lo+hi) // 2 if tails[mid] &lt; num: lo = mid + 1 else: hi = mid tails[lo] = num size = max(lo+1, size) return size 假设输入是[10,9,2,5,3,7,101,18,-1,0,1]，tails这样变化，当出现一个较小的数，找到位置并替换，这样tails有效的部分还是有序的。 1234567891011[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0][10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0][9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0][2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0][2, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0][2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0][2, 3, 7, 0, 0, 0, 0, 0, 0, 0, 0][2, 3, 7, 101, 0, 0, 0, 0, 0, 0, 0][2, 3, 7, 18, 0, 0, 0, 0, 0, 0, 0][-1, 3, 7, 18, 0, 0, 0, 0, 0, 0, 0][-1, 0, 7, 18, 0, 0, 0, 0, 0, 0, 0] 673. Number of Longest Increasing Subsequence求最长递增子序列的个数。和300很像，基于300上进行修改。方法一：基于300方法一进行修改，dp元素保存两个信息，一个是最大长度，一个是数量。思考的时候要想如果dp[-1][-1]不能直接求得值的话，要考虑重新遍历一遍。 12345678910111213def findNumberOfLIS(self, nums: List[int]) -&gt; int: n, longest = len(nums), 1 dp = [[1, 1] for _ in range(n)] for i in range(1, n): cur_long = 1 c = collections.defaultdict(int) for j in range(i): if nums[i] &gt; nums[j]: c[dp[j][0]] += dp[j][1] cur_long = max(cur_long, dp[j][0] + 1) dp[i] = [cur_long, max(c[cur_long-1], 1)] longest = max(longest, cur_long) return sum(cnt for l, cnt in dp if l==longest) 方法二：进行了一些优化。比方法一快了300ms，写完之后和评论区方法比较，明明是一样的，不知道为啥慢了100ms，后来一行一行代码进行替换，调了半天，发现注释部分的代码要慢100ms，刷新了我的认知，为什么数组下标取值会慢这么多？这也太玄学了。 12345678910111213141516def findNumberOfLIS(self, nums: List[int]) -&gt; int: n, max_for_all = len(nums), 1 dp = [[1, 1] for _ in range(n)] for i, num in enumerate(nums): max_len, count = 1, 0 for j in range(i): # if nums[j] &lt; nums[i]: if nums[j] &lt; num: if dp[j][0] + 1 &gt; max_len: max_len = dp[j][0] + 1 count = 0 if dp[j][0] == max_len - 1: count += dp[j][1] dp[i] = [max_len, max(count, dp[i][1])] max_for_all = max(max_len, max_for_all) return sum([item[1] for item in dp if item[0] == max_for_all]) 1594. Maximum Non Negative Product in a Matrix最大的从左上到右下的乘积。方法一：这题想着迭代方法，竞赛的时候差了一行代码，时间就到了。递归的思路好想。 12345678910111213141516def maxProductPath(self, g: List[List[int]]) -&gt; int: mod = 10**9 + 7 M, N = len(g), len(g[0]) @lru_cache(None) def dp(i, j): if i==0 and j==0: return g[0][0], g[0][0] if i&lt;0 or j&lt;0: return float('-inf'), float('inf') if g[i][j] == 0: return 0, 0 mx1, mn1 = dp(i-1, j) mx2, mn2 = dp(i, j-1) mx, mn = max(mx1, mx2)*g[i][j], min(mn1, mn2)*g[i][j] return (mx, mn) if g[i][j]&gt;0 else (mn, mx) mx, _ = dp(M-1, N-1) return mx % mod if mx&gt;=0 else -1 方法二：迭代的初识值没想好，想着赋值成(g[0][0], float(&#39;inf&#39;))了，实际上(g[0][0], g[0][0])就对了。 123456789101112131415161718def maxProductPath(self, g: List[List[int]]) -&gt; int: mod = 10**9 + 7 M, N = len(g), len(g[0]) default = (float('-inf'), float('inf')) dp = [[default]*N for _ in range(M)] dp[0][0] = (g[0][0], g[0][0]) for i in range(M): for j in range(N): if i==0 and j==0: continue cur = g[i][j] if cur == 0: dp[i][j] = 0, 0 continue mx1, mn1 = dp[i-1][j] if i else default mx2, mn2 = dp[i][j-1] if j else default mx, mn = max(mx1, mx2)*cur, min(mn1, mn2)*cur dp[i][j] = (mx, mn) if cur&gt;0 else (mn, mx) return dp[-1][-1][0] % mod if dp[-1][-1][0]&gt;=0 else -1]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（字符串篇）String]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AF%87%EF%BC%89String%2F</url>
    <content type="text"><![CDATA[14. Longest Common Prefix返回最长公共前缀字符串。原题 12Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]Output: &quot;fl&quot; 123456def longest_common_prefix(strs): if not strs: return '' from itertools import takewhile max_pre_len = len(list(takewhile(lambda x: len(set(x))==1, zip(*strs)))) return strs[0][:max_pre_len] 20. Valid Parentheses判断括号是否成对出现，并且嵌套正确。原题 1234Input: &quot;()[]&#123;&#125;&quot;Output: trueInput: &quot;&#123;[]&#125;&quot;Output: true 12345678910111213def is_valid(s): pairs = &#123;')': '(', '&#125;': '&#123;', ']': '['&#125; stack = [] for paren in s: if paren in pairs.values(): stack.append(paren) elif paren in pairs.keys(): if stack == [] or stack.pop() != pairs[paren]: return False else: return False return stack == [] 921. Minimum Add to Make Parentheses Valid给定一个只包含小括号的字符串。返回需要多少个”(“或”)”使其成为完整的括号表达式。原题12345678Input: &quot;())&quot;Output: 1Input: &quot;()))((&quot;Output: 4Input: &quot;()&quot;Output: 0Input: &quot;(((&quot;Output: 3 方法一：平衡问题。 12345678def minAddToMakeValid(self, S: str) -&gt; int: ans = bal = 0 for symbol in S: bal += 1 if symbol=='(' else -1 if bal == -1: ans += 1 bal += 1 return ans + bal 28. Implement strStr()实现index。原题12Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;Output: 2 12345678def str_index(haystack, needle): h = len(haystack) n = len(needle) for i in range(h-n+1): if haystack[i:i+n] == needle: return i else: return -1 38. Count and Say原题123451. 12. 113. 214. 12115. 111221 123456def countAndSay(self, n: int) -&gt; str: ans = '1' for _ in range(n-1): ans = ''.join(str(len(list(c)))+d for d, c in itertools.groupby(ans)) return ans 443. String Compression字符串压缩，实际是要将重复的字符串以个数来表示。要求O(1)空间复杂度，就地修改原数组。原题思路：看上去和38题差不多，但是有些不同，不同的地方在于如果个数为1，则不显示。个数为两位数，要显示两个元素。 123456Input = [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]Output = [&quot;a&quot;,&quot;2&quot;,&quot;b&quot;,&quot;2&quot;,&quot;c&quot;,&quot;3&quot;]Input = [&quot;a&quot;]Output = [&quot;a&quot;]Input = [&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;]Output = [&quot;a&quot;,&quot;b&quot;,&quot;1&quot;,&quot;2&quot;] 123456789101112def compress(self, chars: List[str]) -&gt; int: anchor, write = 0, 0 # anchor为每组连续的第一个位置。 for r, char in enumerate(chars): if r == len(chars)-1 or char != chars[r+1]: chars[write] = chars[anchor] write += 1 if r &gt; anchor: for digit in str(r - anchor + 1): chars[write] = digit write += 1 anchor = r + 1 return write 125. Valid Palindrome验证回文字符串，只判断字母数字，忽略大小写。原题12Input: &quot;A man, a plan, a canal: Panama&quot;Output: true 方法一：切片 123def is_palindrome(s): s_alnum = filter(str.isalnum, s.lower()) return s_alnum == s_alnum[::-1] 方法二：双指针 1234567def is_palindrome(s): s_alnum = list(filter(str.isalnum, s.lower())) mid = len(s_alnum) // 2 for i in range(mid): if s_alnum[i] != s_alnum[-i-1]: return False return True 680. Valid Palindrome II验证是否是回文数，只包含小写字母，但是允许最多去掉一个字母之后是回文数。原题123Input: &quot;abca&quot;Output: TrueExplanation: You could delete the character &apos;c&apos;. 方法一：一开始想的方法。切片由于可能i=0，所以必须反序切片再倒置。 12345678910111213141516171819def validPalindrome(self, s): i, res = self.is_palindrome(s) if res: return True else: _, s1 = self.is_palindrome(s[:i]+s[i+1:]) left = slice(0, -i-1) right = slice(-1, -i-1, -1) _, s2 = self.is_palindrome(s[left]+s[right][::-1]) return s1 or s2 def is_palindrome(self, s): mid = len(s) // 2 # print(s) for i in range(mid): if s[i] != s[-i-1]: # print('&#123;&#125; [&#123;&#125;] != [&#123;&#125;]'.format(s, s[i], s[-i-1])) return i, False return None, True 方法二：双指针方法。 12345678def validPalindrome(self, s): l, r = 0, len(s)-1 while l &lt; r: if s[l] != s[r]: one, two = s[l:r], s[l+1:r+1] return one==one[::-1] or two==two[::-1] l, r = l+1, r-1 return True 方法三：贪心解法，留坑。 151. Reverse Words in a String倒置一句话中的单词。原题12Input: &quot;the sky is blue&quot;,Output: &quot;blue is sky the&quot;. 12def reverse_words(s): return ' '.join(s.split()[::-1]) 344. Reverse String倒置字符串。原题12Input: &quot;A man, a plan, a canal: Panama&quot;Output: &quot;amanaP :lanac a ,nalp a ,nam A&quot; 123456def reverse_str(s): n = len(s) res = list(s) for i in range(n//2): res[i], res[-i-1] = res[-i-1], res[i] return ''.join(res) 242. Valid Anagram验证回文构词法，即两个字符串由同样个数的字符组成。原题12Input: s = &quot;anagram&quot;, t = &quot;nagaram&quot;Output: true 方法一： sort 12def is_anagram(s, t): return sorted(s) == sorted(t) 方法二：Counter 12345def is_anagram(s, t): from collections import Counter c1 = Counter(s) c2 = Counter(t) return c1 == c2 438. Find All Anagrams in a String找出字符串中所有的回文构词。原题方法一：有个小地方注意就是，如果计数为0要删除，否则等式将不成立。 1234567891011121314def findAnagrams(self, s, p): from collections import Counter ns, np = len(s), len(p) cur_c = Counter(s[:np-1]) c_p = Counter(p) res = [] for i in range(np-1, ns): cur_c[s[i]] += 1 if cur_c == c_p: res.append(i-np+1) cur_c[s[i-np+1]] -= 1 if cur_c[s[i-np+1]] == 0: del cur_c[s[i-np+1]] return res 3. Longest Substring Without Repeating Characters最长不含重复字符的子字符串。原题方法一：暴力法，果然超时了。 1234567def lengthOfLongestSubstring(self, s): max_len, n = 0, len(s) for i in range(n): for j in range(i+1, n+1): if len(s[i:j]) == len(set(s[i:j])): max_len = max(max_len, len(s[i:j])) return max_len 方法二：找到重复值时，更新start的值，为什么使用max，因为start有可能大于dic[s[end]]+1，比如当s=&#39;abba&#39;，end走到最后的时候，上一次start因为b做了更新变为了2。 12345678910def lengthOfLongestSubstring(self, s): res, start = 0, 0 dic = &#123;&#125; for end in range(len(s)): if s[end] in dic: start = max(start, dic[s[end]]+1) # start = dic[s[end]] + 1 dic[s[end]] = end res = max(res, end-start+1) return res 也可以把max判断放到条件里。 12345678910def lengthOfLongestSubstring(self, s): res, start = 0, 0 dic = &#123;&#125; for end in range(len(s)): if s[end] in dic and start &lt;= dic[s[end]]: start = dic[s[end]] + 1 else: res = max(res, end-start+1) dic[s[end]] = end return res 387. First Unique Character in a String返回第一个不重复的字符。原题1234s = &quot;leetcode&quot;return 0.s = &quot;loveleetcode&quot;,return 2. Time-O(N), Space-O(N)。暂时没发现更快的算法了。 1234567def firstUniqChar(self, s): from collections import Counter c = Counter(s) for i, ch in enumerate(s): if c[ch] == 1: return i return -1 58. Length of Last Word输入一个字符串，通过空格分割，然后返回最后一个单词的长度，空串不算。原题123456s = &quot;Hello World&quot;return 5s = &quot;a &quot;return 1s = &quot; &quot;return 0 方法一：直观的方法。 123456def lengthOfLastWord(self, s): ss = s.split(' ') for ch in ss[::-1]: if ch: return len(ch) return 0 方法二：使用列表生成式，理论上时间复杂度比上述方法稍微高一点，不过实际时间差不多，估计是list comprehension做了优化。 123def lengthOfLastWord(self, s): ss =[x for x in s.split(' ') if x] return len(ss[-1]) if ss else 0 205. Isomorphic Strings判断两个字符串是否具有一样的形式。s和t长度一样。原题12345678Input: s = &quot;egg&quot;, t = &quot;add&quot;Output: trueInput: s = &quot;foo&quot;, t = &quot;bar&quot;Output: falseInput: s = &quot;paper&quot;, t = &quot;title&quot;Output: true 方法一：使用dict保存每个字母的位置。这里使用了OrderedDict保存了values的顺序，也可以使用sorted对values排序。最后说明一下在Python3中需要使用list格式化一下，因为values()返回一个dict_values对象，而这个对象如果直接使用==判断，会返回False，即使有相同的值，这里还不清楚内部的__eq__方法是如何实现的。而在Python2中可以直接比较。 12345678def isIsomorphic(self, s, t): from collections import OrderedDict d1, d2 = OrderedDict(), OrderedDict() for i, val in enumerate(s): d1[val] = d1.get(val, []) + [i] for i, val in enumerate(t): d2[val] = d2.get(val, []) + [i] return list(d1.values()) == list(d2.values()) 方法二：使用zip并行输出。 12&gt;&gt;&gt; list(zip('paper', 'title'))[('p', 't'), ('a', 'i'), ('p', 't'), ('e', 'l'), ('r', 'e')] 12def isIsomorphic(self, s, t): return len(set(zip(s, t))) == len(set(s)) == len(set(t)) 方法三：两个字符串每个位置的字符，第一次出现的index是否相同。 123def isIsomorphic(self, s, t): # return [s.find(i) for i in s] == [t.find(j) for j in t] return list(map(s.find, s)) == list(map(t.find, t)) 方法四：setdeault妙用。Lee215。 1234567def isIsomorphic(self, s: str, t: str) -&gt; bool: def f(w): m = &#123;&#125; return [m.setdefault(c, len(m)) for c in w] return f(s) == f(t) 290. Word Pattern匹配字符串和空格分隔的字符串是否具有相同形式，此题和上一题相似，只不过将其中一个换成了数组。另一个区别是长度不一定相等。原题12Input: pattern = &quot;abba&quot;, str = &quot;dog cat cat dog&quot;Output: true 1234def wordPattern(self, pattern, str): s = pattern t = str.split() return list(map(s.find, s)) == list(map(t.index, t)) 12345def wordPattern(self, pattern, str): s = pattern t = str.split() return len(set(zip(s, t))) == len(set(s)) == len(set(t)) \ and len(s) == len(t) 1234567def wordPattern(self, pattern: str, str: str) -&gt; bool: def f(w): m = &#123;&#125; return [m.setdefault(c, len(m)) for c in w] return f(pattern) == f(str.split()) 890. Find and Replace Pattern找到和pattern一样模式的字符串。和290，205一样。原题12345Input: words = [&quot;abc&quot;,&quot;deq&quot;,&quot;mee&quot;,&quot;aqq&quot;,&quot;dkd&quot;,&quot;ccc&quot;], pattern = &quot;abb&quot;Output: [&quot;mee&quot;,&quot;aqq&quot;]Explanation: &quot;mee&quot; matches the pattern because there is a permutation &#123;a -&gt; m, b -&gt; e, ...&#125;. &quot;ccc&quot; does not match the pattern because &#123;a -&gt; c, b -&gt; c, ...&#125; is not a permutation,since a and b map to the same letter. 方法一：我使用zip和set来判断的。 1234567def findAndReplacePattern(self, words: List[str], pattern: str) -&gt; List[str]: def same(a, b): return len(set(a)) == len(set(b)) == len(set(zip(a, b))) return [word for word, p in zip(words, itertools.repeat(pattern)) if same(word, p)] 方法二：Lee215的方法。setdefault的妙用。 1234567def findAndReplacePattern(self, words: List[str], p: str) -&gt; List[str]: def F(w): m = &#123;&#125; return [m.setdefault(c, len(m)) for c in w] return [w for w in words if F(w) == F(p)] 917. Reverse Only Letters倒置一个字符串的字母。原题12345Input: &quot;ab-cd&quot;Output: &quot;dc-ba&quot;Input: &quot;a-bC-dEf-ghIj&quot;Output: &quot;j-Ih-gfE-dCba&quot; 注意：不能使用l &lt;= r作为条件，因为会打乱正确结果的排序。输出&quot;dcb-a&quot;。 123456789101112def reverseOnlyLetters(self, S): l, r = 0, len(S)-1 res = list(S) while l &lt; r: while l&lt;r and not res[l].isalpha(): l += 1 while l&lt;r and not res[r].isalpha(): r -= 1 res[l], res[r] = res[r], res[l] l += 1 r -= 1 return ''.join(res) 345.Reverse Vowels of a String倒置一个字符串中的元音字母。原题1234Example 2:Input: &quot;leetcode&quot;Output: &quot;leotcede&quot; 方法一：和917题一样，换汤不换药。只需定义一个vowels={&#39;a&#39;, &#39;e&#39;, &#39;i&#39;, &#39;o&#39;, &#39;u&#39;}然后条件改成while l&lt;r and res[l].lower() not in vowels:，提交了一下beat有68%左右，应该还有更效率的方法。 方法二：改了一下，不再使用lower方法了，把大写字母加上，beat变为99.88%。 12345678910111213def reverseVowels(self, s): l, r = 0, len(s)-1 vowels = set(list('aeiouAEIOU')) res = list(s) while l &lt; r: while l&lt;r and res[l] not in vowels: l += 1 while l&lt;r and res[r] not in vowels: r -= 1 res[l], res[r] = res[r], res[l] l += 1 r -= 1 return ''.join(res) 方法三：正则 1234def reverseVowels(self, s): vowels = re.findall('(?i)[aeiou]', s) # (?i)表示忽略大小写 # repl参数每次返回一个值，用来替换s匹配pattern的字符。 return re.sub('(?i)[aeiou]', lambda m: vowels.pop(), s) 383. Ransom Note判断是否magazine可以构成ransomNote。原题123canConstruct(&quot;a&quot;, &quot;b&quot;) -&gt; falsecanConstruct(&quot;aa&quot;, &quot;ab&quot;) -&gt; falsecanConstruct(&quot;aa&quot;, &quot;aab&quot;) -&gt; true 方法一：使用count。 12345def canConstruct(self, ransomNote, magazine): for item in set(ransomNote): if magazine.count(item) &lt; ransomNote.count(item): return False return True 方法二：one-liner. 123def canConstruct(self, ransomNote, magazine): return all(ransomNote.count(char) &lt;= magazine.count(char) for char in set(ransomNote)) 方法三：Counter。时间复杂度比二稍高。 123def canConstruct(self, ransomNote, magazine): from collections import Counter return not Counter(ransomNote) - Counter(magazine) 925. Long Pressed Name说有这么一个破键盘，老是连键，有时候打一个字母c，出来好几个。给定一个目标字符串和打出来的字符串，判断是否是这个破键盘输出的。原题1234567Input: name = "alex", typed = "aaleex"Output: trueExplanation: 'a' and 'e' in 'alex' were long pressed.Input: name = "saeed", typed = "ssaaedd"Output: falseExplanation: 'e' must have been pressed twice, but it wasn't in the typed output. 思路：一开始还想用Counter，后来发现不对，因为它将所有的一样的字符聚合到了一起。所以此题可以使用groupby 1234567891011def isLongPressedName(self, name, typed): from itertools import groupby name_groups = [(ch, len(list(g))) for ch, g in groupby(name)] typed_groups = [(ch, len(list(g))) for ch, g in groupby(typed)] if len(typed_groups) &lt; len(name_groups): return False for i in range(len(name_groups)): if typed_groups[i][0] != name_groups[i][0] or \ typed_groups[i][1] &lt; name_groups[i][1]: return False return True 方法二：简单的写法。 12345678def isLongPressedName(self, name: str, typed: str) -&gt; bool: ngroups = itertools.groupby(name) tgroups = itertools.groupby(typed) for (nl, nc), (tl, tc) in itertools.zip_longest( ngroups, tgroups, fillvalue=('~', [])): if nl != tl or len(list(nc)) &gt;len(list(tc)): return False return True 929. Unique Email Addresses统计不同的email地址。原题123456789def numUniqueEmails(self, emails): res = set() for email in emails: local, domain = email.split('@') if '+' in local: local = local[:local.index('+')] local = local.replace('.', '') res.add((local, domain)) return len(res) 409. Longest Palindrome给你一堆字符串，返回用它组成的最长的回文串的长度，可以不使用所有的字符。原题方法一：每对一样的数字可以放在两边来组成回文。 1234567def longestPalindrome(self, s): from collections import Counter c = Counter(s) res = 0 for count in c.values(): res += count // 2 return res*2 + (len(s) &gt; res*2) 方法二：从奇数的角度考虑。 1234def longestPalindrome(self, s): from collections import Counter odds = sum(v &amp; 1 for v in Counter(s).values()) return len(s) - odds + bool(odds) # 如果有奇数，总能将其放到中间 434. Number of Segments in a String统计字符串中有多少个以空格分割的字符串。原题方法一：Time-O(n), Space-O(1) 123456def countSegments(self, s): segment_count = 0 for i in range(len(s)): if (i == 0 or s[i-1] == ' ') and s[i] != ' ': segment_count += 1 return segment_count 方法二： 12def countSegments(self, s): return len(s.split()) 500. Keyboard Row输入一个字符串数组，返回字符在键盘同一行的字符串。原题12Input: [&quot;Hello&quot;, &quot;Alaska&quot;, &quot;Dad&quot;, &quot;Peace&quot;]Output: [&quot;Alaska&quot;, &quot;Dad&quot;] 1234567891011class Solution: def findWords(self, words): self.first = &#123;'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P'&#125; self.second = &#123;'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L'&#125; self.third = &#123;'Z', 'X', 'C', 'V', 'B', 'N', 'M'&#125; return list(filter(self.same_line, words)) def same_line(self, word): return set(word.upper()) &lt;= set(self.first) or \ set(word.upper()) &lt;= set(self.second) or \ set(word.upper()) &lt;= set(self.third) 520. Detect Capital判断一个字符串的大写是否使用正确。要么全大写，要么全小写，或者首字母大写。原题12Input: &quot;USA&quot;Output: True 方法一：太简单了，一下子就写出来了，看评论居然好多人不知道istitle。 12def detectCapitalUse(self, word): return word.islower() or word.isupper() or word.istitle() 541. Reverse String II按照2k的长度划分一个字符串，把其中每段前k个字符倒置。原题12Input: s = &quot;abcdefg&quot;, k = 2Output: &quot;bacdfeg&quot; 方法一：比较简单的一题，使用Python的切片。 12345678def reverseStr(self, s, k): letters = list(s) n = len(letters) # for i in range(n//(2*k)+1): # letters[2*k*i:k+2*k*i] = reversed(letters[2*k*i:k+2*k*i]) for i in range(0, n, 2*k): letters[i:k+i] = reversed(letters[i:k+i]) return ''.join(letters) 551. Student Attendance Record I判断一个学生是否有奖励，缺席次数小于等于一天，没有三次连续的迟到。原题12Input: &quot;PPALLP&quot;Output: True 12def checkRecord(self, s): return s.count('A')&lt;= 1 and 'LLL' not in s 557. Reverse Words in a String III倒置一句话中的每个单词。所有单词均已一个空格分隔。原题12Input: &quot;Let&apos;s take LeetCode contest&quot;Output: &quot;s&apos;teL ekat edoCteeL tsetnoc&quot; 12def reverseWords(self, s): return ' '.join([word[::-1] for word in s.split()]) 657. Robot Return to Origin机器人是否能回到原点。’UDLR’分别表示上下左右，每次移动的距离一样。原题123Input: &quot;UD&quot;Output: true Explanation: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true. 方法一：就是看上下和左右的次数是否一样。此题过于简单。 123def judgeCircle(self, moves): return moves.count('L') == moves.count('R') and \ moves.count('U') == moves.count('D') 1234def judgeCircle(self, moves): from collections import Counter c = Counter(moves) return c['U'] == c['D'] and c['L'] == c['R'] 696. Count Binary Substrings二进制字符串计数，有多少个连续的子字符串，由相同的0和1组成，如’10’，’1100’。原题1234567Input: &quot;00110011&quot;Output: 6Explanation: There are 6 substrings that have equal number of consecutive 1&apos;s and 0&apos;s: &quot;0011&quot;, &quot;01&quot;, &quot;1100&quot;, &quot;10&quot;, &quot;0011&quot;, and &quot;01&quot;.Notice that some of these substrings repeat and are counted the number of times they occur.Also, &quot;00110011&quot; is not a valid substring because all the 0&apos;s (and 1&apos;s) are not grouped together. 方法一：正则要比groupby快. 12345def countBinarySubstrings(self, s): from itertools import groupby # groups = [len(list(v)) for _, v in groupby(s)] groups = list(map(len, re.findall('0+|1+', s))) return sum(min(a, b) for a, b in zip(groups, groups[1:])) 方法二：变量，常数空间复杂度。 123456789def countBinarySubstrings(self, s): res, prev, cur = 0, 0, 1 for i in range(1, len(s)): if s[i] != s[i-1]: res += min(prev, cur) prev, cur = cur, 1 else: cur += 1 return res + min(prev, cur) 709. To Lower Case实现字符串的lower方法。原题12Input: &quot;Hello&quot;Output: &quot;hello&quot; 123def toLowerCase(self, str): return ''.join(chr(ord(c)+32) if 65&lt;=ord(c)&lt;=90 else c for c in str) 771. Jewels and Stones判断S里有多少个在J里，J为不重复元素。原题12Input: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;Output: 3 方法一：使用set. 123def numJewelsInStones(self, J: 'str', S: 'str') -&gt; 'int': jewels = set(J) return sum(s in jewels for s in S) 方法二：count. count的值只会是0和1，因为J没有重复元素。由于这个特性，所以反过来也是一样。 123def numJewelsInStones(self, J: 'str', S: 'str') -&gt; 'int': # return sum(map(J.count, S)) return sum(map(S.count, J)) 784. Letter Case Permutation字母组合，给定一个字符串，其中的字母可大写可小写，返回所有可能的字符串。原题123456789Examples:Input: S = &quot;a1b2&quot;Output: [&quot;a1b2&quot;, &quot;a1B2&quot;, &quot;A1b2&quot;, &quot;A1B2&quot;]Input: S = &quot;3z4&quot;Output: [&quot;3z4&quot;, &quot;3Z4&quot;]Input: S = &quot;12345&quot;Output: [&quot;12345&quot;] 方法一：提取字母，然后format。 1234567def letterCasePermutation(self, S: 'str') -&gt; 'List[str]': letters = ''.join(x for x in S if x.isalpha()) s = re.sub(r'[A-Za-z]', '&#123;&#125;', S) ans = [''] for l in letters: ans = [pre+x for pre in ans for x in (l.lower(), l.upper())] return [s.format(*f) for f in ans] 方法二：一开始被题目误导了，以为是排列，后来想到了笛卡尔乘积，但是没想到可以这样写。 1234def letterCasePermutation(self, S: 'str') -&gt; 'List[str]': L = ((s.lower(), s.upper()) if s.isalpha() else s for s in S) # [('a', 'A'), '1', ('b', 'B'), '2'] return [''.join(c) for c in itertools.product(*L)] 788. Rotated Digits可旋转的数字，说把一个数的所有数字旋转180度，是一个正确的数字。并且和原来不同。给定一个N，返回1~N所有这样的数的个数。原题123456Example:Input: 10Output: 4Explanation: There are four good numbers in the range [1, 10] : 2, 5, 6, 9.Note that 1 and 10 are not good numbers, since they remain unchanged after rotating. 12345def rotatedDigits(self, N: 'int') -&gt; 'int': changed = &#123;'2', '5', '6', '9'&#125; valid = changed | &#123;'0', '1', '8'&#125; return sum(bool(set(str(i))&lt;=valid and set(str(i))&amp;changed) for i in range(1, N+1)) 796. Rotate String判断一个字符串A是否可以旋转成B。原题1234567Example 1:Input: A = &apos;abcde&apos;, B = &apos;cdeab&apos;Output: trueExample 2:Input: A = &apos;abcde&apos;, B = &apos;abced&apos;Output: false 方法一：Brute Force. Time: O(N²), Space: O(N²). 12345def rotateString(self, A: 'str', B: 'str') -&gt; 'bool': for k in range(len(A)): if A[-k:] + A[:-k] == B: return True return False if A else A==B 方法二：Time O(N²). Space O(N). 12def rotateString(self, A: 'str', B: 'str') -&gt; 'bool': return len(A)==len(B) and B in A*2 方法三：KMP算法。留坑。 方法四：Rolling Hash算法。留坑。 804. Unique Morse Code Words不重复的莫斯密码，给定一句话，求不重复的单词的莫斯密码个数。原题1234567891011Example:Input: words = [&quot;gin&quot;, &quot;zen&quot;, &quot;gig&quot;, &quot;msg&quot;]Output: 2Explanation: The transformation of each word is:&quot;gin&quot; -&gt; &quot;--...-.&quot;&quot;zen&quot; -&gt; &quot;--...-.&quot;&quot;gig&quot; -&gt; &quot;--...--.&quot;&quot;msg&quot; -&gt; &quot;--...--.&quot;There are 2 different transformations, &quot;--...-.&quot; and &quot;--...--.&quot;. 1234567def uniqueMorseRepresentations(self, words: 'List[str]') -&gt; 'int': codes = [".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."] # morse = dict(zip(string.ascii_lowercase, codes)) # seen = &#123;''.join(morse[c] for c in word) for word in words&#125; seen = &#123;''.join(codes[ord(c)-ord('a')] for c in word) for word in words&#125; return len(seen) 806. Number of Lines To Write String单词换行，已知每个字母的宽度，每100一换行，写不下一个字母时，换行，最一个字符串需要多少行和末尾行的宽度。原题12345678Example :Input: widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]S = &quot;abcdefghijklmnopqrstuvwxyz&quot;Output: [3, 60]Explanation: All letters have the same length of 10. To write all 26 letters,we need two full lines and one line with 60 units. 123456789def numberOfLines(self, widths: 'List[int]', S: 'str') -&gt; 'List[int]': width = dict(zip(string.ascii_letters, widths)) lines, line = 1, 0 for s in S: if line + width[s] &gt; 100: lines += 1 line = 0 line += width[s] return lines, line 819. Most Common Word最常见的单词，从输入的段落中找到出现频率最高并且不在banned列表中的单词。原题12345678910Input: paragraph = &quot;Bob hit a ball, the hit BALL flew far after it was hit.&quot;banned = [&quot;hit&quot;]Output: &quot;ball&quot;Explanation: &quot;hit&quot; occurs 3 times, but it is a banned word.&quot;ball&quot; occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. Note that words in the paragraph are not case sensitive,that punctuation is ignored (even if adjacent to words, such as &quot;ball,&quot;), and that &quot;hit&quot; isn&apos;t the answer even though it occurs more because it is banned. 方法一：一开始写的方法。 12345678def mostCommonWord(self, paragraph: 'str', banned: 'List[str]') -&gt; 'str': words = re.split(r'[!?\',;. ]', paragraph.lower()) c = collections.Counter(words) banned = set(banned) for word, count in c.most_common(): if word and word not in banned: return word return '' 方法二：上述方法的优化。 12345def mostCommonWord(self, paragraph: 'str', banned: 'List[str]') -&gt; 'str': words = re.findall(r'\w+', paragraph.lower()) banset = set(banned) return collections.Counter( (w for w in words if w not in banset)).most_common(1)[0][0] 821. Shortest Distance to a Character根据已知字符串S, 求目标字符C和左右index最近的距离。原题12Input: S = &quot;loveleetcode&quot;, C = &apos;e&apos;Output: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0] 方法一：前后遍历两次，分别求距离。本想通过一次，结果实现过于繁琐。 12345678def shortestToChar(self, S: 'str', C: 'str') -&gt; 'List[int]': n = len(S) ans = [0 if x == C else n for x in S] pos = -n for i in list(range(n)) + list(range(n)[::-1]): if ans[i] == 0: pos = i ans[i] = min(ans[i], abs(pos-i)) return ans 824. Goat Latin山羊拉丁口音，把一句话中的每个单词根据规则，生成一句新的话。原题12Input: &quot;The quick brown fox jumped over the lazy dog&quot;Output: &quot;heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa&quot; 123456789def toGoatLatin(self, S: 'str') -&gt; 'str': vowels = set('aeiouAEIOU') words = [] for i, word in enumerate(S.split(), start=1): if word[0] not in vowels: word = word[1:] + word[0] word += 'ma'+'a'*i words.append(word) return ' '.join(words) 844. Backspace String Compare退格键字符串比较。比较两个带有退格#的字符串，判断最后输出是否一致。原题123Input: S = &quot;ab#c&quot;, T = &quot;ad#c&quot;Output: trueExplanation: Both S and T become &quot;ac&quot;. 方法一：首先想到stack. 123456789101112def backspaceCompare(self, S: 'str', T: 'str') -&gt; 'bool': def type_text(s): stack = [] for c in s: if c != '#': stack.append(c) elif stack: stack.pop() return stack return type_text(S) == type_text(T) 方法二：two pointers. Space Complexity: O(1). 12345678910111213def backspaceCompare(self, S: 'str', T: 'str') -&gt; 'bool': def type_c(s): skip = 0 for x in reversed(s): if x == '#': skip += 1 elif skip: skip -= 1 else: yield x return all(x==y for x, y in itertools.zip_longest(type_c(S), type_c(T))) 方法三：这个方法也很有意思，理论上效率不高，但实际上也并无差别。使用reduce然后切片去掉上次结果的末尾元素。最后一个空串的参数表明了一个初始化参数。如果没有它，#a#c的结果会变成#c。因为第一次循环相当于back(&#39;#&#39;, &#39;a&#39;)所以第一个#会一直保留。 1234def backspaceCompare(self, S: 'str', T: 'str') -&gt; 'bool': from functools import reduce back = lambda res, c: res[:-1] if c == '#' else res + c return reduce(back, S, '') == reduce(back, T, '') 查看文档中reduce实现： 123456789def reduce(function, iterable, initializer=None): it = iter(iterable) if initializer is None: value = next(it) else: value = initializer for element in it: value = function(value, element) return value 859. Buddy Strings好友字符串。指A通过一次交换两个字符变成B。判断是否是好友字符串。原题1234Input: A = &quot;ab&quot;, B = &quot;ba&quot;Output: trueInput: A = &quot;ab&quot;, B = &quot;ab&quot;Output: false 方法一：Brute Force. 效率很低。 12345678910111213def buddyStrings(self, A: 'str', B: 'str') -&gt; 'bool': if len(A) != len(B) or set(A) != set(B): return False seen = set() for i in range(len(A)): if A[i] not in seen: seen.add(A[i]) else: continue for j in range(i+1, len(A)): if A[:i] + A[j] + A[i+1:j] + A[i] + A[j+1:] == B: return True return False 方法二：此题分为两种情况，一种是A==B，此时判断是否有重复元素；另一种找到不相等的对，有且只能有一对。结尾len(pairs)的判断虽然显得有些重复，不过可以在某些情况提前退出提高效率，所以没有写成列表生成式的形式。 1234567891011def buddyStrings(self, A: 'str', B: 'str') -&gt; 'bool': if len(A) != len(B): return False if A == B: return len(A) != len(set(A)) else: pairs = [] for a, b in zip(A, B): if a != b: pairs.append((a, b)) if len(pairs) &gt;= 3: return False return len(pairs) == 2 and pairs[0] == pairs[1][::-1] 893. Groups of Special-Equivalent Strings特殊等价字符串组。这题Contest就没做出来，描述有问题，讨论区一堆diss的评论。总的来说就是把A的字符串分组，能够改变偶数位的字符，或奇数位的字符能使之相等的为一组，求一共有多少个组。原题1234567891011Input: [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;a&quot;,&quot;c&quot;,&quot;c&quot;]Output: 3Explanation: 3 groups [&quot;a&quot;,&quot;a&quot;], [&quot;b&quot;], [&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]Input: [&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]Output: 3Explanation: 3 groups [&quot;abc&quot;,&quot;cba&quot;], [&quot;acb&quot;,&quot;bca&quot;], [&quot;bac&quot;,&quot;cab&quot;]Input: [&quot;abcd&quot;,&quot;cdab&quot;,&quot;adcb&quot;,&quot;cbad&quot;]Output: 1Explanation: 1 group [&quot;abcd&quot;,&quot;cdab&quot;,&quot;adcb&quot;,&quot;cbad&quot;] 方法一：数组保留索引。 12345678def numSpecialEquivGroups(self, A: 'List[str]') -&gt; 'int': def count(A): ans = [0] * 52 for i, letter in enumerate(A): ans[ord(letter) - ord('a') + 26 * (i%2)] += 1 return tuple(ans) return len(&#123;count(word) for word in A&#125;) 方法二：切片字符串排序。 123def numSpecialEquivGroups(self, A: 'List[str]') -&gt; 'int': return len(&#123;''.join(sorted(s[0::2])) + ''.join(sorted(s[1::2])) for s in A&#125;) 1003. Check If Word Is Valid After Substitutions判断字符串是否由abc无限插入得到。原题12345Input: &quot;aabcbc&quot;Output: trueExplanation: We start with the valid string &quot;abc&quot;.Then we can insert another &quot;abc&quot; between &quot;a&quot; and &quot;bc&quot;, resulting in &quot;a&quot; + &quot;abc&quot; + &quot;bc&quot; which is &quot;aabcbc&quot;. 12345678def isValid(self, S: str) -&gt; bool: while len(S) &gt;= 3: if 'abc' in S: i = S.index('abc') S = S[:i] + S[i+3:] else: return False return S == '' 17. Letter Combinations of a Phone Number电话的数字可以组成的字符串组合。原题12Input: &quot;23&quot;Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. 方法一：recursive. 123456789101112def letterCombinations(self, digits: str) -&gt; List[str]: phone = &#123;'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'&#125; if not digits: return [] def helper(digits): if not digits: return [''] return [c + suffix for c in phone[digits[0]] for suffix in helper(digits[1:])] return helper(digits) 方法二：使用product。 12345def letterCombinations(self, digits: str) -&gt; List[str]: phone = &#123;'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'&#125; from itertools import product return digits and list(map(''.join, product(*(phone[d] for d in digits)))) or [] 方法三：实现product。 12345678def letterCombinations(self, digits: str) -&gt; List[str]: phone = &#123;'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'&#125; ans = [''] letters = (phone[d] for d in digits) for key in letters: ans = [x+char for x in ans for char in key] return digits and ans or [] 方法四：评论里看到的reduce方法。 123456def letterCombinations(self, digits: str) -&gt; List[str]: from functools import reduce phone = &#123;'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'&#125; if not digits: return [] return reduce(lambda acc, digit: [x + y for x in acc for y in phone[digit]], digits, ['']) 方法五：Solution中的回溯法。 1234567891011121314def letterCombinations(self, digits: str) -&gt; List[str]: phone = &#123;'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'&#125; def backtrack(combination, digits): if not digits: ans.append(combination) else: for letter in phone[digits[0]]: backtrack(combination + letter, digits[1:]) ans = [] if digits: backtrack('', digits) return ans 1023. Binary String With Substrings Representing 1 To N二进制子串，从1到N。原题12Input: S = &quot;0110&quot;, N = 3Output: true 方法一：暴力法。 12def queryString(self, S: str, N: int) -&gt; bool: return all(bin(n)[2:] in S for n in range(1, N+1)) 方法二：对于任意的i&lt;N/2的数i*2的二进制表示形式一定包含i。因为左移一位。 12def queryString(self, S: str, N: int) -&gt; bool: return all(bin(n)[2:] in S for n in range(N, N//2, -1)) 482. License Key Formatting根据要求格式化字符串。原题12Input: S = &quot;5F3Z-2e-9-w&quot;, K = 4Output: &quot;5F3Z-2E9W&quot; 方法一：使用内置方法。 123def licenseKeyFormatting(self, S: str, K: int) -&gt; str: s = S.replace('-', '').upper()[::-1] return '-'.join(s[i:i+K] for i in range(0, len(s), K))[::-1] 方法二：完整实现。one-pass. 12345678def licenseKeyFormatting(self, S: str, K: int) -&gt; str: s = S.replace('-', '').upper() ans, n = '', len(s) f = n % K ans += s[:f] for i in range(f, n, K): ans += '-' + s[i:i+K] return ans.strip('-') 1071. Greatest Common Divisor of Strings最长公共被整除的字符串。原题12345Input: str1 = &quot;ABCABC&quot;, str2 = &quot;ABC&quot;Output: &quot;ABC&quot;Input: str1 = &quot;ABABAB&quot;, str2 = &quot;ABAB&quot;Output: &quot;AB&quot; 方法一：这里我是从小找一个公共串，并记录重复次数。再从两个重复的次数中取最大公约数。 12345678910111213141516def gcdOfStrings(self, str1: str, str2: str) -&gt; str: n1, n2 = len(str1), len(str2) from math import gcd def repeat(word): n = len(word) for i in range(1, n//2+1): for k in range(i): if len(&#123;word[j] for j in range(k, n, i)&#125;) != 1: break else: return word[:i], n // i return '', 1 common1, num1 = repeat(str1) common2, num2 = repeat(str2) return gcd(num1, num2) * common1 方法二：递归。 12345678910def gcdOfStrings(self, str1: str, str2: str) -&gt; str: if len(str1) == len(str2): return str1 if str1==str2 else '' else: if len(str1) &lt; len(str2): str1, str2 = str2, str1 if str1[:len(str2)] == str2: return self.gcdOfStrings(str1[len(str2):], str2) else: return '' 1156. Swap For Longest Repeated Character Substring最多交换一次两个字符，求连续重复的字符最大个数是多少。原题123456Input: text = &quot;aaabaaa&quot;Output: 6Explanation: Swap &apos;b&apos; with the last &apos;a&apos; (or the first &apos;a&apos;), and we get longest repeated character substring &quot;aaaaaa&quot;, which its length is 6.Input: text = &quot;aaabbaaa&quot;Output: 4 方法一：竞赛没在规定时间内完成，思路是对的，使用groupby，第二个例子那里小细节没有处理好。 123456789def maxRepOpt1(self, text: str) -&gt; int: gg = [(d, len(list(g))) for d, g in itertools.groupby(text)] count = collections.Counter(text) ans = max(min(c+1, count[k]) for k, c in gg) for i in range(1, len(gg)-1): if gg[i-1][0]==gg[i+1][0] and gg[i][1]==1: ans = max(ans, min(gg[i-1][1]+gg[i+1][1]+1, count[gg[i+1][0]])) return ans 1106. Parsing A Boolean Expression转换&amp;|~操作符，返回结果。原题12Input: expression = &quot;|(&amp;(t,f,t),!(t))&quot;Output: false 方法一：这题很有意思，马上就能想到用eval来作弊，但是~没有处理好，看了Lee神答案后恍然大悟。这里需要将非符号转成any数组。 1234def parseBoolExpr(self, expression: str) -&gt; bool: t, f = True, False expression = expression.replace('!', 'not |').replace('&amp;(', 'all([').replace('|(', 'any([').replace(')', '])') return eval(expression) 1408. String Matching in an Array找出字符串是其它子串的字符串。原题1234Input: words = [&quot;mass&quot;,&quot;as&quot;,&quot;hero&quot;,&quot;superhero&quot;]Output: [&quot;as&quot;,&quot;hero&quot;]Explanation: &quot;as&quot; is substring of &quot;mass&quot; and &quot;hero&quot; is substring of &quot;superhero&quot;.[&quot;hero&quot;,&quot;as&quot;] is also a valid answer. 方法一：排序暴力法。 123456789def stringMatching(self, words: List[str]) -&gt; List[str]: words.sort(key=len) ans = [] for i in range(len(words)-1): for j in range(i+1, len(words)): if words[i] in words[j]: ans.append(words[i]) break return ans 791. Custom Sort String自定义排序字符串，按照S中字母顺序排序T。原题12345678Example :Input: S = &quot;cba&quot;T = &quot;abcd&quot;Output: &quot;cbad&quot;Explanation: &quot;a&quot;, &quot;b&quot;, &quot;c&quot; appear in S, so the order of &quot;a&quot;, &quot;b&quot;, &quot;c&quot; should be &quot;c&quot;, &quot;b&quot;, and &quot;a&quot;. Since &quot;d&quot; does not appear in S, it can be at any position in T. &quot;dcba&quot;, &quot;cdba&quot;, &quot;cbda&quot; are also valid outputs. 1234def customSortString(self, S: str, T: str) -&gt; str: # return ''.join(sorted(T, key=S.find)) d = &#123;k: i for i, k in enumerate(S)&#125; return ''.join(sorted(T, key=lambda x: d.get(x, -1))) 678. Valid Parenthesis String匹配括号，*可以表示左右或者空。原题12Input: &quot;(*))&quot;Output: True 方法一：这题一开始想歪了，想用栈和递归的方式实现，结果没想出来。这里用了Lee215的方法。cmin表示至少需要), cmax表示最多。 123456789101112131415def checkValidString(self, s: str) -&gt; bool: cmin = cmax = 0 for c in s: if c == '(': cmin += 1 cmax += 1 elif c == ')': cmax -= 1 cmin = max(cmin - 1, 0) elif c == '*': cmax += 1 cmin = max(cmin - 1, 0) if cmax &lt; 0: return False return cmin == 0 1419. Minimum Number of Frogs Croaking有n个青蛙🐸一起叫，叫声混到了一起，求最小青蛙的个数。原题12345Input: croakOfFrogs = &quot;crcoakroak&quot;Output: 2 Explanation: The minimum number of frogs is two. The first frog could yell &quot;crcoakroak&quot;.The second frog could yell later &quot;crcoakroak&quot;. 方法一：记录每个字母的个数，注意叫的过程中字母数量的顺序。inuse表示同时叫的青蛙。 123456789101112131415161718def minNumberOfFrogs(self, croakOfFrogs: str) -&gt; int: from collections import defaultdict c = defaultdict(int) inuse = 0 ans = 0 for f in croakOfFrogs: if f == 'c': inuse += 1 elif f == 'k': inuse -= 1 c[f] += 1 ans = max(ans, inuse) if not c['c'] &gt;= c['r'] &gt;= c['o'] &gt;= c['a'] &gt;= c['k']: return -1 if inuse==0 and len(set(c.values()))==1: return ans else: return -1 1358. Number of Substrings Containing All Three Characters包含’abc’子串的个数。原题123Input: s = &quot;abcabc&quot;Output: 10Explanation: The substrings containing at least one occurrence of the characters a, b and c are &quot;abc&quot;, &quot;abca&quot;, &quot;abcab&quot;, &quot;abcabc&quot;, &quot;bca&quot;, &quot;bcab&quot;, &quot;bcabc&quot;, &quot;cab&quot;, &quot;cabc&quot; and &quot;abc&quot; (again). 方法一：滑动窗口。记录abc的数量，当无法组成时退出，此时最左的索引为i-1。 12345678910def numberOfSubstrings(self, s: str) -&gt; int: res = i = 0 count = &#123;c: 0 for c in 'abc'&#125; for j in range(len(s)): count[s[j]] += 1 while all(count.values()): count[s[i]] -= 1 i += 1 res += i return res 方法二：数学方法。以右侧点为准，向左累加。 1234567def numberOfSubstrings(self, s: str) -&gt; int: res = 0 last = [-1] * 3 for i, c in enumerate(s): last[ord(c) - 97] = i res += 1 + min(last) return res 1309. Decrypt String from Alphabet to Integer Mapping数字到字母的一个映射。原题123Input: s = &quot;10#11#12&quot;Output: &quot;jkab&quot;Explanation: &quot;j&quot; -&gt; &quot;10#&quot; , &quot;k&quot; -&gt; &quot;11#&quot; , &quot;a&quot; -&gt; &quot;1&quot; , &quot;b&quot; -&gt; &quot;2&quot;. 方法一：比赛时的答案过于繁琐。 12def freqAlphabets(self, s: str) -&gt; str: return ''.join(chr(int(i[:2]) + 96) for i in re.findall(r'\d\d#|\d', s)) 1545. Find Kth Bit in Nth Binary String找到第n个字符串的第k位。原题 S1 = &quot;0&quot; S2 = &quot;0**1**1&quot; S3 = &quot;011**1**001&quot; S4 = &quot;0111001**1**0110001&quot; 123Input: n = 3, k = 1Output: &quot;0&quot;Explanation: S3 is &quot;0111001&quot;. The first bit is &quot;0&quot;. 方法一：比赛时是按照题意的方式写的，效率慢了10倍，这题用逆向思维。by@lee215. 1234567891011def findKthBit(self, n: int, k: int) -&gt; str: flip = 0 l = 2 ** n - 1 while k &gt; 1: if k == l // 2 + 1: return str(1 ^ flip) if k &gt; l // 2: k = l + 1 - k flip = 1 - flip l //= 2 return str(flip) 777. Swap Adjacent in LR String转换成目标字符串，可以将”XL”变成”LX”，或者将”RX”变成”XR”。原题123456789Input: start = &quot;RXXLRXRXL&quot;, end = &quot;XRLXXRRLX&quot;Output: TrueExplanation:We can transform start to end following these steps:RXXLRXRXL -&gt;XRXLRXRXL -&gt;XRLXRXRXL -&gt;XRLXXRRXL -&gt;XRLXXRRLX 方法一：一开始想错了，以为互换倒过来也行。这个变换有点像将L向左移，R向右移，而且不能跨越其它的R或者L也就是可以将X想象成空位。所以这里计算时要将LR一起考虑。 123456789def canTransform(self, start: str, end: str) -&gt; bool: left = [(c, i) for i, c in enumerate(start) if c!='X'] right = [(c, i) for i, c in enumerate(end) if c!='X'] if len(left) != len(right): return False for (c1, i), (c2, j) in zip(left, right): if c1 != c2: return False if c1 == 'L' and i &lt; j: return False if c1 == 'R' and i &gt; j: return False return True 539. Minimum Time Difference两个时间的最小分钟差的绝对值。原题12Input: [&quot;23:59&quot;,&quot;00:00&quot;]Output: 1 方法一：Lee的方法，自己想的一样，优化一下写法。 1234def findMinDifference(self, timePoints: List[str]) -&gt; int: time = sorted(int(t[:2])*60+int(t[-2:]) for t in timePoints) time.append(time[0]+60*24) return min(b-a for a, b in zip(time, time[1:])) 459. Repeated Substring Pattern字符串中是否包含重复的子串模式。原题123Input: &quot;abcabcabcabc&quot;Output: TrueExplanation: It&apos;s the substring &quot;abc&quot; four times. (And the substring &quot;abcabc&quot; twice.) 方法一：如果s包含一个重复的子串，那么通过旋转s在n-1次之内，一定会又出现s本身。如s=&#39;abcabc&#39;那么旋转三次就会得到它。判断是否出现重复那么只要出现两次就算。于是将s+s得到s2。并将头尾去掉，这样s2包含了所有的旋转可能。如果s在其中，那么就说明至少有2次以上的子串重复。 12def repeatedSubstringPattern(self, s: str) -&gt; bool: return s in (s * 2)[1:-1] 165. Compare Version Numbers比较两个版本号，版本的大小。原题12Input: version1 = &quot;7.5.2.4&quot;, version2 = &quot;7.5.3&quot;Output: -1 方法一：这题写完直接自信提交。 12345678def compareVersion(self, version1: str, version2: str) -&gt; int: v1, v2 = map(int, version1.split('.')), map(int, version2.split('.')) for d1, d2 in itertools.zip_longest(v1, v2, fillvalue=0): if d1 &gt; d2: return 1 if d2 &gt; d1: return -1 return 0 方法二：学学stefan的写法。其实就是cmp函数，python3没有这个函数。 1234def compareVersion(self, version1: str, version2: str) -&gt; int: v1, v2 = map(int, version1.split('.')), map(int, version2.split('.')) v1, v2 = zip(*itertools.zip_longest(v1, v2, fillvalue=0)) return [0, 1, -1][(v1&gt;v2)-(v2&gt;v1)] 1371. Find the Longest Substring Containing Vowels in Even Counts找到最长的包含偶数个元音字母的字符串，这道题非常的典型。原题123Input: s = &quot;eleetminicoworoep&quot;Output: 13Explanation: The longest substring is &quot;leetminicowor&quot; which contains two each of the vowels: e, i and o and zero of the vowels: a and u. 方法一：自己研究了半天的写法，其实感觉2个数组记录属实有点多余。对于变化的形态，一种有32种状态，我这里是记录了这个状态最开始时上个状态+1的索引，因为这种状态可以通过非元音往两侧延伸。然后记录了每种状态最后的索引。结果就是两个索引的差值。 12345678910111213def findTheLongestSubstring(self, s: str) -&gt; int: vowels = 'aeiou' mask = last_mask = 0 first = [-1] + [float('inf')] * 31 last = [-1] + [float('-inf')] * 31 for i, c in enumerate(s): if c in set(vowels): j = vowels.index(c) last_mask, mask = mask, mask ^ (1&lt;&lt;j) if first[mask] == float('inf'): first[mask] = last[last_mask] + 1 last[mask] = i return max(j-i for i, j in zip(first, last)) 方法二：Lee的写法。思路是一样的，写法上有了改进，setdefault我也想到了，但是last数组没想到怎么消除。原来要每次计算一下。1&lt;&lt;i&gt;&gt;1是为了将其他find为0的变成0。不过大佬的方法比我的慢了200ms，可能因为’aeiou‘的反复遍历。 12345678def findTheLongestSubstring(self, s: str) -&gt; int: seen = &#123;0: -1&#125; res = cur = 0 for i, c in enumerate(s): cur ^= 1 &lt;&lt; ('aeiou'.find(c) + 1) &gt;&gt; 1 seen.setdefault(cur, i) res = max(res, i - seen[cur]) return res 443. String Compression原地压缩一个字符数组，如果是1则不需要补数量。原题123456Input: chars = [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]Output: Return 6, and the first 6 characters of the input array should be: [&quot;a&quot;,&quot;2&quot;,&quot;b&quot;,&quot;2&quot;,&quot;c&quot;,&quot;3&quot;]Explanation: The groups are &quot;aa&quot;, &quot;bb&quot;, and &quot;ccc&quot;. This compresses to &quot;a2b2c3&quot;.Input: chars = [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;a&quot;,&quot;a&quot;]Output: Return 6, and the first 6 characters of the input array should be: [&quot;a&quot;,&quot;3&quot;,&quot;b&quot;,&quot;2&quot;,&quot;a&quot;,&quot;2&quot;].Explanation: The groups are &quot;aaa&quot;, &quot;bb&quot;, and &quot;aa&quot;. This compresses to &quot;a3b2a2&quot;. Note that each group is independent even if two groups have the same character. 方法一：因为不能使用其它的空间，所以只能是通过指针来改变。0作为一个结尾符号，因为还可能包含其它符号，而不会出现数字。 1234567891011121314def compress(self, chars: List[str]) -&gt; int: i, j, cnt, last = 0, 0, 1, '' chars.append('0') for j, s in enumerate(chars): if s == last: cnt += 1 else: to_add = last + (str(cnt) if cnt!=1 else '') for c in to_add: chars[i] = c i += 1 cnt = 1 last = s return i 809. Expressive Words情感丰富的单词，给定一个单词列表，判断有多少个可以变成S，规则是可以重复一个字母，但是至少要重复到3次。原题12345678Example:Input: S = &quot;heeellooo&quot;words = [&quot;hello&quot;, &quot;hi&quot;, &quot;helo&quot;]Output: 1Explanation: We can extend &quot;e&quot; and &quot;o&quot; in the word &quot;hello&quot; to get &quot;heeellooo&quot;.We can&apos;t extend &quot;helo&quot; to get &quot;heeellooo&quot; because the group &quot;ll&quot; is not size 3 or more. 方法一：首次AC的方法，groupby注意只能遍历一次，哪怕是求len，也会导致其中嵌套的生成器被消耗掉。 1234567891011121314def expressiveWords(self, S: str, words: List[str]) -&gt; int: ans = 0 for word in words: sg = itertools.groupby(S) wg = itertools.groupby(word) for (sc, sgs), (wc, wgs) in itertools.zip_longest( sg, wg, fillvalue=('0', None)): if sc != wc: break cnt_s, cnt_w = len(list(sgs)), len(list(wgs)) if (cnt_s==2 and cnt_w==1) or (cnt_s&lt;cnt_w): break else: ans += 1 return ans 方法二：solution中的方法，和我的思想一样，但是我的写法没有这个好。首先遍历一次然后记录个数就行了，所以为什么要遍历很多次呢，再一个判断时使用满足+1，就可以避免使 用zip_longest。 123456789101112131415def expressiveWords(self, S: str, words: List[str]) -&gt; int: def rle(s): return zip(*[(k, len(list(grp))) for k, grp in itertools.groupby(s)]) if not S: return 0 R, count = rle(S) # [('h', 'e', 'l', 'o'), (1, 3, 2, 3)] ans = 0 for word in words: R2, count2 = rle(word) if R != R2: continue ans += all(c1&gt;=max(c2, 3) or c1==c2 for c1, c2 in zip(count, count2)) return ans 833. Find And Replace in String找到匹配并替换，注意是所有的同时替换，因为替换长度不同可能会导致索引不一致，所以不能用切片直接修改。原题1234Input: S = &quot;abcd&quot;, indexes = [0,2], sources = [&quot;ab&quot;,&quot;ec&quot;], targets = [&quot;eee&quot;,&quot;ffff&quot;]Output: &quot;eeecd&quot;Explanation: &quot;ab&quot; starts at index 0 in S, so it&apos;s replaced by &quot;eee&quot;. &quot;ec&quot; doesn&apos;t starts at index 2 in the original S, so we do nothing. 方法一：注意last_i要更新，还有一点是，islice用的不熟，以为islice(S, 0)是从0开始呢，原来是到0截止。 12345678910def findReplaceString(self, S: str, indexes: List[int], sources: List[str], targets: List[str]) -&gt; str: ans, last_i = [], 0 for i, r, t in sorted(zip(indexes, sources, targets)): ans.append(S[last_i:i]) last_i, j = i, len(r) if all(c1==c2 for c1, c2 in zip(itertools.islice(S, i, i+j), r)): ans.append(t) last_i += j ans += S[last_i:] return ''.join(ans) 方法二：by Lee215，我看了一眼就写出来了，直接使用了切片，因为逆序不影响索引。理论上方法一要快一点，因为没有产生多余的切片，但实际上二者时间相差无几。 1234def findReplaceString(self, S: str, indexes: List[int], sources: List[str], targets: List[str]) -&gt; str: for i, r, t in sorted(zip(indexes, sources, targets), reverse=True): S = S[:i] + t + S[i+len(r):] if S[i:i+len(r)]==r else S return S 方法三：倒序改方法一。 1234567def findReplaceString(self, S: str, indexes: List[int], sources: List[str], targets: List[str]) -&gt; str: s = list(S) for i, r, t in sorted(zip(indexes, sources, targets), reverse=True): j = len(r) if all(c1==c2 for c1, c2 in zip(itertools.islice(s, i, i+j), r)): s[i:i+j] = t return ''.join(s)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（数学篇）Math]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%95%B0%E5%AD%A6%E7%AF%87%EF%BC%89Math%2F</url>
    <content type="text"><![CDATA[7. Reverse Integer倒置一个整数， 此答案忽略了原题中的范围判断。原题12Input: -123Output: -321 方法一：str 12345def reverse_int(x): if x &gt;= 0: return int(str(x)[::-1]) else: return -int(str(x)[:0:-1]) 方法二：math 1234567def reverse(self, x: int) -&gt; int: sign = 1 if x &gt;= 0 else -1 ans, tail = 0, abs(x) while tail: ans = ans*10 + tail%10 tail //= 10 return ans * sign if ans &lt; 2**31 else 0 9. Palindrome Number判断一个数是否是回文数，这里把负数认为是不符合条件的。原题方法一：str 12def is_palindrome(x): return str(x) == str(x)[::-1] 方法二：math 123456def is_palindrome(x): l, r = x, 0 while l &gt; 0: r = r*10 + l%10 l //= 10 return r == x 13. Roman to Integer罗马数字转换整型。原题12345678910def roman_to_int(s): roman = &#123;'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000&#125; total = 0 for i in range(len(s)): if i == len(s)-1 or roman[s[i]] &gt;= roman[s[i+1]] total += roman[s[i]] else: total -= roman[s[i]] return total 69. Sqrt(x)实现开方，返回整数部分。原题1234Input: 8Output: 2Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned. 牛顿迭代法 12345def my_sqrt(x): r = x while r**2 &gt; x: r = (r+x//r) // 2 return r 367. Valid Perfect Square判断一个数是不是某个数的平方。原题12Input: 16Output: true 方法一：牛顿迭代法。同69。 12345def isPerfectSquare(self, num): r = num while r**2 &gt; num: r = (r + num // r) // 2 return r**2 == num 171. Excel Sheet Column Numberexcel表格列表数字转换，二十六进制。原题1234567A -&gt; 1B -&gt; 2C -&gt; 3...Z -&gt; 26AA -&gt; 27AB -&gt; 28 A -&gt; 1 123def titleToNumber(self, s: str) -&gt; int: OFFSET = ord('A')-1 return sum((ord(x)-OFFSET)*26**i for i, x in enumerate(s[::-1])) 168. Excel Sheet Column Titleexcel转换，数字转字母。十进制-&gt;26进制。原题1234567def convertToTitle(self, n): res = '' while n: res = chr((n-1)%26+65) + res # n //= 26 n = (n-1) // 26 return res 172. Factorial Trailing Zeroes求n的阶乘末尾有几个0。原题123Input: 5Output: 1Explanation: 5! = 120, one trailing zero. 思路：每一对2和5可以产生一个0，在n的阶乘中，5比2多，所以问题变成求5的个数，而25这种数有两个5，所以递归求解 12def trailing_zeroes(n): return 0 if n == 0 else n//5 + trailing_zeroes(n//5) 204. Count Primes求小于n的整数中，有多少个质数。原题123456def countPrimes(self, n): is_prime = [False]*2 + [True]*(n-2) for i in range(2, int(n ** 0.5)+1): if is_prime[i]: is_prime[i*i:n:i] = [False] * len(is_prime[i*i:n:i]) return sum(is_prime) 50. Pow(x, n)实现pow函数。原题12345Input: 2.00000, 10Output: 1024.00000Input: 2.00000, -2Output: 0.25000 . 说明：常规方法在Leetcode 上内存会爆掉。 123456789101112131415161718192021class Solution(object): def myPow(self, x, n): if n &lt; 0: return 1 / self.pow_with_unsigned(x, -n) else: return self.pow_with_unsigned(x, n) def pow_with_unsigned(self, x, n): if n == 1: return x if n == 0: return 1 res = self.pow_with_unsigned(x, n &gt;&gt; 1) res *= res if n &amp; 1 == 1: res *= x return res 233. Number of Digit One1~n数字中1的个数。原题1234567def countDigitOne(self, n): countr, i = 0, 1 while i &lt;= n: divider = i * 10 countr += (n // divider) * i + min(max(n % divider - i + 1, 0), i) i *= 10 return countr 263. Ugly Number判断一个数是否是丑数。原题方法一：根据定义实现。&lt; num是为了判断num=0的情况。 12345def isUgly(self, num): for f in 2, 3, 5: while num % f == 0 &lt; num: num //= f return num == 1 264. Ugly Number II输出第n个丑数。原题书中的方法 1234567891011121314def nthUglyNumber(self, n): q = [1] t2, t3, t5 = 0, 0, 0 for i in range(n-1): a2, a3, a5 = q[t2]*2, q[t3]*3, q[t5]*5 to_add = min(a2, a3, a5) q.append(to_add) if a2 == to_add: t2 += 1 if a3 == to_add: t3 += 1 if a5 == to_add: t5 += 1 return q[-1] 67.Add Binary实现二进制加法。原题12Input: a = &quot;11&quot;, b = &quot;1&quot;Output: &quot;100&quot; 方法一：按照加法的二进制思想来计算，不过Runtime大约100ms。后来试着将list comprehension拆成一个for循环，也并没有提高速度。居然beats只有4%，难道大部分人都用的bin。讨论区简单翻了了一下，没有找到一个高效的pythonic的方法。 1234567891011def addBinary(self, a, b): if len(a) &gt; len(b): b = b.zfill(len(a)) else: a = a.zfill(len(b)) while int(b): sum_not_carry = ''.join([str(int(a[i]) ^ int(b[i])) for i in range(len(a))]) carry = ''.join([str(int(a[i]) &amp; int(b[i])) for i in range(len(a))]) a, b = "0"+sum_not_carry, carry+'0' return a.lstrip('0') if a != '0' else '0' 202. Happy Number判断是否是欢乐数。进行所有位的平方和运算，最后为1的是欢乐数。原题1234567Input: 19Output: trueExplanation: 1**2 + 9**2 = 828**2 + 2**2 = 686**2 + 8**2 = 1001**2 + 0**2 + 0**2 = 1 方法一：思路，使用一个字典映射0~9的平方值，然后如果死循环的话，各位数的和一定存在着一种循环，所以用一个set来判断是否重复。 12345678910def isHappy(self, n): squares = &#123;str(k): k**2 for k in range(0, 10)&#125; sum_digit = set() while n != 1: n = sum(squares[digit] for digit in str(n)) if n in sum_digit: return False else: sum_digit.add(n) return True 231. Power of Two判断一个数是否是2的n次方。思路也就是判断这个数的二进制形式是否只有一个’1’。原题方法一：可以用作通用方法。 12345def isPowerOfTwo(self, n, power=2): if n == 0: return False while n % power == 0: n //= power return n == 1 方法二：二进制统计1。 12def isPowerOfTwo(self, n): return n &gt; 0 and bin(n).count('1') == 1 方法三：如果一个数n的二进制只有一个1，那么n&amp;(n-1)一定为0。 12def isPowerOfTwo(self, n): return n &gt; 0 and (n&amp;n-1) == 0 342. Power of Four判断一个数是否是4的n次方。原题方法一：从简单入手通过231题，了解到了2的n次方特点是，二进制形式只有一个’1’，那么4的n次方就是不但只有一个’1’，后面还跟了偶数个’0’。 1234567891011def isPowerOfFour(self, num): single_1 = num &gt; 0 and not (num &amp; num-1) if single_1: while num &gt; 0: if num == 1: return True else: num &gt;&gt;= 2 return False else: return False 方法二：上述代码看起来更像是java代码，我们使用count来判断0的个数是否为偶数个。 123def isPowerOfFour(self, num): # return num &gt; 0 and (num &amp; num-1)==0 and bin(num)[2:].count('0')&amp;1==0 return num &gt; 0 and (num &amp; num-1)==0 and len(bin(num))&amp;1==1 方法三：也可以使用正则。 123def isPowerOfFour(self, num): import re return bool(re.match(r'^0b1(00)*$',bin(num))) 292. Nim Game说，有这么一堆石头，一次只能拿1~3个，拿到最后一个石头的人获胜。求n堆石头，你先拿是否可以获胜。原题思路：找规律，发现只有最后剩4个石头的时候，此时轮到谁，谁输。 12def canWinNim(self, n): return n % 4 != 0 400. Nth Digit找出无限整数序列中的第n个数字。原题123456Input:11Output:0Explanation:The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10. 思路，根据n的位数，将无限序列分为几个范围。 size of n step start ~ stop 1 9 1 ~ 9 2 90 10 ~ 99 3 900 100 ~ 999 寻找范围。寻找n处于哪个范围，是1~9，还是10~99，例如n=15。则需要跳过1~9的范围，而这个范围有size*step个数字，所以问题变成在10~99范围上寻找第15-1*9=6个数。 定位数字。10~99范围中是从10开始的，每一个数都有两位数字，所以最终数字为10+(6-1)//2，因为索引从0开始，所以需要-1。 定位数字的位。上一步找到了数字为12，对size求余就可以知道，&#39;12&#39;[(6-1)%2]=&#39;2&#39;。 12345def findNthDigit(self, n): start, step, size = 1, 9, 1 while n &gt; size * step: n, start, step, size = n-size*step, start*10, step*10, size+1 return int(str(start + (n-1)//size)[(n-1) % size]) 415. Add Stings给定两个字符串表示的数字，把它们相加，这两个数的长度小于5100，不能使用任何BitIntegr库或是直接将其转换为整数。ps: 题中要求不将输入直接转换成int，所以我个人认为int还是可以使用的，有一些答案中是使用了ord来做运算。原题方法一：不使用标准库。 1234567891011121314151617def addStrings(self, num1, num2): if len(num1) &gt; len(num2): num2 = num2.zfill(len(num1)) else: num1 = num1.zfill(len(num2)) res, carry = '', 0 n1, n2 = len(num1)-1, len(num2)-1 while (n1 &gt;= 0 and n2 &gt;= 0) or carry: v1 = int(num1[n1]) if n1 &gt;= 0 else 0 v2 = int(num2[n2]) if n2 &gt;= 0 else 0 carry, val = divmod(v1+v2+carry, 10) res = str(val) + res n1 -= 1 n2 -= 1 return res 方法二：使用zip_longest。 12345678910def addStrings(self, num1, num2): from itertools import zip_longest nums = list(zip_longest(num1[::-1], num2[::-1], fillvalue='0')) carry, res = 0, '' for digits in nums: d1, d2 = map(int, digits) carry, val = divmod(d1+d2+carry, 10) res = res + str(val) res = res if carry==0 else res+str(carry) return res[::-1] 492. Construct the Rectangle给定一个面积，求组成这个面积的长高差最小。原题1234Input: 4Output: [2, 2]Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. But according to requirement 2, [1,4] is illegal; according to requirement 3, [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2. 方法一：一开始我居然这样写。结果超时了，后来发现L+=1，循环次数要比L-=1要多。 12345678910def constructRectangle(self, area): import math squre = math.sqrt(area) if int(squre) == squre: return [int(squre), int(squre)] else: L = int(squre) + 1 while area % L != 0: L += 1 return [L, area//L] 方法二：整理一下思路其实很简单，之前想多了还以为有二分的方法。递减肯定是会优先退出循环的，但是我还不知道怎么证明这个结论。 123456def constructRectangle(self, area): import math w = int(math.sqrt(area)) while area % w != 0: w -= 1 return [area//w, w] 504. Base 710进制转7进制。原题1234Input: 100Output: &quot;202&quot;Input: -7Output: &quot;-10&quot; 方法一：需要注意负数。 1234567def convertToBase7(self, num: int) -&gt; str: if num == 0: return '0' n, ans = abs(num), '' while n: n, val = divmod(n, 7) ans = str(val) + ans return ans if num &gt; 0 else '-'+ans 970. Powerful Integers求满足x^i+y^j &lt;= bound的所有和。原题12345678910Input: x = 2, y = 3, bound = 10Output: [2,3,4,5,7,9,10]Explanation: 2 = 2^0 + 3^03 = 2^1 + 3^04 = 2^0 + 3^15 = 2^1 + 3^17 = 2^2 + 3^19 = 2^3 + 3^010 = 2^0 + 3^2 方法一：这题难得地方在于两个循环的临界值，貌似我这样写也不是最优解，原题的Solution中给定了2**18&gt;bound的最大值。所以两个范围都是18。 123456789101112131415def powerfulIntegers(self, x, y, bound): res = set() imax = self.get_max(x, bound) + 1 jmax = self.get_max(y, bound) + 1 for i in range(imax): for j in range(jmax): if x**i + y**j &lt;= bound: res.add(x**i+y**j) return list(res) def get_max(self, n, bound): for i in range(bound//n + 1): if n ** i &gt;= bound: return i return bound//n + 1 973. K Closest Points to Origin求离原点最近的K个坐标点。原题1234567Input: points = [[1,3],[-2,2]], K = 1Output: [[-2,2]]Explanation: The distance between (1, 3) and the origin is sqrt(10).The distance between (-2, 2) and the origin is sqrt(8).Since sqrt(8) &lt; sqrt(10), (-2, 2) is closer to the origin.We only want the closest K = 1 points from the origin, so the answer is just [[-2,2]]. 方法一：很简单。 123def kClosest(self, points, K): res = sorted(points, key=lambda x: x[0]**2 + x[1]**2) return res[:K] 976. Largest Perimeter Triangle给定一个边长数组，求能组成的三角形的最长周长。原题方法一：这个也不难，就是长度为3的滑动窗口。 123456def largestPerimeter(self, A): res = sorted(A, reverse=True) for i in range(len(res)-2): if sum(res[i+1:i+3]) &gt; res[i]: return sum(res[i:i+3]) return 0 628. Maximum Product of Three Numbers数组中三个数的最大乘积。元素范围[-1000, 1000]。原题12Input: [1,2,3,4]Output: 24 方法一：排序。在正数个数大于等于3的时候，显然最大的三个数就可以产生最大的乘积。而当正数个数不够的时候，那么必须需要两个最小的负数（即绝对值最大），和一个最大的正数。 123def maximumProduct(self, nums): ary = sorted(nums) return max((ary[0]*ary[1]*ary[-1], ary[-3]*ary[-2]*ary[-1])) 方法二：使用heapq. 1234567def maximumProduct(self, nums): import heapq from operator import mul from functools import reduce three_max = heapq.nlargest(3, nums) two_min = heapq.nsmallest(2, nums) return max(reduce(mul, three_max), reduce(mul, two_min + three_max[:1])) 728. Self Dividing Numbers自整除数字，一个数字能够被本身的每个数字整除，并且不能有0，求某个范围内所有的数。原题123Input: left = 1, right = 22Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22] 方法一：Brute Force. 此题强行使用列表生成式没有意义。 123456789def selfDividingNumbers(self, left, right): res = [] for i in range(left, right+1): for char in str(i): if int(char)==0 or i % int(char)!=0: break else: res.append(i) return res 836. Rectangle Overlap矩形是否重叠，矩形的边平行于坐标轴。原题12Input: rec1 = [0,0,2,2], rec2 = [1,1,3,3]Output: true 方法一：通过画图找出的规律。 1234def isRectangleOverlap(self, rec1: 'List[int]', rec2: 'List[int]') -&gt; 'bool': x_overlap = (rec2[0]-rec1[2]) * (rec2[2]-rec1[0]) &lt; 0 y_overlap = (rec2[1]-rec1[3]) * (rec2[3]-rec1[1]) &lt; 0 return x_overlap and y_overlap 方法二：方法一还是想复杂了。 Given 2 segment (left1, right1), (left2, right2), how can we check whether they overlap?If these two intervals overlap, it should exist an number x, 123left1 &lt; x &lt; right1 &amp;&amp; left2 &lt; x &lt; right2left1 &lt; x &lt; right2 &amp;&amp; left2 &lt; x &lt; right1left1 &lt; right2 &amp;&amp; left2 &lt; right1 123def isRectangleOverlap(self, rec1: 'List[int]', rec2: 'List[int]') -&gt; 'bool': return rec2[0] &lt; rec1[2] and rec1[0] &lt; rec2[2] and \ rec2[1] &lt; rec1[3] and rec1[1] &lt; rec2[3] 991. Broken Calculator坏掉的计算器，只能*2或者-1，使X变为Y。原题123Input: X = 5, Y = 8Output: 2Explanation: Use decrement and then double &#123;5 -&gt; 4 -&gt; 8&#125;. 解析：如果从X到Y问题会变得复杂，不确定什么时候该*2或者是-1。所以逆向思维从Y变成X。 If Y &lt;= X, we won’t do Y / 2 anymore.We will increase Y until it equals to X So before that, while Y &gt; X, we’ll keep reducing Y, until it’s smaller than X.If Y is odd, we can do only Y = Y + 1If Y is even, if we plus 1 to Y, then Y is odd, we need to plus another 1.And because (Y + 1 + 1) / 2 = (Y / 2) + 1, 3 operations are more than 2.We always choose Y / 2 if Y is even. 方法一：iteratively. 123456789def brokenCalc(self, X: 'int', Y: 'int') -&gt; 'int': ans = 0 while X &lt; Y: ans += 1 if Y &amp; 1 == 1: Y += 1 else: Y //= 2 return ans + X - Y 方法二：方法一变形。因为如果Y是奇数，那么必定在+1操作后要/2，这里将其合并 123456789def brokenCalc(self, X: 'int', Y: 'int') -&gt; 'int': ans = 0 while X &lt; Y: ans += 1 if Y &amp; 1 == 1: Y += 1 ans += 1 Y = Y // 2 return ans + X - Y 方法三：方法二再变形，看到Y是奇数时，ans + 2，所以可以用ans += (Y&amp;1) + 1表示，而Y在是奇数时先+1再//2即Y = (Y + 1) // 2，偶数时Y = Y // 2，其实，对于偶数来说Y=(Y+1)//2和Y=Y//2结果一样。所以可以写成。 123456def brokenCalc(self, X: 'int', Y: 'int') -&gt; 'int': ans = 0 while X &lt; Y: ans += (Y &amp; 1) + 1 Y = (Y + 1) // 2 return ans + X - Y 方法四：递归写法。Y&amp;1必须括号 12def brokenCalc(self, X: 'int', Y: 'int') -&gt; 'int': return X - Y if X &gt;= Y else 1+(Y&amp;1)+self.brokenCalc(X, (Y+1)//2) 908. Smallest Range I给定一个数组，和一个K，数组里的数加上-k&lt;=x&lt;=k的任意一个数字后，求数组最大数和最小数的，最小差。原题123Input: A = [0,10], K = 2Output: 6Explanation: B = [2,8] 12def smallestRangeI(self, A: 'List[int]', K: 'int') -&gt; 'int': return max(max(A) - min(A) - 2*K, 0) 949. Largest Time for Given Digits给定四个数字，返回能生成的最大时间。24小时制。原题12Input: [1,2,3,4]Output: &quot;23:41&quot; 方法一：排序。 123456def largestTimeFromDigits(self, A: 'List[int]') -&gt; 'str': p = itertools.permutations(A) for a, b, c, d in sorted(p, reverse=True): if 0 &lt;= a*10+b &lt;= 23 and 0 &lt;= 10*c+d &lt;= 59: return '&#123;&#125;&#123;&#125;:&#123;&#125;&#123;&#125;'.format(a, b, c, d) return '' 1234def largestTimeFromDigits(self, A: 'List[int]') -&gt; 'str': p = itertools.permutations(A) return max(['&#123;&#125;&#123;&#125;:&#123;&#125;&#123;&#125;'.format(*d) for d in p if d[:2] &lt; (2, 4) and d[2] &lt; 6] or ['']) 914. X of a Kind in a Deck of Cards有这样一堆数字卡牌，问是否存在一个X&gt;=2，使得将同样数字的卡牌分为每X个一组，并且刚好所有的卡牌分完。原题思路：使用Counter来统计每个数字的个数，然后求这些数字的最大公约数是否大于等于2，这里思路卡了一下，因为没想到最大公约数可以通过reduce来计算，没考虑到是可以累积的。 12345def hasGroupsSizeX(self, deck): from collections import Counter from math import gcd from functools import reduce return reduce(gcd, Counter(deck).values()) &gt;= 2 470. Implement Rand10() Using Rand7()使用rand7实现rand10原题12Input: 3Output: [8,1,10] 方法一：先将rand7-1变为[0, 6]然后乘7，[0,7,14,21,28,35,42]然后+[0,6]这样能将这6个数均匀地分配到每段中，得到了[0, 48]然后舍弃[40,48]剩下[0,39]然后取余得[0,9]最后加一。 12345def rand10(self): while True: x = (rand7()-1)*7 + rand7()-1 if x &lt; 40: return x%10 + 1 1006. Clumsy Factorial将一个阶乘的式子用*/+-替代，给出结果。原题123Input: 10Output: 12Explanation: 12 = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1 方法一：python此题有作弊的方法，我看排行榜中大神有的特意切到python做这道题，不过没我写得好。 1234def clumsy(self, N: int) -&gt; int: op = itertools.cycle(['*', '//', '+', '-']) return eval(''.join(str(n)+next(op) if n!=1 else str(n) for n in range(N, 0, -1))) 1022. Smallest Integer Divisible by K最小的由1组成的能被K整除。原题123Input: 2Output: -1Explanation: There is no such positive integer N divisible by 2. 如果有2或5的质因数，那么不能整除。 123456def smallestRepunitDivByK(self, K: int) -&gt; int: if K % 2 == 0 or K % 5 == 0: return -1 r = 0 for N in range(1, K + 1): r = (r * 10 + 1) % K if not r: return N 1028. Convert to Base -210进制转成-2进制。原题方法一：负数进制时，如果余数为负数，那么商+1。 12345678910def baseNeg2(self, N: int) -&gt; str: if not N: return '0' ans = '' while N: remainder = N % (-2) ans += str(abs(remainder)) N //= -2 N += (remainder &lt; 0) return ans[::-1] 方法二：在二进制上加一个负号。 123456def baseNeg2(self, N: int) -&gt; str: ans = [] while N: ans.append(N &amp; 1) N = -(N &gt;&gt; 1) return ''.join(map(str, ans[::-1] or [0])) 313. Super Ugly Number根据指定的质数序列，找出第n个超级丑数。原题和剑指offer中，丑数一题很像，只不过那题是固定的2,3,5三个质数。 方法一：根据之前的方法进行微调。时间要1s左右，因为遍历了两次primes。 12345678910def nthSuperUglyNumber(self, n: int, primes: List[int]) -&gt; int: ans = [1] last_index = [0] * len(primes) for _ in range(n-1): ugly = min(ans[last_index[i]]*p for i, p in enumerate(primes)) ans.append(ugly) for i, p in enumerate(primes): if ans[last_index[i]] * p == ugly: last_index[i] += 1 return ans[-1] 方法二：304ms。开始想到了生成器和堆，其他结构差不多，但是生成器内部实现想错了。 1234567891011121314def nthSuperUglyNumber(self, n: int, primes: List[int]) -&gt; int: import heapq as hq uglies = [1] def gen_ugly(prime): for ugly in uglies: yield ugly * prime merged = hq.merge(*map(gen_ugly, primes)) while len(uglies) &lt; n: ugly = next(merged) if ugly != uglies[-1]: uglies.append(ugly) return uglies[-1] 869. Reordered Power of 2重新排列一个数字的各位数，判断是否能组成2的幂。原题这题我看到是，显示拆成两个子问题，全排列和判断是否是2的幂，结果超时了，不知道为什么，我看Solution中也有这种解法，我还提交了好几次。 所以此题需要换一种思路，2的幂是指数上升的，所以，在范围内的数一共也没有几个。那么使用Counter来判断是否能组成这个数。 123def reorderedPowerOf2(self, N: int) -&gt; bool: c = Counter(str(N)) return any(c==Counter(str(1&lt;&lt;i)) for i in range(0, 30)) 1025. Divisor Game两个人做游戏，黑板上有个数N，每次找到一个0 &lt;x&lt;N的数，并且N能被x整除，然后替换这个N，直到找不出这样x，就输了。问给出这样一个数N，第一个人是否能赢。原题方法一：写了一个动态规划，最后一分析实际上只要N为偶数就能赢。 1234567891011121314151617ans = []def divisorGame(self, N: int) -&gt; bool: # for i in range(1, N+1): # for j in range(1, i): # if i % (i-j)==0 and not ans[j]: # print('&#123;&#125; % &#123;&#125;'.format(i, j)) # ans.append(True) # break # # for j in range(1, len(ans)): # # if i % (i-j)== 0 and not ans[j]: # # ans.append(True) # # break # else: # ans.append(False) # print('count &#123;&#125; &#123;&#125;'.format(i, ans[-1])) # print(ans) return N &amp; 1 == 0 1037. Valid Boomerang验证三个坐标点是否共线。原题方法一：需要注意的是，除数为0 的情况，所以这里改成了乘法。 123def isBoomerang(self, points: List[List[int]]) -&gt; bool: return (points[1][1]-points[0][1])*(points[2][0]-points[1][0]) != \ (points[2][1]-points[1][1])*(points[1][0]-points[0][0]) 1041. Robot Bounded In Circle一个面向北的机器人进行三种操作，一种是前进，或者向左向右转。问一系列的操作中，无限循环时，机器人是否在绕圈。原题方法一：将操作反复4次，判断是否回到原点。 1234567891011121314def isRobotBounded(self, instructions: str) -&gt; bool: instruction = instructions * 4 operations = [('+0', '+1'), ('-1', '+0'), ('+0', '-1'), ('+1', '+0')] cur_op = 0 x, y = 0, 0 for inst in instruction: if inst == 'G': x_op, y_op = operations[cur_op] x, y = eval(str(x)+x_op), eval(str(y)+y_op) elif inst == 'L': cur_op = (cur_op+1) % 4 else: cur_op = (cur_op-1) % 4 return x == y == 0 方法二：不需要循环四次，在一次之后，如果面向的不再是北，那么最后将会绕圈。 1234567def isRobotBounded(self, instructions: str) -&gt; bool: x, y, dx, dy = 0, 0, 0, 1 for inst in instructions: if inst == 'G': x, y = x+dx, y+dy elif inst == 'L': dx, dy = -dy, dx elif inst == 'R': dx, dy = dy, -dx return (x == y == 0) or (dx, dy) != (0, 1) 1137. N-th Tribonacci Number三个数的斐波那契数列。原题12345Input: n = 4Output: 4Explanation:T_3 = 0 + 1 + 1 = 2T_4 = 1 + 1 + 2 = 4 12345def tribonacci(self, n: int) -&gt; int: a, b, c = 1, 0, 0 for _ in range(n): a, b, c = b, c, a+b+c return c 1073. Adding Two Negabinary Numbers两个-2进制的数相加。原题方法一：转成十进制相加，再转回-2进制。 1234567891011121314151617def addNegabinary(self, arr1: List[int], arr2: List[int]) -&gt; List[int]: def to_ten(arr): return sum(d*(-2)**i for i, d in enumerate(arr[::-1])) def to_neg_binary(n): if not n: return '0' ans = '' while n: remainder = n % (-2) ans += str(abs(remainder)) n //= -2 n += (remainder &lt; 0) return ans[::-1] return to_neg_binary(to_ten(arr1) + to_ten(arr2)) 1154. Day of the Year根据输入的日期，返回它是一年中的第几天。原题方法一：使用了datetime库，开始还自己手动减，后来看评论发现有这样的方法。 1234def dayOfYear(self, date: str) -&gt; int: import datetime date = datetime.datetime.strptime(date, '%Y-%m-%d') return date.timetuple().tm_yday 1155. Number of Dice Rolls With Target Sum扔一个f面的 骰子d次，结果为target的次数。原题12345Input: d = 2, f = 6, target = 7Output: 6Explanation: You throw two dice, each with 6 faces. There are 6 ways to get a sum of 7:1+6, 2+5, 3+4, 4+3, 5+2, 6+1. 方法一：竞赛时用的数组，后来发现字典效率更高。此题和剑指offer中骰子题类似。 123456789def numRollsToTarget(self, d: int, f: int, target: int) -&gt; int: last_p = collections.defaultdict(int) last_p.update(&#123;d: 1 for d in range(1, f+1)&#125;) for i in range(2, d+1): new_p = collections.defaultdict(int) for j in range(i, i*f+1): new_p[j] = sum(last_p[j-k] for k in range(1, f+1)) last_p = new_p return last_p[target] % (10**9+7) 1093. Statistics from a Large Sample统计大量的样本数据，求最小值，最大值，平均值，众数。原题12Input: count = [0,1,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]Output: [1.00000,3.00000,2.37500,2.50000,3.00000] 方法一：中位数的求法这里没想到，使用二分可以完美的解决奇偶问题。 1234567891011def sampleStats(self, count: List[int]) -&gt; List[float]: n = sum(count) mi = next(i for i in range(255) if count[i]) * 1.0 ma = next(i for i in range(255, -1, -1) if count[i]) * 1.0 mean = sum(i * val for i, val in enumerate(count)) * 1.0 / n mode = count.index(max(count)) * 1.0 cc = list(itertools.accumulate(count)) left = bisect.bisect(cc, (n-1)//2) right = bisect.bisect(cc, n//2) median = (left + right) / 2.0 return mi, ma, mean, median, mode 1103. Distribute Candies to People发糖果，按照顺序每个人比上一人多一颗，发到最后再循环。原题1234567Input: candies = 7, num_people = 4Output: [1,2,3,1]Explanation:On the first turn, ans[0] += 1, and the array is [1,0,0,0].On the second turn, ans[1] += 2, and the array is [1,2,0,0].On the third turn, ans[2] += 3, and the array is [1,2,3,0].On the fourth turn, ans[3] += 1 (because there is only one candy left), and the final array is [1,2,3,1]. 方法一：此题做法和Lee神不谋而合。 12345678def distributeCandies(self, candies: int, n: int) -&gt; List[int]: ans = [0] * n cur = 1 while candies &gt; 0: ans[cur%n-1] += min(candies, cur) candies -= cur cur += 1 return ans 1109. Corporate Flight Bookings通过给定的一些区间，确定每天的座位数。原题12Input: bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5Output: [10,55,45,25,25] 方法一：此题暴力法会超时。核心在于记录变化的状态，然后累加求结果。 123456def corpFlightBookings(self, bookings: List[List[int]], n: int) -&gt; List[int]: ans = [0] * (n+1) for s, e, v in bookings: ans[s-1] += v ans[e] -= v return list(itertools.accumulate(ans))[:-1] 1175. Prime Arrangements质数排列。原题123Input: n = 5Output: 12Explanation: For example [1,2,5,4,3] is a valid permutation, but [5,2,3,4,1] is not because the prime number 5 is at index 1. 123456789101112def numPrimeArrangements(self, n: int) -&gt; int: def countPrimes(n): is_prime = [False]*2 + [True]*(n-2) for i in range(2, int(n ** 0.5)+1): if is_prime[i]: is_prime[i*i:n:i] = [False] * len(is_prime[i*i:n:i]) return sum(is_prime) c = countPrimes(n+1) ans = math.factorial(c) * math.factorial(n-c) return ans % (10**9+7) 1360. Number of Days Between Two Dates计算两个日期之间的天数。原题12Input: date1 = &quot;2020-01-15&quot;, date2 = &quot;2019-12-31&quot;Output: 15 方法一：简单的datetime模块方式。 12345def daysBetweenDates(self, date1: str, date2: str) -&gt; int: from datetime import datetime d1 = datetime.strptime(date1, '%Y-%m-%d') d2 = datetime.strptime(date2, '%Y-%m-%d') return abs((d2-d1).days) 方法二：有个公式，如果将1月二月看成是13月和14月，那么月份转化天数有个公式(153 * m + 8) // 5 123456789def daysBetweenDates(self, date1: str, date2: str) -&gt; int: def f(date): y, m, d = map(int, date.split('-')) if m &lt; 3: m += 12 y -= 1 return 365 * y + y // 4 + y // 400 - y // 100 + d + (153 * m + 8) // 5 return abs(f(date1) - f(date2)) 1363. Largest Multiple of Three组成的最大的3的倍数。原题12Input: digits = [8,1,9]Output: &quot;981 方法一：数学。 Calculate the sum of digits total = sum(A) If total % 3 == 0, we got it directly If total % 3 == 1 and we have one of 1,4,7 in A:we try to remove one digit of 1,4,7 If total % 3 == 2 and we have one of 2,5,8 in A:we try to remove one digit of 2,5,8 If total % 3 == 2:we try to remove two digits of 1,4,7 If total % 3 == 1:we try to remove two digits of 2,5,8 12345678910111213141516171819202122def largestMultipleOfThree(self, A): total = sum(A) count = collections.Counter(A) A.sort(reverse=1) def f(i): if count[i]: A.remove(i) count[i] -= 1 if not A: return '' if not any(A): return '0' if sum(A) % 3 == 0: return ''.join(map(str, A)) if total % 3 == 0: return f(-1) if total % 3 == 1 and count[1] + count[4] + count[7]: return f(1) or f(4) or f(7) if total % 3 == 2 and count[2] + count[5] + count[8]: return f(2) or f(5) or f(8) if total % 3 == 2: return f(1) or f(1) or f(4) or f(4) or f(7) or f(7) return f(2) or f(2) or f(5) or f(5) or f(8) or f(8) 1493. Longest Subarray of 1’s After Deleting One Element删除一个元素，子数组有最长的1、子数组长度。原题123Input: nums = [1,1,0,1]Output: 3Explanation: After deleting the number in position 2, [1,1,1] contains 3 numbers with value of 1&apos;s. 方法一：双端队列，其实是求最多包含1个0的滑动窗口长度。 123456789101112def longestSubarray(self, nums: List[int]) -&gt; int: ans = k = 0 q = collections.deque() for num in nums: q.append(num) k += num==0 if k == 2: while q.popleft()!=0: pass k -= 1 ans = max(ans, len(q)-1) return ans 方法二：Lee215的解法，还是选择维持了一个最大的长度，所以没用while 而是if，这样也不用每次max来求值。 12345678def longestSubarray(self, nums: List[int]) -&gt; int: k, i = 1, 0 for j in range(len(nums)): k -= nums[j]==0 if k &lt; 0: k += nums[i]==0 i += 1 return j - i 537. Complex Number Multiplication两个负数相乘。求结果，需要注意的是这里会多一个+。原题123Input: &quot;1+-1i&quot;, &quot;1+-1i&quot;Output: &quot;0+-2i&quot;Explanation: (1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i, and you need convert it to the form of 0+-2i. 方法一：内置库。这里format时不能用d，因为都是float。但是%却可以做到。 123456def complexNumberMultiply(self, a: str, b: str) -&gt; str: a = complex(a.replace('+-', '-').replace('i', 'j')) b = complex(b.replace('+-', '-').replace('i', 'j')) c = a * b return '&#123;:.0f&#125;+&#123;:.0f&#125;i'.format(c.real, c.imag) # return '%d+%di' % (c.real, c.imag) 方法二：不用内置库。 123456def complexNumberMultiply(self, a: str, b: str) -&gt; str: a_real, a_imag = map(int, re.match(r'(\-?\d+)\+(\-?\d+)i', a).groups()) b_real, b_imag = map(int, re.match(r'(\-?\d+)\+(\-?\d+)i', b).groups()) real = a_real*b_real - a_imag*b_imag imag = a_real*b_imag + b_real*a_imag return '&#123;&#125;+&#123;&#125;i'.format(real, imag) 方法三：我还搁这groups呢，人家stefan一行就搞定了。 123def complexNumberMultiply(self, a, b): a, ai, b, bi = map(int, re.findall('-?\d+', a+b)) return '%d+%di' % (a*b - ai*bi, a*bi + ai*b) 794. Valid Tic-Tac-Toe State在一个九宫格里下棋，谁连上3个就算赢，问给出一个棋子局面，判断是否可能下出来。原题方法一：case挺多的，需要想明白判断条件，基本就是请求x,o的分别连3的个数，然后和分别的棋子数，最后判断。 12345678910111213141516171819202122232425def validTicTacToe(self, b: List[str]) -&gt; bool: fb = ''.join(b) x_cnt, o_cnt = fb.count('X'), fb.count('O') cnt = &#123;'X': 0, 'O': 0&#125; for row in b: if len(set(row))==1 and row[0]!=' ': cnt[row[0]] += 1 for col in zip(*b): if len(set(col))==1 and col[0]!=' ': cnt[col[0]] += 1 if b[1][1] != ' ': if len(set(b[i][i] for i in range(3))) == 1: cnt[b[1][1]] += 1 if len(set(b[i][2-i] for i in range(3))) == 1: cnt[b[1][1]] += 1 # print(x_cnt, o_cnt, cnt) if not o_cnt&lt;=x_cnt&lt;=o_cnt+1: return False if cnt['X'] and x_cnt!=o_cnt+1: return False if cnt['O'] and (cnt['X'] or x_cnt!=o_cnt): return False return True 方法二：stefan的答案，判断精简了，求连子过程也精简了。当X&gt;O时，那么O必然没有连3。相等时，X必然没有连3。用了一个切片求出是否出现了连3。 1234b = '|'.join(board) x, o = (any(p*3 in b[s::d] for s in range(9) for d in (1, 3, 4, 5)) for p in 'XO') m = b.count('X') - b.count('O') return m == (not o) if m else not x 227. Basic Calculator II计算式子，没有括号，包含加减乘除和小数点。原题12Input: &quot; 3+5 / 2 &quot;Output: 5 方法一：eval算是作弊了，这个stefan的方法不错。用了生成器。 12345678910111213def calculate(self, s: str) -&gt; int: tokens = iter(re.findall('\d+|\S', s)) total, sign = 0, 1 for token in tokens: if token in '+-': total += sign * term sign = ' +'.find(token) elif token in '*/': n = int(next(tokens)) term = term*n if token == '*' else term//n else: term = int(token) return total + sign * term 640. Solve the Equation解方程，方程中只有x一个变量，只有加减操作。原题123456Input: &quot;x+5-3+x=6+x-2&quot;Output: &quot;x=2&quot;Input: &quot;x=x&quot;Output: &quot;Infinite solutions&quot;Input: &quot;2x+3x-6x=x+2&quot;Output: &quot;x=-1&quot; 方法一：首次AC的方法。正则调了半天，因为不止一为数。 1234567891011121314151617181920212223def solveEquation(self, equation: str) -&gt; str: left, right = equation.split('=') def short(s): coe, d = 0, 0 vs = re.findall(r'[+|-]?\d+x|[+|-]?\d+|[+|-]?x', s) for v in vs: if 'x' in v: c = v[:-1] if not c or not c[-1].isdigit(): c += '1' coe += int(c) else: d += int(v) return coe, d l_c, l_d = short(left) r_c, r_d = short(right) f_c, f_d = l_c-r_c, r_d-l_d if f_c == 0: return ('No solution', 'Infinite solutions')[f_d==0] else: return 'x=&#123;&#125;'.format(f_d//f_c) 方法二：看了stefan的答案。replace呀，这种题可以替换一些字符串产生简单的操作。复数的操作我在想的时候思路一闪而过，然后不知道怎么实现就没往下想。 1234def solveEquation(self, equation: str) -&gt; str: z = eval(equation.replace('x', 'j').replace('=', '-(') + ')', &#123;'j': 1j&#125;) a, x = z.real, -z.imag return 'x=%d' % (a / x) if x else 'No solution' if a else 'Infinite solutions' 方法三：左右可以一起算，通过=来改变一个符号。+的变成-，-变成+，正则分成4个组没有想到。头铁就想把它们塞到一起，那样反而判断得更多了。 1234567891011def solveEquation(self, equation: str) -&gt; str: x = a = 0 side = 1 for eq, sign, num, isx in re.findall('(=)|([-+]?)(\d*)(x?)', equation): if eq: side = -1 elif isx: x += side * int(sign + '1') * int(num or 1) elif num: a -= side * int(sign + num) return 'x=%d' % (a / x) if x else 'No solution' if a else 'Infinite solutions' 319. Bulb Switcher有n个开关控制n个初始化为关的灯泡。从1开始，每次隔1,2,3,4..n开这些开关，问最后有多少个开着的灯。原题方法一：这题有点像脑筋急转弯，我分析出了只有1~n的数有奇数个约数，那么最后就是开着的。然后什么样的数有奇数个约数，看了stefan后恍然大悟，原来是开方。 12def bulbSwitch(self, n: int) -&gt; int: return int(math.sqrt(n)) 592. Fraction Addition and Subtraction分数运算，有负数，只有+-操作，最后要返回一个分数，如果是整数的话，需要分母1。123456Input:&quot;-1/2+1/2&quot;Output: &quot;0/1&quot;Input:&quot;-1/2+1/2+1/3&quot;Output: &quot;1/3&quot;Input:&quot;1/3-1/2&quot;Output: &quot;-1/6&quot; 方法一：cheat 写法。 1234567891011def fractionAddition(self, expression: str) -&gt; str: import fractions tokens = iter(re.findall(r'-?\d+\/-?\d+|[+-]', expression)) ans, sign = fractions.Fraction(0), 1 for token in tokens: if token in '+-': sign = ' +'.find(token) else: ans += sign * fractions.Fraction(token) ans = str(ans) + ('/' not in str(ans)) * '/1' return ans 方法二：自己实现了一个。 123456789101112131415161718def fractionAddition(self, expression: str) -&gt; str: tokens = iter(re.findall(r'-?\d+\/-?\d+|[+-]', expression)) def cal(a, b, sign=1): na, da = map(int, a.split('/')) nb, db = map(int, b.split('/')) dc = da*db // math.gcd(da, db) nc = dc//da*na + sign*dc//db*nb r = math.gcd(nc, dc) return '&#123;&#125;/&#123;&#125;'.format(nc//r, dc//r) ans, sign = '0/1', 1 for token in tokens: if token in '+-': sign = ' +'.find(token) else: ans = cal(ans, token, sign) return ans 方法三：受到评论区大佬启发，优化一下，首先对正则优化，可以将分子分母都拆分出来，然后一次取两个。Stefan的答案，我居然把分数累加的公式都给忘了。 1234567891011def fractionAddition(self, expression: str) -&gt; str: nums = iter(map(int, re.findall(r'[+-]?\d+', expression))) na, da = 0, 1 for nb in nums: db = next(nums) na = na*db + da*nb da *= db r = math.gcd(na, da) na //= r da //= r return '&#123;&#125;/&#123;&#125;'.format(na, da) 方法四：Lee的写法，是我愚钝了。 1234def fractionAddition(self, expression: str) -&gt; str: from fractions import Fraction as f ans = sum(map(f, re.findall(r'[+-]?\d+/\d+', expression))) return '&#123;&#125;/&#123;&#125;'.format(ans.numerator, ans.denominator) 397. Integer Replacement给定一个数，偶数可以/2，奇数可以+1，-1，问最少多少步能到1。12345678Input:8Output:3Explanation:8 -&gt; 4 -&gt; 2 -&gt; 1 方法一：递归。 1234567891011def integerReplacement(self, n: int) -&gt; int: @lru_cache(None) def dp(i): if i == 1: return 0 if i &amp; 1 == 0: return dp(i//2) + 1 else: return min(dp(i+1), dp(i-1)) + 1 return dp(n) 方法二：这是一个贪心的方法。首先需要推导证明。//2的方式一定是最快的，因为2/1也只用了1步。 12345f(1) = 0f(2n) = 1 + f(n)f(2n+1) = min(f(2n)+1, f(2n+2)+1)f(2n+2) = f(n+1) + 1f(2n+1) = min(f(2n)+1, f(n+1)+2) 1234567891011def integerReplacement(self, n): rtn = 0 while n &gt; 1: rtn += 1 if n % 2 == 0: n //= 2 elif n % 4 == 1 or n == 3: n -= 1 else: n += 1 return rtn 372. Super Pow求大数的幂。幂也可以很大。对1337的余数。12Input: a = 2, b = [1,0]Output: 1024 方法一：我用math.pow()， 超过了range error了。而stefan的pow就可以，难道因为取余运算放到方法里就很快？即使是这种方式，将1337用%取余也会超时。 12def superPow(self, a: int, b: List[int]) -&gt; int: return pow(a, int(''.join(map(str, b))), 1337) 方法二：Stefan的方法。 12345def superPow(self, a: int, b: List[int]) -&gt; int: ans = 1 for digit in b: ans = (pow(ans, 10, 1337) * pow(a, digit, 1337)) % 1337 return ans]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（数组篇）Array]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%95%B0%E7%BB%84%E7%AF%87%EF%BC%89Array%2F</url>
    <content type="text"><![CDATA[26. Remove Duplicates from Sorted Array删除排序数组中重复的元素, 在原数组上操作，返回一个长度，标识前n个元素为目标数组。原题 12345Given nums = [0,0,1,1,1,2,2,3,3,4],Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.It doesn&apos;t matter what values are set beyond the returned length. 123456789def remove_duplicates(nums): if not nums: return 0 index = 1 for i in range(len(nums)-1): if nums[i] != nums[i+1]: nums[index] = nums[i+1] index += 1 return index 80. Remove Duplicates from Sorted Array II和上题一样，但是可以允许重复两次。原题方法一：双指针调了半天。 1234567891011121314def removeDuplicates(self, nums: List[int]) -&gt; int: left = right = cnt = 0 last_left = None n = len(nums) while right &lt; n: while right&lt;n and nums[right]==last_left and cnt: right += 1 if right &gt;= n: break nums[left] = nums[right] cnt = last_left==nums[left] last_left = nums[left] left += 1 right += 1 return left 方法二：stefan的方法原来这么简单。i作为待插入的索引位置，用n和他前两位比较，如果一样的话，保持插入位置不动，而nums[i-2]是不变的，一直可以用来作比较。 1234567def removeDuplicates(self, nums: List[int]) -&gt; int: i = 0 for n in nums: if i&lt;2 or n&gt;nums[i-2]: nums[i] = n i += 1 return i 66. Plus One给数组加一，元素为非负整数，不以0开头，每个元素只有一个数字。原题123Input: [4,3,2,1]Output: [4,3,2,2]Explanation: The array represents the integer 4321. 方法一：转成字符串再转成数字 123def plusOne(self, digits: 'List[int]') -&gt; 'List[int]': num = int(''.join(map(str, digits))) return [int(d) for d in str(num + 1)] 方法二：Math 进位 123456789101112def plus_one(digits): d = digits[:] plused = [] carry = 1 while d or carry: if d: v = d.pop() else: v = 0 carry, val = divmod(carry+v, 10) plused.append(val) return plused[::-1] 方法三：数组进位。 123456789def plusOne(self, digits: 'List[int]') -&gt; 'List[int]': d = digits[:] d[-1] += 1 for i in range(len(d)-1, -1, -1): carry, d[i] = divmod(d[i], 10) if i: d[i-1] += carry if carry: d.insert(0, carry) return d 989. Add to Array-Form of Integer和66题很相似。不同的是这个K会大于10，以至于余数也会大于10。原题123Input: A = [2,7,4], K = 181Output: [4,5,5]Explanation: 274 + 181 = 455 方法一：竞赛写法。 123def addToArrayForm(self, A: 'List[int]', K: 'int') -&gt; 'List[int]': a = int(''.join(map(str, A))) return [int(c) for c in str(a + K)] 方法二：原理实现。 12345678def addToArrayForm(self, A: 'List[int]', K: 'int') -&gt; 'List[int]': A[-1] += K for i in range(len(A)-1, -1, -1): carry, A[i] = divmod(A[i], 10) if i: A[i-1] += carry if carry: A = list(map(int, str(carry))) + A return A 88. Merge Sorted Array合并两个有序数组，在nums1上修改。原题12345Input:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3Output: [1,2,2,3,5,6] 12345678910def merge(self, nums1, m, nums2, n): while m&gt;0 and n&gt;0: if nums1[m-1] &gt; nums2[n-1]: nums1[n+m-1] = nums1[m-1] m -= 1 else: nums1[n+m-1] = nums2[n-1] n -= 1 if n &gt; 0: nums1[:n] = nums2[:n] 118. Pascal’s Triangle杨辉三角。原题123456789Input: 5Output:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 方法一: 错位相加。这里也可以使用zip，值得注意的是，res需要➕一个二维数组，而不是一维。结尾的切片是为了0的情况。 123456def generate(self, numRows: 'int') -&gt; 'List[List[int]]': ans = [[1]] for _ in range(numRows-1): ans += [[a+b for a, b in zip([0]+ans[-1], ans[-1]+[0])]] # ans.append(list(map(lambda x, y: x + y, [0]+ans[-1], ans[-1]+[0]))) return ans[:numRows] 方法二 123456789def generate(num): triangle = [] inner = [1] for _ in range(num): triangle.append(list(inner)) inner.append(0) right = [inner[i]+inner[i+1] for i in range(len(inner)-1)] inner = [1] + right return triangle 119.Pascal’s Triangle II杨辉三角，只打印一层。原题12345def getRow(self, rowIndex: 'int') -&gt; 'List[int]': ans = [1] for _ in range(rowIndex): ans = [a+b for a, b in zip([0]+ans, ans+[0])] return ans 169. Majority Element找出数组中出现次数超过一半的元素。原题方法一：排序. Time-O(nlogn), Space-O(n) 12def majority_element(nums): return sorted(nums)[len(nums)//2] 方法二：Counter Time-O(n), Space-O(n) 12345def majority_element(nums): from collections import Counter c = Counter(nums) # return max(c.keys(), key=c.get) return c.most_common(1)[0][0] 方法三：Boyer-Moore Voting Algorithm. 书中的算法说的就是这个，这里附上自己的见解。 波义尔摩尔投票算法 12345678def majorityElement(self, nums): count = 0 candidate = None for num in nums: if count == 0: candidate = num count += (1 if num == candidate else -1) return candidate 229. Majority Element II找到数组中出现超过n/3次的元素。原题12Input: [1,1,1,3,3,2,2,2]Output: [1,2] 方法一：波义尔摩尔投票法同样可用，但是我一开始想一次遍历求，发现好像不可以，最后都要遍历一次判断是否满足条件。循环中是elif，两个候选人开始设为不同的值以用来区分。 123456789101112131415def majorityElement(self, nums: List[int]) -&gt; List[int]: count1, count2, candidate1, candidate2 = 0, 0, 0, 1 for n in nums: if n == candidate1: count1 += 1 elif n == candidate2: count2 += 1 elif count1 == 0: candidate1, count1 = n, 1 elif count2 == 0: candidate2, count2 = n, 1 else: count1, count2 = count1 - 1, count2 - 1 return [n for n in (candidate1, candidate2) if nums.count(n) &gt; len(nums) // 3] 方法二：Counter. by Stefan. 1234567def majorityElement(self, nums: List[int]) -&gt; List[int]: ctr = Counter() for n in nums: ctr[n] += 1 if len(ctr)==3: ctr -= Counter(set(ctr)) # 均-1 return [n for n in ctr if nums.count(n) &gt; len(nums)//3] 189. Rotate Array旋转数组。原题123456Input: [1,2,3,4,5,6,7] and k = 3Output: [5,6,7,1,2,3,4]Explanation:rotate 1 steps to the right: [7,1,2,3,4,5,6]rotate 2 steps to the right: [6,7,1,2,3,4,5]rotate 3 steps to the right: [5,6,7,1,2,3,4] 方法一：slicing。 123def rotate(nums, k): k = k % len(nums) nums[:] = nums[-k:] + nums[:-k] 方法二：这个方法不是很高效 123def rotate(nums, k): for _ in range(k): nums.insert(0, nums.pop()) 方法三：deque实现。 1234def rotate(self, nums: 'List[int]', k: 'int') -&gt; 'None': q = collections.deque(nums) q.rotate(k) nums[:] = q 217. Contains Duplicate数组中是否包含重复元素。原题12Input: [1,2,3,1]Output: true 方法一：set 12def contains_duplicate(nums): return len(set(nums)) &lt; len(nums) 方法二：hash 12345678def containsDuplicate(self, nums: 'List[int]') -&gt; 'bool': seen = set() for num in nums: if num in seen: return True else: seen.add(num) return False 219. Contains Duplicate II数组中是否包含重复元素，且元素下标差小于等于k。原题1234Input: nums = [1,2,3,1], k = 3Output: trueInput: nums = [1,0,1,1], k = 1Output: true 思路：开始想用set作切片来判断，同上题方法一，但是效率太低。故使用字典。 123456789def containsNearbyDuplicate(self, nums, k): n = len(nums) seen = &#123;&#125; for i, num in enumerate(nums): if num in seen: if i-seen[num] &lt;= k: return True seen[num] = i return False 220. Contains Duplicate III是否存在索引差k范围内的绝对值不大于t的两个值。原题1234Input: nums = [1,2,3,1], k = 3, t = 0Output: trueInput: nums = [1,5,9,1,5,9], k = 2, t = 3Output: false 方法一：实际上是桶排序的原理，每个桶的size为t。两个差值为t的的数，只可能出现在同一个桶或者两边的桶中。 12345678910111213def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -&gt; bool: if k &lt; 1 or t &lt; 0: return False dic = collections.OrderedDict() for n in nums: key = n if not t else n // t for m in (dic.get(key - 1), dic.get(key), dic.get(key + 1)): if m is not None and abs(n - m) &lt;= t: return True if len(dic) == k: dic.popitem(False) dic[key] = n return False 283. Move Zeroes将数组0元素移动到末尾，保证其他元素顺序。原题12Input: [0,1,0,3,12]Output: [1,3,12,0,0] 方法一：two pointers 12345678def move_zero(nums): l, r = 0, len(nums)-1 while l &lt; r: if nums[l] == 0: nums[:] = nums[:l] + nums[l+1:] + [0] r -= 1 else: l += 1 方法二： slicing 12def move_zero(nums): nums[:] = [x for x in nums if x != 0] + [x for x in nums if x == 0] 方法三：最后0的位置，感觉像冒泡。 123456def moveZeroes(self, nums: 'List[int]') -&gt; 'None': p = 0 for i, num in enumerate(nums): if num != 0: nums[p], nums[i] = nums[i], nums[p] p += 1 方法四：排序。时间复杂度略高。 12def moveZeroes(self, nums: 'List[int]') -&gt; 'None': nums.sort(key=lambda x: 1 if x==0 else 0) 54. Spiral Matrix螺旋矩阵，顺时针打印矩阵。原题这里注意一点matrix.pop(0)需要转成list，因为zip函数中的每个元素是一个tuple，如果不转变成了一个tuple+list，会抛出异常。 ps: 此题解法为LeetCode一位大神，经常能看到此人的答案，不过这个是我认为最pythonic的一个，没有为了强行one-line而one-line。brilliant! 1TypeError: can only concatenate tuple (not &quot;list&quot;) to tuple 12def spiralOrder(self, matrix): return matrix and list(matrix.pop(0))+self.spiralOrder(list(zip(*matrix))[::-1]) 此题有个变形，如果逆时针该如何打印。这样的话情况稍微复杂一些。 1234567def anti_clock_wise(self, matrix) if not matrix: return [] clock_wise = list(zip(*(matrix[::-1]))) a = list(clock_wise.pop(0))[::-1] b = self.anti_clock_wise(clock_wise) return a + b 59. Spiral Matrix II按照顺时针的顺序生成一个矩阵。原题1234567Input: 3Output:[ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ]] 方法一：自己的方法。使用了一个控制方向，如果超范围或者有值就换方向。1234567891011121314def generateMatrix(self, n: int) -&gt; List[List[int]]: ans = [[0]*n for _ in range(n)] op = itertools.cycle([(0, 1), (1, 0), (0, -1), (-1, 0)]) d = next(op) x, y = (0, 0) for k in range(1, n**2+1): ans[x][y] = k i, j = x+d[0], y+d[1] if not 0&lt;=i&lt;n or not 0&lt;=j&lt;n or ans[i][j]: d = next(op) x, y = x+d[0], y+d[1] else: x, y = i, j return ans 方法二：stefan的旋转法，我往这边想了，zip也想到了，没想到的是，从里往外遍历，还有一点是根据A的长度确定起始点。 123|| =&gt; |9| =&gt; |8| |6 7| |4 5| |1 2 3| |9| =&gt; |9 8| =&gt; |9 6| =&gt; |8 9 4| |8 7| |7 6 5| 123456def generateMatrix(self, n: int) -&gt; List[List[int]]: A, lo = [], n**2+1 while lo &gt; 1: lo, hi = lo - len(A), lo A = [range(lo, hi)] + list(zip(*A[::-1])) return A 885. Spiral Matrix III从二维数组中的某一个点开始顺时针旋转输出所有的坐标。原题方法一：还是通过生成器控制方向，当处于水平位置时步数增加1。 1234567891011121314def spiralMatrixIII(self, R: int, C: int, r0: int, c0: int) -&gt; List[List[int]]: direction = itertools.cycle([(0, 1), (1, 0), (0, -1), (-1, 0)]) ans = [(r0, c0)] step = 0 while len(ans) &lt; R*C: di, dj = next(direction) if di==0: step += 1 for _ in range(step): r0 += di c0 += dj if 0&lt;=r0&lt;R and 0&lt;=c0&lt;C: ans.append((r0, c0)) return ans 方法二：Lee的方法。使用了di, dj = dj, -di刚好是这个右转的方向。然后用一个n来计算步数。 12345678910def spiralMatrixIII(self, R: int, C: int, r0: int, c0: int) -&gt; List[List[int]]: ans = [] di, dj, step = 0, 1, 0 while len(ans) &lt; R*C: for s in range(step//2+1): if 0&lt;=r0&lt;R and 0&lt;=c0&lt;C: ans.append((r0, c0)) r0, c0 = r0+di, c0+dj di, dj, step = dj, -di, step+1 return ans 方法三：Lee的几何方法。根据到目标点的距离大小排序。 12345def spiralMatrixIII(self, R, C, r, c): def key((x, y)): x, y = x - r, y - c return (max(abs(x), abs(y)), -((math.atan2(-1, 1) - math.atan2(x, y)) % (math.pi * 2))) return sorted([(i, j) for i in xrange(R) for j in xrange(C)], key=key) 215. Kth Largest Element in an Array找出数组中最大的第K个数。原题快排的思想，没有通过LeetCode测试用例，因为内存超出了限制。 12345678910111213141516171819def findKthLargest(self, nums, k): if not nums: return pivot = nums[0] left, medium, right = [], [], [] for num in nums: if num &lt; pivot: left.append(num) elif num == pivot: medium.append(num) else: right.append(num) if k &lt;= len(right): return self.findKthLargest(right, k) elif k-len(right) &lt;= len(medium): return pivot else: return self.findKthLargest(left, k-len(right)-len(medium)) 考虑在原数组上进行修改。Time-O(n) 12345678910111213141516171819def findKthLargest(self, nums: List[int], k: int) -&gt; int: random.shuffle(nums) l, r = 0, len(nums)-1 def partition(l, r): for i, v in enumerate(nums[l:r+1], l): if nums[i] &gt;= nums[r]: nums[i], nums[l] = nums[l], nums[i] l += 1 return l-1 # return the index of pivot while True: pos = partition(l, r) # pos是索引，所以要与k-1比较 if pos &lt; k-1: l = pos + 1 elif pos &gt; k-1: r = pos - 1 else: return nums[pos] 使用堆。Time-O(nlogk) 12345678def findKthLargest(self, nums: List[int], k: int) -&gt; int: import heapq as hq heap = nums[:k] hq.heapify(heap) for num in nums[k:]: if num &gt; heap[0]: hq.heapreplace(heap, num) return heap[0] 703. Kth Largest Element in a Stream流中第K个大的数。原题12345678int k = 3;int[] arr = [4,5,8,2];KthLargest kthLargest = new KthLargest(3, arr);kthLargest.add(3); // returns 4kthLargest.add(5); // returns 5kthLargest.add(10); // returns 5kthLargest.add(9); // returns 8kthLargest.add(4); // returns 8 方法一：还是使用堆，一开始没想到切分，所以超时了。注意是heapreplace。 12345678910111213141516class KthLargest: def __init__(self, k, nums): import heapq self.heap = list(nums) self.k = k heapq.heapify(self.heap) while len(self.heap) &gt; k: heapq.heappop(self.heap) def add(self, val): if len(self.heap) &lt; self.k: heapq.heappush(self.heap, val) elif val &gt; self.heap[0]: heapq.heapreplace(self.heap, val) return self.heap[0] 53. Maximum Subarray连续子数组的最大和。原题123Input: [-2,1,-3,4,-1,2,1,-5,4],Output: 6Explanation: [4,-1,2,1] has the largest sum = 6. 方法一：书中的思想。 123456def maxSubArray(self, nums): cp_nums = nums[:] for i in range(1, len(nums)): if cp_nums[i-1] &gt; 0: cp_nums[i] += cp_nums[i-1] return max(cp_nums) 方法二：one-liner。注意accumulate是把函数放到后面的。 123def maxSubArray(self, nums): from itertools import accumulate return max(accumulate(nums, lambda x, y: x+y if x &gt; 0 else y)) 918. Maximum Sum Circular Subarray连续数组的最大和，数组可以首位相连，但是最大长度不能超过一个数组。原题123Input: [1,-2,3,-2]Output: 3Explanation: Subarray [3] has maximum sum 3 方法一：by @Lee215。看完这个解法豁然开朗，只需要同时找到一个累加和最小的子数组，再用总数减掉。 12345678910def maxSubarraySumCircular(self, A: List[int]) -&gt; int: total = cur_max = cur_min = 0 sum_max, sum_min = float('-inf'), float('inf') for a in A: cur_max = max(cur_max+a, a) sum_max = max(sum_max, cur_max) cur_min = min(cur_min+a, a) sum_min = min(sum_min, cur_min) total += a return max(sum_max, total-sum_min) if sum_max &gt; 0 else sum_max 904. Fruit Into Baskets实际上该题抽象为求最大滑动窗口的长度，滑动窗口不同元素最多不超过两个。原题1234tree = [3,3,3,1,2,1,1,2,3,3,4] # 5tree = [1,0,1,4,1,4,1,2,3] # 5tree = [1,2,3,2,2] # 4tree = [0,1,6,6,4,4,6] # 5 一开始没有找到滑动窗口的左边界，老是想直接删除一个key，后来看别人代码受到启发，可以用一个内循环来解决，可以逐个删除，然后判断是否为空。 12345678910111213def totalFruit(self, tree): from collections import Counter basket = Counter() l, res = 0, 0 for r in range(len(tree)): basket[tree[r]] += 1 while len(basket) &gt; 2: basket[tree[l]] -= 1 if basket[tree[l]] == 0: basket.pop(tree[l]) l += 1 res = max(res, r-l+1) return res 27. Remove Element从数组中删除元素，在原数组修改，要求返回一个长度。原题12Given nums = [0,1,2,2,3,0,4,2], val = 2,Your function should return length = 5, 方法一：前后指针，r要从n开始，以n-1作比较，这里r不是从n-1开始是因为nums=[]的情况，否则l+1将超出数组范围。 123456789def removeElement(self, nums, val): l, r = 0, len(nums) while l &lt; r: if nums[l] == val: nums[l], nums[r-1] = nums[r-1], nums[l] r -= 1 else: l += 1 return l 方法二：快慢指针，几乎和283题中的方法一样。 1234567def removeElement(self, nums, val): i = 0 for j in range(len(nums)): if nums[j] != val: nums[i] = nums[j] i += 1 return i 349. Intersection of Two Arrays求两个数组的交集。返回的数组必须元素唯一，可以无序。原题思路：一开始看到这题以为是两个链表求相交点。最后发现Intersection不应该理解为“十字路口”而应该是“交集”。这里翻了一下discuss，大部分都是使用方法一，其它方法要么太繁琐，要么效率低。值得注意的是，此题的相关话题还有一项是Binary Search也就是说，可能会有一个较为高效的二分搜索法的实现方式。 123Example 2:Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]Output: [9,4] 方法一：最快的方法。 12def intersection(self, nums1, nums2): return list(set(nums1) &amp; set(nums2)) 方法二：Sort &amp; Two Pointers. 123456789101112131415161718def intersection(self, nums1: 'List[int]', nums2: 'List[int]') -&gt; 'List[int]': nums1.sort() nums2.sort() i, n1 = 0, len(nums1) j, n2 = 0, len(nums2) ans, last = [], None while i &lt; n1 and j &lt; n2: if nums1[i] == nums2[j]: if nums1[i] != last: ans.append(nums1[i]) last = nums1[i] i += 1 j += 1 elif nums1[i] &gt; nums2[j]: j += 1 elif nums1[i] &lt; nums2[j]: i += 1 return ans 350. Intersection of Two Arrays II和上题不同的是要返回所有的交集元素。原题1234Example 1:Input: nums1 = [1,2,2,1], nums2 = [2,2]Output: [2,2] 方法一：Counter实现了&amp;操作可以直接取交集。 1234def intersect(self, nums1, nums2): from collections import Counter a, b = map(Counter, (nums1, nums2)) return list((a &amp; b).elements()) 方法二：不使用Counter。 1234567891011def intersect(self, nums1, nums2): from collections import defaultdict counter = defaultdict(int) res = [] for num1 in nums1: counter[num1] += 1 for num2 in nums2: if counter[num2] != 0: res.append(num2) counter[num2] -= 1 return res 方法三：可以采用上题349的方法，只需要去掉last即可。 905. Sort Array By Parity将一个数组重新排列，是偶数在前奇数在后。原题123Input: [3,1,2,4]Output: [2,4,3,1]The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted. 方法一：双指针。 123456789def sortArrayByParity(self, A): l, r = 0, len(A)-1 while l &lt; r: while l&lt;r and A[l]&amp;1==0: l += 1 while l&lt;r and A[r]&amp;1==1: r -= 1 A[l], A[r] = A[r], A[l] return A 方法二：列表生成式。 1234def sortArrayByParity(self, A): even = [num for num in A if num &amp; 1 == 0] odd = [num for num in A if num &amp; 1 == 1] return even + odd 922. Sort Array By Parity II输入一个奇数偶数数量相同的数组，返回下标和其对应的值都是奇数或偶数，即奇偶交叉。和905相似。原题方法一：使用切片的特性赋值。 12345def sortArrayByParityII(self, A): res = [None] * len(A) res[::2] = (num for num in A if num &amp; 1 == 0) res[1::2] = (num for num in A if num &amp; 1 == 1) return res 方法二：双指针。 12345678def sortArrayByParityII(self, A: 'List[int]') -&gt; 'List[int]': j = 1 for i in range(0, len(A), 2): if A[i] &amp; 1 == 1: while A[j] &amp; 1 == 1: j += 2 A[i], A[j] = A[j], A[i] return A 933. Number of Recent Calls输入一个时间t，返回3000毫秒内所有的请求个数。原题方法一：deque. 12345678910class RecentCounter: def __init__(self): self.q = collections.deque() def ping(self, t: 'int') -&gt; 'int': self.q.append(t) while self.q[0] &lt; t - 3000: self.q.popleft() return len(self.q) 937. Reorder Log Files按照规则将log文件排序。原题12Input: [&quot;a1 9 2 3 1&quot;,&quot;g1 act car&quot;,&quot;zo4 4 7&quot;,&quot;ab1 off key dog&quot;,&quot;a8 act zoo&quot;]Output: [&quot;g1 act car&quot;,&quot;a8 act zoo&quot;,&quot;ab1 off key dog&quot;,&quot;a1 9 2 3 1&quot;,&quot;zo4 4 7&quot;] 方法一：列表生成式。 12345def reorderLogFiles(self, logs): letter_logs = [l for l in logs if l.split()[1].isalpha()] digit_logs = [l for l in logs if not l.split()[1].isalpha()] letter_logs.sort(key=lambda x: x.split()[1:]) return letter_logs + digit_logs 方法二：sort. 12345def reorderLogFiles(self, logs: 'List[str]') -&gt; 'List[str]': def f(log): pk, text = log.split(" ", 1) return (0, text) if text[0].isalpha() else (1, ) return sorted(logs, key=f) 485. Max Consecutive Ones输入一个二进制数组，返回最大的连续1的长度。原题1234Input: [1,1,0,1,1,1]Output: 3Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3. 方法一：不使用标准库。末尾补0是因为，如果原数组末尾是1的情况下，还需要计算一次max的值。缺点是改变了原数组。也可以使用再计算一次的方式。 123456789def findMaxConsecutiveOnes(self, nums: 'List[int]') -&gt; 'int': ans = count = 0 for num in nums+[0]: if num == 1: count += 1 else: ans = max(ans, count) count = 0 return ans 方法二：使用groupby。 1234567def findMaxConsecutiveOnes(self, nums): from itertools import groupby max_con = 0 for d, group in groupby(nums): if d == 1: max_con = max(max_con, len(list(group))) return max_con 方法三：split。不过这个效率不高。 1234def findMaxConsecutiveOnes(self, nums): nums_str = ''.join(map(str, nums)) ones = nums_str.split('0') return len(max(ones)) 方法四：使用accumulate。Space-complex O(n)。 123def findMaxConsecutiveOnes(self, nums): from itertools import accumulate return max(accumulate(nums, lambda x, y: x+y if y==1 else y)) 1004. Max Consecutive Ones III与上题不同的是，有K次机会可以将0变成1. 原题12345Input: A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3Output: 10Explanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]Bolded numbers were flipped from 0 to 1. The longest subarray is underlined. 方法一：这题竞赛时没想出来，受上题影响，思路跑到了groupby那里，想着怎么分组后操作。实际上此题完全不同，应该使用滑动窗口。 123456789def longestOnes(self, A: List[int], K: int) -&gt; int: ans = i = 0 for j in range(len(A)): K -= A[j]==0 while K &lt; 0: K += A[i]==0 i += 1 ans = max(ans, j-i+1) return ans 946. Validate Stack Sequences给定一个入栈和出栈的顺序，判断是否最后可以清空该栈。原题123456789Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1]Output: trueExplanation: We might do the following sequence:push(1), push(2), push(3), push(4), pop() -&gt; 4,push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1Input: pushed = [1,2,3,4,5], popped = [4,3,5,1,2]Output: falseExplanation: 1 cannot be popped before 2. 123456789def validateStackSequences(self, pushed: 'List[int]', popped: 'List[int]') -&gt; 'bool': stack = [] j = 0 for num in pushed: stack.append(num) while stack and stack[-1] == popped[j]: stack.pop() j += 1 return j == len(popped) 496. Next Greater Element I找出数组nums2中对应的nums1元素的位置之后的第一个比nums1大的元素。nums1是nums2的子集，二者均无重复的元素。原题123456789101112Input: nums1 = [4,1,2], nums2 = [1,3,4,2].Output: [-1,3,-1]Explanation: For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1. For number 1 in the first array, the next greater number for it in the second array is 3. For number 2 in the first array, there is no next greater number for it in the second array, so output -1. Input: nums1 = [2,4], nums2 = [1,2,3,4].Output: [3,-1]Explanation: For number 2 in the first array, the next greater number for it in the second array is 3. For number 4 in the first array, there is no next greater number for it in the second array, so output -1. 方法一：暴力法，因为题中给了范围数组长度小于1000，所以也没有超时。 1234567891011121314def nextGreaterElement(self, nums1, nums2): res = [] for num1 in nums1: index = nums2.index(num1) if not nums2[index+1:]: res.append(-1) else: for num2 in nums2[index+1:]: if num2 &gt; num1: res.append(num2) break else: res.append(-1) return res 方法二：one-liner，生成器一开始想到了，没想到next函数还可以设默认值。 123def nextGreaterElement(self, nums1, nums2): return [next((y for y in nums2[nums2.index(x):] if y &gt; x), -1) for x in nums1] 方法三：Time: O(n). 1234567def nextGreaterElement(self, nums1, nums2): st, d = [], &#123;&#125; for n in nums2: while st and st[-1] &lt; n: d[st.pop()] = n st.append(n) return list(map(lambda x: d.get(x, -1), nums1)) 953. Verifying an Alien Dictionary判断一个字符串数组是否按照特定的字典顺序排序。原题123456789Input: words = [&quot;hello&quot;,&quot;leetcode&quot;], order = &quot;hlabcdefgijkmnopqrstuvwxyz&quot;Output: trueExplanation: As &apos;h&apos; comes before &apos;l&apos; in this language, then the sequence is sorted.Input: words = [&quot;word&quot;,&quot;world&quot;,&quot;row&quot;], order = &quot;worldabcefghijkmnpqstuvxyz&quot;Output: falseExplanation: As &apos;d&apos; comes after &apos;l&apos; in this language, then words[0] &gt; words[1], hence the sequence is unsorted.Input: words = [&quot;apple&quot;,&quot;app&quot;], order = &quot;abcdefghijklmnopqrstuvwxyz&quot;Output: falseExplanation: The first three characters &quot;app&quot; match, and the second string is shorter (in size.) According to lexicographical rules &quot;apple&quot; &gt; &quot;app&quot;, because &apos;l&apos; &gt; &apos;∅&apos;, where &apos;∅&apos; is defined as the blank character which is less than any other character (More info). 方法一：这道题想了很久，最后还是没有做出来，一开始想用zip来自己实现，也想到了sort，但是key里面的匿名函数一直没有想对，关键是二维数组也能排序这点没有想到。 123def isAlienSorted(self, words: 'List[str]', order: 'str') -&gt; 'bool': d = dict(zip(order, range(26))) return words == sorted(words, key=lambda w: [d[c] for c in w]) 方法二：传统方法，优点在于提前退出。 123456789101112131415def isAlienSorted(self, words: 'List[str]', order: 'str') -&gt; 'bool': d = dict(zip(order, range(26))) for i in range(len(words)-1): word1, word2 = words[i:i+2] for c1, c2 in zip(word1, word2): if c1 != c2: if d[c1] &gt; d[c2]: return False break else: if len(word1) &gt; len(word2): return False return True 506. Relative Ranks根据得分，返回排名。前三要用奖牌表示。原题1234Input: [5, 4, 3, 2, 1]Output: [&quot;Gold Medal&quot;, &quot;Silver Medal&quot;, &quot;Bronze Medal&quot;, &quot;4&quot;, &quot;5&quot;]Explanation: The first three athletes got the top three highest scores, so they got &quot;Gold Medal&quot;, &quot;Silver Medal&quot; and &quot;Bronze Medal&quot;. For the left two athletes, you just need to output their relative ranks according to their scores. 方法一：先生成一个排行榜单，再根据每个得分把排序映射上去。 12345def findRelativeRanks(self, nums): ranks = list(map(str,range(1, len(nums)+1))) ranks[:3] = ["Gold Medal", "Silver Medal", "Bronze Medal"] sorted_nums = sorted(nums, reverse=True) return [ranks[sorted_nums.index(num)] for num in nums] # slow 方法二：使用map映射。 1234567def findRelativeRanks(self, nums): ranks = list(map(str,range(1, len(nums)+1))) ranks[:3] = ["Gold Medal", "Silver Medal", "Bronze Medal"] sorted_nums = sorted(nums, reverse=True) # map_rank = &#123;num: ranks[i] for i, num in enumerate(sorted_nums)&#125; # return list(map(map_rank.get, nums)) return list(map(dict(zip(sorted_nums, ranks)).get, nums)) 532. K-diff Pairs in an Array找出差为k的不重复的成对元素的个数。原题1234Input: [3, 1, 4, 1, 5], k = 2Output: 2Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).Although we have two 1s in the input, we should only return the number of unique pairs. 方法一：Counter，一开始没想到，想sort或是set，然后实现不了。 12345678def findPairs(self, nums, k): from collections import Counter c = Counter(nums) res = 0 for num, count in c.items(): if (k == 0 and count &gt; 1) or (k &gt; 0 and num+k in c): res += 1 return res 961. N-Repeated Element in Size 2N Array找出2N长的数组中重复N次的数字，其它数字均只出现一次。此题不能用波义尔摩尔投票因为数量没有大于半数。原题12Input: [2,1,2,5,3,2]Output: 2 方法一：这题本意我看是哈希表，所以大部分答案都是Counter之类的，我看排行榜签名的Python选手也是这么用的，我是灵机一动一动动想出了一个数学方法。看上去迭代了两次数组，并使用了一些空间，但其实速度很快。 12def repeatedNTimes(self, A): return (sum(A)-sum(set(A))) // (len(A)//2-1) 方法二：其实是找重复的数字，那么就数量是一定的话，其他数字的相邻两位中可能会有重复，其他一种不重复情况，2234和2342。此方法不能用于169题，因为169题中的其它元素是可能重复的。 12345def repeatedNTimes(self, A: 'List[int]') -&gt; 'int': for i in range(2, len(A)): if A[i] == A[i-1] or A[i] == A[i-2]: return A[i] return A[0] 967. Numbers With Same Consecutive Differences根据规则生成一组数组，数字长度为N，每两位的差为K。原题方法一：迭代生成，其实此题本是一道动态规划题，但由于解法不是，暂时归到数组里。 1234567891011121314def numsSameConsecDiff(self, N, K): ans = &#123;x for x in range(1, 10)&#125; for _ in range(N-1): ans2 = set() for digit in ans: d = digit % 10 if d - K &gt;= 0: ans2.add(digit*10 + d - K) if d + K &lt;= 9: ans2.add(digit*10 + d + K) ans = ans2 if N == 1: ans.add(0) return list(ans) 方法二：简化。 123456def numsSameConsecDiff(self, N, K): ans = range(10) for _ in range(N-1): ans = &#123;x*10+y for x in ans for y in (x%10-K, x%10+K) if x and 0&lt;=y&lt;10&#125; return list(ans) 561. Array Partition I将数组两两分成一组，累加每组的最小值，使之尽量大。原题1234Input: [1,4,3,2]Output: 4Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4). 12def arrayPairSum(self, nums): return sum(sorted(nums)[::2]) 566. Reshape the Matrix改变矩阵的形状，如果元素超出或不足，返回原矩阵。原题123456789Input: nums = [[1,2], [3,4]]r = 1, c = 4Output: [[1,2,3,4]]Explanation:The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list. 方法一：扁平化后重组。 123456def matrixReshape(self, nums, r, c): a = [x for row in nums for x in row] n = len(a) if r*c != n: return nums return [a[i*c:i*c+c] for i in range(r)] 方法二：使用itertools. 123456def matrixReshape(self, nums, r, c): if r*c != len(nums)*len(nums[0]): return nums from itertools import islice, chain it = chain(*nums) return [list(islice(it, c)) for _ in range(r)] 575. Distribute Candies给姐姐弟弟分糖，两人数量一样，保证姐姐的种类最多，求姐姐最多能分到多少种。原题123456Input: candies = [1,1,2,2,3,3]Output: 3Explanation:There are three different kinds of candies (1, 2 and 3), and two candies for each kind.Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too. The sister has three different kinds of candies. 12def distributeCandies(self, candies): return min(len(candies)//2, len(set(candies))) 594. Longest Harmonious Subsequence最长的和谐子数组，即元素的最大值和最小值正好相差一的子数组，元素顺序无关，求最大子数组长度。原题123Input: [1,3,2,2,5,2,3,7]Output: 5Explanation: The longest harmonious subsequence is [3,2,2,2,3]. 方法一：开始想错了，后来发现子数组只能包含两个元素。 12345678def findLHS(self, nums): from collections import Counter res = 0 c = Counter(nums) for num, count in c.items(): sum_count = count+c[num+1] if c[num+1] else 0 res = max(res, sum_count) return res 方法二：one-liner. 12345def findLHS(self, nums): from collections import Counter c = Counter(nums) return max([count+c[num+1] for num, count in c.items() if num+1 in c] or [0]) 598. Range Addition II这题看上去挺长，其实抽象起来很简单，把整个矩阵想象成一个积木，然后每次往上叠加，每次叠放的矩形都会和左上角对齐，所以最后完成的时候，左上角的一小块一定是最“厚”的，问题就变成和左上一样的厚度的面积。实际上等于叠放的所有矩形的最小长度和最小宽度的乘积。原题123456789101112131415161718192021Input: m = 3, n = 3operations = [[2,2],[3,3]]Output: 4Explanation: Initially, M = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]After performing [2,2], M = [[1, 1, 0], [1, 1, 0], [0, 0, 0]]After performing [3,3], M = [[2, 2, 1], [2, 2, 1], [1, 1, 1]]So the maximum integer in M is 2, and there are four of it in M. So return 4. 12345def maxCount(self, m, n, ops): if not ops: return m*n length, width = list(zip(*ops)) return min(length) * min(width) 599. Minimum Index Sum of Two Lists找出两个人共同最喜欢的餐厅。如果有多个输出多个。原题1234Input:[&quot;Shogun&quot;,&quot;Tapioca Express&quot;,&quot;Burger King&quot;,&quot;KFC&quot;][&quot;Piatti&quot;,&quot;The Grill at Torrey Pines&quot;,&quot;Tapioca Express&quot;,&quot;Shogun&quot;]Output: [&apos;Shogun&apos;, &apos;Tapioca Express&apos;] 方法一：这里做了一个优化，以原list1的顺序输出数组，如果索引太大超出了最小索引和，这样即使是map2使用第一个元素也无法满足条件，直接退出。 1234567891011121314def findRestaurant(self, list1, list2): map2 = &#123;x: i for i, x in enumerate(list2)&#125; res, min_sum = [], float('inf') for i, rest in enumerate(list1): # optimize if i &gt; min_sum: break if rest in map2: if i+map2[rest] &lt; min_sum: res = [rest] min_sum = i+map2[rest] elif i+map2[rest] == min_sum: res += [rest] return res 605. Can Place Flowers是否可以种下给定数量的花。两颗花不能挨着，给定的数组中满足这一条件。原题12Input: flowerbed = [1,0,0,0,1], n = 2Output: False 123456789def canPlaceFlowers(self, flowerbed, n): plots = [0] + flowerbed + [0] p = 1 while p &lt;= len(flowerbed) and n &gt; 0: if plots[p] == 0 and plots[p-1] == 0 and plots[p+1] == 0: plots[p] = 1 n -= 1 p += 1 return n == 0 643. Maximum Average Subarray I最大的连续的长度为k的子数组的平均值。原题123Input: [1,12,-5,-6,50,3], k = 4Output: 12.75Explanation: Maximum average is (12-5-6+50)/4 = 51/4 = 12.75 方法一：参考了stefen大神的答案，自己写的滑动窗口居然超时了。accumulate也不是想不到，此答案厉害的地方在于 补0 和map操作。像这种固定长度的滑动窗口使用补0的accumulate，可以用到其他的题上。 123def findMaxAverage(self, nums, k): sums = [0] + list(itertools.accumulate(nums)) return max(map(operator.sub, sums[k:], sums)) / k 645. Set Mismatch1~n数组中包含一个重复的元素和一个缺失的元素。找出这两个元素。原题12Input: nums = [1,2,2,4]Output: [2,3] 方法一：开始还想着用Counter实现，有些愚蠢。 123def findErrorNums(self, nums): diff_sum = sum(set(nums)) return sum(nums)-diff_sum, sum(range(1, len(nums)+1))-diff_sum 方法二：在原数组元素*-1记录。空间复杂度为常数，但是改变了原数组，时间复杂度稍微高一点，因为迭代两次。 12345678910111213def findErrorNums(self, nums: 'List[int]') -&gt; 'List[int]': dup, miss = -1, 1 for num in nums: if nums[abs(num)-1] &lt; 0: dup = abs(num) else: nums[abs(num)-1] *= -1 for i in range(len(nums)): if nums[i] &gt; 0: miss = i + 1 return dup, miss 方法三：XOR。 661. Image Smoother使图片平滑模糊，一个矩阵使每个点的值为周围所有点的平均值，包括自己。原题123456789101112Input:[[1,1,1], [1,0,1], [1,1,1]]Output:[[0, 0, 0], [0, 0, 0], [0, 0, 0]]Explanation:For the point (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0For the point (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0For the point (1,1): floor(8/9) = floor(0.88888889) = 0 方法一：参考了评论区一位朋友的写法，不过效率不是很高，800ms，Solution给出的方法也是这个速度，看来如果优化的话，可能使用numpy会好一点。 1234567891011def imageSmoother(self, M): import itertools R, C = len(M), len(M[0]) res = [[0]*C for _ in range(R)] offset = list(itertools.product([-1, 0, 1], [-1, 0, 1])) for i in range(R): for j in range(C): points = [M[i+x][j+y] for x, y in offset if 0&lt;=i+x&lt;R and 0&lt;=j+y&lt;C] res[i][j] = sum(points) // len(points) return res 665. Non-decreasing Array判断是否改变一个数，可使其变成单调递增数组。原题123Input: [4,2,3]Output: TrueExplanation: You could modify the first 4 to 1 to get a non-decreasing array. 12345678910def checkPossibility(self, nums): n = len(nums) p = None for i in range(n-1): if nums[i] &gt; nums[i+1]: if p is not None: return False p = i return (not p) or p == n-2 or nums[p-1] &lt;= nums[p+1] or \ nums[p] &lt;= nums[p+2] If p = 0, then we could make the array good by setting A[p] = A[p+1] if p = len(A) - 2, then we could make the array good by setting A[p+1] = A[p] Otherwise, A[p-1], A[p], A[p+1], A[p+2] all exist, and: change A[p] to be between A[p-1] and A[p+1] if possible, or: [4, 8, 6] change A[p+1] to be between A[p] and A[p+2] if possible. [4, 5, 3, 6] 674. Longest Continuous Increasing Subsequence最长连续递增子数组长度。原题1234Input: [1,3,5,4,7]Output: 3Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3. Even though [1,3,5,7] is also an increasing subsequence, it&apos;s not a continuous one where 5 and 7 are separated by 4. 12345678def findLengthOfLCIS(self, nums: 'List[int]') -&gt; 'int': ans = anchor = 0 for i in range(len(nums)): if i and nums[i] &lt;= nums[i-1]: anchor = i else: ans = max(ans, i-anchor+1) return ans 682. Baseball Game棒球游戏，给了一些积分规则。原题12345678Input: [&quot;5&quot;,&quot;2&quot;,&quot;C&quot;,&quot;D&quot;,&quot;+&quot;]Output: 30Explanation: Round 1: You could get 5 points. The sum is: 5.Round 2: You could get 2 points. The sum is: 7.Operation 1: The round 2&apos;s data was invalid. The sum is: 5. Round 3: You could get 10 points (the round 2&apos;s data has been removed). The sum is: 15.Round 4: You could get 5 + 10 = 15 points. The sum is: 30. 123456789101112def calPoints(self, ops): stack = [] for op in ops: if op == 'C': stack.pop() elif op == 'D': stack.append(stack[-1]*2) elif op == '+': stack.append(stack[-1] + stack[-2]) else: stack.append(int(op)) return sum(stack) 690. Employee Importance员工重要值。原题1234Input: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1Output: 11Explanation:Employee 1 has importance value 5, and he has two direct subordinates: employee 2 and employee 3. They both have importance value 3. So the total importance value of employee 1 is 5 + 3 + 3 = 11. 方法一：iteratively. 12345678def getImportance(self, employees, id): emp_dict = &#123;ep.id: (ep.importance, ep.subordinates) for ep in employees&#125; res, stack = 0, [id] while stack: value, subs = emp_dict.get(stack.pop()) res += value stack += subs return res 方法二：recursively. 12345def getImportance(self, employees, id): emp_dict = &#123;ep.id: (ep.importance, ep.subordinates) for ep in employees&#125; def dfs(pk): return emp_dict[pk][0] + sum(dfs(sub) for sub in emp_dict[pk][1]) return dfs(id) 697. Degree of an Arraydegree这里表示数组最常见的元素的频率，然后在连续的子数组中寻找同样的degree，求最小子数组的长度。原题1234567Input: [1, 2, 2, 3, 1]Output: 2Explanation: The input array has a degree of 2 because both elements 1 and 2 appear twice.Of the subarrays that have the same degree:[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]The shortest length is 2. So return 2. 方法一：使用Counter 和index. 600ms有点慢。 12345678910111213def findShortestSubArray(self, nums): from collections import Counter c = Counter(nums) degree = None res = n = len(nums) for num, count in c.most_common(): if degree and count != degree: break min_len = n - nums[::-1].index(num) - 1 - nums.index(num) + 1 # print(min_len, num) res = min(res, min_len) degree = count return res 方法二：使用dict记录索引。 1234567891011121314def findShortestSubArray(self, nums): c = collections.defaultdict(int) left, right = &#123;&#125;, &#123;&#125; for i, num in enumerate(nums): if num not in left: left[num] = i right[num] = i c[num] += 1 res = len(nums) degree = max(c.values()) for num, count in c.items(): if count == degree: res = min(res, right[num]-left[num]+1) return res 方法三：使用Counter + dict. 1234567891011121314def findShortestSubArray(self, nums: 'List[int]') -&gt; 'int': c = collections.Counter(nums) left, right = &#123;&#125;, &#123;&#125; for i, num in enumerate(nums): if num not in left: left[num] = i right[num] = i degree, res = 0, len(nums) for num, count in c.most_common(): if degree and count != degree: break res = min(res, right[num]-left[num]+1) degree = count return res 724. Find Pivot Index找到中心索引，使得左右两边和相等。左右求和时均不包含该索引。原题12345678910Input: nums = [1, 7, 3, 6, 5, 6]Output: 3Explanation: The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3.Also, 3 is the first index where this occurs.Input:nums = [1,0]Output: 0 方法一：指针。 123456789def pivotIndex(self, nums): left, right, i = 0, sum(nums), 0 while i &lt; len(nums): left += nums[i-1] if i &gt; 0 else 0 right -= nums[i] if left == right: return i i += 1 return -1 方法二：不使用指针。 1234567def pivotIndex(self, nums): S, left = sum(nums), 0 for i, num in enumerate(nums): if left == S-left-num: return i left += num return -1 985. Sum of Even Numbers After Queries计算Queries后，累加所有的偶数。原题12345678Input: A = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]]Output: [8,6,2,4]Explanation: At the beginning, the array is [1,2,3,4].After adding 1 to A[0], the array is [2,2,3,4], and the sum of even values is 2 + 2 + 4 = 8.After adding -3 to A[1], the array is [2,-1,3,4], and the sum of even values is 2 + 4 = 6.After adding -4 to A[0], the array is [-2,-1,3,4], and the sum of even values is -2 + 4 = 2.After adding 2 to A[3], the array is [-2,-1,3,6], and the sum of even values is -2 + 6 = 4. 1234567891011def sumEvenAfterQueries(self, A: 'List[int]', queries: 'List[List[int]]') -&gt; 'List[int]': res = [] sum_even = sum(x for x in A if x &amp; 1 == 0) for v, i in queries: if A[i] &amp; 1 == 0: sum_even -= A[i] A[i] += v if A[i] &amp; 1 == 0: sum_even += A[i] res.append(sum_even) return res 986. Interval List Intersections两个区间列表求相交。原题 123Input: A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]]Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]Reminder: The inputs and the desired output are lists of Interval objects, and not arrays or lists. 12345678910111213def intervalIntersection(self, A: 'List[Interval]', B: 'List[Interval]') -&gt; 'List[Interval]': i = j = 0 res = [] while i &lt; len(A) and j &lt; len(B): lo = max(A[i].start, B[j].start) hi = min(A[i].end, B[j].end) if lo &lt;= hi: res.append(Interval(lo, hi)) if A[i].end &gt; B[j].end: j += 1 else: i += 1 return res 733. Flood Fill“洪水填充”，给定一个二维数组表示一张图片的像素，然后指定一个点和一个颜色，将这个点和上下左右四个点使用新的颜色填充，和这个点原来相同的颜色的点也受到影响，依次扩散，返回新的图片数组。原题123456789Input: image = [[1,1,1],[1,1,0],[1,0,1]]sr = 1, sc = 1, newColor = 2Output: [[2,2,2],[2,2,0],[2,0,1]]Explanation: From the center of the image (with position (sr, sc) = (1, 1)), all pixels connected by a path of the same color as the starting pixel are colored with the new color.Note the bottom corner is not colored 2, because it is not 4-directionally connectedto the starting pixel. 方法一：dfs. 需要注意的是，如果目标点与颜色相同，则原图不变。 1234567891011121314151617def floodFill(self, image, sr, sc, newColor): rows, cols = len(image), len(image[0]) old_val = image[sr][sc] def spread(x, y): if old_val == image[x][y]: image[x][y] = newColor if x-1 &gt;= 0: spread(x-1, y) if x+1 &lt; rows: spread(x+1, y) if y-1 &gt;= 0: spread(x, y-1) if y+1 &lt; cols: spread(x, y+1) if old_val != newColor: spread(sr, sc) return image 方法二：上述方法的变形。看起来更优雅。 1234567891011def floodFill(self, image, sr, sc, newColor): def dfs(x, y): image[x][y] = newColor for x, y in ((x-1, y), (x+1, y), (x, y+1), (x, y-1)): if 0&lt;=x&lt;rows and 0&lt;=y&lt;cols and image[x][y]==old_val: dfs(x, y) old_val, rows, cols = image[sr][sc], len(image), len(image[0]) if old_val != newColor: dfs(sr, sc) return image 747. Largest Number At Least Twice of Others最大的数是否大于等于所有其它数的两倍。原题1234Input: nums = [3, 6, 1, 0]Output: 1Explanation: 6 is the largest integer, and for every other number in the array x,6 is more than twice as big as x. The index of value 6 is 1, so we return 1. 12345def dominantIndex(self, nums: 'List[int]') -&gt; 'int': max_v = max(nums) if all(max_v &gt;= 2*x for x in nums if x!=max_v): return nums.index(max_v) return -1 766. Toeplitz MatrixToeplitz矩阵，即对角矩阵，斜角具有相同的值，判断一个矩阵是否是对角矩阵。原题1234567891011Input:matrix = [ [1,2,3,4], [5,1,2,3], [9,5,1,2]]Output: TrueExplanation:In the above grid, the diagonals are:&quot;[9]&quot;, &quot;[5, 5]&quot;, &quot;[1, 1, 1]&quot;, &quot;[2, 2, 2]&quot;, &quot;[3, 3]&quot;, &quot;[4]&quot;.In each diagonal all elements are the same, so the answer is True. 方法一：嵌套循环。 1234def isToeplitzMatrix(self, matrix: 'List[List[int]]') -&gt; 'bool': return all(x==0 or y==0 or matrix[x-1][y-1]==val for x, rows in enumerate(matrix) for y, val in enumerate(rows)) 方法二：切片，与上述方法在效率空间上没有差距，更喜欢这个方法。 123def isToeplitzMatrix(self, matrix: 'List[List[int]]') -&gt; 'bool': return all(matrix[i][1:]==matrix[i-1][:-1] for i in range(1, len(matrix))) 830. Positions of Large Groups根据指定字符串分组，超过三个元素的称为大组，求所有大组的位置。原题12Input: &quot;abcdddeeeeaabbbcd&quot;Output: [[3,5],[6,9],[12,14]] 方法一：groupby. 123456789def largeGroupPositions(self, S: 'str') -&gt; 'List[List[int]]': groups = itertools.groupby(S) index, ans = 0, [] for s, group in groups: count = len(list(group)) if count &gt;= 3: ans.append([index, index+count-1]) index += count return ans 方法二：two pointers. 123456789def largeGroupPositions(self, S: 'str') -&gt; 'List[List[int]]': i = 0 # start of each group ans = [] for j in range(len(S)): if j == len(S)-1 or S[j] != S[j+1]: if j - i &gt;= 2: ans.append([i, j]) i = j + 1 return ans 832. Flipping an Image水平翻转一张图片并反转(invert). 原题1234Input: [[1,1,0],[1,0,1],[0,0,0]]Output: [[1,0,0],[0,1,0],[1,1,1]]Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]] 12def flipAndInvertImage(self, A: 'List[List[int]]') -&gt; 'List[List[int]]': return [[x ^ 1 for x in reversed(row)] for row in A] 840. Magic Squares In Grid找出grid中数独的个数。原题12345678910111213141516Input: [[4,3,8,4], [9,5,1,9], [2,7,6,2]]Output: 1Explanation: The following subgrid is a 3 x 3 magic square:438951276while this one is not:384519762In total, there is only one magic square inside the given grid. 方法一：Brute Force. 12345678910111213141516171819202122232425def numMagicSquaresInside(self, grid: 'List[List[int]]') -&gt; 'int': digits = set(range(1, 10)) ans = 0 def is_sudoku(matrix): if matrix[1][1] != 5: # for optimization return False if set(sum(matrix, [])) != digits: return False if &#123;sum(row) for row in matrix&#125; != &#123;15&#125;: return False if &#123;sum(col) for col in zip(*matrix)&#125; != &#123;15&#125;: return False if matrix[0][0] + matrix[1][1] + matrix[2][2] != 15 or \ matrix[2][0] + matrix[1][1] + matrix[0][2] != 15: return False return True for i in range(len(grid)-2): for j in range(len(grid[0])-2): matrix = [rows[j:j+3] for rows in grid[i:i+3]] # print(matrix) if is_sudoku(matrix): ans += 1 return ans 方法二：参考了大神的解法。外层循环中只把左上角的点传入子方法进行判断，并在外循环判断中心点是否为5； 另外一个规律就是，满足条件数独的9宫格中，4个角都是偶数，4个边都是奇数，并且沿着一个方向必然是’43816729’的正序或者倒序。所以当左上角为偶数时，并满足顺序要求，另两个条件也自然满足了。 1234567891011def numMagicSquaresInside(self, g: 'List[List[int]]') -&gt; 'int': def is_sudoku(i, j): # clockwise begin i, j s = ''.join(str(g[i + x//3][j + x%3]) for x in (0, 1, 2, 5, 8, 7, 6, 3)) return g[i][j] &amp; 1 == 0 and ( s in '43816729'*2 or s in '43816729'[::-1]*2) return sum(is_sudoku(i, j) for i in range(len(g)-2) for j in range(len(g[0])-2) if g[i+1][j+1] == 5) 849. Maximize Distance to Closest Person一排电影院座位，离人的最远距离。数组中必含有一个1和0。原题123456Input: [1,0,0,0,1,0,1]Output: 2Explanation: If Alex sits in the second open seat (seats[2]), then the closest person has distance 2.If Alex sits in any other open seat, the closest person has distance 1.Thus, the maximum distance to the closest person is 2. 方法一：groupby。需要注意两个地方：一个是group是一个生成器，必须转成list才可以求长度；另一个地方是reversed(seats)也是一个生成器，所以这里要用切片。 1234567def maxDistToClosest(self, seats: 'List[int]') -&gt; 'int': ans = 0 groups = itertools.groupby(seats) for seat, group in groups: if not seat: ans = max(ans, (len(list(group))+1) // 2) return max(ans, seats.index(1), seats[::-1].index(1)) 方法二：two pointers. 在第一个1出现之前长度都是j。直到第二个1出现时，计算方式变为平均数。这里使用i = j + 1而不是i = j是因为有根据i判断的条件，在计算平均距离时又将其加了回来。最后的len(seats)-i是为了[1, 0, 0, 0]末尾的0作结算。 123456789101112def maxDistToClosest(self, seats: 'List[int]') -&gt; 'int': ans = i = 0 for j in range(len(seats)): # print(j, i, ans) if seats[j] == 1: dis = (j - i + 1) // 2 if i == 0: dis = j ans = max(ans, dis) i = j + 1 # print(ans) return max(ans, len(seats)-i) 方法三：方法二的简洁写法。 1234567def maxDistToClosest(self, seats: 'List[int]') -&gt; 'int': ans = i = 0 for j in range(len(seats)): if seats[j] == 1: ans = max(ans, ((j-i+1)//2, j)[i==0]) i = j + 1 return max(ans, len(seats)-i) 867. Transpose Matrix转置矩阵。原题12Input: [[1,2,3],[4,5,6],[7,8,9]]Output: [[1,4,7],[2,5,8],[3,6,9]] 方法一：zip。 这里testcase并没有检测其中的元素是否为list。所以不需要转换。 12def transpose(self, A: 'List[List[int]]') -&gt; 'List[List[int]]': return list(zip(*A)) 方法二：zip原理。 12def transpose(self, A: 'List[List[int]]') -&gt; 'List[List[int]]': return list(map(lambda *arg: arg, *A)) 方法三：列表生成式。 123def transpose(self, A: 'List[List[int]]') -&gt; 'List[List[int]]': return [[A[i][j] for i in range(len(A))] for j in range(len(A[0]))] 方法四：numpy. 123def transpose(self, A): import numpy as np return np.transpose(A).tolist() 888. Fair Candy Swap公平的糖果交换。两个人有很多糖果酒吧，交换其中一间使，糖果相同，可能有多个答案，返回任意一个。原题12Input: A = [1,1], B = [2,2]Output: [1,2] 方法一：Solution中的答案。 123456def fairCandySwap(self, A: 'List[int]', B: 'List[int]') -&gt; 'List[int]': diff = (sum(B) - sum(A)) // 2 set_b = set(B) for a in A: if diff + a in set_b: return a, diff + a 896. Monotonic Array判断一个数组是不是单调递增或递减。原题12345Input: [1,2,2,3]Output: trueInput: [6,5,4,4]Output: true 方法一：迭代两次。但是由于是生成器，平均效率比下面要高。 123def isMonotonic(self, A: 'List[int]') -&gt; 'bool': return all(A[i] &lt;= A[i+1] for i in range(len(A)-1)) or \ all(A[i] &gt;= A[i+1] for i in range(len(A)-1)) 方法二：迭代一次。 12345678910def isMonotonic(self, A: 'List[int]') -&gt; 'bool': increasing = decreasing = True for i in range(len(A)-1): if A[i+1] &gt; A[i]: decreasing = False if A[i+1] &lt; A[i]: increasing = False if not decreasing and not increasing: return False return True 方法三：python2的一种写法。 12def isMonotonic(self, A): return not &#123;cmp(i, j) for i, j in zip(A, A[1:])&#125; &gt;= &#123;1, -1&#125; 977. Squares of a Sorted Array求一个有序数组，平方后的有序结果。原题12Input: [-4,-1,0,3,10]Output: [0,1,9,16,100] 方法一：双指针填充数组。 123456789101112def sortedSquares(self, A: 'List[int]') -&gt; 'List[int]': answer = [0] * len(A) l, r = 0, len(A) - 1 while l &lt;= r: left, right = abs(A[l]), abs(A[r]) if left &gt; right: answer[r - l] = left * left l += 1 else: answer[r - l] = right * right r -= 1 return answer 941. Valid Mountain Array验证是否是山峰数组，前段单调增（不重复），后段单调减，必须是单峰值。原题12Input: [0,3,2,1]Output: true 方法一：传统迭代方式。 123456789101112def validMountainArray(self, A: 'List[int]') -&gt; 'bool': increasing = True for i in range(len(A)-1): if A[i] == A[i+1]: return False if A[i] &gt; A[i+1]: increasing = False if not increasing and (A[i] &lt; A[i+1] or i ==0): return False if i == len(A)-2 and increasing: return False return len(A) &gt;= 3 方法二：这个方法挺新颖，根据值来递增索引。中途暂停一下判断峰值是否在首位点。 123456789def validMountainArray(self, A: 'List[int]') -&gt; 'bool': l, r = 0, len(A)-1 while l &lt; r and A[l] &lt; A[l+1]: l += 1 if l==0 or l == r: return False while l &lt; r and A[l] &gt; A[l+1]: l += 1 return l == r 方法三：Lee神的双指针，想象两个人同时从左右两边爬山，最终是否相遇在一点。 12345def validMountainArray(self, A: 'List[int]') -&gt; 'bool': l, r, n = 0, len(A)-1, len(A) while l &lt; r and A[l] &lt; A[l+1]: l += 1 while r &gt; 0 and A[r] &lt; A[r-1]: r -= 1 return 0 &lt; l==r &lt; n-1 942. DI String Match根据一个”IDID”字符串（I表示增加，D表示减少）生成一个数组，数组元素不能重复，答案不唯一。原题12Input: &quot;IDID&quot;Output: [0,4,1,3,2] 1234567891011def diStringMatch(self, S: 'str') -&gt; 'List[int]': l = r = 0 ans = [0] for s in S: if s == 'I': r += 1 ans.append(r) else: l -= 1 ans.append(l) return [x-l for x in ans] 994. Rotting Oranges腐烂的橘子，1表示新鲜，2表示腐烂，每分钟腐烂的会传染给四周上下左右的橘子，问所有的橘子腐烂最少需要几分钟。原题 方法一：竞赛时虽然做出来了，但有些点没想出来，其实是BFS，这样一想退出条件就很清楚了。 12345678910111213141516171819def orangesRotting(self, g: 'List[List[int]]') -&gt; 'int': R, C = len(g), len(g[0]) rotted = ((x, y, 0) for x in range(R) for y in range(C) if g[x][y]==2) q = collections.deque(rotted) def to_rot(x, y): for x, y in ((x-1, y), (x, y-1), (x+1, y), (x, y+1)): if 0&lt;=x&lt;R and 0&lt;=y&lt;C and g[x][y]==1: yield x, y d = 0 while q: r, c, d = q.popleft() for sr, sc in to_rot(r, c): g[sr][sc] = 2 q.append((sr, sc, d+1)) if 1 in sum(g, []): return -1 return d 1002. Find Common Characters在给定的单词列表中找到公共字符。原题12Input: [&quot;bella&quot;,&quot;label&quot;,&quot;roller&quot;]Output: [&quot;e&quot;,&quot;l&quot;,&quot;l&quot;] 1234def commonChars(self, A: List[str]) -&gt; List[str]: from collections import Counter from functools import reduce return list(reduce(lambda x, y: x &amp; y, map(Counter, A)).elements()) 1007. Minimum Domino Rotations For Equal Row旋转最小次，是上下的多米诺骨牌有一行全部相同。原题 方法一：竞赛时写的Brute Force.当时觉得炒鸡硬核。 12345678def minDominoRotations(self, A: List[int], B: List[int]) -&gt; int: ans = reduce(lambda x, y: set(x) &amp; set(y), zip(A, B)) if not ans: return -1 else: a = set(ans).pop() dul = sum(a==c==d for c, d in zip(A, B)) return min(A.count(a), B.count(a)) - dul 方法二：Lee神的方法。有个地方想错了，想要算出重复的值，实际上就是求非目标值的最小值就行了。 1234567def minDominoRotations(self, A: List[int], B: List[int]) -&gt; int: ans = reduce(lambda x, y: x &amp; y, map(set, zip(A, B))) if not ans: return -1 else: a = ans.pop() return min(len(A)-A.count(a), len(B)-B.count(a)) 48. Rotate Image矩阵顺时针旋转90度。原题12345678910111213Given input matrix = [ [1,2,3], [4,5,6], [7,8,9]],rotate the input matrix in-place such that it becomes:[ [7,4,1], [8,5,2], [9,6,3]] 方法一：使用zip。 12def rotate(self, matrix: List[List[int]]) -&gt; None: matrix[:] = list(zip(*reversed(matrix))) 方法二：通用写法。 12345def rotate(self, matrix: List[List[int]]) -&gt; None: matrix.reverse() for i in range(len(matrix)): for j in range(i+1, len(matrix[0])): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] 方法三：找到四个点，直接互换。 123456def rotate(self, A: List[List[int]]) -&gt; None: n = len(A) for i in range(n//2): for j in range(n-n//2): A[i][j], A[~j][i], A[~i][~j], A[j][~i] = \ A[~j][i], A[~i][~j], A[j][~i], A[i][j] 695. Max Area of Island最大的岛屿面积。原题方法一：dfs. 1234567891011121314def maxAreaOfIsland(self, grid: List[List[int]]) -&gt; int: R, C = len(grid), len(grid[0]) area, seen = 0, set() def spread(i, j): if not (0&lt;=i&lt;R and 0&lt;=j&lt;C and (i, j) not in seen and grid[i][j]): return 0 seen.add((i, j)) surrounds = ((i-1, j), (i+1, j), (i, j-1), (i, j+1)) return 1 + sum(map(lambda x: spread(x[0], x[1]), surrounds)) return max(spread(i, j) for i in range(R) for j in range(C)) 1020. Partition Array Into Three Parts With Equal Sum一个数组是否可以分成三个和相同的部分。原题123Input: [0,2,1,-6,6,-7,9,1,2,0,1]Output: trueExplanation: 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1 方法一：竞赛时写的Time: O(n²)的方法。 12345678def canThreePartsEqualSum(self, A: List[int]) -&gt; bool: a = list(itertools.accumulate(A)) n, a_set = len(a), set(a) for i, total in enumerate(a): if total==a[-1]//3 and total*2 in a_set: if n-1-a[::-1].index(total*2) &gt; i: return True return False 方法二：其实不需要遍历。每部分的和可以通过总和/3得到。比如每部分和为3，只要找到3和6，并且3在6的左边。 123456789101112131415def canThreePartsEqualSum(self, A: List[int]) -&gt; bool: a = list(itertools.accumulate(A)) total = sum(A) if total % 3 != 0: return False one = total // 3 two = one * 2 if one in a: l_index = a.index(one) else: return False if two in a[l_index:]: return True else: return False 1021. Best Sightseeing Pair得分最高的两个景点。原题两个景点之间有距离。 123Input: [8,1,5,2,6]Output: 11Explanation: i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11 方法一：cur保存着一个上一次最好的景点。 123456def maxScoreSightseeingPair(self, A: List[int]) -&gt; int: cur = res = 0 for a in A: res = max(res, cur + a) cur = max(cur, a) - 1 return res 1029. Binary Prefix Divisible By 5二进制前缀能否被5整除。原题12Input: [0,1,1,1,1,1]Output: [true,false,false,false,true,false] 方法一：首次AC的方法。 1234567def prefixesDivBy5(self, A: List[int]) -&gt; List[bool]: num, ans = 0, [] for d in A: num &lt;&lt;= 1 num |= d ans.append(not bool(num%5)) return ans 方法二：取余操作具有累加性，简单的优化提升了3倍的速度。 12345678def prefixesDivBy5(self, A: List[int]) -&gt; List[bool]: num, ans = 0, [] for d in A: num &lt;&lt;= 1 num |= d num %= 5 ans.append(not bool(num)) return ans 1031. Number of Enclaves求被困的地点个数。1表示陆地，不能够走到边界的陆地称为被困的陆地。原题方法一：简单的DFS 1234567891011121314151617181920212223def numEnclaves(self, A: List[List[int]]) -&gt; int: if not A: return 0 R, C = len(A), len(A[0]) def spread(i, j): A[i][j] = 0 for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)): if 0&lt;=x&lt;R and 0&lt;=y&lt;C and A[x][y] == 1: spread(x, y) for i in range(R): if A[i][0]==1: spread(i, 0) if A[i][C-1] == 1: spread(i, C-1) for j in range(C): if A[0][j] == 1: spread(0, j) if A[R-1][j] == 1: spread(R-1, j) return sum(sum(row) for row in A) 503. Next Greater Element II下一个比当前元素大的元素，数组首位连接。原题和1030题相似。方法一：首位连接，所以要遍历两次。 12345678def nextGreaterElements(self, nums: List[int]) -&gt; List[int]: ans, stack = [], [] for num in nums * 2: while stack and stack[-1][1] &lt; num: ans[stack.pop()[0]] = num stack.append((len(ans), num)) ans.append(-1) return ans[:len(nums)] 方法二：实际并不需要保存数字。 1234567def nextGreaterElements(self, nums: List[int]) -&gt; List[int]: ans, stack = [-1]*len(nums), [] for i in list(range(len(nums)))*2: while stack and nums[stack[-1]] &lt; nums[i]: ans[stack.pop()] = nums[i] stack.append(i) return ans 56. Merge Intervals合并时间段。如果时间段有重叠，则将其合并成一个。原题123Input: [[1,3],[2,6],[8,10],[15,18]]Output: [[1,6],[8,10],[15,18]]Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. 方法一：先排序，在根据条件判断是合并还是修改。 123456789101112131415# class Interval:# def __init__(self, s=0, e=0):# self.start = s# self.end = eclass Solution: def merge(self, intervals: List[Interval]) -&gt; List[Interval]: intervals.sort(key=operator.attrgetter('start')) ans = [] for interval in intervals: if not ans or ans[-1].end &lt; interval.start: ans.append(interval) else: ans[-1].end = max(ans[-1].end, interval.end) return ans 57. Insert Interval有一个排好序的时间段，并且没有重复，现在有一个新的段，要求插入其中，如果有重合需要合并。原题123Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]Output: [[1,2],[3,10],[12,16]]Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]. 方法一：用56的方法合并，使用二分法将其插入。140ms。这题本来想用二分法找到索引，然后前后切片做，后来发现边界太多不好判断，还是从头到尾遍历一遍比较稳。 1234567891011def insert(self, inter: List[List[int]], newInterval: List[int]) -&gt; List[List[int]]: n = len(inter) i = bisect.insort(inter, [*newInterval]) # print(inter, i) stack = [] for j in range(0, n+1): if not stack or stack[-1][1] &lt; inter[j][0]: stack.append(inter[j]) else: stack[-1][1] = max(stack[-1][1], inter[j][1]) return stack 方法二：stefan的方法1，我改了点，条件语句改成长度比较了。启发1，用长度记录索引，简洁明了。72ms 12345678def insert(self, inter: List[List[int]], newInterval: List[int]) -&gt; List[List[int]]: s, e = newInterval left = [i for i in inter if i[1] &lt; s] right = [i for i in inter if i[0] &gt; e] if len(left) + len(right) != len(inter): s = min(s, inter[len(left)][0]) e = max(e, inter[~len(right)][1]) return left + [[s, e]] + right 方法三：stefan的方法2，和方法二思路一样，写法上不同。right里添加时索引是-1。还有一种一次遍历的实现就是每次都求一下s, e。 123456789def insert(self, inter: List[List[int]], newInterval: List[int]) -&gt; List[List[int]]: s, e = newInterval parts = merge, left, right = [], [], [] for start, end in inter: parts[(end&lt;s) - (start&gt;e)].append((start, end)) if merge: s = min(s, merge[0][0]) e = max(e, merge[-1][-1]) return left + [[s, e]] + right 1030. Matrix Cells in Distance Order矩阵坐标距离指定点的排序。原题1234Input: R = 2, C = 2, r0 = 0, c0 = 1Output: [[0,1],[0,0],[1,1],[1,0]]Explanation: The distances from (r0, c0) to other cells are: [0,1,1,2]The answer [[0,1],[1,1],[0,0],[1,0]] would also be accepted as correct. 123def twoCitySchedCost(self, costs: List[List[int]]) -&gt; int: costs.sort(key=lambda x: x[0]-x[1]) return sum(i[0] for i in costs[:len(costs)//2]) + sum(j[1] for j in costs[len(costs)//2:]) 1033. Moving Stones Until Consecutive三个石子移到连续的位置，最少和最多需要几步。原题123456Input: a = 1, b = 2, c = 5Output: [1,2]Explanation: Move the stone from 5 to 3, or move the stone from 5 to 4 to 3.Input: a = 4, b = 3, c = 2Output: [0,0]Explanation: We cannot make any moves. 12345678def numMovesStones(self, a: int, b: int, c: int) -&gt; List[int]: a, b, c = sorted((a, b, c)) if c-b==1 and b-a==1: return 0, c-a-2 elif c-b&lt;=2 or b-a&lt;=2: return 1, c-a-2 else: return 2, c-a-2 1034. Coloring A Border给边界染色，此题和733.flood fill很像，区别在于，那个是将所有区域染色，这个是只将边界染色。原题方法一：写法稍作修改，将判断移到前面。四个方向只要有一个返回False就说明是边界的点。 1234567891011121314def colorBorder(self, grid: List[List[int]], r0: int, c0: int, color: int) -&gt; List[List[int]]: def dfs(x, y): if (x, y) in seen: return True if not (0&lt;=x&lt;R and 0&lt;=y&lt;C and grid[x][y]==grid[r0][c0]): return False seen.add((x, y)) if dfs(x+1, y) + dfs(x-1, y) + dfs(x, y-1) + dfs(x, y+1) &lt; 4: grid[x][y] = color return True seen, R, C = set(), len(grid), len(grid[0]) dfs(r0, c0) return grid 1051. Height Checker高度检查。原题12def heightChecker(self, heights: List[int]) -&gt; int: return sum(a!=b for a, b in zip(heights, sorted(heights))) 1052. Grumpy Bookstore Owner这题描述的比较抽象，其实就是一个滑动窗口的问题。原题方法一：一开始我用的双端队列，并且使用了compress. 12345678910111213141516def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -&gt; int: from itertools import compress from collections import deque base_satisfied = sum(compress(customers, map(lambda x: x^1, grumpy))) q = deque([customers[i] if grumpy[i]==1 else 0 for i in range(X)]) cur_sum = 0 max_sum = cur_sum for i in range(len(grumpy)): if grumpy[i] == 1: q.append(customers[i]) cur_sum += q[-1] else: q.append(0) cur_sum -= q.popleft() max_sum = max(max_sum, cur_sum) return max_sum + base_satisfied 方法二：其实不需要双端队列。 123456789def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -&gt; int: n = len(grumpy) base = sum(c for c, g in zip(customers, grumpy) if g == 0) max_added = added = sum(c for c, g in zip(customers, grumpy[:X]) if g == 1) for i in range(X, n): added -= customers[i-X] * grumpy[i-X] added += customers[i] * grumpy[i] max_added = max(max_added, added) return max_added + base 1139. Largest 1-Bordered Square最大的以1为边长的正方形。原题12Input: grid = [[1,1,1],[1,0,1],[1,1,1]]Output: 9 方法一：开始以为像其他小岛问题那样，要回溯延伸。其实此题是暴力法。先对数组进行一个预处理，判断每个点上面和左面连续的1的个数。 12345678910111213141516def largest1BorderedSquare(self, g: List[List[int]]) -&gt; int: R, C = len(g), len(g[0]) from copy import deepcopy top, left = deepcopy(g), deepcopy(g) for i in range(R): for j in range(C): if g[i][j]: if i: top[i][j] = top[i - 1][j] + 1 if j: left[i][j] = left[i][j - 1] + 1 for w in range(min(R, C), 0, -1): for i in range(R-w+1): for j in range(C-w+1): if top[i+w-1][j] &gt;= w and top[i+w-1][j+w-1] &gt;= w: if left[i][j+w-1] &gt;= w and left[i+w-1][j+w-1] &gt;= w: return w * w return 0 1078. Occurrences After Bigram打印第三个单词。原题12Input: text = &quot;alice is a good girl she is a good student&quot;, first = &quot;a&quot;, second = &quot;good&quot;Output: [&quot;girl&quot;,&quot;student&quot;] 1234567def findOcurrences(self, text: str, first: str, second: str) -&gt; List[str]: words = text.split() ans = [] for i in range(len(words)-2): if words[i] == first and words[i+1] == second: ans.append(words[i+2]) return ans 1144. Decrease Elements To Make Array Zigzag每次操作某个元素-1，多少次操作后，可以使数组称为一个zigzag。原题12Input: nums = [9,6,1,6,2]Output: 4 方法一：暴力的方法。遍历两次。 12345678910111213141516def movesToMakeZigzag(self, nums: List[int]) -&gt; int: n = len(nums) even_sum = 0 for i in range(1, n, 2): left = float('inf') if i == 0 else nums[i-1] right = float('inf') if i == n-1 else nums[i+1] to_add = nums[i]-min(left, right)+1 even_sum += to_add if to_add &gt; 0 else 0 odd_sum = 0 for i in range(0, n, 2): left = float('inf') if i == 0 else nums[i-1] right = float('inf') if i == n-1 else nums[i+1] to_min = nums[i]-min(left, right)+1 odd_sum += to_min if to_min &gt; 0 else 0 return min(even_sum, odd_sum) 方法二：利用奇偶性，整合到一次循环。 123456def movesToMakeZigzag(self, nums: List[int]) -&gt; int: ans = [0, 0] ary = [float('inf')] + nums + [float('inf')] for i in range(1, len(ary)-1): ans[i % 2] += max(0, ary[i]-min(ary[i-1], ary[i+1])+1) return min(ans) 1146. Snapshot Array数组的快照。原题123456789Input: [&quot;SnapshotArray&quot;,&quot;set&quot;,&quot;snap&quot;,&quot;set&quot;,&quot;get&quot;][[3],[0,5],[],[0,6],[0,0]]Output: [null,null,0,null,5]Explanation: SnapshotArray snapshotArr = new SnapshotArray(3); // set the length to be 3snapshotArr.set(0,5); // Set array[0] = 5snapshotArr.snap(); // Take a snapshot, return snap_id = 0snapshotArr.set(0,6);snapshotArr.get(0,0); // Get the value of array[0] with snap_id = 0, return 5 方法一：此题暴力法时，空间复杂度会过高。采用针对每个元素，变化时，记录该变化的历史。再用二分法查找。 注意查找时，是通过数组查找而不是数字，查找比其大的再-1。 123456789101112131415161718class SnapshotArray: def __init__(self, length: int): self.ary = [[[-1, 0]] for _ in range(length)] self.snap_id = 0 def set(self, index: int, val: int) -&gt; None: self.ary[index].append([self.snap_id, val]) def snap(self) -&gt; int: self.snap_id += 1 return self.snap_id - 1 def get(self, index: int, snap_id: int) -&gt; int: i = bisect.bisect(self.ary[index], [snap_id+1]) - 1 return self.ary[index][i][1] 1089. Duplicate Zeros复制数组中的0，数组长度不变，多出的元素将被“挤掉”。要求在原数组上修改。原题123Input: [1,0,2,3,0,4,5,0]Output: nullExplanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4] 方法一：竞赛时的方法，需要注意末尾不要多加0。空间复杂度过高。 1234567891011def duplicateZeros(self, arr: List[int]) -&gt; None: # arr_reversed = arr[::-1] # ans = [] # while len(ans) &lt; len(arr): # val = arr_reversed.pop() # if val == 0 and len(ans) &lt; len(arr)-1: # ans.extend([0, 0]) # else: # ans.append(val) # arr[:] = ans arr[:] = [x for a in arr for x in ([a] if a else [0, 0])][:len(arr)] 方法二：双指针的O(1)Space。 1234567891011121314151617def duplicateZeros(self, arr: List[int]) -&gt; None: zero_c = arr.count(0) n = len(arr) j = n + zero_c - 1 i = n - 1 while i &gt;= 0: if arr[i] != 0: if j &lt; n: arr[j] = arr[i] else: if j &lt; n: arr[j] = arr[i] j -= 1 if j &lt; n: arr[j] = arr[i] j -= 1 i -= 1 1091. Shortest Path in Binary Matrix从左上到右下，只能走0，求最短路径长度，可以斜着走。原题方法一：核心思想为，BFS，到终点的深度，使用两个数组。 12345678910111213141516171819202122232425262728def shortestPathBinaryMatrix(self, grid: List[List[int]]) -&gt; int: n = len(grid) if not grid[0][0] == grid[-1][-1] == 0: return -1 def spread(i, j): di = (1, 0, -1) dj = (1, 0, -1) for k in di: for m in dj: x, y = i+k, j+m if 0&lt;=x&lt;n and 0&lt;=y&lt;n and grid[x][y]==0: yield x, y d = 0 bfs = [(0, 0)] seen = set() while bfs: d += 1 bfs2 = [] for (x, y) in bfs: if x==n-1 and y==n-1: return d if (x, y) not in seen: bfs2.extend([(i, j) for i, j in spread(x, y)]) seen.add((x, y)) bfs = bfs2 return -1 方法二：使用双端队列。为了避免起点为1，所以从-1开始，深度为0. 12345678910111213def shortestPathBinaryMatrix(self, grid: List[List[int]]) -&gt; int: n = len(grid) q = collections.deque([(-1, -1, 0)]) seen = set() while q: x, y, d = q.popleft() if x==n-1 and y==n-1: return d for i, j in ((x-1, y-1), (x-1, y), (x-1, y+1), (x, y-1), (x, y+1), (x+1, y-1), (x+1, y), (x+1, y+1)): if 0&lt;=i&lt;n and 0&lt;=j&lt;n and grid[i][j]==0 and (i, j) not in seen: q.append((i, j, d+1)) seen.add((i, j)) return -1 1157. Online Majority Element In Subarray实时的最多元素查询。原题1234MajorityChecker majorityChecker = new MajorityChecker([1,1,2,2,1,1]);majorityChecker.query(0,5,4); // returns 1majorityChecker.query(0,3,3); // returns -1majorityChecker.query(2,3,2); // returns 2 方法一：竞赛时，用了个dict嵌套，内存溢出了。此题的解法是存索引，然后二分。 class MajorityChecker: 123456789101112131415def __init__(self, arr: List[int]): self.c = collections.defaultdict(list) for i, x in enumerate(arr): self.c[x].append(i)def query(self, left: int, right: int, threshold: int) -&gt; int: for k, v in self.c.items(): if len(v) &lt; threshold: continue low = bisect.bisect_left(v, left) high = bisect.bisect_right(v, right) if high - low &gt;= threshold: return k return -1 1162. As Far from Land as Possible离陆地最远的点的距离。原题1234Input: [[1,0,1],[0,0,0],[1,0,1]]Output: 2Explanation: The cell (1, 1) is as far as possible from all the land with distance 2. 方法一：bfs. 此题竞赛时想到了解法，但是出发点有点问题，是从水找陆地，这样的话有很多重复的循环，导致超时。正确的思路是从陆地遍历水。 12345678910111213141516def maxDistance(self, grid: List[List[int]]) -&gt; int: R, C = len(grid), len(grid[0]) q = collections.deque([(i, j, 0) for i in range(R) for j in range(C) if grid[i][j] == 1]) d = -1 while q: x, y, d = q.popleft() if grid[x][y] == 0: return d surrounds = ((x-1, y), (x+1, y), (x, y-1), (x, y+1)) for i, j in surrounds: if 0&lt;=i&lt;R and 0&lt;=j&lt;C and grid[i][j]==0: q.append((i, j, d+1)) grid[i][j] = 1 return d or -1 1169. Invalid Transactions非法交易，单笔金额大于1000，或者60分钟内有异地交易，那么为非法交易。列出所有的非法交易。原题123Input: transactions = [&quot;alice,20,800,mtv&quot;,&quot;alice,50,100,beijing&quot;]Output: [&quot;alice,20,800,mtv&quot;,&quot;alice,50,100,beijing&quot;]Explanation: The first transaction is invalid because the second transaction occurs within a difference of 60 minutes, have the same name and is in a different city. Similarly the second one is invalid too. 方法一：暴力法。 12345678910111213141516171819def invalidTransactions(self, transactions: List[str]) -&gt; List[str]: ts = [] for line in transactions: name, time, amount, city = line.split(',') ts.append((name, time, amount, city)) city_times = collections.defaultdict(list) for t in ts: city_times[t[0]+','+t[3]].append(int(t[1])) ans = [] for t in ts: if int(t[2]) &gt; 1000: ans.append(','.join(t)) else: diff_cities = (c for c in city_times.keys() if c!=t[0]+','+t[3] and c.startswith(t[0]+',')) for d_c in diff_cities: if any(abs(tt-int(t[1])) &lt;= 60 for tt in city_times[d_c]): ans.append(','.join(t)) break return ans 1170. Compare Strings by Frequency of the Smallest Character比较最小字符的频率。原题123Input: queries = [&quot;cbd&quot;], words = [&quot;zaaaz&quot;]Output: [1]Explanation: On the first query we have f(&quot;cbd&quot;) = 1, f(&quot;zaaaz&quot;) = 3 so f(&quot;cbd&quot;) &lt; f(&quot;zaaaz&quot;). 方法一：暴力法。 1234def numSmallerByFrequency(self, queries: List[str], words: List[str]) -&gt; List[int]: qq = [q.count(min(q)) for q in queries] ww = [w.count(min(w)) for w in words] return [sum(q &lt; w for w in ww) for q in qq] 方法二：二分法 123456def numSmallerByFrequency(self, queries: List[str], words: List[str]) -&gt; List[int]: qq = [q.count(min(q)) for q in queries] ww = [w.count(min(w)) for w in words] ww.sort() n = len(ww) return [n-bisect.bisect_right(ww, q) for q in qq] 1122. Relative Sort Array按照数组2的相对位置给另一个数组排序。原题方法一：和Lee神写法不谋而合，只不过自己用了乘法，其实加法就可以了。 123def relativeSortArray(self, arr1: List[int], arr2: List[int]) -&gt; List[int]: index = &#123;d: i for i, d in enumerate(arr2)&#125; return sorted(arr1, key=lambda x: index.get(x, 1000+x)) 1128. Number of Equivalent Domino Pairs相等的多米诺骨牌对数。原题方法一：把牌翻转成一样的，然后组合。 123def numEquivDominoPairs(self, dominoes: List[List[int]]) -&gt; int: dominoes = collections.Counter(tuple(sorted(d)) for d in dominoes) return sum(v*(v-1)//2 for v in dominoes.values()) 1176. Diet Plan Performance燃烧你的卡路里，卡路里和体重的关系。原题12345Input: calories = [1,2,3,4,5], k = 1, lower = 3, upper = 3Output: 0Explanation: Since k = 1, we consider each element of the array separately and compare it to lower and upper.calories[0] and calories[1] are less than lower so 2 points are lost.calories[3] and calories[4] are greater than upper so 2 points are gained. 123456789101112def dietPlanPerformance(self, calories: List[int], k: int, lower: int, upper: int) -&gt; int: ans = 0 calories.insert(0, 0) cur_sum = sum(calories[:k]) for i in range(1, len(calories)-k+1): cur_sum -= calories[i-1] cur_sum += calories[i+k-1] if cur_sum &gt; upper: ans += 1 elif cur_sum &lt; lower: ans -= 1 return ans 1394. Find Lucky Integer in an Array找到数组中数字和出现次数一致的最大的数。原题123Input: arr = [2,2,3,4]Output: 2Explanation: The only lucky number in the array is 2 because frequency[2] == 2. 1234567def findLucky(self, arr: List[int]) -&gt; int: from collections import Counter c = Counter(arr) for d, f in c.most_common(): if d == f: return d return -1 1395. Count Number of Teams数字分组计数。原题123Input: rating = [2,5,3,4,1]Output: 3Explanation: We can form three teams given the conditions. (2,3,4), (5,4,1), (5,3,1). 123456789101112131415161718192021def numTeams(self, rating: List[int]) -&gt; int: from collections import defaultdict n = len(rating) greater = defaultdict(int) less = defaultdict(int) ans = 0 for i in range(n): for j in range(i+1, n): if rating[i] &gt; rating[j]: less[i] += 1 else: greater[i] += 1 for i in range(n-2): for j in range(i+1, n): if rating[i] &gt; rating[j]: ans += less[j] else: ans += greater[j] return ans 1399. Count Largest Group以数字和为分组，求最大组的个数。原题1234Input: n = 13Output: 4Explanation: There are 9 groups in total, they are grouped according sum of its digits of numbers from 1 to 13:[1,10], [2,11], [3,12], [4,13], [5], [6], [7], [8], [9]. There are 4 groups with largest size 方法一：Counter 1234567891011121314def countLargestGroup(self, n: int) -&gt; int: from collections import Counter c = Counter() for i in range(1, n+1): c[sum(int(d) for d in str(i))] += 1 ans = 0 largest_size = 0 for s, cnt in c.most_common(): if largest_size!=0 and cnt!=largest_size: return ans else: largest_size = cnt ans += 1 return ans 方法二：标准库。statistics.multimode返回一个可迭代对象中出现次数最多的元素。 123def countLargestGroup(self, n: int) -&gt; int: import statistics return len(statistics.multimode(sum(map(int, str(d))) for d in range(1, n+1))) 1391. Check if There is a Valid Path in a Grid判断是否能到达右下点。原题123Input: grid = [[2,4,3],[6,5,2]]Output: trueExplanation: As shown you can start at cell (0, 0) and visit all the cells of the grid to reach (m - 1, n - 1). 方法一：dfs。需要注意的是(-x, -y) in directions[grid[ni][nj]])是用来判断该块和下一块是否是联通的。 1234567891011121314151617181920212223242526def hasValidPath(self, grid: List[List[int]]) -&gt; bool: directions = &#123; 1: ((0, 1), (0, -1)), 2: ((1, 0), (-1, 0)), 3: ((1, 0), (0, -1)), 4: ((0, 1), (1, 0)), 5: ((-1, 0), (0, -1)), 6: ((0, 1), (-1, 0)) &#125; m, n = len(grid), len(grid[0]) seen = set() def dfs(i, j): seen.add((i, j)) if (i, j) == (m-1, n-1): return True block = grid[i][j] for x, y in directions[block]: ni, nj = i+x, j+y if 0&lt;=ni&lt;m and 0&lt;=nj&lt;n and (ni, nj) not in seen and ( (-x, -y) in directions[grid[ni][nj]]): if dfs(ni, nj): return True return False return dfs(0, 0) 1375. Bulb Switcher III灯泡开关，记录灯泡全部变蓝的次数。原题123Input: light = [2,1,3,5,4]Output: 3Explanation: All bulbs turned on, are blue at the moment 1, 2 and 4. 方法一：使用堆。其实没必要增加O(n)的空间 12345678910def numTimesAllBlue(self, light: List[int]) -&gt; int: import heapq as hq s = [] hq.heapify(s) ans = 0 for i, b in enumerate(light, 1): hq.heappush(s, -b) if -s[0] == i: ans += 1 return ans 方法二：只需要维护一个最大值变量即可 1234567def numTimesAllBlue(self, light: List[int]) -&gt; int: cur_max = ans = 0 for i, b in enumerate(light, 1): cur_max = max(cur_max, b) if cur_max == i: ans += 1 return ans 方法三：一行 12def numTimesAllBlue(self, light: List[int]) -&gt; int: return sum(i==b for i, b in enumerate(itertools.accumulate(light, max), 1)) 498. Diagonal Traverse对角线z字形遍历。原题方法一：费劲心思去找i,j的关系，其实只需要知道一点，i和j都是越来越大的就行。 1234567891011121314def findDiagonalOrder(self, matrix: List[List[int]]) -&gt; List[int]: if not matrix: return [] dd = collections.defaultdict(list) ans = [] m, n = len(matrix), len(matrix[0]) for i in range(m): for j in range(n): dd[i+j].append(matrix[i][j]) for k in range(m+n-1): if k % 2 == 0: dd[k].reverse() ans.extend(dd[k]) return ans 1424. Diagonal Traverse II对角线遍历，每行长度可能不一样。原题12345678def findDiagonalOrder(self, g: List[List[int]]) -&gt; List[int]: res = [] for i, r in enumerate(g): for j, a in enumerate(r): if len(res) &lt;= i + j: res.append([]) res[i + j].append(a) return [a for r in res for a in reversed(r)] 1365. How Many Numbers Are Smaller Than the Current Number数组中比当前数小的个数。原题方法一：排序。T=O(n*lgn) 12345def smallerNumbersThanCurrent(self, nums: List[int]) -&gt; List[int]: indices = &#123;&#125; for i, d in enumerate(sorted(nums)): indices.setdefault(d, i) return [indices[d] for d in nums] 方法二：利用了数的范围在1~100之间。 123456def smallerNumbersThanCurrent(self, nums: List[int]) -&gt; List[int]: count = [0] * 102 for num in nums: count[num+1] += 1 count = list(itertools.accumulate(count)) return [count[num] for num in nums] 1366. Rank Teams by Votes投票选举。首先按照排名，然后按照字母顺序。原题12345678910Input: votes = [&quot;ABC&quot;,&quot;ACB&quot;,&quot;ABC&quot;,&quot;ACB&quot;,&quot;ACB&quot;]Output: &quot;ACB&quot;Explanation: Team A was ranked first place by 5 voters. No other team was voted as first place so team A is the first team.Team B was ranked second by 2 voters and was ranked third by 3 voters.Team C was ranked second by 3 voters and was ranked third by 2 voters.As most of the voters ranked C second, team C is the second team and team B is the third.Input: votes = [&quot;WXYZ&quot;,&quot;XYZW&quot;]Output: &quot;XWYZ&quot;Explanation: X is the winner due to tie-breaking rule. X has same votes as W for the first position but X has one vote as second position while W doesn&apos;t have any votes as second position. 方法一：列举了所有的票数，然后对tuple进行排序。 1234567891011def rankTeams(self, votes: List[str]) -&gt; str: from collections import Counter, defaultdict cc = defaultdict(lambda : [0]*26) i = 0 for w in zip(*votes): for k, v in Counter(w).items(): cc[k][i] = v i += 1 # print(cc) cmp = (tuple(p) + (-ord(a), a) for a, p in cc.items()) return ''.join(x[-1] for x in sorted(cmp, reverse=True)) 方法二：忽略了一个问题，其实每个人都需要对所有人投票。根据第一个来进行初始化。数组同样可以比较大小，无须转化为tuple 123456def rankTeams(self, votes: List[str]) -&gt; str: count = &#123;c: [0] * len(votes[0]) + [c] for c in votes[0]&#125; for vote in votes: for i, v in enumerate(vote): count[v][i] -= 1 return ''.join(sorted(votes[0], key=count.get)) 1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit最长的连续子数组，绝对值不大于limit。原题1234567891011121314Input: nums = [8,2,4,7], limit = 4Output: 2 Explanation: All subarrays are: [8] with maximum absolute diff |8-8| = 0 &lt;= 4.[8,2] with maximum absolute diff |8-2| = 6 &gt; 4. [8,2,4] with maximum absolute diff |8-2| = 6 &gt; 4.[8,2,4,7] with maximum absolute diff |8-2| = 6 &gt; 4.[2] with maximum absolute diff |2-2| = 0 &lt;= 4.[2,4] with maximum absolute diff |2-4| = 2 &lt;= 4.[2,4,7] with maximum absolute diff |2-7| = 5 &gt; 4.[4] with maximum absolute diff |4-4| = 0 &lt;= 4.[4,7] with maximum absolute diff |4-7| = 3 &lt;= 4.[7] with maximum absolute diff |7-7| = 0 &lt;= 4. Therefore, the size of the longest subarray is 2. 方法一：堆，Time: O(NlogN) 12345678910111213def longestSubarray(self, nums: List[int], limit: int) -&gt; int: maxd, mind = [], [] res = i = 0 for j, a in enumerate(nums): heapq.heappush(maxd, (-a, j)) heapq.heappush(mind, (a, j)) while -maxd[0][0] - mind[0][0] &gt; limit: i = min(maxd[0][1], mind[0][1]) + 1 while maxd[0][1] &lt; i: heapq.heappop(maxd) while mind[0][1] &lt; i: heapq.heappop(mind) print(maxd, '--', mind) res = max(res, j - i + 1) return res 1345. Jump Game IV跳到末尾最小步数，可以向前向后或者跳到一样的值。原题123Input: arr = [100,-23,-23,404,100,23,23,23,3,404]Output: 3Explanation: You need three jumps from index 0 --&gt; 4 --&gt; 3 --&gt; 9. Note that index 9 is the last index of the array. 方法一：bfs。需要注意num_seen记录所有的同值，否则会超时。 1234567891011121314151617def minJumps(self, arr: List[int]) -&gt; int: equal = collections.defaultdict(list) for i, a in enumerate(arr): equal[a].append(i) q = collections.deque([(0, 0)]) pos_seen, num_seen = set(), set() while q: p, s = q.popleft() pos_seen.add(p) num = arr[p] if p == len(arr)-1: return s for nxt in [p-1, p+1] + equal[num] * (num not in num_seen): if nxt in pos_seen or not 0&lt;=nxt&lt;len(arr): continue q.append((nxt, s+1)) num_seen.add(num) 1331. Rank Transform of an Array将数组转化为排行。原题123Input: arr = [40,10,20,30]Output: [4,1,2,3]Explanation: 40 is the largest element. 10 is the smallest. 20 is the second smallest. 30 is the third smallest. 方法一：setdefault的妙用。 by Lee215 12345def arrayRankTransform(self, arr: List[int]) -&gt; List[int]: rank = &#123;&#125; for a in sorted(arr): rank.setdefault(a, len(rank)+1) return map(rank.get, arr) 1314. Matrix Block Sum矩阵块的求和。原题12Input: mat = [[1,2,3],[4,5,6],[7,8,9]], K = 1Output: [[12,21,16],[27,45,33],[24,39,28]] 方法一：竞赛时暴力法过的。这里实际上求和时可以利用之前的和。 123456789101112131415161718192021def matrixBlockSum(self, mat: List[List[int]], k: int) -&gt; List[List[int]]: m, n = len(mat), len(mat[0]) dp = [list(itertools.accumulate(row)) for row in mat] dp = [list(itertools.accumulate(row)) for row in zip(*dp)] dp = list(zip(*dp)) ans = [] for i in range(m): tmp = [] for j in range(n): r_lo, r_hi = max(0, i-k), min(i+k, m-1) c_lo, c_hi = max(0, j-k), min(j+k, n-1) cur_sum = dp[r_hi][c_hi] if r_lo &gt; 0: cur_sum -= dp[r_lo-1][c_hi] if c_lo &gt; 0: cur_sum -= dp[r_hi][c_lo-1] if r_lo &gt; 0 and c_lo &gt; 0: cur_sum += dp[r_lo-1][c_lo-1] tmp.append(cur_sum) ans.append(tmp) return ans 1306. Jump Game III跳跃游戏，从start开始，可以沿着value向前向后跳，求是否可以跳到0.原题123456Input: arr = [4,2,3,0,3,1,2], start = 5Output: trueExplanation: All possible ways to reach at index 3 with value 0 are: index 5 -&gt; index 4 -&gt; index 1 -&gt; index 3 index 5 -&gt; index 6 -&gt; index 4 -&gt; index 1 -&gt; index 3 方法一：Bfs. 1234567891011def canReach(self, arr: List[int], start: int) -&gt; bool: q, seen = collections.deque([start]), &#123;start&#125; while q: i = q.popleft() if arr[i] == 0: return True for nxt in (i-arr[i], i+arr[i]): if nxt not in seen and 0&lt;=nxt&lt;len(arr): q.append(nxt) seen.add(nxt) return False 方法二：数组中元素均为非负数，所以用负数来标记已经跳过的点。 12345def canReach(self, arr: List[int], i: int) -&gt; bool: if 0&lt;=i&lt;len(arr) and arr[i]&gt;=0: arr[i] = -arr[i] return arr[i]==0 or self.canReach(arr, i+arr[i]) or self.canReach(arr, i-arr[i]) return False 1298. Maximum Candies You Can Get from Boxes最多从盒子中拿到的糖果。从初始的盒子中往外取，盒子能嵌套盒子，盒子如果上锁还需要钥匙打开。原题方法一：有一点没有想到，就是如果前面的盒子被拿出来，但是没有钥匙，知道后面的盒子才获取到钥匙。这种情况需要如何处理？这里参考了lee215的方式。q来表示所有已经打开的盒子，seen表示所有可见的盒子，这样当拿到钥匙时，其实需要做两个操作，如果这个盒子可见，将其放入q，如果盒子没见，将其锁打开（虽不符常理），这样在遇见盒子时可以直接将其添加到队列。 12345678910111213141516def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -&gt; int: ans = 0 q = collections.deque(b for b in initialBoxes if status[b]) seen = set(initialBoxes) while q: b = q.popleft() ans += candies[b] for new_box in containedBoxes[b]: seen.add(new_box) if status[new_box]: q.append(new_box) for key in keys[b]: if status[key] == 0 and key in seen: q.append(key) status[key] = 1 return ans 1297. Maximum Number of Occurrences of a Substring出现次数最多的子串。滑动窗口可伸缩，最多包含maxLetters个字母。原题123def maxFreq(self, s: str, maxLetters: int, k: int, maxSize: int) -&gt; int: c = collections.Counter(s[i:i+k] for i in range(len(s)-k+1)) return max([n for sub, n in c.items() if len(set(sub)) &lt;= maxLetters] + [0]) 1291. Sequential Digits按序求组区间中的顺子。原题12Input: low = 1000, high = 13000Output: [1234,2345,3456,4567,5678,6789,12345] 方法一：开始时用的转化字符串的方式。不优雅，借鉴了他人解法。生成器有个好处是你可以暂时先不关心顺序。因为low&gt;=10，所以一开始不会以9开头。 1234567891011def sequentialDigits(self, low: int, high: int) -&gt; List[int]: def gen(digit): num = digit while num &lt;= high and digit &lt; 10: if num &gt;= low: yield num digit += 1 num = num*10 + digit return sorted(num for i in range(1, 9) for num in gen(i)) 1293. Shortest Path in a Grid with Obstacles Elimination最短路径，可以打通障碍k次。原题123456789101112Input: grid = [[0,0,0], [1,1,0], [0,0,0], [0,1,1], [0,0,0]], k = 1Output: 6Explanation: The shortest path without eliminating any obstacle is 10. The shortest path with one obstacle elimination at position (3,2) is 6. Such path is (0,0) -&gt; (0,1) -&gt; (0,2) -&gt; (1,2) -&gt; (2,2) -&gt; (3,2) -&gt; (4,2). 方法一：一开始想到了正确思路，但是想错了最小步骤怎么求，其实不用求，第一个到达的就是最小的步数。 123456789101112131415161718def shortestPath(self, g: List[List[int]], k: int) -&gt; int: m, n = len(g), len(g[0]) q = collections.deque([(0, 0, k, 0)]) seen = &#123;(0, 0, k)&#125; while q: x, y, r, s = q.popleft() if x==m-1 and y==n-1: return s # 如果可以直接直角边走到末尾，那么直接过去，优化快了700ms+. if r &gt;= m + n - 3 - x - y: return s + m + n - 2 - x - y for i, j in ((0, 1), (1, 0), (-1, 0), (0, -1)): if 0&lt;=x+i&lt;m and 0&lt;=y+j&lt;n: nr = r-(g[x+i][y+j]==1) if (x+i, y+j, nr) not in seen and nr&gt;=0: q.append((x+i, y+j, nr, s+1)) seen.add((x+i, y+j, nr)) return -1 1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix二维矩阵中， 每次翻拍“十”字，最小步数翻成0.原题123Input: mat = [[0,0],[0,1]]Output: 3Explanation: One possible solution is to flip (1, 0) then (0, 1) and finally (1, 1) as shown. 方法一：看了答案才做出来，看到提示bfs，但是没有想到可以将这个二维矩阵转成一个二进制是它的数。 12345678910111213141516171819def minFlips(self, mat: List[List[int]]) -&gt; int: m, n = len(mat), len(mat[0]) start = sum(cell&lt;&lt;(i*n+j) for i, row in enumerate(mat) for j, cell in enumerate(row)) q = collections.deque([(start, 0)]) seen = &#123;start&#125; while q: cur, step = q.popleft() if not cur: return step for x in range(m): for y in range(n): nxt = cur for i, j in ((0, 1), (1, 0), (-1, 0), (0, -1), (0, 0)): if m &gt; x+i &gt;= 0 &lt;= y+j &lt; n: nxt ^= 1 &lt;&lt; ((x+i)*n + y+j) # 0 ^ 0 = 0, 1 ^ 0 = 1 if nxt not in seen: q.append((nxt, step+1)) seen.add(nxt) return -1 1275. Find Winner on a Tic Tac Toe Game三子棋的游戏，谁先连到3个子谁就赢。原题123456Input: moves = [[0,0],[2,0],[1,1],[2,1],[2,2]]Output: &quot;A&quot;Explanation: &quot;A&quot; wins, he always plays first.&quot;X &quot; &quot;X &quot; &quot;X &quot; &quot;X &quot; &quot;X &quot;&quot; &quot; -&gt; &quot; &quot; -&gt; &quot; X &quot; -&gt; &quot; X &quot; -&gt; &quot; X &quot;&quot; &quot; &quot;O &quot; &quot;O &quot; &quot;OO &quot; &quot;OOX&quot; 方法一：这题是为数不多easy里面想了时间那么长的，除了暴力法没有想到什么思路。 1234567891011121314def tictactoe(self, moves: List[List[int]]) -&gt; str: line = collections.defaultdict(list) for i, (x, y) in enumerate(moves): p = 'A' if i&amp;1==0 else 'B' xk, yk = 'x_&#123;&#125;'.format(x), 'y_&#123;&#125;'.format(y) line[xk].append(p) line[yk].append(p) if x == y: line['d_0'].append(p) if x + y == 2: line['d_1'].append(p) if any(len(l)==3 and len(set(l))==1 for l in (line[xk], line[yk], line['d_0'], line['d_1'])): return p return 'Draw' if len(moves) == 9 else 'Pending' 方法二：将A, B分为2组，这样比较时更简单一点。 123456789101112def tictactoe(self, moves: List[List[int]]) -&gt; str: row, col = [[0] * 3 for _ in range(2)], [[0] * 3 for _ in range(2)] d1, d2, p = [0] * 2, [0] * 2, 0 for r, c in moves: row[p][r] += 1 col[p][c] += 1 d1[p] += r==c d2[p] += r+c==2 if 3 in (row[p][r], col[p][c], d1[p], d2[p]): return 'AB'[p] p ^= 1 return 'Draw' if len(moves)==9 else 'Pending' 1260. Shift 2D Grid2D滑动，每次列右移一次，首列下移一次。原题12Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1Output: [[9,1,2],[3,4,5],[6,7,8]] 方法一：deque。最直观的方法。 1234567def shiftGrid(self, g: List[List[int]], k: int) -&gt; List[List[int]]: m, n = len(g), len(g[0]) q = collections.deque(zip(*g)) for _ in range(k): head = q.pop() q.appendleft(head[-1:]+head[:-1]) return [a for a in zip(*q)] 方法二：调了半天，找了一些规律，然而并没有方法一快多少，时间上差不多，反而是更难理解了。 123456def shiftGrid(self, g: List[List[int]], k: int) -&gt; List[List[int]]: m, n = len(g), len(g[0]) mk = k % n a = list(zip(*g)) a = a[-mk:] + a[:-mk] return zip(*[row[-((k//n+(i&lt;mk))%m):] + row[:-((k//n+(i&lt;mk))%m)] for i, row in enumerate(a)]) 方法三：看来时间效率应该是差不多了，将数组转成一维，会发现规律。 12345def shiftGrid(self, g: List[List[int]], k: int) -&gt; List[List[int]]: col, nums = len(g[0]), sum(g, []) k = k % len(nums) nums = nums[-k:] + nums[:-k] return [nums[i:i+col] for i in range(0, len(nums), col)] 1252. Cells with Odd Values in a Matrix根据坐标每次将所在的行和列+1，这个点+2，统计所有的奇数个数。原题12345Input: n = 2, m = 3, indices = [[0,1],[1,1]]Output: 6Explanation: Initial matrix = [[0,0,0],[0,0,0]].After applying first increment it becomes [[1,2,1],[0,1,0]].The final matrix will be [[1,3,1],[1,3,1]] which contains 6 odd numbers. 方法一：异或。 123456def oddCells(self, n: int, m: int, indices: List[List[int]]) -&gt; int: row, col = [0] * n, [0] * m for x, y in indices: row[x] ^= 1 col[y] ^= 1 return sum(r ^ c for r in row for c in col) 1248. Count Number of Nice Subarrays找到包含k个奇数的子数组个数。原题123Input: nums = [1,1,2,1,1], k = 3Output: 2Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1]. 方法一：找到所有的奇数索引，然后滑动窗口累加值。 123456789def numberOfSubarrays(self, nums: List[int], k: int) -&gt; int: n = len(nums) odd = [i for i, num in enumerate(nums) if num&amp;1==1] ans = 0 for i in range(len(odd)-k+1): pre = -1 if not i else odd[i-1] hi = n if i==len(odd)-k else odd[i+k] ans += (odd[i]-pre) * (hi-odd[i+k-1]) return ans 方法二：遍历一次 123456789101112def numberOfSubarrays(self, A: List[int], k: int) -&gt; int: i = count = res = 0 for j in range(len(A)): if A[j] &amp; 1: k -= 1 count = 0 while k == 0: k += A[i] &amp; 1 i += 1 count += 1 res += count return res 1234. Replace the Substring for Balanced String将每个QWER出现的次数变为一样，最少需要修改的子串长度是多少。原题123Input: s = &quot;QQWE&quot;Output: 1Explanation: We need to replace a &apos;Q&apos; to &apos;R&apos;, so that &quot;RQWE&quot; (or &quot;QRWE&quot;) is balanced. 方法一：例子有地不好，子串必须是连续的。和lee大佬解法差不多。 123456789101112def balancedString(self, s: str) -&gt; int: diff = Counter(s) - Counter(&#123;c: len(s)//4 for c in 'QWER'&#125;) ans = float('inf') c = Counter() i = 0 for j, a in enumerate(s): c[a] += 1 while i!=len(s) and not diff-c: ans = min(ans, j-i+1) c[s[i]] -= 1 i += 1 return ans 1208. Get Equal Substrings Within Budget将字符串s变为t。需要ascii码的差，问在指定的差中，最长的可以变成的子串长度是多少。原题123Input: s = &quot;abcd&quot;, t = &quot;bcdf&quot;, maxCost = 3Output: 3Explanation: &quot;abc&quot; of s can change to &quot;bcd&quot;. That costs 3, so the maximum length is 3. 方法一：滑动窗口问题。比赛的答案。 1234567891011def equalSubstring(self, s: str, t: str, maxCost: int) -&gt; int: diff = [abs(ord(a)-ord(b)) for a, b in zip(s, t)] q = collections.deque() cur_sum = ans = 0 for d in diff: q.append(d) cur_sum += d while cur_sum &gt; maxCost: cur_sum -= q.popleft() ans = max(ans, len(q)) return ans 方法二：Lee215，开始比较迷惑为什么i, j 不用max来求值，看了评论发现有人和我有一样的疑惑，并且给了解释，对于此题而言，滑动窗口的长度不会缩短。因为只用了if 而不是while 12345678def equalSubstring(self, s: str, t: str, cost: int) -&gt; int: i = 0 for j in range(len(s)): cost -= abs(ord(s[j]) - ord(t[j])) if cost &lt; 0: cost += abs(ord(s[i]) - ord(t[i])) i += 1 return j - i + 1 Sort Colors0,1,2的数组排序。原题12Input: [2,0,2,1,1,0]Output: [0,0,1,1,2,2] 方法一：没想到有快排的思想。维持三个区间[0,i) [i,j),[j,k)分别表示0，1，2的区间。 1234567891011def sortColors(self, nums: List[int]) -&gt; None: i, j = 0, 0 for k in range(len(nums)): v = nums[k] nums[k] = 2 if v &lt; 2: nums[j] = 1 j += 1 if v == 0: nums[i] = 0 i += 1 1191. K-Concatenation Maximum Sum求k*arr的连续数组最大和。原题1234Input: arr = [1,2], k = 3Output: 9Input: arr = [1,-2,1], k = 5Output: 2 方法一：想到了卡登算法，但是没想明白为啥要加(k-2)个数组的和，因为首位数组中间可以夹带(k-2)个数组，如果数组和是正数的话，就将它算进去 1234def kConcatenationMaxSum(self, arr: List[int], k: int, mod=10**9+7) -&gt; int: def acc(nums): return max(accumulate(nums+[0], lambda x, y: x+y if x&gt;0 else y)) return ((k-2)*max(sum(arr), 0) + acc(arr*2)) % mod if k &gt; 1 else acc(arr) % mod 448. Find All Numbers Disappeared in an Array找出n长度的数组中1-n缺失的数字，有的数字会出现多次。原题12345Input:[4,3,2,7,8,2,3,1]Output:[5,6] 方法一：这道题解法挺新颖，看着这题和剑指offer中的有点类似，但是那道题是其它数字出现一次。这个题的解法是出现的位置的数变成负的，最后找正数的索引。 12345def findDisappearedNumbers(self, nums: List[int]) -&gt; List[int]: for i in range(len(nums)): index = abs(nums[i]) - 1 nums[index] = -abs(nums[index]) return [i+1 for i, num in enumerate(nums) if num&gt;0] 11. Container With Most Water最大的水容积，用坐标轴装水，有点像木桶原理。原题方法一：双指针，开始没有想到指针如何移动。其实这样想，如果一个坐标比较矮，那就将其舍弃，因为宽度是越来越小的，所以需要更高的木桶才能弥补。 def maxArea(self, height: List[int]) -&gt; int: lo, hi = 0, len(height)-1 ans = 0 while lo &lt; hi: ans = max(ans, (hi-lo)*min(height[hi], height[lo])) if height[lo] &lt; height[hi]: lo += 1 else: hi -= 1 return ans 1498. Number of Subsequences That Satisfy the Given Sum Condition给定一个数组，返回最大值最小值和小于目标值的子序列，可以不连续，的个数。原题1234567Input: nums = [3,5,6,7], target = 9Output: 4Explanation: There are 4 subsequences that satisfy the condition.[3] -&gt; Min value + max value &lt;= target (3 + 3 &lt;= 9)[3,5] -&gt; (3 + 5 &lt;= 9)[3,5,6] -&gt; (3 + 6 &lt;= 9)[3,6] -&gt; (3 + 6 &lt;= 9) 方法一：一开始思路相对了，但是指针移动没想好。来自Lee215，累加的时候要计算一下mod否则效率会变很慢。 1234567891011def numSubseq(self, nums: List[int], target: int) -&gt; int: nums.sort() lo, hi = 0, len(nums)-1 res = 0 while lo &lt;= hi: if nums[lo] + nums[hi] &gt; target: hi -= 1 else: res += pow(2, hi - lo, 10**9+7) lo += 1 return res % (10**9+7) 463. Island Perimeter小岛的周长，小岛中间没有湖。原题1234567Input:[[0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0]]Output: 16 方法一：stefan、因为中间没有湖，所以呢周长等于所以相邻格子不相等的个数。这里将列也放在一起计算了 123def islandPerimeter(self, grid: List[List[int]]) -&gt; int: return sum(sum(map(operator.ne, [0] + row, row + [0])) for row in grid + list(map(list, zip(*grid)))) 15. 3Sum找出数组中3个数相加为0，返回所有的组合非重复。原题1234567Given array nums = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] 方法一：这里看了提示后用的2sum的方法。 123456789101112131415161718def threeSum(self, nums: List[int]) -&gt; List[List[int]]: nums.sort() ans = [] seen = set() n = len(nums) for i in range(n): a = nums[i] if a in seen: continue seen.add(a) d = &#123;&#125; for j in range(i+1, n): b = nums[j] if b in d and (not(ans) or (ans[-1][0]!=a or ans[-1][2]!=b)): ans.append((a, -a-b, b)) else: d[-a-b] = 0 return ans 方法二：讨论区看到的一个方法。明白了还有许多可以优化的地方。 12345678910111213141516171819202122232425def threeSum(self, nums: List[int]) -&gt; List[List[int]]: nums.sort() ans, n = [], len(nums) for i in range(n-2): a = nums[i] if a &gt; 0: break # 因为a&gt;0, b,c&gt;0，所以不可能和为0 if i and a == nums[i-1]: continue lo, hi = i+1, n-1 while lo &lt; hi: total = nums[lo] + nums[hi] if total &gt; -a: hi -= 1 elif total &lt; -a: lo += 1 else: while lo&lt;hi and nums[lo]==nums[lo+1]: lo += 1 while lo&lt;hi and nums[hi]==nums[hi-1]: hi -= 1 ans.append((a, nums[lo], nums[hi])) lo += 1 hi -= 1 return ans 1508. Range Sum of Sorted Subarray Sums数组的累加和排序，取区间中的数字和。原题123Input: nums = [1,2,3,4], n = 4, left = 1, right = 5Output: 13 Explanation: All subarray sums are 1, 3, 6, 10, 2, 5, 9, 3, 7, 4. After sorting them in non-decreasing order we have the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from index le = 1 to ri = 5 is 1 + 2 + 3 + 3 + 4 = 13. 方法一：O(n^2)的方法。比赛的时候还用了accumulate， 但是其实没必要。 1234567891011def rangeSum(self, nums: List[int], n: int, left: int, right: int) -&gt; int: mod = 10**9 + 7 n = len(nums) ans = [] for i in range(n): cur = 0 for j in range(i, n): cur += nums[j] ans.append(cur) ans.sort() return sum(ans[left-1: right]) % mod 1509. Minimum Difference Between Largest and Smallest Value in Three Moves删除3个数，数组的最大值最小值差最小是多少。原题方法一：首次ac的方法。思路很直观，但是写法却有点复杂。 1234567891011def minDifference(self, nums: List[int]) -&gt; int: nums.sort() n = len(nums) if n &lt;= 3: return 0 # print(nums) ans = float('inf') for i in range(4): tmp = nums[i:n-3+i] ans = min(ans, max(tmp) - min(tmp)) return ans 方法二：2行就可以搞定。 123def minDifference(self, nums: List[int]) -&gt; int: nums.sort() return min(b-a for a, b in zip(nums[:4], nums[-4:])) 方法三：堆求也可以。 123def minDifference(self, nums: List[int]) -&gt; int: nums.sort() return min(a - b for a,b in zip(heapq.nlargest(4, nums), heapq.nsmallest(4, nums)[::-1])) 1529. Bulb Switcher IV灯泡开关，每次只能开关从后开始的连续的n个，问变成目标状态，最少需要几次操作。原题1234567Input: target = &quot;10111&quot;Output: 3Explanation: Initial configuration &quot;00000&quot;.flip from the third bulb: &quot;00000&quot; -&gt; &quot;00111&quot;flip from the first bulb: &quot;00111&quot; -&gt; &quot;11000&quot;flip from the second bulb: &quot;11000&quot; -&gt; &quot;10111&quot;We need at least 3 flip operations to form target. 方法一：竞赛时的方法。 分组。 12345678910def minFlips(self, target: str) -&gt; int: ans = 0 first = True for l, g in itertools.groupby(target): if l == '0' and first: continue else: ans += 1 first = False return ans 方法二：上诉方法补0 优化。 12def minFlips(self, target: str) -&gt; int: return len(list(itertools.groupby('0' + target))) - 1 方法三：不分组，一次遍历。 1234567def minFlips(self, target: str) -&gt; int: ans, b = 0, 1 for c in target: if int(c) == b: ans += 1 b = 1 - b return ans 442. Find All Duplicates in an Array找到所有重复的元素，数组中的元素都在1~n之间，n为数组的长度。原题方法一：要求在O(n)时间，O(1)空间实现，那么就考虑修改原数组来节省空间。以负值来记录是否出现过。 12345678def findDuplicates(self, nums: List[int]) -&gt; List[int]: res = [] for x in nums: if nums[abs(x)-1] &lt; 0: res.append(abs(x)) else: nums[abs(x)-1] *= -1 return res 713. Subarray Product Less Than K连续子数组乘积小于k的个数，元素为正数。原题1234Input: nums = [10, 5, 2, 6], k = 100Output: 8Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k. 方法一：一开始想到了双端队列，但是累加时end-start+1数量没想到。此题用双指针即可 123456789101112def numSubarrayProductLessThanK(self, nums: List[int], k: int) -&gt; int: if k == 0: return 0 start = ans = 0 prod = 1 for end, num in enumerate(nums): while start&lt;=end and prod*num&gt;=k: prod //= nums[start] start += 1 prod = 1 if start&gt;end else prod*num ans += (end-start+1) * (start&lt;=end) return ans 915. Partition Array into Disjoint Intervals将数组拆成两个非空数组，要求左侧的每个元素都小于等于右侧的每个元素，求左侧最小的长度，假设答案一定存在。原题123Input: [5,0,3,8,6]Output: 3Explanation: left = [5,0,3], right = [8,6] 方法一：蛮简单的，two-pass的方法，这个累加函数的生成器不能直接reversed，要将其转换成数组，这里产生了一次遍历。 1234567def partitionDisjoint(self, A: List[int]) -&gt; int: left = itertools.accumulate(A, max) right = reversed(list(itertools.accumulate(reversed(A), min))) next(right, None) for i, (a, b) in enumerate(zip(left, right)): if a &lt;= b: return i + 1 方法二：one-pass. 这个方法不是很好想，思路是这样的，当当前数小于之前的最大值，那么久将其算入左侧的数组中。 123456789def partitionDisjoint(self, A: List[int]) -&gt; int: p = 0 cur_max = left_max = A[0] for i, a in enumerate(A): cur_max = max(cur_max, a) if a &lt; left_max: left_max = cur_max p = i return p + 1 1562. Find Latest Group of Size M将一个全是0的字符串按照arr的索引顺序变为1，整体被0分割成若干段，问最后有m个长度的”1”的段时是第几步、原题123456789Input: arr = [3,5,1,2,4], m = 1Output: 4Explanation:Step 1: &quot;00100&quot;, groups: [&quot;1&quot;]Step 2: &quot;00101&quot;, groups: [&quot;1&quot;, &quot;1&quot;]Step 3: &quot;10101&quot;, groups: [&quot;1&quot;, &quot;1&quot;, &quot;1&quot;]Step 4: &quot;11101&quot;, groups: [&quot;111&quot;, &quot;1&quot;]Step 5: &quot;11111&quot;, groups: [&quot;11111&quot;]The latest step at which there exists a group of size 1 is step 4. 方法一：比赛时没做出来，Lee的方法。length表示第i个bit的长度，count表示这么长的group有多少个。严格来说length[a-left]和lenght[a+right]区间内都应该变成left+right+1。但是由于中间的后续用不到，所以不必赋值。 1234567891011121314def findLatestStep(self, arr: List[int], m: int) -&gt; int: length = [0] * (len(arr)+2) count = [0] * (len(arr)+1) ans = -1 for i, a in enumerate(arr): left, right = length[a-1], length[a+1] length[a] = length[a-left] = length[a+right] = left + right + 1 count[left] -= 1 count[right] -= 1 count[length[a]] += 1 # print(length, count) if count[m]: ans = i + 1 return ans 334. Increasing Triplet Subsequence数组中是否有三个元素递增。原题1234Input: [1,2,3,4,5]Output: trueInput: [1,5,3,4,2]Output: true 方法一：首次ac的方法，看了要求在O(n)时间O(1)空间实现。 1234567def increasingTriplet(self, nums: List[int]) -&gt; bool: a = b = float('inf') for num in nums: if num &gt; b: return True a = min(a, num) if a&lt;num&lt;b: b=num return False 方法二：这个stefan的方法，具有泛化性，如果求4，5个元素递增可以直接修改变量。 1234567inc = [float('inf')] * 2 for x in nums: i = bisect.bisect_left(inc, x) if i &gt;= 2: return True inc[i] = x return False 926. Flip String to Monotone Increasing将一个二进制字符串翻转成单调递增最少要几步。原题123Input: &quot;010110&quot;Output: 2Explanation: We flip to get 011111, or alternatively 000111. 方法一：看了一眼讨论区，就明白了，遍历时找到递增的点，也就是第一个1，记录后边的0和前边的1。这里我是在后面补1，也可以将ans初始化为len(S)-suffix_0。 1234567891011def minFlipsMonoIncr(self, S: str) -&gt; int: S += '1' suffix_0, prefix_1 = S.count('0'), 0 ans = float('inf') for c in S: if c == '0': suffix_0 -= 1 else: ans = min(ans, suffix_0+prefix_1) prefix_1 += 1 return ans 424. Longest Repeating Character Replacement由26个大写字母组成的字符串，在k次替换范围内，产生的最长的重复字符串是多少。原题12345678Input:s = &quot;ABAB&quot;, k = 2Output:4Explanation:Replace the two &apos;A&apos;s with two &apos;B&apos;s or vice versa. 方法一：滑动窗口加数组计数。time- O(26N)。while是没有必要的，left+1后 左边等号就会刚好=k, 不过这里的left, right表示的区间意义变了，表示的是最大的滑动窗口，窗口内的字符串不一定是可以满足条件的。 1234567891011def characterReplacement(self, s: str, k: int) -&gt; int: cnt = [0] * 26 left = ans = 0 for right, d in enumerate(s): cnt[ord(d)-ord('A')] += 1 # while right-left+1-max(cnt) &gt; k: if right-left+1-max(cnt) &gt; k: cnt[ord(s[left])-ord('A')] -= 1 left += 1 ans = max(ans, right-left+1) return ans 方法二：研究了很久也没弄明白，为什么maxf曾经最大的值，可以替代max(cnt)。理论上时间确实比上述快了。Time-O(N)。我试了一个特殊的例子，”BBBCADEF”1，在某些情况maxf &gt; max(cnt)的，但即便这样也没有影响if判断，猜测可能为right-left+1区间为最大区间。不过又将if改成while循环，依然没有影响。此解法还是有些疑惑。 12345678910111213def characterReplacement(self, s: str, k: int) -&gt; int: cnt = [0] * 26 left = ans = maxf = 0 for right, d in enumerate(s): cnt[ord(d)-ord('A')] += 1 maxf = max(maxf, cnt[ord(d)-ord('A')]) # while right-left+1-max(cnt) &gt; k: # print(maxf, max(cnt), left, right, ans) if right-left+1-maxf &gt; k: cnt[ord(s[left])-ord('A')] -= 1 left += 1 ans = max(ans, right-left+1) return ans 398. Random Pick Index有这样一个数组，我想随机的去一个目标的元素，找到和目标相等的这些元素随机返回一个索引。原题12345678int[] nums = new int[] &#123;1,2,3,3,3&#125;;Solution solution = new Solution(nums);// pick(3) should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.solution.pick(3);// pick(1) should return 0. Since in the array only nums[0] is equal to 1.solution.pick(1); 方法一：直接放到defaultdict中也没有超过空间限制。 123456789class Solution: def __init__(self, nums: List[int]): self.p = collections.defaultdict(list) for i, d in enumerate(nums): self.p[d].append(i) def pick(self, target: int) -&gt; int: return random.choice(self.p[target]) 方法二：一个新的方法叫作蓄水池取样，当遇见了一个目标数，就将它放到池子中，然后随机一个数。并在随到当前数时更新索引。 123456789101112131415class Solution: def __init__(self, nums: List[int]): self.nums = nums def pick(self, target: int) -&gt; int: ans = None count = 0 for i, num in enumerate(self.nums): if num == target: count += 1 chance = random.randint(1, count) if chance == count: ans = i return ans 382. Linked List Random Node在一个链表上随机取一个节点值。原题方法一：和398一样。假设链表无限大，不能够获取它的长度。这是非常经典的一个题。一个很大的数据流，对数据流的内容只能访问一次，随机算法使数据流中所有的被选中的概率相等。 123456789101112131415class Solution: def __init__(self, nums: List[int]): self.nums = nums def pick(self, target: int) -&gt; int: ans = None count = 0 for i, num in enumerate(self.nums): if num == target: count += 1 chance = random.randint(1, count) if chance == count: ans = i return ans 209. Minimum Size Subarray Sum累加和大于s的最短的子数组长度。原题123Input: s = 7, nums = [2,3,1,2,4,3]Output: 2Explanation: the subarray [4,3] has the minimal length under the problem constraint. 方法一：滑动窗口。注意A为空的情况。 123456789def minSubArrayLen(self, s: int, A: List[int]) -&gt; int: i, ans = 0, len(A)+1 for j in range(len(A)): s -= A[j] while s &lt;= 0: ans = min(ans, j-i+1) s += A[i] i += 1 return ans % (len(A)+1) 930. Binary Subarrays With Sum求和我S的子数组个数，数组元素只包含0，1。原题12345678Input: A = [1,0,1,0,1], S = 2Output: 4Explanation: The 4 subarrays are bolded below:[1,0,1,0,1][1,0,1,0,1][1,0,1,0,1][1,0,1,0,1] 方法一：这种题要求at_most. 滑动窗口，用和小于等于S的子数组个数减去小于等于S-1的子数组个数。 1234567891011121314def numSubarraysWithSum(self, A: List[int], S: int) -&gt; int: def at_most(S): if S &lt; 0: return 0 res = i = 0 for j in range(len(A)): S -= A[j] while S &lt; 0: S += A[i] i += 1 res += j-i+1 return res return at_most(S) - at_most(S-1) 969. Pancake Sorting煎饼排序。由1~n组成，没次只能reverse前k个，求k的数组，答案不唯一。原题12345678910Input: A = [3,2,4,1]Output: [4,2,4,3]Explanation: We perform 4 pancake flips, with k values 4, 2, 4, and 3.Starting state: A = [3, 2, 4, 1]After 1st flip (k = 4): A = [1, 4, 2, 3]After 2nd flip (k = 2): A = [4, 1, 2, 3]After 3rd flip (k = 4): A = [3, 2, 1, 4]After 4th flip (k = 3): A = [1, 2, 3, 4], which is sorted.Notice that we return an array of the chosen k values of the pancake flips. 方法一：例子中的做法不是很好，只需要每次找最大的，然后翻到首位，然后再全翻转使其到达末尾。 1234567891011def pancakeSort(self, A: List[int]) -&gt; List[int]: ans, n = [], len(A) for i in range(n, -1, -1): if A[i] != i+1: j = A.index(i+1) if j: ans.append(j+1) A = A[:j+1][::-1] + A[j+1:] ans.append(i+1) A = A[:i+1][::-1] + A[i+1:] return ans 方法二：Lee的方法，这种方法把1也放进去了。其实是无所谓的。 1234567def pancakeSort(self, A: List[int]) -&gt; List[int]: ans, n = [], len(A) for x in range(n, 1, -1): i = A.index(x) ans.extend((i+1, x)) A = A[:i:-1] + A[:i] return ans 1566. Detect Pattern of Length M Repeated K or More Times判断数组中是否有k次以上个重复的M大小的组。原题123Input: arr = [1,2,4,4,4,4], m = 1, k = 3Output: trueExplanation: The pattern (4) of length 1 is repeated 4 consecutive times. Notice that pattern can be repeated k or more times but not less. 方法一：暴力。 12345678910def containsPattern(self, arr: List[int], m: int, k: int) -&gt; bool: n = len(arr) for i in range(n): end = i + m*k if end &gt; n: return False tmp = arr[i:i+m] # if all(arr[i+m*j:i+m*j+m] == tmp for j in range(1, k)): if arr[i:i+m*k] == tmp*k: return True return False 方法二：这个方法挺难想，为什么是(k-1)*m因为第一个用来比较，不算在内，如果在达到之前有一个不相等，则归零。 123456def containsPattern(self, arr: List[int], m: int, k: int) -&gt; bool: streak = 0 for i in range(len(arr)-m): streak = streak + 1 if arr[i] == arr[i+m] else 0 if streak == (k-1)*m: return True return False 228. Summary Ranges格式化一段range。原题123Input: [0,1,2,4,5,7]Output: [&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]Explanation: 0,1,2 form a continuous range; 4,5 form a continuous range. 方法一：很简单，记录这题主要是学到了一个新的写法。先贴自己的解法。 12345678910def summaryRanges(self, nums: List[int]) -&gt; List[str]: stack = [] for d in nums: if not stack or stack[-1][-1]+1&lt;d: stack.append([d]) else: if len(stack[-1]) == 2: stack[-1].pop() stack[-1].append(d) return ['-&gt;'.join(map(str, p)) for p in stack] 方法二：stefan的写法。[][1:] = 1,数组会变成[1]。 1234567def summaryRanges(self, nums: List[int]) -&gt; List[str]: stack = [] for d in nums: if not stack or stack[-1][-1]+1&lt;d: stack.append([]) stack[-1][1:] = d, return ['-&gt;'.join(map(str, p)) for p in stack] 769. Max Chunks To Make Sorted可以将一个数组分成几块小数组，然后使每个小数组排序后连接起来，整个大数组有序，问最多可以分成多少块。原题12345Input: arr = [1,0,2,3,4]Output: 4Explanation:We can split into two chunks, such as [1, 0], [2, 3, 4].However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible. 方法一：直白来看，如果某一段包含了排序后应该有的所有的数，那么久将其分成一段。 12345678def maxChunksToSorted(self, arr: List[int]) -&gt; int: ans, n = 0, len(arr) start = 0 for end in range(1, n+1): if sorted(arr[start:end]) == list(range(start, end)): ans += 1 start = end return ans 方法二：Lee的方法。当max(A[0]~A[i])==i时分割，其中包含了一个原理，如果更大的数参入到之前的段中，最大值就会更新，想要在某点和索引相等，就必须将比它小的数全找到。 123456def maxChunksToSorted(self, arr: List[int]) -&gt; int: cur_max, ans = -1, 0 for i, num in enumerate(arr): cur_max = max(num, cur_max) ans += cur_max==i return ans 390. Elimination Game消除游戏，从1~n的数组，每次从左到右隔一个删除，然后从右到左隔一个删除。最后剩下一个数字是哪个。原题123456789Input:n = 9,1 2 3 4 5 6 7 8 92 4 6 82 66Output:6 方法一：在用切片方法发现n能到1亿时，超时了；然后想到其实只需要控制一个范围即可。每次操作后，数组中的等差变为原来的2倍。 123456789101112131415def lastRemaining(self, n: int) -&gt; int: start, end, d = 1, n, 1 op = 1 while start &lt; end: # print(start, end, d, op) num = (end-start)//d + 1 if op: start += d end -= (num&amp;1) * d else: start += (num&amp;1) * d end -= d op ^= 1 d *= 2 return start 方法二：整理代码。end其实无用，用一个num表示剩余的数字个数。 123456789def lastRemaining(self, n: int) -&gt; int: start = d = left = 1 num = n while num &gt; 1: start += (left or (num&amp;1)) * d left ^= 1 d *= 2 num //= 2 return start 853. Car Fleet超车车队，说有这么一些车向同一个目的地出发，起始位置和速度不同，当快车遇见慢车时不能超过，而是跟在后面变成一个车队。问最后到达终点时有几个车队，1辆车也算一个车队。原题1234567Input: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]Output: 3Explanation:The cars starting at 10 and 8 become a fleet, meeting each other at 12.The car starting at 0 doesn&apos;t catch up to any other car, so it is a fleet by itself.The cars starting at 5 and 3 become a fleet, meeting each other at 6.Note that no other cars meet these fleets before the destination, so the answer is 3. 方法一：思路很快想出来了，就是排序，但是根据什么排序，怎么比较想了半天。问题出在这个例子上：10, [0,4,2],[2,1,3]这个排序后时[(4, 6), (2, 2.6), (0, 5)]，以起始点位置排序，当一个时间小于等于之前的时间时，那么这辆车就能追上之前的，变成一个车队；反之，则形成一个单独的车队。这个“之前的时间”指的不是挨着的前面的一个时间，而是之前最慢的一个车。也就是时间最大的。 12345678def carFleet(self, target: int, position: List[int], speed: List[int]) -&gt; int: cars = ((target-p)/s for p, s in sorted(zip(position, speed), reverse=True)) ans = cur_t = 0 for t in cars: if t &gt; cur_t: cur_t = t ans += 1 return ans 1574. Shortest Subarray to be Removed to Make Array Sorted删除一个最短的子数组使整个数组有序。问最短数组长度为多少。原题1234Input: arr = [1,2,3,10,4,2,3,5]Output: 3Explanation: The shortest subarray we can remove is [10,4,2] of length 3. The remaining elements after that will be [1,2,3,3,5] which are sorted.Another correct solution is to remove the subarray [3,10,4]. 方法一：这个题竞赛时没做出来，只想到从左到右找坏的点，没想到从右到左也需要找一次。而且找完之后，要控制两个指针，从0和j出发遍历，自己想的是从中间往两边遍历。边界条件非常多。 1234567891011121314151617181920def findLengthOfShortestSubarray(self, arr: List[int]) -&gt; int: n = len(arr) i = 0 while i+1&lt;n and arr[i]&lt;=arr[i+1]: i += 1 if i == n-1: return 0 j = n-1 while j &gt; i and arr[j-1] &lt;= arr[j]: j -= 1 if j == 0: return n-1 ans = min(n-i-1, j) left = 0 right = j while left &lt;= i and right &lt; n: if arr[right] &gt;= arr[left]: ans = min(ans, right-left-1) left += 1 else: right += 1 return ans 835. Image Overlap图片覆盖。两个二维矩阵，A可以向一个方向滑动N个单位，然后放到B上，如果都为1，则表示某个像素是覆盖的。求最多有多少个像素覆盖。原题12345678Input: A = [[1,1,0], [0,1,0], [0,1,0]] B = [[0,0,0], [0,1,1], [0,0,1]]Output: 3Explanation: We slide A to right by 1 unit and down by 1 unit. 方法一：逆向思维，将1的点都求出来，然后每两个做比较。相同偏移量的算到一起。 def largestOverlap(self, A: List[List[int]], B: List[List[int]]) -&gt; int: A = [(x, y) for x, row in enumerate(A) for y, d in enumerate(row) if d] B = [(x, y) for x, row in enumerate(B) for y, d in enumerate(row) if d] c = Counter((xa-xb, ya-yb) for xa, ya in A for xb, yb in B) return max(c.values() or [0]) 方法二：数学的降维打击。卷积。其中涉及到了一些数学知识还没有完全参透。 123456import numpy as npfrom scipy.signal import convolve2dclass Solution: def largestOverlap(self, A: List[List[int]], B: List[List[int]]) -&gt; int: return np.max(convolve2d(A, np.rot90(B, 2))) 12345from scipy.signal import correlate2dclass Solution: def largestOverlap(self, A: List[List[int]], B: List[List[int]]) -&gt; int: return correlate2d(A, B).max() 42. Trapping Rain Water接雨水。给定一些柱状图的高度，问能接多少雨水。原题 方法一：用了逆向思维，通过总面积-损失的水-柱体面积求的。 123456789101112131415def trap(self, height: List[int]) -&gt; int: if not height: return 0 h_max, n = max(height), len(height) def get_lost(heights, target): cur_h = lost = 0 for i, h in enumerate(heights): lost += max(h-cur_h, 0) * i cur_h = max(cur_h, h) if h == target: break return lost lost = get_lost(height, h_max) + get_lost(height[::-1], h_max) return n*h_max - lost - sum(height) 方法二：遍历一次，其实思路是一样的，从两边到中间，当遇见一次下降时，计算差值面积，就是蓄水面积。left_max, right_max可以看做是两面墙。 12345678910111213def trap(self, height: List[int]) -&gt; int: left, right = 0, len(height)-1 ans = left_max = right_max = 0 while left &lt; right: left_max = max(left_max, height[left]) right_max = max(right_max, height[right]) if left_max &lt; right_max: ans += left_max - height[left] left += 1 else: ans += right_max - height[right] right -= 1 return ans 36. Valid Sudoku验证一个数独的正确性，只需要考虑填入数字的格子。原题方法一：比较直观的写法。 123456789101112def isValidSudoku(self, board: List[List[str]]) -&gt; bool: row = [[True]*9 for i in range(9)] col = [[True]*9 for i in range(9)] sub = [[True]*9 for i in range(9)] for i in range(9): for j in range(9): if board[i][j] != '.': d = int(board[i][j]) - 1 if not (row[i][d] and col[j][d] and sub[i//3*3+j//3][d]): return False row[i][d] = col[j][d] = sub[i//3*3+j//3][d] = False return True 方法二：Counter, by Stefan. 记录3种元素，如果有重复的 就说明不行。这里和python2有个区别，原来是用的+，python3中字典的values()方法返回的是一个dict_values的对象。 1234567def isValidSudoku(self, board: List[List[str]]) -&gt; bool: return 1 == max(collections.Counter( x for i, row in enumerate(board) for j, c in enumerate(row) if c != '.' for x in ((c, i), (j, c), (i//3, j//3, c)) ).values() or [1]) 方法三：同样来自Stefan，这个方法很有趣，将判断放到了生成器中。 1234567def isValidSudoku(self, board: List[List[str]]) -&gt; bool: seen = set() return not any(x in seen or seen.add(x) for i, row in enumerate(board) for j, c in enumerate(row) if c != '.' for x in ((c, i), (j, c), (i//3, j//3, c))) 1054. Distant Barcodes分散的条形码，就是将一个数组中的元素重新排序，让其没有两个一样的相邻。原题方法一：我首次AC的方法就是用堆，取出一个或者2个数。 12345678910111213141516171819def rearrangeBarcodes(self, barcodes: List[int]) -&gt; List[int]: c = Counter(barcodes) heap = [] ans = [] for k, v in c.items(): heapq.heappush(heap, (-v, k)) while heap: most, d1 = heapq.heappop(heap) if ans and ans[-1]==d1: more, d2 = heapq.heappop(heap) ans.append(d2) if more &lt; -1: heapq.heappush(heap, (more+1, d2)) heapq.heappush(heap, (most, d1)) continue ans.append(d1) if most &lt; -1: heapq.heappush(heap, (most+1, d1)) return ans 方法二：by Lee, 将最多的数字，按索引分割依次插入。 123456789def rearrangeBarcodes(self, barcodes: List[int]) -&gt; List[int]: i, n = 0, len(barcodes) ans = [0] * n for k, v in collections.Counter(barcodes).most_common(): for _ in range(v): ans[i] = k i += 2 if i &gt;= n: i = 1 return ans 方法三：by Lee，看到方法二时就想到了，这里需要注意一下，排序时要用一个元组，将一样的元素放到一起。 12345def rearrangeBarcodes(self, a: List[int]) -&gt; List[int]: count = collections.Counter(a) a.sort(key=lambda x: (count[x], x)) a[1::2], a[::2] = a[:len(a)//2], a[len(a)//2:] return a 1588. Sum of All Odd Length Subarrays求所有奇数长度的子数组的和。方法一：这题给的范围比较小，竞赛时用O(n^2)暴力就解了，不过实际有O(n)的方法。通过前缀和的方式，累加，再通过减法算和。比如[1,4,2,5,3]。j-i表示的是子数组的长度。 12345678def sumOddLengthSubarrays(self, arr: List[int]) -&gt; int: n, sum_odd = len(arr), 0 p_sum = [0] + list(itertools.accumulate(arr)) for i, p in enumerate(p_sum): for j in range(i + 1, n + 1, 2): # print(i, j, p_sum[j], p_sum[i]) sum_odd += p_sum[j] - p_sum[i] return sum_odd 1234567890 1 1 00 3 7 00 5 15 01 2 5 11 4 12 12 3 7 52 5 15 53 4 12 74 5 15 12 方法二：通过观察可以找到规律，每个数字出现的个数是有规律的。 1234567891011121314151 2 3 4 5 subarray length 11 2 X X X subarray length 2X 2 3 X X subarray length 2X X 3 4 X subarray length 2X X X 4 5 subarray length 21 2 3 X X subarray length 3X 2 3 4 X subarray length 3X X 3 4 5 subarray length 31 2 3 4 X subarray length 4X 2 3 4 5 subarray length 41 2 3 4 5 subarray length 55 8 9 8 5 total times each index was added.3 4 5 4 3 total times in odd length array with (x + 1) / 22 4 4 4 2 total times in even length array with x / 2 方法二：在所有子数组中，不管奇偶总共有多少，比如包含2的子数组，左边有2个子数组，右边4个子数组，一共有24，也就是说对于第i个元素，包含第i个元素的子数组=`(i+1) (n-i)奇数数组(x+1)//2`, x表示总数。 12345def sumOddLengthSubarrays(self, arr: List[int]) -&gt; int: ans, n = 0, len(arr) for i, a in enumerate(arr): ans += (((i+1)*(n-i) + 1) // 2) * a return ans]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（链表篇）LinkedList]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E9%93%BE%E8%A1%A8%E7%AF%87%EF%BC%89LinkedList%2F</url>
    <content type="text"><![CDATA[链表的定义1234class ListNode: def __init__(self, x): self.val = x self.next = None 2. Add Two Numbers两个链表相加123Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 123456789101112131415def addTwoNumbers(l1, l2): l = head = ListNode(0) carry = 0 while l1 or l2 or carry: v1 = v2 = 0 if l1: v1 = l1.val l1 = l1.next if l2: v2 = l2.val l2 = l2.next carry, val = divmod(v1+v2+carry, 10) l.next = ListNode(val) l = l.next return head.next 445. Add Two Numbers II跟上题类似，只不过是进位方式不同。原题12Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 8 -&gt; 0 -&gt; 7 方法一：先reverse再相加，最后再reverse。 1234567891011121314151617181920212223def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: def reverse(head): prev = None while head: head.next, prev, head = prev, head, head.next return prev ans = head = ListNode(0) l1, l2 = reverse(l1), reverse(l2) carry = 0 while l1 or l2 or carry: v1 = v2 = 0 if l1: v1 = l1.val l1 = l1.next if l2: v2 = l2.val l2 = l2.next carry, val = divmod(v1+v2+carry, 10) head.next = ListNode(val) head = head.next return reverse(ans.next) 方法二：由于Python int没有限制，所以可以遍历相加，再从尾到头还原节点。 12345678910111213141516def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: v1 = v2 = 0 while l1: v1 = v1*10 + l1.val l1 = l1.next while l2: v2 = v2*10 + l2.val l2 = l2.next val = v1 + v2 tail, head = None, None while val &gt; 0: head = ListNode(val % 10) head.next = tail tail = head val //= 10 return head if head else ListNode(0) 21. Merge Two Sorted Lists合并两个有序链表。原题12Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 方法1：iteratively 迭代 12345678910def mergeTwoLists(l1, l2): l = head = ListNode(0) while l1 and l2: if l1.val &lt;= l2.val: l.next, l1 = l1, l1.next else: l.next, l2 = l2, l2.next l = l.next l.next = l1 or l2 return head.next 方法2：recursively 递归 12345678910def mergeTwoLists(l1, l2): # 判断是否存在None if not l1 or not l2: return l1 or l2 if l1.val &lt; l2.val: l1.next = mergeTwoLists(l1.next, l2) return l1 else: l2.next = mergeTwoLists(l1, l2.next) return l2 23. Merge k Sorted Lists合并k个有序列表。原题1234567Input:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 方法一：Brute Force. time: O(NlogN) 1234567891011def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode: ans = [] for l in lists: while l: ans.append(l.val) l = l.next h = head = ListNode(0) for v in sorted(ans): h.next = ListNode(v) h = h.next return head.next 方法二：优先级队列。本来优先级就没有方法一快，再加上Python3中的比较符机制不同，导致要实现__lt__方法，就更慢了。不过理论时间复杂度是比方法一小的。Time: O(Nlogk) 123456789101112131415161718192021222324class CmpNode: def __init__(self, node): self.node = node def __lt__(self, other): return self.node.val &lt; other.node.val class Solution: def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode: from queue import PriorityQueue head = h = ListNode(0) q = PriorityQueue() for l in lists: if l: q.put(CmpNode(l)) while not q.empty(): to_add = q.get().node h.next = to_add h = h.next if to_add.next: q.put(CmpNode(to_add.next)) return head.next 方法三：规避ListNode的比较，以解决上述问题。只要加上该链表在原数组中的索引位置，就一定不会重复，从而忽略对ListNode的比较。 1234567891011121314def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode: from queue import PriorityQueue q = PriorityQueue() for idx, l in enumerate(lists): if l: q.put((l.val, idx, l)) h = head = ListNode(0) while not q.empty(): val, idx, node = q.get() h.next = node h, node = h.next, node.next if node: q.put((node.val, idx, node)) return head.next 方法四：俩俩合并。Time: O(Nlogk) 1234567891011121314151617181920def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode: def merge_both(l1, l2): if not l1 or not l2: return l1 or l2 if l1.val &lt;= l2.val: l1.next = merge_both(l1.next, l2) return l1 else: l2.next = merge_both(l1, l2.next) return l2 pairs = list(lists) while len(pairs) &gt; 1: n = len(pairs) if n &amp; 1 == 1: pairs.append(None) pairs = [merge_both(pairs[i*2], pairs[i*2+1]) for i in range(((n+1)//2))] return pairs[0] if pairs else None 141. Linked List Cycle判断一个链表是否有环。原题经典的一道题，看成两个人在赛跑，如果有环，快的人会和慢的人相遇 1234567def hasCycle(self, head): slow = fast = head: while fast and fast.next: slow, fast = slow.next, fast.next.next if fast is slow: return True return False 142. Linked List Cycle II求链表中环的入口节点。原题 首先判断此链表是否有环。 然后在相交点和头结点一起走，一定会在入口相遇。 Consider the following linked list, where E is the cylce entry and X, the crossing point of fast and slow. H: distance from head to cycle entry E D: distance from E to X L: cycle length ​ _____ ​ / \ head_____H______E \ ​ \ / ​ X_____/ If fast and slow both start at head, when fast catches slow, slow has traveled H+D and fast 2(H+D). Assume fast has traveled n loops in the cycle, we have: 2H + 2D = H + D + L --&gt; H + D = nL --&gt; H = nL - D Thus if two pointers start from head and X, respectively, one first reaches E, the other also reaches E. In my solution, since fast starts at head.next, we need to move slow one step forward in the beginning of part 2 12345678910111213def detectCycle(self, head): fast = slow = head # 检测是否有环 while fast and fast.next: slow, fast = slow.next, fast.next.next if slow is fast: break else: return None # 找出入口节点 while head is not slow: head, slow = head.next, slow.next return head 206. Reverse Linked List倒置一个链表。原题12Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 方法一： iteratively 12345678def reverseList(head): prev = None while head: cur = head head = head.next cur.next = prev prev = cur return prev 方法二：使用一行赋值 12345def reverseList(self, head): prev = None while head: head.next, prev, head = prev, head, head.next return prev Python同时给多个变量赋值。 方法三：递归 123456def reverseList(self, head, prev=None): if not head: return prev cur, head.next = head.next, prev return self.reverseList(cur, head) 92. Reverse Linked List II跟上题不同的是，只倒置指定区间的部分。原题12Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL 123456789101112131415161718def reverseBetween(self, head: ListNode, m: int, n: int) -&gt; ListNode: root = h = ListNode(0) h.next = head for _ in range(m-1): h = h.next cur_head = h p1 = p2 = cur_head.next for _ in range(n-m): p2 = p2.next prev = p2.next if p2 else None if p2: p2.next = None while p1: p1.next, prev, p1 = prev, p1, p1.next cur_head.next = prev return root.next 160. Intersection of Two Linked Lists两个链表求相交。原题123456def getIntersectionNode(self, headA, headB): p1, p2 = headA, headB while p1 is not p2: p1 = p1.next if p1 else headB p2 = p2.next if p2 else headA return p1 138. Copy List with Random Pointer深拷贝一个复杂链表，链表多包含了一个随机指针。原题 Time-O(2n), Memory-O(n). 12345678910111213def copyRandomList(self, head): cp_map = &#123;&#125; m = n = head while m: cp_map[m] = RandomListNode(m.label) m = m.next while n: cp_map[n].next = cp_map.get(n.next) cp_map[n].random = cp_map.get(n.random) n = n.next return cp_map.get(head) Time-O(n), Memory-O(n). 这种方式是相当于把第一次迭代的过程委托给了defaultdict，通过创建一个默认的对象，再去修改它的label值。 1234567891011def copyRandomList(self, head): from collections import defaultdict cp = defaultdict(lambda: RandomListNode(0)) cp[None] = None n = head while n: cp[n].label = n.label cp[n].next = cp[n.next] cp[n].random = cp[n.random] n = n.next return cp[head] 237. Delete Node in a Linked List在链表中删除节点。给定的节点不是尾节点。原题12Input: head = [4,5,1,9], node = 5Output: [4,1,9] 开始看到这题的思路是，要是能拿到父节点就好了，然后这道题需要别的思路，其关键在于复制 123def deleteNode(self, node): node.val = node.next.val # 4-&gt;1-&gt;1-&gt;9 node.next = node.next.next # 4-&gt;1-&gt;9 203. Remove Linked List Elements删除链表中值为val的元素。原题方法一：遍历head并构建新的ListNode。 12345678def removeElements(self, head, val): l = res = ListNode(0) while head: if head.val != val: l.next = ListNode(head.val) l = l.next head = head.next return res.next 方法二：更喜欢这个方法。 123456789def removeElements(self, head: 'ListNode', val: 'int') -&gt; 'ListNode': l = ListNode(0) l.next, ans = head, l while l and l.next: if l.next.val == val: l.next = l.next.next else: l = l.next return ans.next 83. Remove Duplicates from Sorted List删除有序链表中重复的节点。原题12345678def delete_duplicates(head): root = head while head and head.next: if head.val == head.next.val: head.next = head.next.next else: head = head.next return root 82. Remove Duplicates from Sorted List II和上题不同的是，重复的节点要全部删除。原题12Input: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5Output: 1-&gt;2-&gt;5 方法一：首次AC的方法。 123456789101112131415def deleteDuplicates(self, head: ListNode) -&gt; ListNode: prev = ans = ListNode(0) prev.next = h = head while h and h.next: remove = False while h.next and h.val == h.next.val: h.next = h.next.next remove = True if remove: prev.next = h.next else: prev = prev.next h = h.next return ans.next 876. Middle of the Linked List链表中点，如果偶数个，则返回第二个节点。原题12345678Input: [1,2,3,4,5]Output: Node 3 from this list (Serialization: [3,4,5])The returned node has value 3. (The judge&apos;s serialization of this node is [3,4,5]).Note that we returned a ListNode object ans, such that:ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL.Output: Node 4 from this list (Serialization: [4,5,6])Since the list has two middle nodes with values 3 and 4, we return the second one. 12345def middleNode(self, head: 'ListNode') -&gt; 'ListNode': fast = slow = head while fast and fast.next: slow, fast = slow.next, fast.next.next return slow 234. Palindrome Linked List判断一个链表是否是回文链表。原题12Input: 1-&gt;2-&gt;2-&gt;1Output: true 方法一：此题为倒置链表和快慢指针的总和应用。 1234567891011def isPalindrome(self, head: 'ListNode') -&gt; 'bool': rev = None slow = fast = head while fast and fast.next: fast = fast.next.next slow.next, rev, slow = rev, slow, slow.next if fast: slow = slow.next while rev and rev.val == slow.val: rev, slow = rev.next, slow.next return rev is None 方法二：上述方法有一个缺点就是改变了原始的head，这里进行一些改进。 12345678910111213def isPalindrome(self, head): rev = None fast = head while fast and fast.next: fast = fast.next.next rev, rev.next, head = head, rev, head.next tail = head.next if fast else head isPali = True while rev: isPali = isPali and rev.val == tail.val head, head.next, rev = rev, head, rev.next tail = tail.next return isPali 24. Swap Nodes in Pairs成对转换链表。原题1Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. 12345678def swapPairs(self, head: ListNode) -&gt; ListNode: prev, prev.next = self, head while prev.next and prev.next.next: a = prev.next # current b = a.next prev.next, b.next, a.next = b, a, b.next prev = a return self.next 19. Remove Nth Node From End of List删除倒数第N个节点。原题123Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. 12345678910def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode: root = slow = fast = ListNode(0) slow.next = head while n &gt;= 0 and fast: fast = fast.next n -= 1 while fast: slow, fast = slow.next, fast.next slow.next = slow.next.next if slow.next else None return root.next 328. Odd Even Linked List重排链表，使奇数位节点在前，偶数位节点在后，就地排序。原题12Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL 123456789101112def oddEvenList(self, head: ListNode) -&gt; ListNode: if not head: return None odd = head even_h = even = head.next while even and even.next: odd.next = odd.next.next odd = odd.next even.next = even.next.next even = even.next odd.next = even_h return head ***. Sort a linked list that is sorted alternating asc and desc这题不是LC上的，是面经里的，要求将一个奇数位升序，偶数位降序的链表转成一个升序的链表。12Input List: 10-&gt;40-&gt;53-&gt;30-&gt;67-&gt;12-&gt;89-&gt;NULLOutput List: 10-&gt;12-&gt;30-&gt;40-&gt;53-&gt;67-&gt;89-&gt;NULL 方法一：分别参考了328，206，21三题，但是有一个副作用，就是将输入的链表改变了，一开始我是想针对链表就地修改，但是发现最后合并的时候又不太好实现。 12345678910111213141516171819202122232425262728def sort_alternating(head: ListNode) -&gt; ListNode: if not head: return None # separate two lists odd = head even_h = even = head.next while even and even.next: odd.next = odd.next.next odd = odd.next even.next = even.next.next even = even.next odd.next = None # for last even tail ！！ # reverse the one with descending order prev = None while even_h: even_h.next, prev, even_h = prev, even_h, even_h.next # merge both lists ans = h = ListNode(0) while head and prev: if head.val &lt;= prev.val: h.next, head = head, head.next else: h.next, prev = prev, prev.next h = h.next h.next = head or prev # head is not head original return ans.next 方法二：修改了方法一中的不足，在一开始就建立两个链表。两个链表要分开迭代才不会遗漏元素。 12345678910111213141516171819202122232425262728293031def sort_alternating(head: ListNode) -&gt; ListNode: if not head: return None # separate two lists odd_head = odd_h = ListNode(0) even_head = even_h = ListNode(0) odd = head even = head.next while odd: odd_h.next = ListNode(odd.val) odd, odd_h = odd.next.next if odd.next else None, odd_h.next while even: even_h.next = ListNode(even.val) even, even_h = even.next.next if even.next else None, even_h.next # reverse the one with descending order prev = None odd_head, even_head = odd_head.next, even_head.next while even_head: even_head.next, prev, even_head = prev, even_head, even_head.next # merge both lists ans = h = ListNode(0) while odd_head and prev: if odd_head.val &lt;= prev.val: h.next, odd_head = odd_head, odd_head.next else: h.next, prev = prev, prev.next h = h.next h.next = odd_head or prev return ans.next 148. Sort List给链表排序。原题12Input: 4-&gt;2-&gt;1-&gt;3Output: 1-&gt;2-&gt;3-&gt;4 方法一： 1234567891011121314151617181920212223242526def sortList(self, head: ListNode) -&gt; ListNode: def merge_both(l1, l2): l = h = ListNode(0) while l1 and l2: if l1.val &lt;= l2.val: l.next, l1 = l1, l1.next else: l.next, l2 = l2, l2.next l = l.next l.next = l1 or l2 return h.next def merge_sort(h): if not h or not h.next: return h slow = fast = h prev = None while fast and fast.next: prev, slow, fast = slow, slow.next, fast.next.next prev.next = None left = merge_sort(h) right = merge_sort(slow) return merge_both(left, right) return merge_sort(head) 817. Linked List Components链表的组件。给定一个集合G，然后根据是否在G中分成若干部分，求连起来在G中的部分的个数。原题123456Input: head: 0-&gt;1-&gt;2-&gt;3-&gt;4G = [0, 3, 1, 4]Output: 2Explanation: 0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components. 1234567891011def numComponents(self, head: ListNode, G: List[int]) -&gt; int: SET_G = set(G) h = head count = 0 while h: if h.val in SET_G: if (h.next and h.next.val not in SET_G or not h.next): count += 1 h = h.next return count 86. Partition List链表分区，将比x小的节点放到前面，其余节点放到后面，并保持原有顺序。原题12Input: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5 方法一：首次AC的方法。注意最后gt后面可能有残留的节点比如最后一个2. 123456789101112131415def partition(self, head: ListNode, x: int) -&gt; ListNode: lt = letter = ListNode(0) gt = greater = ListNode(0) h = head while h: if h.val &lt; x: lt.next = h lt = h else: gt.next = h gt = h h = h.next gt.next = None # important !! lt.next = greater.next return letter.next 61. Rotate List向右旋转链表k次。原题1234567Input: 0-&gt;1-&gt;2-&gt;NULL, k = 4Output: 2-&gt;0-&gt;1-&gt;NULLExplanation:rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULLrotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULLrotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULLrotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL 1234567891011121314def rotateRight(self, head: ListNode, k: int) -&gt; ListNode: n, cur, prev = 0, head, None while cur: n += 1 prev, cur = cur, cur.next if n==0 or k%n==0: return head k = k % n tail = head for _ in range(n-k-1): tail = tail.next ans, tail.next, prev.next = tail.next, None, head return ans 725. Split Linked List in Parts按部分拆分链表。如果不能整除，要保证前面部分的大。原题123456Input: root = [1, 2, 3], k = 5Output: [[1],[2],[3],[],[]]Input: root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3Output: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]] 12345678910111213141516def splitListToParts(self, root: ListNode, k: int) -&gt; List[ListNode]: n, cur = 0, root ans = [] while cur: n += 1 cur = cur.next parts, remain = divmod(n, k) h = root for i in range(k): head = h for i in range(parts-1+(i&lt;remain)): h = h.next if h: h.next, h = None, h.next ans.append(head) return ans 143. Reorder List1Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3. 1234567891011121314151617def reorderList(self, head: ListNode) -&gt; None: if not head: return slow = fast = head while fast and fast.next: slow, fast = slow.next, fast.next.next tail, slow.next = slow.next, None def reverse(node): prev = None while node: node.next, prev, node = prev, node, node.next return prev tail = reverse(tail) h = head while h and tail: h.next, tail.next, tail, h = tail, h.next, tail.next, h.next 1030. Next Greater Node In Linked List链表中下一个比当前节点大的值。和503题类似。原题12Input: [2,7,4,3,5]Output: [7,0,5,5,0] 方法一：竞赛时没有做出来，虽然是一个链表题，但是跟链表没啥关系。思路vals保存了之前所有节点的值，stack按序存的索引，当遍历一个新的节点时，不断地去和之前的节点比较，如果大于，那么久更新ans中的值，之前设为了0。 12345678910111213def nextLargerNodes(self, head: ListNode) -&gt; List[int]: stack, vals = [], [] i, ans = 0, [] while head: num = head.val vals.append(num) while stack and num &gt; vals[stack[-1]]: ans[stack.pop()] = num stack.append(i) ans.append(0) i += 1 head = head.next return ans 方法二：去除方法一中无用的变量。 123456789def nextLargerNodes(self, head: ListNode) -&gt; List[int]: ans, stack = [], [] while head: while stack and stack[-1][1] &lt; head.val: ans[stack.pop()[0]] = head.val stack.append((len(ans), head.val)) ans.append(0) head = head.next return ans 1171. Remove Zero Sum Consecutive Nodes from Linked List移除相连和为0的节点。像祖玛一样，连续地删除。答案不唯一。原题123Input: head = [1,2,-3,3,1]Output: [3,1]Note: The answer [1,2,1] would also be accepted. 方法一：使用字典记录和，当和出现重复的时候，说明其中的一段和为0。看了评论发现此题OJ有错误，[1,3,2,-3,-2,5,5,-5,1]结果为[1,5,5,-5,1]居然对了。 12345678910111213def removeZeroSumSublists(self, head: ListNode) -&gt; ListNode: p = dummy = ListNode(0) dummy.next = head s = 0 vals = &#123;&#125; while p: s += p.val if s not in vals: vals[s] = p else: vals[s].next = p.next p = p.next return dummy.next 仔细分析一下上述代码，再结果变成[1,5,5,-5,1]时，没有将vals中删除的节点清空。 123456789101112131415161718def removeZeroSumSublists(self, head: ListNode) -&gt; ListNode: p = dummy = ListNode(0) dummy.next = head s = 0 s_sum = [s] vals = &#123;&#125; while p: s += p.val s_sum.append(s) if s not in vals: vals[s] = p else: vals[s].next = p.next s_sum.pop() # remove cur, keep the last while s_sum[-1] != s: vals.pop(s_sum.pop()) p = p.next return dummy.next]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建遇到的问题及优化]]></title>
    <url>%2Fhexo%E6%90%AD%E5%BB%BA%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前言终于有了一个整理自己学习笔记的地方了，之前用过印象笔记，觉得它的markdown格式处理得不是很完美，复制粘贴出来总是格式不对。后来又用过jupyter_nootboke，但是不方便在其它客户端查看。折腾了半天终于弄好了期间遇到过不少坑，发现hexo有时候同一样的问题总是对应着几种不同的解决方法，在此整理一下以便之后遇到问题。 关于问题NexT这里使用了next主题，这个主题特别简洁，还有很多易用性的扩展，尤其侧边栏的快速定位，让我爱不释手。 头像不显示开始按照_config.yml中所说把avatar.gif放到blog-site/source/下，没有任何的作用。后来发现是主题的原因，放到themes/next/source/images/下就好了，默认的头像是正方形的，这里修改了一下代码把它改成圆形，文件位置在themes/next/source/css_common_components/sidebar/sidebar-author.styl 1234567891011121314.site-author-image &#123; display: block; margin: 0 auto; max-width: 96px; height: auto; border: 2px solid #333; padding: 2px; /* start*/ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* end */&#125; 网页图标favicon.ico不显示这里也是因为Next的原因，把favicon.ico放到themes/next/source/images/下，然后修改_config.yml中favicon: /images/favicon.ico解决了问题。这里介绍一个很方便转换ico的网站favicon在线制作。 没有建立资源文件夹 设置post_asset_foler: true之后执行hexo new post_name后没有建立资源文件夹。搜索没有查到相关记录，后来想到之前next主题设置时，把配置文件拆分了出来，这样每次执行hexo clean/generate的时候在后面加了参数--config指定了配置文件。但是这样修改的文件对于hexo new post_name来说是没有修过的，所以要在source/_config.yml修改这项参数。 之后没有选择官方的标签插件是因为，在编辑markdown时无法看到预览效果所以安装npm install https://github.com/CodeFalling/hexo-asset-image --save，在文章中使用markdown语法引用![logo](&lt;title_name&gt;/a.png)使用。 选择官方的标签插件引用图片。 关于优化在右上角或者左上角实现fork me on github在这里选择喜欢的样式。这里选择的是 1&lt;a href="https://your-url" class="github-corner" aria-label="View source on Github"&gt;&lt;svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"&gt;&lt;path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"&gt;&lt;/path&gt;&lt;path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"&gt;&lt;/path&gt;&lt;path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;style&gt;.github-corner:hover .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;@keyframes octocat-wave&#123;0%,100%&#123;transform:rotate(0)&#125;20%,60%&#123;transform:rotate(-25deg)&#125;40%,80%&#123;transform:rotate(10deg)&#125;&#125;@media (max-width:500px)&#123;.github-corner:hover .octo-arm&#123;animation:none&#125;.github-corner .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;&#125;&lt;/style&gt; 将其粘贴到themes/next/layout/_layout.swig中，放在div class=&quot;headhand&quot;&gt;&lt;/div&gt;下面。 修改文章底部的那个带#号的标签修改模板/themes/next/layout/_macro/post.swig，搜索rel=&quot;tag&quot;&gt;#，将#换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 侧边栏社交小图标设置在配置文件搜索social_icons，把值换成喜欢的图标名字，这里列出了图标库 在网站底部加上访问量打开/themes/next/layout/_partials/footer.swig文件添加红框内的代码 1&lt;script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt; 添加统计代码如下位置 12345&lt;div class="powered-by"&gt;&lt;i class="fa fa-user-md"&gt;&lt;/i&gt;&lt;span id="busuanzi_container_site_uv"&gt; 本站访客数:&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt; 网站底部字数统计根目录安装npm install hexo-wordcount --save然后再/themes/next/layout/_partials/footer.swig文件最后加上 1234&lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 添加顶部加载条_config.yml设置中pace:true 在文章底部增加版权信息在目录themes/next/layout/_macro/下添加my-copyright.swig: 123456789101112131415161718192021222324252627282930&#123;% if page.copyright %&#125;&lt;div class="my_post_copyright"&gt; &lt;script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"&gt;&lt;/script&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;"&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href="/" title="访问 &#123;&#123; theme.author &#125;&#125; 的个人博客"&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format("YYYY年MM月DD日 - HH:MM") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format("YYYY年MM月DD日 - HH:MM") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;" title="&#123;&#123; page.title &#125;&#125;"&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class="copy-path" title="点击复制文章链接"&gt;&lt;i class="fa fa-clipboard" data-clipboard-text="&#123;&#123; page.permalink &#125;&#125;" aria-label="复制成功！"&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class="fa fa-creative-commons"&gt;&lt;/i&gt; &lt;a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)"&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard('.fa-clipboard'); $(".fa-clipboard").click(function()&#123; clipboard.on('success', function()&#123; swal(&#123; title: "", text: '复制成功', icon: "success", showConfirmButton: true &#125;); &#125;); &#125;); &lt;/script&gt;&#123;% endif %&#125; 在目录themes/next/source/css/_common/components/post/下添加my-post-copyright.styl: 123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 修改/themes/next/layout/_macro/post.swig在如下位置 添加代码：(注意和之前的教程不一样，这里可能是next的更新了，所以要把代码放到外面，否则在wechat_subscriber未开启时会导致失效。) 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'my-copyright.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 修改themes/next/source/css/_common/components/post/post.styl末尾增加一行1@import &quot;my-post-copyright&quot; 博文置顶替换node_modules/hexo-generator-index/lib/generator.js所有的代码为： 12345678910111213141516171819202122232425262728'use strict';var pagination = require('hexo-pagination');module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 使用：在头部添加top 12345678---title: date: 2017-05-22 22:45:48tags: 技巧categories: 技巧copyright: truetop: 100--- 修改字体大小/themes/next/source/css/_variables/base.styl搜索font-size-base 设置阅读次数添加阅读量统计 添加搜索12local_search: enable: true SEO优化两个搜索引擎入口： 谷歌搜索引擎验证 百度搜索引擎验证 这里选择用下载文件的方式，将文件放到source/目录下，注意一点应该在文件前添加两行代码，防止hexo将其格式化 12layout: false--- 生成站点地图 sitemap 站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知Google和其他搜索引擎。Googlebot等搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站。 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 更改配置 12345# 自动生成sitemapsitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 使搜索引擎收录我们的博客 谷歌比较简单向谷歌站长工具提交sitemap 百度。参考Hexo插件之百度主动提交链接 网站自身优化给出站链接添加 “nofollow” 标签/themes/next/layout/_partials/footer.swig找到下面两行，分别在a标签中添加rel=&quot;texternal nofollow&quot;属性 同样在/themes/next/layout/_macor/sidebar.swig中添加这个属性 设置更改属性seo: true 缩短文章链接编辑配置文件permalink: :title.html 添加文章更新时间参考了hexo添加文章更新时间 首先找到/themes/next/layout/_macro/post.swig文件，在&lt;span class=&quot;post-time&quot;&gt;...&lt;/span&gt;后添加： 12345678&#123;%if post.updated and post.updated &gt; post.date%&#125; &lt;span class="post-updated"&gt; &amp;nbsp; | &amp;nbsp; &#123;&#123; __('Updated on') &#125;&#125; &lt;time itemprop="dateUpdated" datetime="&#123;&#123; moment(post.updated).format() &#125;&#125;" content="&#123;&#123; date(post.updated, config.date_format) &#125;&#125;"&gt; &#123;&#123; date(post.updated, config.date_format) &#125;&#125; &lt;/time&gt; &lt;/span&gt;&#123;% endif %&#125; 博主这里改了一下显式的文本，后面的语言配置没有配，如果想手动更改文章更新时间在文章前加上： 1updated: 2018-01-01 12:00:00 默认使用md的修改时间。 文章添加阴影效果找到文件themes/next/source/css/_custom/custom.styl，添加如下代码。 12345678// 主页文章添加阴影效果.post &#123; margin-top: 0px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
