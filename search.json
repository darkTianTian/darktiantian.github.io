[{"title":"371. Sum of Two Integers - Python","url":"/371-Sum-of-Two-Integers-Python/","content":"<h3 id=\"不用加减乘除做加法\"><a href=\"#不用加减乘除做加法\" class=\"headerlink\" title=\"不用加减乘除做加法\"></a>不用加减乘除做加法</h3><p>剑指Offer中也出现过此题，此篇文章着重分析一下为什么Python需要做一些多余的操作。<br><a id=\"more\"></a></p>\n<p>根据书中的分析，大致分为三步：</p>\n<ul>\n<li>相加但不进位，使用<code>^</code></li>\n<li>进位使用<code>&amp;</code>和<code>&lt;&lt;</code></li>\n<li>前两步结果相加</li>\n</ul>\n<p>这里不再赘述详细过程。那么我们不难写出代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_sum</span><span class=\"params\">(a, b)</span>:</span></span><br><span class=\"line\">    res, carry = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> b != <span class=\"number\">0</span>:</span><br><span class=\"line\">        res = a ^ b</span><br><span class=\"line\">        carry = (a &amp; b) &lt;&lt; <span class=\"number\">1</span></span><br><span class=\"line\">        a, b = res, carry</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<p>但是当输入<code>a=-1, b=1</code>时，会发现程序超时。<br>先来看看正常的32位int类型运算时发生了什么，因为进行位运算时要使用补码进行运算，而正数的反码和补码都是本身，负数的反码为除符号位，其它按位取反，负数的补码为反码+1。下面列出了32为整数传入<code>a=-1,b=1</code>时，每次循环中<code>a</code>和<code>b</code>的补码。</p>\n<table>\n<thead>\n<tr>\n<th>a的原码</th>\n<th>a的补码</th>\n<th>b的补码</th>\n<th>a ^ b</th>\n<th>a &amp; b </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>10…0001</td>\n<td>11…1111</td>\n<td>00…0001</td>\n<td>11…1110</td>\n<td>00…0001</td>\n</tr>\n<tr>\n<td>10…0010</td>\n<td>11…1110</td>\n<td>00…0010</td>\n<td>11…1100</td>\n<td>00…0010</td>\n</tr>\n<tr>\n<td>10…0100</td>\n<td>11…1100</td>\n<td>00…0100</td>\n<td>11…1000</td>\n<td>00…0100</td>\n</tr>\n<tr>\n<td>⋮</td>\n<td>⋮</td>\n<td>⋮</td>\n<td>⋮</td>\n<td>⋮</td>\n</tr>\n<tr>\n<td>110…000</td>\n<td>110…000</td>\n<td>010…000</td>\n<td>100…000</td>\n<td>010…000</td>\n</tr>\n<tr>\n<td>100…000</td>\n<td>100…000</td>\n<td>100…000</td>\n<td>000…000</td>\n<td>100…000</td>\n</tr>\n<tr>\n<td>000…000</td>\n<td>000…000</td>\n<td>000…000</td>\n<td>‘break’</td>\n<td>‘break’</td>\n</tr>\n</tbody>\n</table>\n<p>可以看出由于位数的限制，b和a最后都变成了0。因为Python中的int没有范围限制，所以这就是为什么会死循环的原因。</p>\n<p>如何解决这个问题呢？我们需要在b的补码变成<code>1000…000</code>(32个0)时终止循环，如何将一个一个无限位的整型转成32位呢，想到了<code>&amp;</code>，所以我们找到一个<code>mask=2**32-1</code>也就是32个1，用一个无限位的值和mask进行与运算，就变成了上述表格中的例子，于是我们将代码改为：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getSum</span><span class=\"params\">(self, a, b)</span>:</span></span><br><span class=\"line\">    res, carry = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    mask = <span class=\"number\">0xFFFFFFFF</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> b != <span class=\"number\">0</span>:</span><br><span class=\"line\">        res = (a ^ b) &amp; mask</span><br><span class=\"line\">        carry = ((a &amp; b) &lt;&lt; <span class=\"number\">1</span>) &amp; mask</span><br><span class=\"line\">        a, b = res, carry</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<p>提交之后还是不能通过测试用例，当<code>a=-12, b=-8</code>时输出了<code>4294967276</code>而不是<code>-20</code>。好，把mask先去掉，传入这两个值，发现可以正常输出<code>-20</code>，那么这里的mask是怎么造成了一些副作用的。<br>再来分析一下这两个参数下，具体的过程是怎样的。</p>\n<!--\na的原码|a的补码|b的原码|b的补码|a ^ b| a & b | (a & b) << 1\n--------|--------|--------|--------|--------|-------|---------\n100…1100|111…0100|100…1000|111…1000|000…1100|111…10000|1…100000\n000…1100|000…1100|100…100000|11…1100000|11…1101100|000…000|000…000\n100…10100|11…1101100|000…000|000…000|'break'|'break'\n\n最后a的原码为`-20`，再来看加上mask的情况。\n\na的原码|a的补码|b的原码|b的补码|(a^b) & mask| a & b | ((a&b)<<1) & mask\n--------|--------|--------|--------|--------|-------|-------\n100…1100|111…0100|100…1000|111…1000|000…1100|111…10000|\n000…1100|000…1100|100…100000|11…1100000|11…1101100|000…000\n100…10100|11…1101100|000…000|000…000|'break'|'break'\n-->\n<p>为了方便DEBUG，我们添加一些输出：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_sum</span><span class=\"params\">(self, a, b)</span>:</span></span><br><span class=\"line\">    mask = <span class=\"number\">0xFFFFFFFF</span></span><br><span class=\"line\">    res, carry = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> b != <span class=\"number\">0</span>:</span><br><span class=\"line\">        print(<span class=\"string\">'bin(&#123;&#125;) = &#123;&#125;, bin(&#123;&#125;) = &#123;&#125;'</span>.format(a, bin(a), b, bin(b)))</span><br><span class=\"line\">        res = (a ^ b) &amp; mask</span><br><span class=\"line\">        <span class=\"comment\"># res = (a ^ b) </span></span><br><span class=\"line\">        print(<span class=\"string\">'\\t res = &#123;&#125;, bin(res) = &#123;&#125;'</span>.format(res, bin(res)))</span><br><span class=\"line\">        carry = ((a &amp; b) &lt;&lt; <span class=\"number\">1</span>) &amp; mask</span><br><span class=\"line\">        <span class=\"comment\"># carry = ((a &amp; b) &lt;&lt; 1)</span></span><br><span class=\"line\">        print(<span class=\"string\">'\\t \\t a&amp;b = &#123;&#125;, (a&amp;b)&lt;&lt;1 = &#123;&#125;, carry = &#123;&#125;'</span>.format((a&amp;b), ((a&amp;b)+<span class=\"number\">1</span>), carry))</span><br><span class=\"line\">        a, b = res, carry</span><br><span class=\"line\">    <span class=\"comment\"># return res if res &lt;= MAX else ~(res ^ mask)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<p>输出如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">Finished <span class=\"keyword\">in</span> <span class=\"number\">20</span> ms</span><br><span class=\"line\">bin(<span class=\"number\">-12</span>) = <span class=\"number\">-0</span>b1100, bin(<span class=\"number\">-8</span>) = <span class=\"number\">-0</span>b1000</span><br><span class=\"line\">\t res = <span class=\"number\">12</span>, bin(res) = <span class=\"number\">0b1100</span></span><br><span class=\"line\">\t \t a&amp;b = <span class=\"number\">-16</span>, (a&amp;b)&lt;&lt;<span class=\"number\">1</span> = <span class=\"number\">-15</span>, carry = <span class=\"number\">-32</span></span><br><span class=\"line\">bin(<span class=\"number\">12</span>) = <span class=\"number\">0b1100</span>, bin(<span class=\"number\">-32</span>) = <span class=\"number\">-0</span>b100000</span><br><span class=\"line\">\t res = <span class=\"number\">-20</span>, bin(res) = <span class=\"number\">-0</span>b10100</span><br><span class=\"line\">\t \t a&amp;b = <span class=\"number\">0</span>, (a&amp;b)&lt;&lt;<span class=\"number\">1</span> = <span class=\"number\">1</span>, carry = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">-20</span></span><br><span class=\"line\">Finished <span class=\"keyword\">in</span> <span class=\"number\">24</span> ms</span><br><span class=\"line\">bin(<span class=\"number\">-12</span>) = <span class=\"number\">-0</span>b1100, bin(<span class=\"number\">-8</span>) = <span class=\"number\">-0</span>b1000</span><br><span class=\"line\">\t res = <span class=\"number\">12</span>, bin(res) = <span class=\"number\">0b1100</span></span><br><span class=\"line\">\t \t a&amp;b = <span class=\"number\">-16</span>, (a&amp;b)&lt;&lt;<span class=\"number\">1</span> = <span class=\"number\">-15</span>, carry = <span class=\"number\">4294967264</span></span><br><span class=\"line\">bin(<span class=\"number\">12</span>) = <span class=\"number\">0b1100</span>, bin(<span class=\"number\">4294967264</span>) = <span class=\"number\">0b11111111111111111111111111100000</span></span><br><span class=\"line\">\t res = <span class=\"number\">4294967276</span>, bin(res) = <span class=\"number\">0b11111111111111111111111111101100</span></span><br><span class=\"line\">\t \t a&amp;b = <span class=\"number\">0</span>, (a&amp;b)&lt;&lt;<span class=\"number\">1</span> = <span class=\"number\">1</span>, carry = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">4294967276</span></span><br></pre></td></tr></table></figure>\n<p>可以看到在进行<code>-15&amp;mask</code>时，carry变成了一个很大的正数，并丢失了符号。此处为个人猜想，当负数与<code>mask</code>进行与运算时，比如-2，此时-2的补码变为<code>11…10</code>，一个33-bit的数字，然后和32位的<code>mask</code>与操作后，变为了一个<code>33位</code>的正数。</p>\n<p>有一个公式可以帮我们还原<code>a</code>，如果一个负数<code>n</code>，它的无符号的32位补码是<code>m</code>，那么<code>m=~(n ^ mask)</code> 或者<code>n=~(m ^ mask)</code></p>\n<p>于是代码修改为：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getSum</span><span class=\"params\">(self, a, b)</span>:</span></span><br><span class=\"line\">    MASK = <span class=\"number\">0xffffffff</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># in Python, every integer is associated with its two's complement and its sign.</span></span><br><span class=\"line\">    <span class=\"comment\"># However, doing bit operation \"&amp; mask\" loses the track of sign. </span></span><br><span class=\"line\">    <span class=\"comment\"># Therefore, after the while loop, a is the two's complement of the final result as a 32-bit unsigned integer. </span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> b != <span class=\"number\">0</span>:</span><br><span class=\"line\">        a, b = (a ^ b) &amp; MASK, ((a &amp; b) &lt;&lt; <span class=\"number\">1</span>) &amp; MASK</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># a is negative if the first bit is 1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a &gt;&gt; <span class=\"number\">31</span>) &amp; <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ~(a ^ MASK)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a</span><br></pre></td></tr></table></figure>\n<p>虽然python进行大数字运算很方便，但是无限制位数往往会对位运算的操作中产生一些陷阱。如果可以直接转成Java中那种32的int，岂不是没有这么多麻烦了，好在<code>numpy</code>为我们提供了这样的方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getSum</span><span class=\"params\">(self, a, b)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> b != <span class=\"number\">0</span>:</span><br><span class=\"line\">            a, b = np.int32(a ^ b), np.int32((a &amp; b) &lt;&lt; <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> int(a)</span><br></pre></td></tr></table></figure>\n<p>最后要再转回<code>int</code>，否则是没法通过测试用例的。</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://leetcode.com/problems/sum-of-two-integers/discuss/140525/Python-3/173361\" target=\"_blank\" rel=\"noopener\">numpy实现方式</a></li>\n<li><a href=\"https://leetcode.com/problems/sum-of-two-integers/discuss/84350/Most-Straightforward-Python-Solution!/173184\" target=\"_blank\" rel=\"noopener\">mask实现方式</a></li>\n<li><a href=\"https://stackoverflow.com/questions/46573219/the-meaning-of-bit-wise-not-in-python\" target=\"_blank\" rel=\"noopener\">the-meaning-of-bit-wise-not-in-python stackoverflow</a></li>\n</ul>\n","categories":["算法"],"tags":["LeetCode","Python","Algorithm","Bit Manipulation"]},{"title":"Google kickstart Round G 2020","url":"/Google-kickstart-Round-G-2020/","content":"<h5 id=\"首次参加Google-kick-start的线上比赛，获得了1337-6700-提交了答案的选手-的成绩，提升空间还是比较大。第3题的Test3本应该过的。之前也是很久没有刷HackerRank了。这里的提交方式和HackerRank的很相似。好处是可以用自己的编辑器来做题，相比于LeetCode中的编辑器更好一点，之前用LeetCode的Vim编辑模式老是错误地显示光标模式。不过这次因为用例不知道怎么用Vim调，所以暂时用了CodeRunner来写的。\"><a href=\"#首次参加Google-kick-start的线上比赛，获得了1337-6700-提交了答案的选手-的成绩，提升空间还是比较大。第3题的Test3本应该过的。之前也是很久没有刷HackerRank了。这里的提交方式和HackerRank的很相似。好处是可以用自己的编辑器来做题，相比于LeetCode中的编辑器更好一点，之前用LeetCode的Vim编辑模式老是错误地显示光标模式。不过这次因为用例不知道怎么用Vim调，所以暂时用了CodeRunner来写的。\" class=\"headerlink\" title=\"首次参加Google kick start的线上比赛，获得了1337/6700(提交了答案的选手)的成绩，提升空间还是比较大。第3题的Test3本应该过的。之前也是很久没有刷HackerRank了。这里的提交方式和HackerRank的很相似。好处是可以用自己的编辑器来做题，相比于LeetCode中的编辑器更好一点，之前用LeetCode的Vim编辑模式老是错误地显示光标模式。不过这次因为用例不知道怎么用Vim调，所以暂时用了CodeRunner来写的。\"></a>首次参加Google kick start的线上比赛，获得了1337/6700(提交了答案的选手)的成绩，提升空间还是比较大。第3题的Test3本应该过的。之前也是很久没有刷HackerRank了。这里的提交方式和HackerRank的很相似。好处是可以用自己的编辑器来做题，相比于LeetCode中的编辑器更好一点，之前用LeetCode的Vim编辑模式老是错误地显示光标模式。不过这次因为用例不知道怎么用Vim调，所以暂时用了CodeRunner来写的。</h5><a id=\"more\"></a>\n<h3 id=\"Kick-Start\"><a href=\"#Kick-Start\" class=\"headerlink\" title=\"Kick_Start\"></a><a href=\"https://codingcompetitions.withgoogle.com/kickstart/round/00000000001a0069/0000000000414bfb\" target=\"_blank\" rel=\"noopener\">Kick_Start</a></h3><h4 id=\"给定字符串S，求有多少种字符串是以KICK开头，START结尾的。\"><a href=\"#给定字符串S，求有多少种字符串是以KICK开头，START结尾的。\" class=\"headerlink\" title=\"给定字符串S，求有多少种字符串是以KICK开头，START结尾的。\"></a>给定字符串S，求有多少种字符串是以<code>KICK</code>开头，<code>START</code>结尾的。</h4><p>方法一：比较简单，由于读题花的时间比较长，而且不确定用例是否严格，担心5长度的切片过不了大的测试用例。所以提交地比较慢。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">solve</span><span class=\"params\">(s)</span>:</span></span><br><span class=\"line\">    k = ans = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(s)):</span><br><span class=\"line\">        head = s[i:i+<span class=\"number\">5</span>]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> head.startswith(<span class=\"string\">'KICK'</span>):</span><br><span class=\"line\">            k += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> head.startswith(<span class=\"string\">'START'</span>):</span><br><span class=\"line\">            ans += k</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"Maximum-Coins\"><a href=\"#Maximum-Coins\" class=\"headerlink\" title=\"Maximum Coins\"></a><a href=\"https://codingcompetitions.withgoogle.com/kickstart/round/00000000001a0069/0000000000414a23\" target=\"_blank\" rel=\"noopener\">Maximum Coins</a></h3><h4 id=\"求二维矩阵中斜边（左到右）最大的路径和。\"><a href=\"#求二维矩阵中斜边（左到右）最大的路径和。\" class=\"headerlink\" title=\"求二维矩阵中斜边（左到右）最大的路径和。\"></a>求二维矩阵中斜边（左到右）最大的路径和。</h4><p>方法一：这题也比较简单，直接就过了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">solve</span><span class=\"params\">(g, n)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(sum(g[j][j+i] <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n) <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=i+j&lt;n)</span><br><span class=\"line\">               <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(-n+<span class=\"number\">1</span>, n))</span><br></pre></td></tr></table></figure>\n<h3 id=\"Combination-Lock\"><a href=\"#Combination-Lock\" class=\"headerlink\" title=\"Combination Lock\"></a><a href=\"https://codingcompetitions.withgoogle.com/kickstart/round/00000000001a0069/0000000000414a24#problem\" target=\"_blank\" rel=\"noopener\">Combination Lock</a></h3><h4 id=\"有这么W个密码锁，锁上数字是从1-N。给你一个锁的初始状态，问最小需要多少步能将这些锁上的数字调成一样。\"><a href=\"#有这么W个密码锁，锁上数字是从1-N。给你一个锁的初始状态，问最小需要多少步能将这些锁上的数字调成一样。\" class=\"headerlink\" title=\"有这么W个密码锁，锁上数字是从1~N。给你一个锁的初始状态，问最小需要多少步能将这些锁上的数字调成一样。\"></a>有这么W个密码锁，锁上数字是从1~N。给你一个锁的初始状态，问最小需要多少步能将这些锁上的数字调成一样。</h4><p>这题比赛的时候Case3没有跑过，TLE了。但是原理上基本都想对了。此题和LeetCode上462很像，但是那题比较简单，因为没有环。</p>\n<p>比赛时没有过的代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> deque</span><br><span class=\"line\">T = int(input())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">solve</span><span class=\"params\">(ary)</span>:</span></span><br><span class=\"line\">    i, n = <span class=\"number\">0</span>, len(ary)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(ary[~i]-ary[i] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n//<span class=\"number\">2</span>))</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"keyword\">for</span> case <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, T+<span class=\"number\">1</span>):</span><br><span class=\"line\">    W, N = map(int, input().split())</span><br><span class=\"line\">    wheels = sorted(map(int, input().split()))</span><br><span class=\"line\">    q = deque(wheels)</span><br><span class=\"line\">    ans = float(<span class=\"string\">'inf'</span>)</span><br><span class=\"line\">    cur = solve(q)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(W):</span><br><span class=\"line\">        l, r = (W<span class=\"number\">-1</span>)//<span class=\"number\">2</span>, (W)//<span class=\"number\">2</span></span><br><span class=\"line\">        a, b = q[<span class=\"number\">0</span>], q[r]</span><br><span class=\"line\">        left = q.popleft()</span><br><span class=\"line\">        q.append(left + N)</span><br><span class=\"line\">        c, d = q[l], q[<span class=\"number\">-1</span>]</span><br><span class=\"line\">        cur += (d-c) - (b-a)</span><br><span class=\"line\">        ans = min(ans, cur)</span><br><span class=\"line\">    print(<span class=\"string\">'Case #&#123;&#125;: &#123;&#125;'</span>.format(case, ans))</span><br></pre></td></tr></table></figure>\n<p>按照理论来说是件复杂度是一样的，不知道为什么就过不了。</p>\n<p>正确的写法，滑动窗口就能过，按理说，双端队列首位的原子操作应该和这个时间复杂度一样，不知道为什么一直超时。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> deque</span><br><span class=\"line\">T = int(input())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">solve</span><span class=\"params\">(ary)</span>:</span></span><br><span class=\"line\">    i, n = <span class=\"number\">0</span>, len(ary)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(ary[~i]-ary[i] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n//<span class=\"number\">2</span>))</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"keyword\">for</span> case <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, T+<span class=\"number\">1</span>):</span><br><span class=\"line\">    W, N = map(int, input().split())</span><br><span class=\"line\">    wheels = sorted(map(int, input().split()))</span><br><span class=\"line\">    wheels = wheels + [num+N <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> wheels]</span><br><span class=\"line\">    cur = ans = solve(wheels[:W])</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(W):</span><br><span class=\"line\">        l, r = W//<span class=\"number\">2</span>, (W+<span class=\"number\">1</span>)//<span class=\"number\">2</span></span><br><span class=\"line\">        cur += wheels[i] + wheels[i+W] - wheels[i+r] - wheels[i+l]</span><br><span class=\"line\">        ans = min(ans, cur)</span><br><span class=\"line\">    print(<span class=\"string\">'Case #&#123;&#125;: &#123;&#125;'</span>.format(case, ans))</span><br></pre></td></tr></table></figure>\n<p>双端队列中间取值的时间复杂度是O(n)，而不是O(1)。这是我一直忽略的一个问题。所以在W此循环中取了两个中间的值。还有使用solve求中位数时还用了双端队列。这个solve方法在最大数据集下执行时间就是1s！！这是我用Pycharm中profile run两个方法比较后找到的问题所在。终于将这个疑惑解决了，以后可以避免踩坑了。</p>\n","categories":["算法"],"tags":["kickstart"]},{"title":"LeetCode算法题整理（sql篇）sql","url":"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88sql%E7%AF%87%EF%BC%89sql/","content":"<h3 id=\"595-Big-Countries\"><a href=\"#595-Big-Countries\" class=\"headerlink\" title=\"595. Big Countries\"></a>595. Big Countries</h3><h4 id=\"查询’大城市’。原题\"><a href=\"#查询’大城市’。原题\" class=\"headerlink\" title=\"查询’大城市’。原题\"></a>查询’大城市’。<a href=\"https://leetcode.com/problems/big-countries/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><a id=\"more\"></a>\n<ul>\n<li><p>使用<code>where OR</code></p>\n  <figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">name</span>, population, area </span><br><span class=\"line\"><span class=\"keyword\">from</span> World </span><br><span class=\"line\"><span class=\"keyword\">where</span> area &gt; <span class=\"number\">3000000</span> <span class=\"keyword\">or</span> population &gt; <span class=\"number\">25000000</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用<code>UNION</code></p>\n  <figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">name</span>, population, area </span><br><span class=\"line\"><span class=\"keyword\">from</span> World </span><br><span class=\"line\"><span class=\"keyword\">where</span> area &gt; <span class=\"number\">3000000</span></span><br><span class=\"line\"><span class=\"keyword\">union</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">name</span>, population, area</span><br><span class=\"line\"><span class=\"keyword\">from</span> World</span><br><span class=\"line\"><span class=\"keyword\">where</span> population &gt; <span class=\"number\">25000000</span></span><br><span class=\"line\">;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>补充说明：Solution中解释道，使用<code>UNION</code>会比<code>OR</code>快上一丢丢。</p>\n<blockquote>\n<p>Suppose we are searching population and area, Given that MySQL usually uses one one index per table in a given query, so when it uses the 1st index rather than 2nd index, it would still have to do a table-scan to find rows that fit the 2nd index.</p>\n</blockquote>\n<p>因为前者查询的时候只用到第一个索引，对第二个条件查询时，也就是<code>population</code>，使用的是全表扫描，于是浪费了一些时间。但是想想背后的代价，想必是以空间来换时间。</p>\n<h3 id=\"627-Swap-Salary\"><a href=\"#627-Swap-Salary\" class=\"headerlink\" title=\"627. Swap Salary\"></a>627. Swap Salary</h3><h4 id=\"转换性别。原题\"><a href=\"#转换性别。原题\" class=\"headerlink\" title=\"转换性别。原题\"></a>转换性别。<a href=\"https://leetcode.com/problems/swap-salary/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><ul>\n<li><p>使用<code>if</code></p>\n  <figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">UPDATE</span> salary</span><br><span class=\"line\"><span class=\"keyword\">SET</span> sex=<span class=\"keyword\">IF</span>(sex=<span class=\"string\">'m'</span>, <span class=\"string\">'f'</span>, <span class=\"string\">'m'</span>)</span><br><span class=\"line\">;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用<code>CASE</code></p>\n  <figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">update</span> salary</span><br><span class=\"line\"><span class=\"keyword\">set</span> </span><br><span class=\"line\">    sex = <span class=\"keyword\">CASE</span> sex</span><br><span class=\"line\">    <span class=\"keyword\">when</span> <span class=\"string\">'m'</span> <span class=\"keyword\">Then</span> <span class=\"string\">'f'</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"string\">'m'</span></span><br><span class=\"line\">    <span class=\"keyword\">END</span></span><br><span class=\"line\">;</span><br></pre></td></tr></table></figure></li>\n<li><p>使用<code>XOR</code></p>\n  <figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">update</span> salary</span><br><span class=\"line\"><span class=\"keyword\">set</span> sex = <span class=\"built_in\">CHAR</span>(<span class=\"keyword\">ASCII</span>(<span class=\"string\">'f'</span>) ^ <span class=\"keyword\">ASCII</span>(<span class=\"string\">'m'</span>) ^ <span class=\"keyword\">ASCII</span>(sex))</span><br><span class=\"line\">;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"620-Not-Boring-Movies\"><a href=\"#620-Not-Boring-Movies\" class=\"headerlink\" title=\"620. Not Boring Movies\"></a>620. Not Boring Movies</h3><h4 id=\"使用MOD替代-。原题\"><a href=\"#使用MOD替代-。原题\" class=\"headerlink\" title=\"使用MOD替代%。原题\"></a>使用<code>MOD</code>替代<code>%</code>。<a href=\"https://leetcode.com/problems/not-boring-movies/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> cinema</span><br><span class=\"line\"><span class=\"keyword\">where</span> <span class=\"keyword\">mod</span>(<span class=\"keyword\">id</span>, <span class=\"number\">2</span>) = <span class=\"number\">1</span> <span class=\"keyword\">and</span> description != <span class=\"string\">'boring'</span></span><br><span class=\"line\"><span class=\"keyword\">order</span> <span class=\"keyword\">by</span> rating <span class=\"keyword\">DESC</span></span><br><span class=\"line\">;</span><br></pre></td></tr></table></figure>\n<h3 id=\"182-Duplicate-Emails\"><a href=\"#182-Duplicate-Emails\" class=\"headerlink\" title=\"182. Duplicate Emails\"></a>182. Duplicate Emails</h3><h4 id=\"查询多余的重复值。原题\"><a href=\"#查询多余的重复值。原题\" class=\"headerlink\" title=\"查询多余的重复值。原题\"></a>查询多余的重复值。<a href=\"https://leetcode.com/problems/duplicate-emails/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>思考：开始陷入了误区，以为要将重复的id也查出来。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> email</span><br><span class=\"line\"><span class=\"keyword\">FROM</span>   Person</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span>  <span class=\"keyword\">BY</span> email</span><br><span class=\"line\"><span class=\"keyword\">HAVING</span> <span class=\"keyword\">Count</span>(*) &gt; <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"175-Combine-Two-Tables\"><a href=\"#175-Combine-Two-Tables\" class=\"headerlink\" title=\"175. Combine Two Tables\"></a>175. Combine Two Tables</h3><h4 id=\"左链接。过于简单。原题\"><a href=\"#左链接。过于简单。原题\" class=\"headerlink\" title=\"左链接。过于简单。原题\"></a>左链接。过于简单。<a href=\"https://leetcode.com/problems/combine-two-tables/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> p.FirstName, p.LastName,</span><br><span class=\"line\">    ad.City, ad.State</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Person p</span><br><span class=\"line\">    <span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> Address ad</span><br><span class=\"line\">        <span class=\"keyword\">ON</span> p.PersonId = ad.PersonId</span><br><span class=\"line\">;</span><br></pre></td></tr></table></figure>\n<h3 id=\"181-Employees-Earning-More-Than-Their-Managers\"><a href=\"#181-Employees-Earning-More-Than-Their-Managers\" class=\"headerlink\" title=\"181. Employees Earning More Than Their Managers\"></a>181. Employees Earning More Than Their Managers</h3><h4 id=\"自链接。原题\"><a href=\"#自链接。原题\" class=\"headerlink\" title=\"自链接。原题\"></a>自链接。<a href=\"https://leetcode.com/problems/employees-earning-more-than-their-managers/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> e.name Employee</span><br><span class=\"line\"><span class=\"keyword\">from</span> Employee e</span><br><span class=\"line\">    <span class=\"keyword\">inner</span> <span class=\"keyword\">join</span> Employee m</span><br><span class=\"line\">        <span class=\"keyword\">on</span> e.ManagerId = m.Id</span><br><span class=\"line\"><span class=\"keyword\">where</span> e.Salary &gt; m.Salary</span><br><span class=\"line\">;</span><br></pre></td></tr></table></figure>\n<h3 id=\"183-Customers-Who-Never-Order\"><a href=\"#183-Customers-Who-Never-Order\" class=\"headerlink\" title=\"183. Customers Who Never Order\"></a>183. Customers Who Never Order</h3><h4 id=\"没有订单的顾客。原题\"><a href=\"#没有订单的顾客。原题\" class=\"headerlink\" title=\"没有订单的顾客。原题\"></a>没有订单的顾客。<a href=\"https://leetcode.com/problems/customers-who-never-order/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> c.name Customers</span><br><span class=\"line\"><span class=\"keyword\">from</span> Customers c</span><br><span class=\"line\">    <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> Orders o</span><br><span class=\"line\">        <span class=\"keyword\">on</span> c.id = o.CustomerId</span><br><span class=\"line\"><span class=\"keyword\">where</span> o.CustomerId <span class=\"keyword\">is</span> <span class=\"literal\">Null</span></span><br><span class=\"line\">;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> customers.name <span class=\"keyword\">as</span> <span class=\"string\">'Customers'</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> customers</span><br><span class=\"line\"><span class=\"keyword\">where</span> customers.id <span class=\"keyword\">not</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">(</span><br><span class=\"line\">    <span class=\"keyword\">select</span> customerid <span class=\"keyword\">from</span> orders</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h3 id=\"596-Classes-More-Than-5-Students\"><a href=\"#596-Classes-More-Than-5-Students\" class=\"headerlink\" title=\"596. Classes More Than 5 Students\"></a>596. Classes More Than 5 Students</h3><h4 id=\"超过5个学生的班级。原题\"><a href=\"#超过5个学生的班级。原题\" class=\"headerlink\" title=\"超过5个学生的班级。原题\"></a>超过5个学生的班级。<a href=\"https://leetcode.com/problems/classes-more-than-5-students/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">class</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> courses</span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> <span class=\"keyword\">class</span></span><br><span class=\"line\"><span class=\"keyword\">having</span> <span class=\"keyword\">count</span>(<span class=\"keyword\">distinct</span> student) &gt;= <span class=\"number\">5</span></span><br><span class=\"line\">;</span><br></pre></td></tr></table></figure>\n<h3 id=\"197-Rising-Temperature\"><a href=\"#197-Rising-Temperature\" class=\"headerlink\" title=\"197. Rising Temperature\"></a>197. Rising Temperature</h3><h4 id=\"这个挺有意思，开始天真地想用id作为条件，测试用例教做人。原题\"><a href=\"#这个挺有意思，开始天真地想用id作为条件，测试用例教做人。原题\" class=\"headerlink\" title=\"这个挺有意思，开始天真地想用id作为条件，测试用例教做人。原题\"></a>这个挺有意思，开始天真地想用id作为条件，测试用例教做人。<a href=\"https://leetcode.com/problems/rising-temperature/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><ul>\n<li><p>我的答案</p>\n  <figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> today.Id</span><br><span class=\"line\"><span class=\"keyword\">FROM</span>   Weather yest</span><br><span class=\"line\">       <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> Weather today</span><br><span class=\"line\">              <span class=\"keyword\">ON</span> today.RecordDate = <span class=\"keyword\">DATE_ADD</span>(yest.RecordDate, <span class=\"built_in\">INTERVAL</span> <span class=\"number\">1</span> <span class=\"keyword\">day</span>)</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span>  today.Temperature &gt; yest.Temperature</span><br><span class=\"line\">;</span><br></pre></td></tr></table></figure></li>\n<li><p>标准答案</p>\n  <figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">    weather.id <span class=\"keyword\">AS</span> <span class=\"string\">'Id'</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">    weather</span><br><span class=\"line\">        <span class=\"keyword\">JOIN</span></span><br><span class=\"line\">    weather w <span class=\"keyword\">ON</span> <span class=\"keyword\">DATEDIFF</span>(weather.date, w.date) = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">AND</span> weather.Temperature &gt; w.Temperature</span><br><span class=\"line\">;</span><br></pre></td></tr></table></figure>\n<p>查看Mysql文档：</p>\n<blockquote>\n<p>DATEDIFF(expr1,expr2)</p>\n<p>DATEDIFF() returns expr1 − expr2 expressed as a value in days from one date to the other. expr1 and expr2 are date or date-and-time expressions. Only the date parts of the values are used in the calculation.</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">mysql&gt;</span><span class=\"bash\"> SELECT DATEDIFF(<span class=\"string\">'2007-12-31 23:59:59'</span>,<span class=\"string\">'2007-12-30'</span>);</span></span><br><span class=\"line\">        -&gt; 1</span><br><span class=\"line\"><span class=\"meta\">mysql&gt;</span><span class=\"bash\"> SELECT DATEDIFF(<span class=\"string\">'2010-11-30 23:59:59'</span>,<span class=\"string\">'2010-12-31'</span>);</span></span><br><span class=\"line\">        -&gt; -31</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"196-Delete-Duplicate-Emails\"><a href=\"#196-Delete-Duplicate-Emails\" class=\"headerlink\" title=\"196. Delete Duplicate Emails\"></a>196. Delete Duplicate Emails</h3><h4 id=\"删除重复的邮件。原题\"><a href=\"#删除重复的邮件。原题\" class=\"headerlink\" title=\"删除重复的邮件。原题\"></a>删除重复的邮件。<a href=\"https://leetcode.com/problems/delete-duplicate-emails/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">delete</span> p1 </span><br><span class=\"line\"><span class=\"keyword\">from</span> Person p1, Person p2</span><br><span class=\"line\"><span class=\"keyword\">where</span> p1.email=p2.email <span class=\"keyword\">and</span> p1.Id &gt; p2.Id</span><br><span class=\"line\">;</span><br></pre></td></tr></table></figure>\n<h3 id=\"176-Second-Highest-Salary\"><a href=\"#176-Second-Highest-Salary\" class=\"headerlink\" title=\"176. Second Highest Salary\"></a>176. Second Highest Salary</h3><h4 id=\"返回第二高的salary。原题\"><a href=\"#返回第二高的salary。原题\" class=\"headerlink\" title=\"返回第二高的salary。原题\"></a>返回第二高的salary。<a href=\"https://leetcode.com/problems/second-highest-salary/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>PS：奇怪的题，没有记录非要人返回Null，只能再套一层查询或者使用<code>IFNULL</code>也可以。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">    (<span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span></span><br><span class=\"line\">            Salary</span><br><span class=\"line\">        <span class=\"keyword\">FROM</span></span><br><span class=\"line\">            Employee</span><br><span class=\"line\">        <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> Salary <span class=\"keyword\">DESC</span></span><br><span class=\"line\">        <span class=\"keyword\">LIMIT</span> <span class=\"number\">1</span> <span class=\"keyword\">OFFSET</span> <span class=\"number\">1</span>) <span class=\"keyword\">AS</span> SecondHighestSalary</span><br><span class=\"line\">;</span><br></pre></td></tr></table></figure>\n<h3 id=\"626-Exchange-Seats\"><a href=\"#626-Exchange-Seats\" class=\"headerlink\" title=\"626. Exchange Seats\"></a>626. Exchange Seats</h3><h4 id=\"交换相邻两行的值。原题\"><a href=\"#交换相邻两行的值。原题\" class=\"headerlink\" title=\"交换相邻两行的值。原题\"></a>交换相邻两行的值。<a href=\"https://leetcode.com/problems/exchange-seats/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>开始理解错了，以为要update。</p>\n<ul>\n<li><p><code>CASE</code></p>\n  <figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> ( <span class=\"keyword\">CASE</span></span><br><span class=\"line\">           <span class=\"keyword\">WHEN</span> <span class=\"keyword\">MOD</span>(<span class=\"keyword\">id</span>, <span class=\"number\">2</span>) != <span class=\"number\">0</span></span><br><span class=\"line\">                <span class=\"keyword\">AND</span> counts != <span class=\"keyword\">id</span> <span class=\"keyword\">THEN</span> <span class=\"keyword\">id</span> + <span class=\"number\">1</span></span><br><span class=\"line\">           <span class=\"keyword\">WHEN</span> <span class=\"keyword\">MOD</span>(<span class=\"keyword\">id</span>, <span class=\"number\">2</span>) != <span class=\"number\">0</span></span><br><span class=\"line\">                <span class=\"keyword\">AND</span> counts = <span class=\"keyword\">id</span> <span class=\"keyword\">THEN</span> <span class=\"keyword\">id</span></span><br><span class=\"line\">           <span class=\"keyword\">ELSE</span> <span class=\"keyword\">id</span> - <span class=\"number\">1</span></span><br><span class=\"line\">         <span class=\"keyword\">end</span> ) <span class=\"keyword\">AS</span> <span class=\"keyword\">id</span>,</span><br><span class=\"line\">       student</span><br><span class=\"line\"><span class=\"keyword\">FROM</span>   seat,</span><br><span class=\"line\">       (<span class=\"keyword\">SELECT</span> <span class=\"keyword\">Count</span>(*) <span class=\"keyword\">AS</span> counts</span><br><span class=\"line\">        <span class=\"keyword\">FROM</span>   seat) <span class=\"keyword\">AS</span> seat_counts</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span>  <span class=\"keyword\">BY</span> <span class=\"keyword\">id</span> <span class=\"keyword\">ASC</span>;;</span><br></pre></td></tr></table></figure></li>\n<li><p><code>COALESCE()</code></p>\n<ul>\n<li><p>第一步：使用<code>XOR</code>，但是不能直接使用排序因为id为5的被换成了6。</p>\n  <figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">id</span>, (<span class=\"keyword\">id</span>+<span class=\"number\">1</span>)^<span class=\"number\">1</span><span class=\"number\">-1</span>, student <span class=\"keyword\">FROM</span> seat;</span><br></pre></td></tr></table></figure>\n  <figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">+------+------+----------+------------+---------+</span><br><span class=\"line\">| id   | id+1 | (id+1)^1 | (id+1)^1-1 | student |</span><br><span class=\"line\">+------+------+----------+------------+---------+</span><br><span class=\"line\">|    1 |    2 |        3 |          2 | Abbot   |</span><br><span class=\"line\">|    2 |    3 |        2 |          1 | Doris   |</span><br><span class=\"line\">|    3 |    4 |        5 |          4 | Emerson |</span><br><span class=\"line\">|    4 |    5 |        4 |          3 | Green   |</span><br><span class=\"line\">|    5 |    6 |        7 |          6 | Jeame   |</span><br><span class=\"line\">+------+------+----------+------------+---------+</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>第二步：使用<code>LEFT JOIN</code>链接。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> *</span><br><span class=\"line\"><span class=\"keyword\">FROM</span>   seat s1</span><br><span class=\"line\">       <span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> seat s2</span><br><span class=\"line\">              <span class=\"keyword\">ON</span> ( s1.id + <span class=\"number\">1</span> )^<span class=\"number\">1</span> - <span class=\"number\">1</span> = s2.id</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span>  <span class=\"keyword\">BY</span> s1.id;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">+------+---------+------+---------+</span><br><span class=\"line\">| id   | student | id   | student |</span><br><span class=\"line\">+------+---------+------+---------+</span><br><span class=\"line\">|    1 | Abbot   |    2 | Doris   |</span><br><span class=\"line\">|    2 | Doris   |    1 | Abbot   |</span><br><span class=\"line\">|    3 | Emerson |    4 | Green   |</span><br><span class=\"line\">|    4 | Green   |    3 | Emerson |</span><br><span class=\"line\">|    5 | Jeame   | NULL | NULL    |</span><br><span class=\"line\">+------+---------+------+---------+</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>第三步：使用<code>COALESCE()</code></p>\n  <figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> s1.id,</span><br><span class=\"line\">       <span class=\"keyword\">Coalesce</span>(s2.student, s1.student) <span class=\"keyword\">as</span> student</span><br><span class=\"line\"><span class=\"keyword\">FROM</span>   seat s1</span><br><span class=\"line\">       <span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> seat s2</span><br><span class=\"line\">              <span class=\"keyword\">ON</span> ( s1.id + <span class=\"number\">1</span> )^<span class=\"number\">1</span> - <span class=\"number\">1</span> = s2.id</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span>  <span class=\"keyword\">BY</span> s1.id</span><br><span class=\"line\">;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p>参考：Mysql文档</p>\n<blockquote>\n<p>Returns the first non-NULL value in the list, or NULL if there are no non-NULL values.<br>The return type of COALESCE() is the aggregated type of the argument types.</p>\n</blockquote>\n<h3 id=\"178-Rank-Scores\"><a href=\"#178-Rank-Scores\" class=\"headerlink\" title=\"178. Rank Scores\"></a>178. Rank Scores</h3>","categories":["sql"],"tags":["LeetCode","Mysql"]},{"title":"LeetCode算法题整理（堆篇）Heap","url":"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%A0%86%E7%AF%87%EF%BC%89Heap/","content":"<h3 id=\"1606-Find-Servers-That-Handled-Most-Number-of-Requests\"><a href=\"#1606-Find-Servers-That-Handled-Most-Number-of-Requests\" class=\"headerlink\" title=\"1606. Find Servers That Handled Most Number of Requests\"></a><a href=\"https://leetcode.com/problems/find-servers-that-handled-most-number-of-requests/\" target=\"_blank\" rel=\"noopener\">1606. Find Servers That Handled Most Number of Requests</a></h3><h4 id=\"有k个服务器处理一些请求，第i个请求需要第i-k服务器来处理，如果服务器繁忙，则按序号向下找；找到末尾后再从头开始，如果所有的服务器都忙，那么该请求被丢弃。给定一些请求的到达时间和需要处理的时间，问处理最多个请求的服务器有哪些。\"><a href=\"#有k个服务器处理一些请求，第i个请求需要第i-k服务器来处理，如果服务器繁忙，则按序号向下找；找到末尾后再从头开始，如果所有的服务器都忙，那么该请求被丢弃。给定一些请求的到达时间和需要处理的时间，问处理最多个请求的服务器有哪些。\" class=\"headerlink\" title=\"有k个服务器处理一些请求，第i个请求需要第i%k服务器来处理，如果服务器繁忙，则按序号向下找；找到末尾后再从头开始，如果所有的服务器都忙，那么该请求被丢弃。给定一些请求的到达时间和需要处理的时间，问处理最多个请求的服务器有哪些。\"></a>有k个服务器处理一些请求，第i个请求需要第i%k服务器来处理，如果服务器繁忙，则按序号向下找；找到末尾后再从头开始，如果所有的服务器都忙，那么该请求被丢弃。给定一些请求的到达时间和需要处理的时间，问处理最多个请求的服务器有哪些。</h4><a id=\"more\"></a>\n<p>方法一：比赛时没有做出，后来想想发现挺简单的，用一个堆来维护繁忙的服务器，用一个有序的列表维护可用的服务器，环的问题比较难想，但是其实处理起来很简单，就是当找到末尾不够用时，使用队首的服务器就可以了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">busiestServers</span><span class=\"params\">(self, k: int, arrival: List[int], load: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    cnt = [<span class=\"number\">0</span>] * k</span><br><span class=\"line\">    available_servers = list(range(k))</span><br><span class=\"line\">    busy_servers = []  <span class=\"comment\"># (endtime, server_id)</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, (at, rt) <span class=\"keyword\">in</span> enumerate(zip(arrival, load)):</span><br><span class=\"line\">        <span class=\"comment\"># release busy servers</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> busy_servers <span class=\"keyword\">and</span> busy_servers[<span class=\"number\">0</span>][<span class=\"number\">0</span>] &lt;= at:</span><br><span class=\"line\">            _, server = heapq.heappop(busy_servers)</span><br><span class=\"line\">            bisect.insort(available_servers, server)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(available_servers) == <span class=\"number\">0</span>: </span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        cur_server = i % k</span><br><span class=\"line\">        index = bisect.bisect_left(available_servers, cur_server) % (len(available_servers))</span><br><span class=\"line\">        server = available_servers.pop(index)</span><br><span class=\"line\">        cnt[server] += <span class=\"number\">1</span></span><br><span class=\"line\">        heapq.heappush(busy_servers, (at+rt, server))</span><br><span class=\"line\">        </span><br><span class=\"line\">    max_cnt = max(cnt)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [i <span class=\"keyword\">for</span> i, s <span class=\"keyword\">in</span> enumerate(cnt) <span class=\"keyword\">if</span> s==max_cnt]</span><br></pre></td></tr></table></figure>\n<h3 id=\"215-Kth-Largest-Element-in-an-Array\"><a href=\"#215-Kth-Largest-Element-in-an-Array\" class=\"headerlink\" title=\"215. Kth Largest Element in an Array\"></a>215. Kth Largest Element in an Array</h3><h4 id=\"找出数组中最大的第K个数。原题\"><a href=\"#找出数组中最大的第K个数。原题\" class=\"headerlink\" title=\"找出数组中最大的第K个数。原题\"></a>找出数组中最大的第K个数。<a href=\"https://leetcode.com/problems/kth-largest-element-in-an-array/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p><del>快排的思想，没有通过LeetCode测试用例，因为内存超出了限制。</del></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findKthLargest</span><span class=\"params\">(self, nums, k)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> nums:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> </span><br><span class=\"line\">    pivot = nums[<span class=\"number\">0</span>]</span><br><span class=\"line\">    left, medium, right = [], [], []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> num &lt; pivot:</span><br><span class=\"line\">            left.append(num)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> num == pivot:</span><br><span class=\"line\">            medium.append(num)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            right.append(num)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> k &lt;= len(right):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.findKthLargest(right, k)</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> k-len(right) &lt;= len(medium):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pivot</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.findKthLargest(left, k-len(right)-len(medium))</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">考虑在原数组上进行修改。Time-O(n)</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findKthLargest</span><span class=\"params\">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class=\"line\">    random.shuffle(nums)</span><br><span class=\"line\">    l, r = <span class=\"number\">0</span>, len(nums)<span class=\"number\">-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">partition</span><span class=\"params\">(l, r)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, v <span class=\"keyword\">in</span> enumerate(nums[l:r+<span class=\"number\">1</span>], l):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i] &gt;= nums[r]:</span><br><span class=\"line\">                nums[i], nums[l] = nums[l], nums[i]</span><br><span class=\"line\">                l += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> l<span class=\"number\">-1</span>  <span class=\"comment\"># return the index of pivot</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">        pos = partition(l, r)   <span class=\"comment\"># pos是索引，所以要与k-1比较</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> pos &lt; k<span class=\"number\">-1</span>:</span><br><span class=\"line\">            l = pos + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> pos &gt; k<span class=\"number\">-1</span>:</span><br><span class=\"line\">            r = pos - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums[pos]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">使用堆。Time-O(nlogk)</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findKthLargest</span><span class=\"params\">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">import</span> heapq <span class=\"keyword\">as</span> hq</span><br><span class=\"line\">    heap = nums[:k]</span><br><span class=\"line\">    hq.heapify(heap)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums[k:]:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> num &gt; heap[<span class=\"number\">0</span>]:</span><br><span class=\"line\">            hq.heapreplace(heap, num)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> heap[<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"703-Kth-Largest-Element-in-a-Stream\"><a href=\"#703-Kth-Largest-Element-in-a-Stream\" class=\"headerlink\" title=\"703. Kth Largest Element in a Stream\"></a>703. Kth Largest Element in a Stream</h3><h4 id=\"流中第K个大的数。原题\"><a href=\"#流中第K个大的数。原题\" class=\"headerlink\" title=\"流中第K个大的数。原题\"></a>流中第K个大的数。<a href=\"https://leetcode.com/problems/kth-largest-element-in-a-stream/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">int k &#x3D; 3;</span><br><span class=\"line\">int[] arr &#x3D; [4,5,8,2];</span><br><span class=\"line\">KthLargest kthLargest &#x3D; new KthLargest(3, arr);</span><br><span class=\"line\">kthLargest.add(3);   &#x2F;&#x2F; returns 4</span><br><span class=\"line\">kthLargest.add(5);   &#x2F;&#x2F; returns 5</span><br><span class=\"line\">kthLargest.add(10);  &#x2F;&#x2F; returns 5</span><br><span class=\"line\">kthLargest.add(9);   &#x2F;&#x2F; returns 8</span><br><span class=\"line\">kthLargest.add(4);   &#x2F;&#x2F; returns 8</span><br></pre></td></tr></table></figure>\n<p>方法一：还是使用堆，一开始没想到切分，所以超时了。注意是<code>heapreplace</code>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KthLargest</span>:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, k, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">import</span> heapq</span><br><span class=\"line\">        self.heap = list(nums)</span><br><span class=\"line\">        self.k = k</span><br><span class=\"line\">        heapq.heapify(self.heap)</span><br><span class=\"line\">        <span class=\"keyword\">while</span> len(self.heap) &gt; k:</span><br><span class=\"line\">            heapq.heappop(self.heap)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span><span class=\"params\">(self, val)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(self.heap) &lt; self.k:</span><br><span class=\"line\">            heapq.heappush(self.heap, val)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> val &gt; self.heap[<span class=\"number\">0</span>]:</span><br><span class=\"line\">            heapq.heapreplace(self.heap, val)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.heap[<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"1438-Longest-Continuous-Subarray-With-Absolute-Diff-Less-Than-or-Equal-to-Limit\"><a href=\"#1438-Longest-Continuous-Subarray-With-Absolute-Diff-Less-Than-or-Equal-to-Limit\" class=\"headerlink\" title=\"1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit\"></a>1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit</h3><h4 id=\"最长的连续子数组，绝对值不大于limit。原题\"><a href=\"#最长的连续子数组，绝对值不大于limit。原题\" class=\"headerlink\" title=\"最长的连续子数组，绝对值不大于limit。原题\"></a>最长的连续子数组，绝对值不大于limit。<a href=\"https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [8,2,4,7], limit &#x3D; 4</span><br><span class=\"line\">Output: 2 </span><br><span class=\"line\">Explanation: All subarrays are: </span><br><span class=\"line\">[8] with maximum absolute diff |8-8| &#x3D; 0 &lt;&#x3D; 4.</span><br><span class=\"line\">[8,2] with maximum absolute diff |8-2| &#x3D; 6 &gt; 4. </span><br><span class=\"line\">[8,2,4] with maximum absolute diff |8-2| &#x3D; 6 &gt; 4.</span><br><span class=\"line\">[8,2,4,7] with maximum absolute diff |8-2| &#x3D; 6 &gt; 4.</span><br><span class=\"line\">[2] with maximum absolute diff |2-2| &#x3D; 0 &lt;&#x3D; 4.</span><br><span class=\"line\">[2,4] with maximum absolute diff |2-4| &#x3D; 2 &lt;&#x3D; 4.</span><br><span class=\"line\">[2,4,7] with maximum absolute diff |2-7| &#x3D; 5 &gt; 4.</span><br><span class=\"line\">[4] with maximum absolute diff |4-4| &#x3D; 0 &lt;&#x3D; 4.</span><br><span class=\"line\">[4,7] with maximum absolute diff |4-7| &#x3D; 3 &lt;&#x3D; 4.</span><br><span class=\"line\">[7] with maximum absolute diff |7-7| &#x3D; 0 &lt;&#x3D; 4. </span><br><span class=\"line\">Therefore, the size of the longest subarray is 2.</span><br></pre></td></tr></table></figure>\n<p>方法一：堆，Time: O(NlogN)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestSubarray</span><span class=\"params\">(self, nums: List[int], limit: int)</span> -&gt; int:</span></span><br><span class=\"line\">    maxd, mind = [], []</span><br><span class=\"line\">    res = i = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j, a <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">        heapq.heappush(maxd, (-a, j))</span><br><span class=\"line\">        heapq.heappush(mind, (a, j))</span><br><span class=\"line\">        <span class=\"keyword\">while</span> -maxd[<span class=\"number\">0</span>][<span class=\"number\">0</span>] - mind[<span class=\"number\">0</span>][<span class=\"number\">0</span>] &gt; limit:</span><br><span class=\"line\">            i = min(maxd[<span class=\"number\">0</span>][<span class=\"number\">1</span>], mind[<span class=\"number\">0</span>][<span class=\"number\">1</span>]) + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> maxd[<span class=\"number\">0</span>][<span class=\"number\">1</span>] &lt; i: heapq.heappop(maxd)</span><br><span class=\"line\">            <span class=\"keyword\">while</span> mind[<span class=\"number\">0</span>][<span class=\"number\">1</span>] &lt; i: heapq.heappop(mind)</span><br><span class=\"line\">        print(maxd, <span class=\"string\">'--'</span>, mind)</span><br><span class=\"line\">        res = max(res, j - i + <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"1631-Path-With-Minimum-Effort\"><a href=\"#1631-Path-With-Minimum-Effort\" class=\"headerlink\" title=\"1631. Path With Minimum Effort\"></a><a href=\"https://leetcode.com/problems/path-with-minimum-effort/\" target=\"_blank\" rel=\"noopener\">1631. Path With Minimum Effort</a></h3><h4 id=\"找出一条左上到右下的路径，路径中体力消耗为最大的两个格子的差，找到能走到右下的最小消耗值，可以走上下左右。\"><a href=\"#找出一条左上到右下的路径，路径中体力消耗为最大的两个格子的差，找到能走到右下的最小消耗值，可以走上下左右。\" class=\"headerlink\" title=\"找出一条左上到右下的路径，路径中体力消耗为最大的两个格子的差，找到能走到右下的最小消耗值，可以走上下左右。\"></a>找出一条左上到右下的路径，路径中体力消耗为最大的两个格子的差，找到能走到右下的最小消耗值，可以走上下左右。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: heights &#x3D; [[1,2,2],[3,8,2],[5,3,5]]</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: The route of [1,3,5,3,5] has a maximum absolute difference of 2 in consecutive cells.</span><br><span class=\"line\">This is better than the route of [1,2,2,2,5], where the maximum absolute difference is 3.</span><br></pre></td></tr></table></figure>\n<p>方法一：作为竞赛3题，1个小时都没有想出来，想法想偏了，因为如果只能走右和下，那么问题很简单，是一个dp问题。所以一开始也往dp方向考虑。实际上通过数据范围的上限可以考虑二分法 + bfs。效率不高，4000ms。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minimumEffortPath</span><span class=\"params\">(self, g: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    lo, hi = <span class=\"number\">0</span>, <span class=\"number\">10</span>**<span class=\"number\">6</span></span><br><span class=\"line\">    M, N = len(g), len(g[<span class=\"number\">0</span>])</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check</span><span class=\"params\">(d)</span>:</span></span><br><span class=\"line\">        q = [(<span class=\"number\">0</span>, <span class=\"number\">0</span>)]</span><br><span class=\"line\">        seen = [[<span class=\"literal\">False</span>]*N <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(M)]</span><br><span class=\"line\">        seen[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, j <span class=\"keyword\">in</span> q:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i==M<span class=\"number\">-1</span> <span class=\"keyword\">and</span> j==N<span class=\"number\">-1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> ((i<span class=\"number\">-1</span>, j), (i+<span class=\"number\">1</span>, j), (i, j<span class=\"number\">-1</span>), (i, j+<span class=\"number\">1</span>)):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=x&lt;M <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=y&lt;N <span class=\"keyword\">and</span> abs(g[x][y]-g[i][j])&lt;=d <span class=\"keyword\">and</span> \\</span><br><span class=\"line\">                    <span class=\"keyword\">not</span> seen[x][y]:</span><br><span class=\"line\">                    q.append((x, y))</span><br><span class=\"line\">                    seen[x][y] = <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> lo &lt; hi:</span><br><span class=\"line\">        mid = (lo + hi) &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> check(mid):</span><br><span class=\"line\">            hi = mid</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            lo = mid + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> lo</span><br></pre></td></tr></table></figure>\n<p>方法二：Dijikstra’s算法。堆，堆的方法比方法一快很多，哟还那个是700ms。核心是维护一个<code>dist</code>用来记录每个点的最小距离。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minimumEffortPath</span><span class=\"params\">(self, g: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    heap = [(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>)]        </span><br><span class=\"line\">    M, N = len(g), len(g[<span class=\"number\">0</span>])</span><br><span class=\"line\">    dist = [[float(<span class=\"string\">'inf'</span>)]*N <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(M)]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> heap:</span><br><span class=\"line\">        d, i, j = heapq.heappop(heap)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i==M<span class=\"number\">-1</span> <span class=\"keyword\">and</span> j==N<span class=\"number\">-1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> d</span><br><span class=\"line\">        cur = g[i][j]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> ((i<span class=\"number\">-1</span>, j), (i+<span class=\"number\">1</span>, j), (i, j+<span class=\"number\">1</span>), (i, j<span class=\"number\">-1</span>)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=x&lt;M <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=y&lt;N:</span><br><span class=\"line\">                new_dist = max(d, abs(g[x][y]-cur))</span><br><span class=\"line\">                <span class=\"keyword\">if</span> dist[x][y] &gt; new_dist:</span><br><span class=\"line\">                    dist[x][y] = new_dist</span><br><span class=\"line\">                    heapq.heappush(heap, (max(d, abs(g[x][y]-cur)), x, y))</span><br></pre></td></tr></table></figure>\n<h3 id=\"778-Swim-in-Rising-Water\"><a href=\"#778-Swim-in-Rising-Water\" class=\"headerlink\" title=\"778. Swim in Rising Water\"></a><a href=\"https://leetcode.com/problems/swim-in-rising-water/\" target=\"_blank\" rel=\"noopener\">778. Swim in Rising Water</a></h3><h4 id=\"和1631几乎一样，从左上到右下，经过的所有点的最大值最小。\"><a href=\"#和1631几乎一样，从左上到右下，经过的所有点的最大值最小。\" class=\"headerlink\" title=\"和1631几乎一样，从左上到右下，经过的所有点的最大值最小。\"></a>和1631几乎一样，从左上到右下，经过的所有点的最大值最小。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]</span><br><span class=\"line\">Output: 16</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\"> 0  1  2  3  4</span><br><span class=\"line\">24 23 22 21  5</span><br><span class=\"line\">12 13 14 15 16</span><br><span class=\"line\">11 17 18 19 20</span><br><span class=\"line\">10  9  8  7  6</span><br><span class=\"line\"></span><br><span class=\"line\">The final route is marked in bold.</span><br><span class=\"line\">We need to wait until time 16 so that (0, 0) and (4, 4) are connected.</span><br></pre></td></tr></table></figure>\n<p>方法一：二分法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">swimInWater</span><span class=\"params\">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    lo, hi = max(grid[<span class=\"number\">0</span>][<span class=\"number\">0</span>], grid[<span class=\"number\">-1</span>][<span class=\"number\">-1</span>]), <span class=\"number\">50</span>*<span class=\"number\">50</span></span><br><span class=\"line\">    M, N = len(grid), len(grid[<span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check</span><span class=\"params\">(d)</span>:</span></span><br><span class=\"line\">        q = [(<span class=\"number\">0</span>, <span class=\"number\">0</span>)]</span><br><span class=\"line\">        seen = [[<span class=\"literal\">False</span>]*N <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(M)]</span><br><span class=\"line\">        seen[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, j <span class=\"keyword\">in</span> q:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i==M<span class=\"number\">-1</span> <span class=\"keyword\">and</span> j==N<span class=\"number\">-1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> ((i+<span class=\"number\">1</span>, j), (i<span class=\"number\">-1</span>, j), (i, j+<span class=\"number\">1</span>), (i, j<span class=\"number\">-1</span>)):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=x&lt;M <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=y&lt;N <span class=\"keyword\">and</span> grid[x][y]&lt;=d <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> seen[x][y]:</span><br><span class=\"line\">                    q.append((x, y))</span><br><span class=\"line\">                    seen[x][y] = <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> lo &lt; hi:</span><br><span class=\"line\">        mid = (lo + hi) &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> check(mid):</span><br><span class=\"line\">            hi = mid</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            lo = mid + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> lo</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：Dijikstra’s。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">swimInWater</span><span class=\"params\">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    heap = [(grid[<span class=\"number\">0</span>][<span class=\"number\">0</span>], <span class=\"number\">0</span>, <span class=\"number\">0</span>)]</span><br><span class=\"line\">    M, N = len(grid), len(grid[<span class=\"number\">0</span>])</span><br><span class=\"line\">    res = [[inf]*N <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(M)]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> heap:</span><br><span class=\"line\">        d, i, j = heapq.heappop(heap)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i==M<span class=\"number\">-1</span> <span class=\"keyword\">and</span> j==N<span class=\"number\">-1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> d</span><br><span class=\"line\">        cur = grid[i][j]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> ((i+<span class=\"number\">1</span>, j), (i<span class=\"number\">-1</span>, j), (i, j+<span class=\"number\">1</span>), (i, j<span class=\"number\">-1</span>)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=x&lt;M <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=y&lt;N:</span><br><span class=\"line\">                new_d = max(d, grid[x][y])</span><br><span class=\"line\">                <span class=\"keyword\">if</span> new_d &lt; res[x][y]:</span><br><span class=\"line\">                    res[x][y] = new_d</span><br><span class=\"line\">                    heapq.heappush(heap, (new_d, x, y))</span><br></pre></td></tr></table></figure>\n<h3 id=\"1642-Furthest-Building-You-Can-Reach\"><a href=\"#1642-Furthest-Building-You-Can-Reach\" class=\"headerlink\" title=\"1642. Furthest Building You Can Reach\"></a><a href=\"https://leetcode.com/problems/furthest-building-you-can-reach/\" target=\"_blank\" rel=\"noopener\">1642. Furthest Building You Can Reach</a></h3><h4 id=\"一个人在爬一群建筑物，当建筑物比当前高时，需要一个梯子和高度差个砖块，给你一些梯子和砖块，问最远能走到哪里。\"><a href=\"#一个人在爬一群建筑物，当建筑物比当前高时，需要一个梯子和高度差个砖块，给你一些梯子和砖块，问最远能走到哪里。\" class=\"headerlink\" title=\"一个人在爬一群建筑物，当建筑物比当前高时，需要一个梯子和高度差个砖块，给你一些梯子和砖块，问最远能走到哪里。\"></a>一个人在爬一群建筑物，当建筑物比当前高时，需要一个梯子和高度差个砖块，给你一些梯子和砖块，问最远能走到哪里。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: heights &#x3D; [4,2,7,6,9,14,12], bricks &#x3D; 5, ladders &#x3D; 1</span><br><span class=\"line\">Output: 4</span><br><span class=\"line\">Explanation: Starting at building 0, you can follow these steps:</span><br><span class=\"line\">- Go to building 1 without using ladders nor bricks since 4 &gt;&#x3D; 2.</span><br><span class=\"line\">- Go to building 2 using 5 bricks. You must use either bricks or ladders because 2 &lt; 7.</span><br><span class=\"line\">- Go to building 3 without using ladders nor bricks since 7 &gt;&#x3D; 6.</span><br><span class=\"line\">- Go to building 4 using your only ladder. You must use either bricks or ladders because 6 &lt; 9.</span><br><span class=\"line\">It is impossible to go beyond building 4 because you do not have any more bricks or ladders.</span><br></pre></td></tr></table></figure>\n<p>方法一：竞赛时想偏了，超时了。这里有点贪心的思维，需要爬升的次数优先使用梯子，如果不够了，使用高度差最小的用砖块替代，如果不够了，证明走得是最远了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">furthestBuilding</span><span class=\"params\">(self, heights: List[int], bricks: int, ladders: int)</span> -&gt; int:</span></span><br><span class=\"line\">    upstairs = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(heights)<span class=\"number\">-1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> heights[i+<span class=\"number\">1</span>] &gt; heights[i]:</span><br><span class=\"line\">            heapq.heappush(upstairs, heights[i+<span class=\"number\">1</span>]-heights[i])</span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(upstairs) &gt; ladders:</span><br><span class=\"line\">            bricks -= heapq.heappop(upstairs)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> bricks &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> i</span><br><span class=\"line\">    <span class=\"keyword\">return</span> len(heights) - <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1675-Minimize-Deviation-in-Array\"><a href=\"#1675-Minimize-Deviation-in-Array\" class=\"headerlink\" title=\"1675. Minimize Deviation in Array\"></a><a href=\"https://leetcode.com/problems/minimize-deviation-in-array/\" target=\"_blank\" rel=\"noopener\">1675. Minimize Deviation in Array</a></h3><h4 id=\"将奇数-2，或者偶数除2，返回可以将数组最大值最小值差最小是多少。\"><a href=\"#将奇数-2，或者偶数除2，返回可以将数组最大值最小值差最小是多少。\" class=\"headerlink\" title=\"将奇数*2，或者偶数除2，返回可以将数组最大值最小值差最小是多少。\"></a>将奇数*2，或者偶数除2，返回可以将数组最大值最小值差最小是多少。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [4,1,5,20,3]</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: You can transform the array after two operations to [4,2,5,5,3], then the deviation will be 5 - 2 &#x3D; 3.</span><br></pre></td></tr></table></figure>\n<p>方法一：将所有奇数变成偶数，这个时候所有的值都是最大的，包括最小值。然后每次将最大的值除2，来降低上限。注意这个过程中最小值可能更新。使用堆来做优先级队列。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minimumDeviation</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    nums = [n*<span class=\"number\">2</span> <span class=\"keyword\">if</span> n&amp;<span class=\"number\">1</span>==<span class=\"number\">1</span> <span class=\"keyword\">else</span> n <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> nums]</span><br><span class=\"line\">    mi = min(nums)</span><br><span class=\"line\">    heap = [-n <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> nums]</span><br><span class=\"line\">    heapq.heapify(heap)</span><br><span class=\"line\">    res = inf</span><br><span class=\"line\">    <span class=\"keyword\">while</span> heap[<span class=\"number\">0</span>] &amp; <span class=\"number\">1</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">        mi = min(mi, -heap[<span class=\"number\">0</span>]//<span class=\"number\">2</span>)</span><br><span class=\"line\">        heapq.heapreplace(heap, heap[<span class=\"number\">0</span>]//<span class=\"number\">2</span>)</span><br><span class=\"line\">        res = min(res, abs(-heap[<span class=\"number\">0</span>] - mi))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"1439-Find-the-Kth-Smallest-Sum-of-a-Matrix-With-Sorted-Rows\"><a href=\"#1439-Find-the-Kth-Smallest-Sum-of-a-Matrix-With-Sorted-Rows\" class=\"headerlink\" title=\"1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows\"></a><a href=\"https://leetcode.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/\" target=\"_blank\" rel=\"noopener\">1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows</a></h3><h4 id=\"二维数组每行有序，从每行选出一个数字，所有的行累加和第K小的是多少。\"><a href=\"#二维数组每行有序，从每行选出一个数字，所有的行累加和第K小的是多少。\" class=\"headerlink\" title=\"二维数组每行有序，从每行选出一个数字，所有的行累加和第K小的是多少。\"></a>二维数组每行有序，从每行选出一个数字，所有的行累加和第K小的是多少。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: mat &#x3D; [[1,3,11],[2,4,6]], k &#x3D; 5</span><br><span class=\"line\">Output: 7</span><br><span class=\"line\">Explanation: Choosing one element from each row, the first k smallest sum are:</span><br><span class=\"line\">[1,2], [1,4], [3,2], [3,4], [1,6]. Where the 5th sum is 7.</span><br></pre></td></tr></table></figure>\n<p>方法一：可以暴力，但是不能使用<code>product</code>，那样复杂度太高了</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">kthSmallest</span><span class=\"params\">(self, mat: List[List[int]], k: int)</span> -&gt; int:</span></span><br><span class=\"line\">    h = mat[<span class=\"number\">0</span>][:]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> mat[<span class=\"number\">1</span>:]:</span><br><span class=\"line\">        h = sorted([i+j <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> row <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> h])[:k]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h[<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<p>方法二：使用堆作为优先级队列，枚举每行向右移动一位。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">kthSmallest</span><span class=\"params\">(self, mat: List[List[int]], k: int)</span> -&gt; int:</span></span><br><span class=\"line\">    M, N = len(mat), len(mat[<span class=\"number\">0</span>])</span><br><span class=\"line\">    p = [<span class=\"number\">0</span>] * M</span><br><span class=\"line\">    cur_sum = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> mat:</span><br><span class=\"line\">        row.append(inf)</span><br><span class=\"line\">        cur_sum += row[<span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    seen = &#123;tuple(p)&#125;</span><br><span class=\"line\">    heap = [(cur_sum, tuple(p))]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(k<span class=\"number\">-1</span>):</span><br><span class=\"line\">        cur_sum, p = heapq.heappop(heap)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, d <span class=\"keyword\">in</span> enumerate(p):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> d &lt; N<span class=\"number\">-1</span>:</span><br><span class=\"line\">                tp = p[:i] + (d+<span class=\"number\">1</span>, ) + p[i+<span class=\"number\">1</span>:]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> tp <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> seen:</span><br><span class=\"line\">                    heapq.heappush(heap, (cur_sum+mat[i][d+<span class=\"number\">1</span>]-mat[i][d], tp))</span><br><span class=\"line\">                    seen.add(tp)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> heap[<span class=\"number\">0</span>][<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n","categories":["Heap"],"tags":["LeetCode","heap"]},{"title":"LeetCode算法题整理（并发篇）Threading","url":"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%B9%B6%E5%8F%91%E7%AF%87%EF%BC%89Threading/","content":"<h3 id=\"1114-Print-in-Order\"><a href=\"#1114-Print-in-Order\" class=\"headerlink\" title=\"1114. Print in Order\"></a><a href=\"https://leetcode.com/problems/print-in-order/\" target=\"_blank\" rel=\"noopener\">1114. Print in Order</a></h3><h4 id=\"按照指定的顺序打印，三个线程的方法。\"><a href=\"#按照指定的顺序打印，三个线程的方法。\" class=\"headerlink\" title=\"按照指定的顺序打印，三个线程的方法。\"></a>按照指定的顺序打印，三个线程的方法。</h4><a id=\"more\"></a>\n<p>方法一：Lock 锁对象法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> threading <span class=\"keyword\">import</span> Lock</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.locks = (Lock(),Lock())</span><br><span class=\"line\">        self.locks[<span class=\"number\">0</span>].acquire()</span><br><span class=\"line\">        self.locks[<span class=\"number\">1</span>].acquire()</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">first</span><span class=\"params\">(self, printFirst)</span>:</span></span><br><span class=\"line\">        printFirst()</span><br><span class=\"line\">        self.locks[<span class=\"number\">0</span>].release()</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">second</span><span class=\"params\">(self, printSecond)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">with</span> self.locks[<span class=\"number\">0</span>]:</span><br><span class=\"line\">            printSecond()</span><br><span class=\"line\">            self.locks[<span class=\"number\">1</span>].release()</span><br><span class=\"line\">            </span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">third</span><span class=\"params\">(self, printThird)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">with</span> self.locks[<span class=\"number\">1</span>]:</span><br><span class=\"line\">            printThird()</span><br></pre></td></tr></table></figure>\n<p>方法二：信号量。<code>Semaphore</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> threading <span class=\"keyword\">import</span> Semaphore</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.gates = (Semaphore(<span class=\"number\">0</span>),Semaphore(<span class=\"number\">0</span>))</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">first</span><span class=\"params\">(self, printFirst)</span>:</span></span><br><span class=\"line\">        printFirst()</span><br><span class=\"line\">        self.gates[<span class=\"number\">0</span>].release()</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">second</span><span class=\"params\">(self, printSecond)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">with</span> self.gates[<span class=\"number\">0</span>]:</span><br><span class=\"line\">            printSecond()</span><br><span class=\"line\">            self.gates[<span class=\"number\">1</span>].release()</span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">third</span><span class=\"params\">(self, printThird)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">with</span> self.gates[<span class=\"number\">1</span>]:</span><br><span class=\"line\">            printThird()</span><br></pre></td></tr></table></figure>\n<p>方法三：Event事件对象法。原理同上，用<code>wait</code>方法作为阻塞，用<code>set</code>来释放线程，默认类赋值就是阻塞的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.e1 = threading.Event()</span><br><span class=\"line\">        self.e2 = threading.Event()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">first</span><span class=\"params\">(self, printFirst: <span class=\"string\">'Callable[[], None]'</span>)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        printFirst()</span><br><span class=\"line\">        self.e1.set()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">second</span><span class=\"params\">(self, printSecond: <span class=\"string\">'Callable[[], None]'</span>)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        self.e1.wait()</span><br><span class=\"line\">        printSecond()</span><br><span class=\"line\">        self.e2.set()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">third</span><span class=\"params\">(self, printThird: <span class=\"string\">'Callable[[], None]'</span>)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        self.e2.wait()</span><br><span class=\"line\">        printThird()</span><br></pre></td></tr></table></figure>\n<p>方法四：<code>Barrier</code>障碍法。<code>Barrier</code>初始化的时候定义了<code>parties = 2</code>个等待线程，调用完了<code>parties</code>个<code>wait</code>就会释放线程。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.b1 = threading.Barrier(<span class=\"number\">2</span>)</span><br><span class=\"line\">        self.b2 = threading.Barrier(<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">first</span><span class=\"params\">(self, printFirst: <span class=\"string\">'Callable[[], None]'</span>)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        printFirst()</span><br><span class=\"line\">        self.b1.wait()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">second</span><span class=\"params\">(self, printSecond: <span class=\"string\">'Callable[[], None]'</span>)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        self.b1.wait()</span><br><span class=\"line\">        printSecond()</span><br><span class=\"line\">        self.b2.wait()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">third</span><span class=\"params\">(self, printThird: <span class=\"string\">'Callable[[], None]'</span>)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        self.b2.wait()</span><br><span class=\"line\">        printThird()</span><br></pre></td></tr></table></figure>\n<p>方法五：队列法。直接使用多线程专用的阻塞队列，对于队列为空时，<code>get</code>方法就会自动阻塞，直到<code>put</code>使之非空才会释放进程。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> queue</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.q1 = queue.Queue()</span><br><span class=\"line\">        self.q2 = queue.Queue()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">first</span><span class=\"params\">(self, printFirst: <span class=\"string\">'Callable[[], None]'</span>)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        printFirst()</span><br><span class=\"line\">        self.q1.put(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">second</span><span class=\"params\">(self, printSecond: <span class=\"string\">'Callable[[], None]'</span>)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        self.q1.get()</span><br><span class=\"line\">        printSecond()</span><br><span class=\"line\">        self.q2.put(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">third</span><span class=\"params\">(self, printThird: <span class=\"string\">'Callable[[], None]'</span>)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        self.q2.get()</span><br><span class=\"line\">        printThird()</span><br></pre></td></tr></table></figure>\n<p>方法六：反过来，对于定容队列来说，如果队列满了，<code>put</code>方法也是阻塞。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> queue</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.q1 = queue.Queue(<span class=\"number\">1</span>)</span><br><span class=\"line\">        self.q1.put(<span class=\"number\">0</span>)</span><br><span class=\"line\">        self.q2 = queue.Queue(<span class=\"number\">1</span>)</span><br><span class=\"line\">        self.q2.put(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">first</span><span class=\"params\">(self, printFirst: <span class=\"string\">'Callable[[], None]'</span>)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        printFirst()</span><br><span class=\"line\">        self.q1.get()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">second</span><span class=\"params\">(self, printSecond: <span class=\"string\">'Callable[[], None]'</span>)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        self.q1.put(<span class=\"number\">0</span>)</span><br><span class=\"line\">        printSecond()</span><br><span class=\"line\">        self.q2.get()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">third</span><span class=\"params\">(self, printThird: <span class=\"string\">'Callable[[], None]'</span>)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        self.q2.put(<span class=\"number\">0</span>)</span><br><span class=\"line\">        printThird()</span><br></pre></td></tr></table></figure>\n<p>方法七：<code>Condition</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> threading <span class=\"keyword\">import</span> Condition</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.exec_condition = Condition()</span><br><span class=\"line\">        self.order = <span class=\"number\">0</span></span><br><span class=\"line\">        self.first_finish = <span class=\"keyword\">lambda</span>: self.order == <span class=\"number\">1</span></span><br><span class=\"line\">        self.second_finish = <span class=\"keyword\">lambda</span>: self.order == <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">first</span><span class=\"params\">(self, printFirst)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">with</span> self.exec_condition:</span><br><span class=\"line\">            printFirst()</span><br><span class=\"line\">            self.order = <span class=\"number\">1</span></span><br><span class=\"line\">            self.exec_condition.notify(<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">second</span><span class=\"params\">(self, printSecond)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">with</span> self.exec_condition:</span><br><span class=\"line\">            self.exec_condition.wait_for(self.first_finish)</span><br><span class=\"line\">            printSecond()</span><br><span class=\"line\">            self.order = <span class=\"number\">2</span></span><br><span class=\"line\">            self.exec_condition.notify()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">third</span><span class=\"params\">(self, printThird)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">with</span> self.exec_condition:</span><br><span class=\"line\">            self.exec_condition.wait_for(self.second_finish)</span><br><span class=\"line\">            printThird()</span><br></pre></td></tr></table></figure>","categories":["Concurrency"],"tags":["LeetCode","concurrency"]},{"title":"LeetCode算法题整理（正则篇）regex","url":"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%AD%A3%E5%88%99%E7%AF%87%EF%BC%89regex/","content":"<h3 id=\"193-Valid-Phone-Numbers\"><a href=\"#193-Valid-Phone-Numbers\" class=\"headerlink\" title=\"193. Valid Phone Numbers\"></a>193. Valid Phone Numbers</h3><h4 id=\"使用bash命令在一行中提取一个文本中的手机号。原题\"><a href=\"#使用bash命令在一行中提取一个文本中的手机号。原题\" class=\"headerlink\" title=\"使用bash命令在一行中提取一个文本中的手机号。原题\"></a>使用<code>bash</code>命令在一行中提取一个文本中的手机号。<a href=\"https://leetcode.com/problems/valid-phone-numbers/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">(xxx) xxx-xxxx or xxx-xxx-xxxx. (x means a digit).</span><br><span class=\"line\">Assume that file.txt has the following content:</span><br><span class=\"line\"></span><br><span class=\"line\">987-123-4567</span><br><span class=\"line\">123 456 7890</span><br><span class=\"line\">(123) 456-7890</span><br><span class=\"line\">Your script should output the following valid phone numbers:</span><br><span class=\"line\"></span><br><span class=\"line\">987-123-4567</span><br><span class=\"line\">(123) 456-7890</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">awk <span class=\"string\">'/^([0-9]&#123;3&#125;-|\\([0-9]&#123;3&#125;\\) )[0-9]&#123;3&#125;-[0-9]&#123;4&#125;$/'</span> telephone.txt</span><br></pre></td></tr></table></figure>","categories":["算法"],"tags":["LeetCode","Python","Algorithm","Regex"]},{"title":"Python 并行赋值","url":"/Python-%E5%A4%9A%E4%B8%AA%E5%8F%98%E9%87%8F%E5%90%8C%E6%97%B6%E8%B5%8B%E5%80%BC/","content":"<h3 id=\"经常可以在Python看到这样的赋值语句\"><a href=\"#经常可以在Python看到这样的赋值语句\" class=\"headerlink\" title=\"经常可以在Python看到这样的赋值语句\"></a>经常可以在Python看到这样的赋值语句</h3><a id=\"more\"></a>\n<p><code>a, b, c = 1, 2, 3</code>，其执行顺序先执行=右边的表达式，再依次将值赋给左边，Python解释器会将其组成为一个tuple，赋值的时候再unpack。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a, b = <span class=\"number\">2</span>, <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a, b, a = <span class=\"number\">1</span>, a, <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a, b</span><br><span class=\"line\">(<span class=\"number\">4</span>, <span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<p>可以看到，上面是先把算出右边的值<code>(1, 2, 4)</code>再将其赋值给左边，最后a的值被修改成了4。</p>\n<p>如果是可变的对象怎么办，LeetCode有一道经典的题，叫反转一个链表。要求将<code>1-&gt;2-3-&gt;None</code>的链表反转成<code>3-&gt;2-&gt;1-&gt;None</code>。<br>有一个迭代的写法是这样的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseList</span><span class=\"params\">(head)</span>:</span></span><br><span class=\"line\">    prev = <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> head:</span><br><span class=\"line\">        cur = head</span><br><span class=\"line\">        head = head.next</span><br><span class=\"line\">        cur.next = prev</span><br><span class=\"line\">        prev = cur</span><br><span class=\"line\">    <span class=\"keyword\">return</span> prev</span><br></pre></td></tr></table></figure>\n<p>它的简化写法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseList</span><span class=\"params\">(self, head)</span>:</span></span><br><span class=\"line\">    prev = <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> head:</span><br><span class=\"line\">        head.next, prev, head = prev, head, head.next</span><br><span class=\"line\">    <span class=\"keyword\">return</span> prev</span><br></pre></td></tr></table></figure>\n<p>具体的过程是这样的。先执行=右边表达式<code>(None, head, head.next)</code>，然后第一步把<code>head.next=None</code>，此时<code>head</code>变成了<code>1-&gt;None</code>；第二步，执行<code>prev=head</code>，这里为什么<code>head</code>的值时<code>1-&gt;None</code>而不是<code>1-&gt;2-3-&gt;None</code>呢，因为虽然等式先执行的右边，拿到了<code>head</code>，但是上一步的操作是将<code>head</code>修改了，由于head是一个可变对象，prev的值是<code>1-&gt;None</code>，最后再把<code>head=head.next</code>，这里为什么<code>head.next</code>的值又是<code>2-&gt;3-&gt;None</code>了呢，因为，执行右侧的表达式之后，<code>head.next</code>这个对象再前两步中没有被修改，一直都是<code>2-&gt;3-&gt;None</code>，这正是和第二步不同的地方，所以这两个写法是等同的。</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/8725673/multiple-assignment-and-evaluation-order-in-python\" target=\"_blank\" rel=\"noopener\">Multiple assignment and evaluation order in Python\n</a> </li>\n</ul>\n","categories":["Python"]},{"title":"Python排序算法","url":"/Python%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","content":"<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><img src=\"/Python%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/quick_sort.gif\" class>\n<a id=\"more\"></a>\n<blockquote>\n<p>快排算是应用中广泛的排序算法了。由于实现简单，适用于不同的输入数据且在一般应用中比其他排序算法要快。快排的一个特点是<em>原地排序</em>，内循环比大多数排序算法要短小。它的主要缺点是非常脆弱，在实现中要非常小心才能避免低劣的性能。                                              </p>\n</blockquote>\n<blockquote>\n<p>快排是一种分治的排序算法。它将一个数组分成两个子数组，将两部分独立地排序。快排和归并排序是互补的：<strong>归并排序将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组排序，递归调用发生在处理整个数组之前；而快排将数组排序的方式则是当两个子数组都有序时整个数组自然也就有序了，递归调用发生在处理整个数组之后。</strong> </p>\n</blockquote>\n<p>按照《算法第4版》中的例子，实现一个标准的python解法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> random</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">quick_sort</span><span class=\"params\">(a)</span>:</span></span><br><span class=\"line\">    random.shuffle(a)  <span class=\"comment\"># 消除输入依赖，保持随机性，也可使用随机选取切分元素</span></span><br><span class=\"line\">    quick_sort_divide(a, <span class=\"number\">0</span>, len(a)<span class=\"number\">-1</span>)  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">quick_sort_divide</span><span class=\"params\">(a, lo, hi)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> hi &lt;= lo:</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    j = partition(a, lo, hi)</span><br><span class=\"line\">    quick_sort_divide(a, lo, j<span class=\"number\">-1</span>)</span><br><span class=\"line\">    quick_sort_divide(a, j+<span class=\"number\">1</span>, hi)</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">partition</span><span class=\"params\">(a, lo, hi)</span>:</span></span><br><span class=\"line\">    i, j = lo+<span class=\"number\">1</span>, hi</span><br><span class=\"line\">    pivot = a[lo]  <span class=\"comment\"># 选取第一个元素作为切分元素</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> a[i]&lt;pivot <span class=\"keyword\">and</span> i&lt;hi:  <span class=\"comment\"># 遇到大于等于pivot时停止，某些情况可以避免算法运行时间变为平方级别</span></span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> a[j]&gt;pivot <span class=\"keyword\">and</span> j&gt;lo:</span><br><span class=\"line\">            j -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i &gt;= j:</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        a[i], a[j] = a[j], a[i]</span><br><span class=\"line\">        i += <span class=\"number\">1</span></span><br><span class=\"line\">        j -= <span class=\"number\">1</span></span><br><span class=\"line\">    a[lo], a[j] = a[j], a[lo]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> j</span><br></pre></td></tr></table></figure>\n<p>写法二：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sortArray</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">q_sort</span><span class=\"params\">(lo, hi)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> lo &gt;= hi: <span class=\"keyword\">return</span> </span><br><span class=\"line\">        m = (lo + hi) // <span class=\"number\">2</span></span><br><span class=\"line\">        l, r = lo, hi</span><br><span class=\"line\">        pivot = nums[m]</span><br><span class=\"line\">        <span class=\"keyword\">while</span> l &lt;= r:</span><br><span class=\"line\">            <span class=\"keyword\">while</span> l&lt;=r <span class=\"keyword\">and</span> nums[l]&lt;pivot:</span><br><span class=\"line\">                l += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> l&lt;=r <span class=\"keyword\">and</span> nums[r]&gt;pivot:</span><br><span class=\"line\">                r -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> l&lt;=r:</span><br><span class=\"line\">                nums[l], nums[r] = nums[r], nums[l]</span><br><span class=\"line\">                l += <span class=\"number\">1</span></span><br><span class=\"line\">                r -= <span class=\"number\">1</span></span><br><span class=\"line\">        q_sort(lo, r)</span><br><span class=\"line\">        q_sort(l, hi)</span><br><span class=\"line\"></span><br><span class=\"line\">    random.shuffle(nums)</span><br><span class=\"line\">    q_sort(<span class=\"number\">0</span>, len(nums)<span class=\"number\">-1</span>)</span><br></pre></td></tr></table></figure>\n<p>性能分析：</p>\n<ul>\n<li>内循环使用一个递增的索引将数组元素和一个定值比较，相对于归并和希尔的在内循环中移动数据的方法更快，更简洁。</li>\n<li>比较的次数很少。排序效率依赖切分数组的效果。</li>\n</ul>\n<p>基于Dijkstra-三路快排实现：当数组中包含大量重复的元素时，上述快排做出了一些无意义的切分。从左到右遍历数组，维护一个指针<code>lt</code>使<code>a[lo..lt-1]</code>中的元素都小于p，一个指针<code>gt</code>使得<code>a[gt+1..hi]</code>中的元素都大于p，一个指针<code>i</code>使得<code>a[lt..i-1]</code>中的元素都等于p，由于Python可以返回元组，所以改写成三路非常简单。</p>\n<img src=\"/Python%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/q_sort_3ways.png\" class>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> random</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">q3_sort</span><span class=\"params\">(a)</span>:</span></span><br><span class=\"line\">    random.shuffle(a)</span><br><span class=\"line\">    q_divide(a, <span class=\"number\">0</span>, len(a)<span class=\"number\">-1</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">q_divide</span><span class=\"params\">(a, lo, hi)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> lo &gt;= hi:</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    i, j = partition(a, lo, hi)</span><br><span class=\"line\">    q_divide(a, lo, i)</span><br><span class=\"line\">    q_divide(a, j, hi)</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">partition</span><span class=\"params\">(a, lo, hi)</span>:</span></span><br><span class=\"line\">    lt, i, gt = lo, lo+<span class=\"number\">1</span>, hi</span><br><span class=\"line\">    p = a[lo]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> i &lt;= gt:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> a[i] &lt; p:</span><br><span class=\"line\">            a[i], a[lt] = a[lt], a[i]</span><br><span class=\"line\">            lt += <span class=\"number\">1</span></span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> a[i] &gt; p:</span><br><span class=\"line\">            a[i], a[gt] = a[gt], a[i]</span><br><span class=\"line\">            gt -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> lt<span class=\"number\">-1</span>, gt+<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sortArray</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    n = len(nums)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">        flag = <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n-i<span class=\"number\">-1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[j] &gt; nums[j+<span class=\"number\">1</span>]:</span><br><span class=\"line\">                nums[j], nums[j+<span class=\"number\">1</span>] = nums[j+<span class=\"number\">1</span>], nums[j]</span><br><span class=\"line\">                flag = <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> flag: <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">select_sort</span><span class=\"params\">(nums: list)</span> -&gt; list:</span></span><br><span class=\"line\">    n = len(nums)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n<span class=\"number\">-1</span>):</span><br><span class=\"line\">        min_i = i</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i+<span class=\"number\">1</span>, n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[min_i] &gt; nums[j]:</span><br><span class=\"line\">                min_i = j</span><br><span class=\"line\">        nums[min_i], nums[i] = nums[i], nums[min_i]</span><br></pre></td></tr></table></figure>\n<h3 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h3><img src=\"/Python%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/insert_sort.gif\" class>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">insertion</span><span class=\"params\">(ary: list)</span> -&gt; list:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(ary)):</span><br><span class=\"line\">        val, index = ary[i], i</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ary[j] &gt; val:</span><br><span class=\"line\">                ary[j+<span class=\"number\">1</span>] = ary[j]</span><br><span class=\"line\">                index = j</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">        ary[index] = val</span><br></pre></td></tr></table></figure>\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><p>使用切片的方式实现了一个简单的希尔排序，但是希尔排序应该是不产生空间的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">shell_sorted</span><span class=\"params\">(nums)</span>:</span></span><br><span class=\"line\">    res = list(nums)</span><br><span class=\"line\">    n = len(res)</span><br><span class=\"line\">    step = round(n/<span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> step &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(step):</span><br><span class=\"line\">            res[i:n:step] = insert_sorted(res[i:n:step])</span><br><span class=\"line\">        step = round(step/<span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3><img src=\"/Python%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/merge_sort.gif\" class>\n<p>原地归并</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge_sort</span><span class=\"params\">(nums: list)</span>:</span></span><br><span class=\"line\">    _merge_divide(nums, <span class=\"number\">0</span>, len(nums)<span class=\"number\">-1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_merge_divide</span><span class=\"params\">(a, l, r)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> l &gt;= r:</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    mid = (l + r) // <span class=\"number\">2</span></span><br><span class=\"line\">    _merge_divide(a, l, mid)</span><br><span class=\"line\">    _merge_divide(a, mid+<span class=\"number\">1</span>, r)</span><br><span class=\"line\">    _merge(a, l, mid, r)</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_merge</span><span class=\"params\">(a, l, mid, r)</span>:</span></span><br><span class=\"line\">    aux = []</span><br><span class=\"line\">    i, j = l, mid + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> a[mid] &lt;= a[mid+<span class=\"number\">1</span>]:\t<span class=\"comment\"># 有序则跳出</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> i&lt;=mid <span class=\"keyword\">and</span> j&lt;=r:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> a[i] &lt;= a[j]:</span><br><span class=\"line\">            aux.append(a[i])</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            aux.append(a[j])</span><br><span class=\"line\">            j += <span class=\"number\">1</span></span><br><span class=\"line\">    aux += a[i:mid+<span class=\"number\">1</span>] <span class=\"keyword\">or</span> a[j:r+<span class=\"number\">1</span>]</span><br><span class=\"line\">    a[l:r+<span class=\"number\">1</span>] = aux</span><br></pre></td></tr></table></figure>\n<p>自底向上的归并排序。<code>_merge</code>方法都是一样的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge_sort_bu</span><span class=\"params\">(nums: list)</span>:</span></span><br><span class=\"line\">    sz, n = <span class=\"number\">1</span>, len(nums)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> sz &lt;= n:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, n-sz, sz*<span class=\"number\">2</span>):\t<span class=\"comment\"># sz 表示子数组大小</span></span><br><span class=\"line\">            <span class=\"comment\"># 把两个大小为sz的数组归并成一个</span></span><br><span class=\"line\">            _merge(nums, i, i+sz<span class=\"number\">-1</span>, min(i+sz*<span class=\"number\">2</span><span class=\"number\">-1</span>, n<span class=\"number\">-1</span>))</span><br><span class=\"line\">        sz *= <span class=\"number\">2</span></span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_merge</span><span class=\"params\">(a, l, mid, r)</span>:</span></span><br><span class=\"line\">    aux = []</span><br><span class=\"line\">    i, j = l, mid + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> a[mid] &lt;= a[mid+<span class=\"number\">1</span>]:</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> i&lt;=mid <span class=\"keyword\">and</span> j&lt;=r:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> a[i] &lt;= a[j]:</span><br><span class=\"line\">            aux.append(a[i])</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            aux.append(a[j])</span><br><span class=\"line\">            j += <span class=\"number\">1</span></span><br><span class=\"line\">    aux += a[i:mid+<span class=\"number\">1</span>] <span class=\"keyword\">or</span> a[j:r+<span class=\"number\">1</span>]</span><br><span class=\"line\">    a[l:r+<span class=\"number\">1</span>] = aux</span><br></pre></td></tr></table></figure>\n<h3 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h3><p>将数组构建成堆，从最后一个非叶子节点<code>n//2-1</code>对每个节点进行sink操作，完成heapify。</p>\n<p>从堆顶最大的元素，和末尾互换，然后将堆顶元素下沉。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">heap_sort</span><span class=\"params\">(ary)</span>:</span></span><br><span class=\"line\">    n = len(ary)</span><br><span class=\"line\">    <span class=\"comment\"># heapify array</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n//<span class=\"number\">2</span><span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">        __sink(ary, n, i)</span><br><span class=\"line\">       </span><br><span class=\"line\">    <span class=\"comment\"># move maximum to the end, then sink first</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n<span class=\"number\">-1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">        ary[j], ary[<span class=\"number\">0</span>] = ary[<span class=\"number\">0</span>], ary[j]</span><br><span class=\"line\">        __sink(ary, j, <span class=\"number\">0</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__sink</span><span class=\"params\">(ary, n, p)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> p * <span class=\"number\">2</span> + <span class=\"number\">1</span> &lt; n:</span><br><span class=\"line\">        j = p * <span class=\"number\">2</span> + <span class=\"number\">1</span>        <span class=\"comment\"># sink swap with j</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> j + <span class=\"number\">1</span> &lt; n <span class=\"keyword\">and</span> ary[j+<span class=\"number\">1</span>] &gt; ary[j]:\t<span class=\"comment\"># 找到叶子节点中较大的进行替换。</span></span><br><span class=\"line\">            j += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ary[p] &gt;= ary[j]:</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        ary[p], ary[j] = ary[j], ary[p]</span><br><span class=\"line\">        p = j</span><br></pre></td></tr></table></figure>\n<img src=\"/Python%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/summary.jpg\" class>","categories":["算法"],"tags":["Python","Algorithm","Sort"]},{"title":"Hello World","url":"/hello-world/","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.<br><a id=\"more\"></a></p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"工作中项目优化小记","url":"/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E5%B0%8F%E8%AE%B0/","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><h5 id=\"博主目前接手了一个项目，该项目代码从某马微店那里买来，社交金融相关。这个项目的代码可以说是逻辑混乱，毫无可重用性，而且又无文档，git-message中一堆毫无用处的“update”，PEP8规范？不存在的。使得我每日游走在被代码劝退的边缘。\"><a href=\"#博主目前接手了一个项目，该项目代码从某马微店那里买来，社交金融相关。这个项目的代码可以说是逻辑混乱，毫无可重用性，而且又无文档，git-message中一堆毫无用处的“update”，PEP8规范？不存在的。使得我每日游走在被代码劝退的边缘。\" class=\"headerlink\" title=\"博主目前接手了一个项目，该项目代码从某马微店那里买来，社交金融相关。这个项目的代码可以说是逻辑混乱，毫无可重用性，而且又无文档，git message中一堆毫无用处的“update”，PEP8规范？不存在的。使得我每日游走在被代码劝退的边缘。\"></a>博主目前接手了一个项目，该项目代码从某马微店那里买来，社交金融相关。这个项目的代码可以说是逻辑混乱，毫无可重用性，而且又无文档，git message中一堆毫无用处的“update”，PEP8规范？不存在的。使得我每日游走在被代码劝退的边缘。</h5><h5 id><a href=\"#\" class=\"headerlink\" title></a><a id=\"more\"></a></h5><h4 id=\"震惊！一次请求1W多条sql。\"><a href=\"#震惊！一次请求1W多条sql。\" class=\"headerlink\" title=\"震惊！一次请求1W多条sql。\"></a>震惊！一次请求1W多条sql。</h4><p>该功能为商品的热销分类表单。之前大概看了一眼，数据是先从redis中取，redis值存的永久有效，没有的话查DB。然后某天清了一下测试数据库的redis，这下好了，接口超时。查了一下silk发现运行了1w多次sql。</p>\n<img src=\"/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E5%B0%8F%E8%AE%B0/before.png\" class>\n<p>万恶之源的代码，难怪查了1W多次，这外键coupon，每次都要查询数据库。而且这里channel也没有用set，这简直基础数据结构都没掌握啊。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">tbkcoupons = TbkCouponTags.objects.filter(is_hot=<span class=\"literal\">True</span>)</span><br><span class=\"line\">channel = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> tbkcoupons:</span><br><span class=\"line\">    cc = t.coupon.channel</span><br><span class=\"line\">    <span class=\"keyword\">if</span> cc <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> channel:</span><br><span class=\"line\">        channel.append(cc)</span><br></pre></td></tr></table></figure>\n<p>使用select_related简单的处理了一下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">tbkcoupons = TbkCouponTags.objects.select_related(<span class=\"string\">'coupon'</span>).filter(is_hot=<span class=\"literal\">True</span>)</span><br><span class=\"line\">channel = set()</span><br><span class=\"line\"><span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> tbkcoupons:</span><br><span class=\"line\">    cc = t.coupon.channel</span><br><span class=\"line\">    channel.add(cc)</span><br></pre></td></tr></table></figure>\n<img src=\"/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E5%B0%8F%E8%AE%B0/baokuan_1.png\" class>\n<p>快了10倍，冷静一下，思考一下这大哥到底要干嘛，后面看到拿到了<code>tbkcoupons</code>没有再做其他用处。所以这东西完全可以使用反向连接加去重来解决啊，看来sql基础也欠缺。这里改成了values+distinct来处理，因为mysql不支持distinct(‘channel’)这种指定字段的形式。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">tbkcoupons = TbkCoupon.objects.filter(tbkcoupontags__is_hot=<span class=\"literal\">True</span>).values(<span class=\"string\">'channel'</span>).distinct()</span><br><span class=\"line\">channels = [c[<span class=\"string\">'channel'</span>] <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> tbkcoupons]</span><br></pre></td></tr></table></figure>\n<p>后面的逻辑判断，又使用了一堆的<code>ifelse</code>，看着不清晰，将其改为了字典。这些倒不是什么大问题。</p>\n<p>最后，修改了一些取值的逻辑。最后将结果保存到了redis中。命中缓存的话大概10+ms。</p>\n<img src=\"/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E5%B0%8F%E8%AE%B0/baokuan_2.png\" class>\n<p>后来又发现了一个有意思的事情，他好像也知道这个查询挺慢的，所以用celerybeat实现了一个周期任务，定时地更新这个redis。</p>\n<h4 id=\"返回按照当前查询数组顺序的queryset。\"><a href=\"#返回按照当前查询数组顺序的queryset。\" class=\"headerlink\" title=\"返回按照当前查询数组顺序的queryset。\"></a>返回按照当前查询数组顺序的queryset。</h4><p>遇见了这样一个需求 ，收藏列表需要返回按照收藏顺序的商品。而这个顺序保存在java后台。通过Thrift接口调用，返回了一个id列表，而商品保存在我这里。需要根据这个id的顺序返回queryset。<a href=\"https://stackoverflow.com/questions/4916851/django-get-a-queryset-from-array-of-ids-in-specific-order\" target=\"_blank\" rel=\"noopener\">django-get-a-queryset-from-array-of-ids-in-specific-order</a>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> django.db.models <span class=\"keyword\">import</span> Case, When</span><br><span class=\"line\">preserved = Case(*[When(num_iid=num_iid, then=pos) <span class=\"keyword\">for</span> pos, num_iid <span class=\"keyword\">in</span> enumerate(num_iids)])</span><br><span class=\"line\">TbkCoupon.objects.filter(num_iid__in=num_iids).order_by(preserved)</span><br></pre></td></tr></table></figure>\n","categories":["Project"],"tags":["Django","Django-rest-framework"]},{"title":"波义尔摩尔投票算法（Boyer-Moore Voting Algorithm）","url":"/%E6%B3%A2%E4%B9%89%E5%B0%94%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95%EF%BC%88Boyer-Moore-Voting-Algorithm%EF%BC%89/","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><blockquote>\n<p>The Boyer–Moore majority vote algorithm is an algorithm for finding the majority of a sequence of elements using linear time and constant space. It is named after Robert S. Boyer and J Strother Moore, who published it in 1981,[1] and is a prototypical example of a streaming algorithm.</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>波义尔摩尔投票算法是一种使用线性时间复杂度和常数空间复杂度来找到数组的主要元素（出现超过一半次数的元素）。</p>\n<h3 id=\"题目-169-Majority-Element。找出数组中出现超过一半的元素。\"><a href=\"#题目-169-Majority-Element。找出数组中出现超过一半的元素。\" class=\"headerlink\" title=\"题目: 169. Majority Element。找出数组中出现超过一半的元素。\"></a>题目: 169. Majority Element。找出数组中出现超过一半的元素。</h3><blockquote>\n<p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p>\n</blockquote>\n<blockquote>\n<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>\n</blockquote>\n<h3 id=\"《剑指Offer》中的解释\"><a href=\"#《剑指Offer》中的解释\" class=\"headerlink\" title=\"《剑指Offer》中的解释\"></a>《剑指Offer》中的解释</h3><blockquote>\n<p>遍历数组的时候保存两个值：一个是数组中的数字，另一个是次数。当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1；如果下一个数字和我们之前保存的数字不同，则次数减1。如果次数为零，那么需要保存下一个数字，并把次数设为1.由于我们要找的数字出现的次数比其他所有数字出现的次数之和还要多，那么要找的数字肯定是最后一次把次数设为1时的对应数字。</p>\n</blockquote>\n<h3 id=\"整个过程想象成一次投票选举\"><a href=\"#整个过程想象成一次投票选举\" class=\"headerlink\" title=\"整个过程想象成一次投票选举\"></a>整个过程想象成一次投票选举</h3><h4 id=\"投票规则：大屏幕上只允许出现一位候选人。如果选举人投的票不是当前候选人，那么让当前候选人票-1，如果是，则-1。\"><a href=\"#投票规则：大屏幕上只允许出现一位候选人。如果选举人投的票不是当前候选人，那么让当前候选人票-1，如果是，则-1。\" class=\"headerlink\" title=\"投票规则：大屏幕上只允许出现一位候选人。如果选举人投的票不是当前候选人，那么让当前候选人票-1，如果是，则+1。\"></a>投票规则：大屏幕上只允许出现一位候选人。如果选举人投的票不是当前候选人，那么让当前候选人票-1，如果是，则+1。</h4><p>OK，我们现在把所有数组的元素当成是选举人举出的号牌。我们先考虑最极端的情况：最后的<code>winner</code>以一票之差险胜。也就是元素出现的次数为<code>n//2+1</code>。这种情况是如何出现的呢，假设数组是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[7, 7, 7, 7, 1, 2, 3]</span><br></pre></td></tr></table></figure>\n<p>没有投7的选举人假设在一开始知道了最有潜力的<code>winner</code>即7号，那么他们‘同仇敌忾’，将-1的票都投在了7号上，这种情况7号一直处于大屏幕中，没有更换过候选人。但是最后也没能打败7号，因为7号最后还保留一票。</p>\n<p>另外一种非极端的情况，没有投7的选举人产生了‘内讧’：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[7, 1, | 2, 3, | 7, 7, 7]</span><br></pre></td></tr></table></figure>\n<p>首先7号得到一票，然后被1号干掉，接着2号称为候选人，被3号干掉。3号的票浪费在了‘自己人’身上，即‘我们中出了一个叛徒’。就算团结起来都干不过7号，所以<code>winner</code>还是7号。</p>\n<p>最后附上LeetCode上的Python代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">majorityElement</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        count = <span class=\"number\">0</span></span><br><span class=\"line\">        candidate = <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> count == <span class=\"number\">0</span>:</span><br><span class=\"line\">                candidate = num</span><br><span class=\"line\">            count += (<span class=\"number\">1</span> <span class=\"keyword\">if</span> num == candidate <span class=\"keyword\">else</span> <span class=\"number\">-1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> candidate</span><br></pre></td></tr></table></figure>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\" target=\"_blank\" rel=\"noopener\">维基百科</a></li>\n<li><a href=\"https://leetcode.com/problems/majority-element/solution/\" target=\"_blank\" rel=\"noopener\">LeetCode</a></li>\n</ul>\n","categories":["算法"],"tags":["algorithm"]},{"title":"算法篇目录汇总","url":"/%E7%AE%97%E6%B3%95%E7%AF%87%E7%9B%AE%E5%BD%95%E6%B1%87%E6%80%BB/","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>从去年9开始刷算法题，截止到今天，陆续用了大概半年的时间，已经完成《剑指Offer》中的题目，LeetCode中Easy难度的题型也已经基本完成了。由于相关算法博客日益增多，所以建立此目录方便快速查找。另外有一些题型在初期分类不是很合适，所以在完成Easy题之后对所有种类了解的情况下，重新修改一些题的分类。</p>\n<a id=\"more\"></a>\n<h3 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h3><ul>\n<li><a href=\"/%E5%89%91%E6%8C%87Offer/\" title=\"《剑指Offer》\">《剑指Offer》</a></li>\n<li><a href=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%95%B0%E7%BB%84%E7%AF%87%EF%BC%89Array/\" title=\"LeetCode 数组篇\">LeetCode 数组篇</a></li>\n<li><a href=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E9%93%BE%E8%A1%A8%E7%AF%87%EF%BC%89LinkedList/\" title=\"LeetCode 链表篇\">LeetCode 链表篇</a></li>\n<li><a href=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AF%87%EF%BC%89Tree/\" title=\"LeetCode 二叉树篇\">LeetCode 二叉树篇</a></li>\n<li><a href=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%93%88%E5%B8%8C%E7%AF%87%EF%BC%89hashtable/\" title=\"LeetCode 哈希篇\">LeetCode 哈希篇</a></li>\n<li><a href=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AF%87%EF%BC%89String/\" title=\"LeetCode 字符串篇\">LeetCode 字符串篇</a></li>\n<li><a href=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AF%87%EF%BC%89Bit-Manipulation/\" title=\"LeetCode 位运算篇\">LeetCode 位运算篇</a></li>\n<li><a href=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%E5%88%86%E6%B3%95%E7%AF%87%EF%BC%89Binary-Search/\" title=\"LeetCode 二分法篇\">LeetCode 二分法篇</a></li>\n<li><a href=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%9B%9E%E6%BA%AF%E7%AF%87%EF%BC%89BackTracking/\" title=\"LeetCode 回溯篇\">LeetCode 回溯篇</a></li>\n<li><a href=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%A0%88%E7%AF%87%EF%BC%89Stack/\" title=\"LeetCode 栈篇\">LeetCode 栈篇</a></li>\n<li><a href=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%A0%86%E7%AF%87%EF%BC%89Heap/\" title=\"LeetCode 堆篇\">LeetCode 堆篇</a></li>\n<li><a href=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%95%B0%E5%AD%A6%E7%AF%87%EF%BC%89Math/\" title=\"LeetCode 数学篇\">LeetCode 数学篇</a></li>\n<li><a href=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E8%AE%BE%E8%AE%A1%E7%AF%87%EF%BC%89Design/\" title=\"LeetCode 设计篇\">LeetCode 设计篇</a></li>\n<li><a href=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AF%87%EF%BC%89Danymic-Programming/\" title=\"LeetCode 动态规划篇\">LeetCode 动态规划篇</a></li>\n<li><a href=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E8%B4%AA%E5%BF%83%E7%AF%87%EF%BC%89greedy/\" title=\"LeetCode 贪心篇\">LeetCode 贪心篇</a></li>\n<li><a href=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%8D%95%E8%AF%8D%E6%9F%A5%E6%89%BE%E6%A0%91%E7%AF%87%EF%BC%89Trie/\" title=\"LeetCode 单词查找树篇\">LeetCode 单词查找树篇</a></li>\n<li><a href=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%AD%A3%E5%88%99%E7%AF%87%EF%BC%89regex/\" title=\"LeetCode 正则篇\">LeetCode 正则篇</a></li>\n<li><a href=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%9B%BE%E7%AF%87%EF%BC%89Graph/\" title=\"LeetCode 图篇\">LeetCode 图篇</a></li>\n<li><a href=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88sql%E7%AF%87%EF%BC%89sql/\" title=\"LeetCode sql篇\">LeetCode sql篇</a></li>\n<li><a href=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%B9%B6%E5%8F%91%E7%AF%87%EF%BC%89Threading/\" title=\"LeetCode 并发篇\">LeetCode 并发篇</a></li>\n<li><a href=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AF%87%EF%BC%89UnionFind/\" title=\"LeetCode 并查集篇\">LeetCode 并查集篇</a>\n</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>目前收录大概不到300题，但是并没有追求数量，每道题都是先思考用自己的方法做，然后再不断地优化，最后结合Solution和Discuss里大神的写法进行修改。一开始有时候一道题想好几天，后来一天可以完成5，6道题，期间也通过Weekly Contest来测试自己，前几次只能做出一两道题，后来有时候甚至最后一题也差点几步就完成，收货颇丰。刷到差不多后半段的时候，基本上有些题就是换汤不换药，可以用之前的解法做出来，或者是几道题的步骤加起来。</p>\n<p>关于分类，因为LeetCode中的分类其实是多对多的关系，这里博客中并不想记录重复的题，所以分类是没有按照LeetCode中来分的，有时候会根据题目分类，有时候会根据答案的最优解分类。答案中标记绿色的部分表示是最优解，但不唯一；极个别用红色标出为错误答案，因为具有强烈的误导性，所以记录下来。</p>\n<p>期间在Discuss中单方面结识了两位大神，一位叫<code>Stefan Pochmann</code>，另一位叫<code>lee215</code>。两者都是万星大神，博客中有一些题的最优解都是这两位的答案。前者在小题号时比较活跃，后者在大题号时较活跃，他们俩的答案总是给人眼前一亮的感觉，从中学习到了很多，也能应用到其它一些题上。</p>\n<p>关于周赛，周赛的时候感觉又和刷别的题不一样，周赛一般的解法偏向于解答速度，有什么现成的库就直接用，哪个解法最稳用那个，因为Bug会有惩罚时间，排行榜前十的也是这么做的。而平时刷题更倾向于时间复杂度和空间复杂度低，并且写法优雅。</p>\n<p>有时候Discuss中也没有自己满意的答案，也会自己冥思苦想想出一个优雅的解法，然后Share给大家，获得几个点赞。这种赞同还有看到Contest上升的排名，都会让自己信心十足，去面对更加艰难的挑战。2019年给自己定了一个小目标，解题达到500+，rating达到1800+，star达到200+。接下来准备重新整理一下目前的题，然后按照类别进行一次解答，疑难题会记录到LeetCode的<code>flashcard</code>中反复训练。不断告诉自己，不要为了刷题而刷题，重要的是思考的过程。然后优化一些还不够优雅的答案，最后迈向Medium难度。</p>\n","categories":["算法"],"tags":["Python","Algorithm"]},{"title":"约瑟夫环问题（Josephus problem）","url":"/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98%EF%BC%88Josephus-problem%EF%BC%89/","content":"<h3 id=\"问题：0，1，…，n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求这个圆圈里剩下的最后一个数字。\"><a href=\"#问题：0，1，…，n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求这个圆圈里剩下的最后一个数字。\" class=\"headerlink\" title=\"问题：0，1，…，n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求这个圆圈里剩下的最后一个数字。\"></a>问题：0，1，…，n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求这个圆圈里剩下的最后一个数字。</h3><a id=\"more\"></a>\n<p>注意到，一开始有 n 个人，报到 m 的人出局后，如果我们从刚才出局的那人的下一位开始重新从 1 开始编号，原问题就转化为了一个 n–1 人的问题。如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th>原始编号(i)</th>\n<th>第一个人出局后的编号(j)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>m</td>\n<td>0</td>\n</tr>\n<tr>\n<td>m+1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>m+2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>…</td>\n<td>…</td>\n</tr>\n<tr>\n<td>m-2</td>\n<td>n-2 （n为出局前的总人数）</td>\n</tr>\n<tr>\n<td>m-1</td>\n<td>OUT</td>\n</tr>\n</tbody>\n</table>\n<p>可以看出老编号i和新编号j的关系为：<code>i = (j+m) % n</code>，于是总结递推公式：</p>\n<p><code>f(n) = (f(n-1) + m) % n</code>   (n &gt; 1)，其中f(n)为当场上还有n个人时在场的人的编号。<br>当最后只剩下一个人的时候，这个人的编号只能是0，即<code>f(1)=0</code>，现在根据上面的公式反推，推导出当n个人在场时这个最后幸存者的编号。例如：<code>f(2)=(f(1)+m) % 2</code>，所以<code>range</code>范围从2开始，执行<code>n-1</code>次，也就是<code>range(2, n+1)</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">LastRemaining_Solution</span><span class=\"params\">(self, n, m)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># write code here</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> n&lt;=<span class=\"number\">0</span> <span class=\"keyword\">or</span> m&lt;=<span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    last_num = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>, n+<span class=\"number\">1</span>):</span><br><span class=\"line\">        last_num = (last_num+m) % i</span><br><span class=\"line\">    <span class=\"keyword\">return</span> last_num</span><br></pre></td></tr></table></figure>\n","categories":["算法"],"tags":["Python","algorithm","剑指Offer"]},{"title":"龟速爬天梯","url":"/%E9%BE%9F%E9%80%9F%E7%88%AC%E5%A4%A9%E6%A2%AF/","content":"<h3 id=\"好激动，第一次离大神这么近\"><a href=\"#好激动，第一次离大神这么近\" class=\"headerlink\" title=\"好激动，第一次离大神这么近\"></a>好激动，第一次离大神这么近</h3><p>像每个周日一样，9点半起来，然后点了外卖，整理了一下最近的笔记。然后开始等待LeetCode Contest的到来。这周的题确实相对来说比较简单，做着做着发现到了最后一题。然后最后一题也只有Medium难度。感觉还没有Q3难，用了递归就做出来了。</p>\n<a id=\"more\"></a>\n<p>惊奇的发现，居然用了一小时就做完了。以前有时还会卡在第3题，然后看了排行榜，开始还有点担心，Q2是否算作弊，不过后来完成了一看，排行榜前十的大神也是这么写的，而且还没我写的优雅，（虽然用了三方库）。</p>\n<p>吃过早饭，然后该review一下题目，优化一下解法并整理到相关博客中。给自己定个小目标，向前200努力。</p>\n<p>好气，lee神居然比我先发了答案，我俩的方法是一样的，😦错过了好几个赞。</p>\n<img src=\"/%E9%BE%9F%E9%80%9F%E7%88%AC%E5%A4%A9%E6%A2%AF/rank.png\" class>\n","categories":["记录"],"tags":["LeetCode","Python"]},{"title":"LeetCode算法题整理（单词查找树篇）Trie","url":"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%8D%95%E8%AF%8D%E6%9F%A5%E6%89%BE%E6%A0%91%E7%AF%87%EF%BC%89Trie/","content":"<p>此篇为预留篇章，其中的算法有些还未使用Trie进行优化。</p>\n<h3 id=\"1023-Camelcase-Matching\"><a href=\"#1023-Camelcase-Matching\" class=\"headerlink\" title=\"1023. Camelcase Matching\"></a>1023. Camelcase Matching</h3><h4 id=\"驼峰匹配。原题\"><a href=\"#驼峰匹配。原题\" class=\"headerlink\" title=\"驼峰匹配。原题\"></a>驼峰匹配。<a href=\"https://leetcode.com/problems/camelcase-matching/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: queries &#x3D; [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern &#x3D; &quot;FB&quot;</span><br><span class=\"line\">Output: [true,false,true,true,false]</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">&quot;FooBar&quot; can be generated like this &quot;F&quot; + &quot;oo&quot; + &quot;B&quot; + &quot;ar&quot;.</span><br><span class=\"line\">&quot;FootBall&quot; can be generated like this &quot;F&quot; + &quot;oot&quot; + &quot;B&quot; + &quot;all&quot;.</span><br><span class=\"line\">&quot;FrameBuffer&quot; can be generated like this &quot;F&quot; + &quot;rame&quot; + &quot;B&quot; + &quot;uffer&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">[&quot;CompetitiveProgramming&quot;,&quot;CounterPick&quot;,&quot;ControlPanel&quot;]</span><br><span class=\"line\">&quot;CooP&quot;</span><br><span class=\"line\">[false,false,true]</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>方法一：竞赛时AC的方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">camelMatch</span><span class=\"params\">(self, queries: List[str], pattern: str)</span> -&gt; List[bool]:</span></span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> queries:</span><br><span class=\"line\">        p = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, c <span class=\"keyword\">in</span> enumerate(word):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> p == len(pattern):</span><br><span class=\"line\">                ans.append(all(char.islower() <span class=\"keyword\">for</span> char <span class=\"keyword\">in</span> word[i:]))</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> c == pattern[p]:</span><br><span class=\"line\">                p += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> c.isupper():</span><br><span class=\"line\">                    ans.append(<span class=\"literal\">False</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            ans.append(all(char.islower() <span class=\"keyword\">for</span> char <span class=\"keyword\">in</span> pattern[p:]))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：首先判断单词和<code>pattern</code>是否具有相同的大写字母。<code>iter</code>保证了每次c开始的位置是从上一个匹配结束的地方开始的。这个非常重要，保证了比较的顺序。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">camelMatch</span><span class=\"params\">(self, qs: List[str], p: str)</span> -&gt; List[bool]:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">u</span><span class=\"params\">(s)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> [c <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> s <span class=\"keyword\">if</span> c.isupper()]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">issub</span><span class=\"params\">(s, t)</span>:</span></span><br><span class=\"line\">        it = iter(t)        <span class=\"comment\"># importand, pass the `Coop` testcase</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> all(c <span class=\"keyword\">in</span> it <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> p)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [u(q)==u(p) <span class=\"keyword\">and</span> issub(p, q) <span class=\"keyword\">for</span> q <span class=\"keyword\">in</span> qs]</span><br></pre></td></tr></table></figure>\n<h3 id=\"212-Word-Search-II\"><a href=\"#212-Word-Search-II\" class=\"headerlink\" title=\"212. Word Search II\"></a>212. Word Search II</h3><h4 id=\"在矩阵中搜索多个单词，返回存在的单词。原题\"><a href=\"#在矩阵中搜索多个单词，返回存在的单词。原题\" class=\"headerlink\" title=\"在矩阵中搜索多个单词，返回存在的单词。原题\"></a>在矩阵中搜索多个单词，返回存在的单词。<a href=\"https://leetcode.com/problems/word-search-ii/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: </span><br><span class=\"line\">board &#x3D; [</span><br><span class=\"line\">  [&#39;o&#39;,&#39;a&#39;,&#39;a&#39;,&#39;n&#39;],</span><br><span class=\"line\">  [&#39;e&#39;,&#39;t&#39;,&#39;a&#39;,&#39;e&#39;],</span><br><span class=\"line\">  [&#39;i&#39;,&#39;h&#39;,&#39;k&#39;,&#39;r&#39;],</span><br><span class=\"line\">  [&#39;i&#39;,&#39;f&#39;,&#39;l&#39;,&#39;v&#39;]</span><br><span class=\"line\">]</span><br><span class=\"line\">words &#x3D; [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">Output: [&quot;eat&quot;,&quot;oath&quot;]</span><br></pre></td></tr></table></figure>\n<p>方法一：和单词搜索一样，大体的原理还是回溯法，但是要考虑一些优化，所以用Trie 这里有个地方注意要在循环刚开始前将g[i][j]设为’#’不能过早地放在return 前。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TrieNode</span>:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.child = collections.defaultdict(TrieNode)</span><br><span class=\"line\">        self.is_word = <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Trie</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.root = TrieNode()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">insert</span><span class=\"params\">(self, word: str)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        cur = self.root</span><br><span class=\"line\">        <span class=\"keyword\">for</span> letter <span class=\"keyword\">in</span> word:</span><br><span class=\"line\">            cur = cur.child[letter]</span><br><span class=\"line\">        cur.is_word = <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">search</span><span class=\"params\">(self, word: str)</span> -&gt; bool:</span></span><br><span class=\"line\">        cur = self.root</span><br><span class=\"line\">        <span class=\"keyword\">for</span> letter <span class=\"keyword\">in</span> word:</span><br><span class=\"line\">            cur = cur.child.get(letter)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> cur:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> cur.is_word</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findWords</span><span class=\"params\">(self, g: List[List[str]], words: List[str])</span> -&gt; List[str]:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(i, j, node, path)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.is_word:</span><br><span class=\"line\">                ans.append(path)</span><br><span class=\"line\">                node.is_word = <span class=\"literal\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> R&gt;i&gt;=<span class=\"number\">0</span>&lt;=j&lt;C:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> </span><br><span class=\"line\">            tmp = g[i][j]</span><br><span class=\"line\">            node = node.child.get(tmp)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> </span><br><span class=\"line\">            g[i][j] = <span class=\"string\">'#'</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> ((i<span class=\"number\">-1</span>, j), (i+<span class=\"number\">1</span>, j), (i, j<span class=\"number\">-1</span>), (i, j+<span class=\"number\">1</span>)):</span><br><span class=\"line\">                dfs(x, y, node, path+tmp)</span><br><span class=\"line\">            g[i][j] = tmp</span><br><span class=\"line\">        </span><br><span class=\"line\">        R, C = len(g), len(g[<span class=\"number\">0</span>])</span><br><span class=\"line\">        ans = []</span><br><span class=\"line\">        trie = Trie()</span><br><span class=\"line\">        node = trie.root</span><br><span class=\"line\">        <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> words:</span><br><span class=\"line\">            trie.insert(w)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(R):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(C):</span><br><span class=\"line\">                dfs(i, j, node, <span class=\"string\">\"\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"211-Add-and-Search-Word-Data-structure-design\"><a href=\"#211-Add-and-Search-Word-Data-structure-design\" class=\"headerlink\" title=\"211. Add and Search Word - Data structure design\"></a>211. Add and Search Word - Data structure design</h3><h4 id=\"和前缀单词查找树题一样，区别在于，这里搜索的时候可以使用’-’来匹配所有的字母。原题\"><a href=\"#和前缀单词查找树题一样，区别在于，这里搜索的时候可以使用’-’来匹配所有的字母。原题\" class=\"headerlink\" title=\"和前缀单词查找树题一样，区别在于，这里搜索的时候可以使用’.’来匹配所有的字母。原题\"></a>和前缀单词查找树题一样，区别在于，这里搜索的时候可以使用’.’来匹配所有的字母。<a href=\"https://leetcode.com/problems/add-and-search-word-data-structure-design/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">addWord(&quot;bad&quot;)</span><br><span class=\"line\">addWord(&quot;dad&quot;)</span><br><span class=\"line\">addWord(&quot;mad&quot;)</span><br><span class=\"line\">search(&quot;pad&quot;) -&gt; false</span><br><span class=\"line\">search(&quot;bad&quot;) -&gt; true</span><br><span class=\"line\">search(&quot;.ad&quot;) -&gt; true</span><br><span class=\"line\">search(&quot;b..&quot;) -&gt; true</span><br></pre></td></tr></table></figure>\n<p>方法一：Trie + dfs.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TrieNode</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.child = collections.defaultdict(TrieNode)</span><br><span class=\"line\">        self.is_word = <span class=\"literal\">False</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordDictionary</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.root = TrieNode()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addWord</span><span class=\"params\">(self, word: str)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        cur = self.root</span><br><span class=\"line\">        <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> word:</span><br><span class=\"line\">            cur = cur.child[c]</span><br><span class=\"line\">        cur.is_word = <span class=\"literal\">True</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">search</span><span class=\"params\">(self, word: str)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(cur, w)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> cur:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> w:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> cur.is_word</span><br><span class=\"line\">            <span class=\"keyword\">if</span> w[<span class=\"number\">0</span>] != <span class=\"string\">'.'</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> dfs(cur.child.get(w[<span class=\"number\">0</span>]), w[<span class=\"number\">1</span>:])</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> any(dfs(c, w[<span class=\"number\">1</span>:]) <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> cur.child.values())</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs(self.root, word)</span><br></pre></td></tr></table></figure>\n<h3 id=\"820-Short-Encoding-of-Words\"><a href=\"#820-Short-Encoding-of-Words\" class=\"headerlink\" title=\"820. Short Encoding of Words\"></a>820. Short Encoding of Words</h3><h4 id=\"这个题描述的有点乱，简单来说就是将一个单词列表转成另一个单词列表，使前者的单词每一个都是后者的后缀。求列表的长度加上分隔符-。原题\"><a href=\"#这个题描述的有点乱，简单来说就是将一个单词列表转成另一个单词列表，使前者的单词每一个都是后者的后缀。求列表的长度加上分隔符-。原题\" class=\"headerlink\" title=\"这个题描述的有点乱，简单来说就是将一个单词列表转成另一个单词列表，使前者的单词每一个都是后者的后缀。求列表的长度加上分隔符#。原题\"></a>这个题描述的有点乱，简单来说就是将一个单词列表转成另一个单词列表，使前者的单词每一个都是后者的后缀。求列表的长度加上分隔符#。<a href=\"https://leetcode.com/problems/short-encoding-of-words/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: words &#x3D; [&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]</span><br><span class=\"line\">Output: 10</span><br><span class=\"line\">Explanation: S &#x3D; &quot;time#bell#&quot; and indexes &#x3D; [0, 2, 5].</span><br></pre></td></tr></table></figure>\n<p>方法一：因为数据不都大，所以直接用set。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minimumLengthEncoding</span><span class=\"params\">(self, words: List[str])</span> -&gt; int:</span></span><br><span class=\"line\">    s = set(words)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> words:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(w)):</span><br><span class=\"line\">            s.discard(w[i:])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(len(w)+<span class=\"number\">1</span> <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> s)</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：单词查找树。最后不为空的node表示只是后缀的一部分。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minimumLengthEncoding</span><span class=\"params\">(self, words: List[str])</span> -&gt; int:</span></span><br><span class=\"line\">    root = dict()</span><br><span class=\"line\">    leaves = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> set(words):</span><br><span class=\"line\">        cur = root</span><br><span class=\"line\">        <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> reversed(word):</span><br><span class=\"line\">            cur[w] = cur = cur.get(w, dict())</span><br><span class=\"line\">        leaves.append((cur, len(word)+<span class=\"number\">1</span>))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(d <span class=\"keyword\">for</span> node, d <span class=\"keyword\">in</span> leaves <span class=\"keyword\">if</span> len(node)==<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"1032-Stream-of-Characters\"><a href=\"#1032-Stream-of-Characters\" class=\"headerlink\" title=\"1032. Stream of Characters\"></a>1032. Stream of Characters</h3><h4 id=\"给定一些单词，查询字母，判断是否能和前k步的字母组成某个单词。原题\"><a href=\"#给定一些单词，查询字母，判断是否能和前k步的字母组成某个单词。原题\" class=\"headerlink\" title=\"给定一些单词，查询字母，判断是否能和前k步的字母组成某个单词。原题\"></a>给定一些单词，查询字母，判断是否能和前k步的字母组成某个单词。<a href=\"https://leetcode.com/problems/stream-of-characters/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">StreamChecker streamChecker &#x3D; new StreamChecker([&quot;cd&quot;,&quot;f&quot;,&quot;kl&quot;]); &#x2F;&#x2F; init the dictionary.</span><br><span class=\"line\">streamChecker.query(&#39;a&#39;);          &#x2F;&#x2F; return false</span><br><span class=\"line\">streamChecker.query(&#39;b&#39;);          &#x2F;&#x2F; return false</span><br><span class=\"line\">streamChecker.query(&#39;c&#39;);          &#x2F;&#x2F; return false</span><br><span class=\"line\">streamChecker.query(&#39;d&#39;);          &#x2F;&#x2F; return true, because &#39;cd&#39; is in the wordlist</span><br><span class=\"line\">streamChecker.query(&#39;e&#39;);          &#x2F;&#x2F; return false</span><br><span class=\"line\">streamChecker.query(&#39;f&#39;);          &#x2F;&#x2F; return true, because &#39;f&#39; is in the wordlist</span><br><span class=\"line\">streamChecker.query(&#39;g&#39;);          &#x2F;&#x2F; return false</span><br><span class=\"line\">streamChecker.query(&#39;h&#39;);          &#x2F;&#x2F; return false</span><br><span class=\"line\">streamChecker.query(&#39;i&#39;);          &#x2F;&#x2F; return false</span><br><span class=\"line\">streamChecker.query(&#39;j&#39;);          &#x2F;&#x2F; return false</span><br><span class=\"line\">streamChecker.query(&#39;k&#39;);          &#x2F;&#x2F; return false</span><br><span class=\"line\">streamChecker.query(&#39;l&#39;);          &#x2F;&#x2F; return true, because &#39;kl&#39; is in the wordlist</span><br></pre></td></tr></table></figure>\n<p>方法一：我写的方法和这个差不多，但是超时了，这里Lee用了一些内置的方法，才不会超时。但是耗时也很长。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StreamChecker</span>:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, words: List[str])</span>:</span></span><br><span class=\"line\">        T = <span class=\"keyword\">lambda</span>: collections.defaultdict(T)</span><br><span class=\"line\">        self.trie = T()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> words:</span><br><span class=\"line\">            reduce(dict.__getitem__, w, self.trie)[<span class=\"string\">'#'</span>] = <span class=\"literal\">True</span></span><br><span class=\"line\">        self.waiting = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">query</span><span class=\"params\">(self, letter: str)</span> -&gt; bool:</span></span><br><span class=\"line\">        self.waiting = [node[letter] <span class=\"keyword\">for</span> node <span class=\"keyword\">in</span> self.waiting + [self.trie] <span class=\"keyword\">if</span> letter <span class=\"keyword\">in</span> node]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> any(<span class=\"string\">'#'</span> <span class=\"keyword\">in</span> node <span class=\"keyword\">for</span> node <span class=\"keyword\">in</span> self.waiting)</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：这个方法倒置单词存储，这样可以提前退出循环，而且维持一个最大的单词的长度即可。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StreamChecker</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, words: List[str])</span>:</span></span><br><span class=\"line\">        T = <span class=\"keyword\">lambda</span>: collections.defaultdict(T)</span><br><span class=\"line\">        self.trie = T()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> words:</span><br><span class=\"line\">            reduce(dict.__getitem__, w[::<span class=\"number\">-1</span>], self.trie)[<span class=\"string\">'#'</span>] = <span class=\"literal\">True</span></span><br><span class=\"line\">        self.S = <span class=\"string\">\"\"</span></span><br><span class=\"line\">        self.W = max(map(len, words))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">query</span><span class=\"params\">(self, letter: str)</span> -&gt; bool:</span></span><br><span class=\"line\">        self.S = (letter + self.S)[:self.W]</span><br><span class=\"line\">        cur = self.trie</span><br><span class=\"line\">        <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> self.S:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> c <span class=\"keyword\">in</span> cur:</span><br><span class=\"line\">                cur = cur[c]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> cur[<span class=\"string\">'#'</span>]:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n","categories":["算法"],"tags":["LeetCode","Python","Algorithm","Trie"]},{"title":"hexo搭建遇到的问题及优化","url":"/hexo%E6%90%AD%E5%BB%BA%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E4%BC%98%E5%8C%96/","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>终于有了一个整理自己学习笔记的地方了，之前用过印象笔记，觉得它的markdown格式处理得不是很完美，复制粘贴出来总是格式不对。后来又用过jupyter_nootboke，但是不方便在其它客户端查看。<br><a id=\"more\"></a><br>折腾了半天终于弄好了期间遇到过不少坑，发现hexo有时候同一样的问题总是对应着几种不同的解决方法，在此整理一下以便之后遇到问题。</p>\n<h3 id=\"关于问题\"><a href=\"#关于问题\" class=\"headerlink\" title=\"关于问题\"></a>关于问题</h3><p><a href=\"https://github.com/iissnan/hexo-theme-next\" target=\"_blank\" rel=\"noopener\">NexT</a>这里使用了next主题，这个主题特别简洁，还有很多易用性的扩展，尤其侧边栏的快速定位，让我爱不释手。</p>\n<h4 id=\"头像不显示\"><a href=\"#头像不显示\" class=\"headerlink\" title=\"头像不显示\"></a>头像不显示</h4><p>开始按照<code>_config.yml</code>中所说把<code>avatar.gif</code>放到<code>blog-site/source/</code>下，没有任何的作用。后来发现是主题的原因，放到<code>themes/next/source/images/</code>下就好了，默认的头像是正方形的，这里修改了一下代码把它改成圆形，文件位置在<br><code>themes/next/source/css_common_components/sidebar/sidebar-author.styl</code></p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.site-author-image</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span> auto;</span><br><span class=\"line\">  <span class=\"attribute\">max-width</span>: <span class=\"number\">96px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: auto;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">2px</span> solid <span class=\"number\">#333</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">2px</span>;  </span><br><span class=\"line\">  <span class=\"comment\">/* start*/</span></span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">80px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-border-radius</span>: <span class=\"number\">80px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">-moz-border-radius</span>: <span class=\"number\">80px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">box-shadow</span>: inset <span class=\"number\">0</span> -<span class=\"number\">1px</span> <span class=\"number\">0</span> <span class=\"number\">#333</span>sf;</span><br><span class=\"line\">  <span class=\"comment\">/* end */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"网页图标favicon-ico不显示\"><a href=\"#网页图标favicon-ico不显示\" class=\"headerlink\" title=\"网页图标favicon.ico不显示\"></a>网页图标favicon.ico不显示</h4><p>这里也是因为Next的原因，把<code>favicon.ico</code>放到<code>themes/next/source/images/</code>下，然后修改<code>_config.yml</code>中<code>favicon: /images/favicon.ico</code>解决了问题。这里介绍一个很方便转换ico的网站<a href=\"http://tool.lu/favicon/]\" target=\"_blank\" rel=\"noopener\">favicon在线制作</a>。</p>\n<h4 id=\"没有建立资源文件夹\"><a href=\"#没有建立资源文件夹\" class=\"headerlink\" title=\"没有建立资源文件夹\"></a>没有建立资源文件夹</h4><ul>\n<li><p>设置<code>post_asset_foler: true</code>之后执行<code>hexo new post_name</code>后没有建立资源文件夹。搜索没有查到相关记录，后来想到之前next主题设置时，把配置文件拆分了出来，这样每次执行<code>hexo clean/generate</code>的时候在后面加了参数<code>--config</code>指定了配置文件。但是这样修改的文件对于<code>hexo new post_name</code>来说是没有修过的，所以要在<code>source/_config.yml</code>修改这项参数。</p>\n</li>\n<li><p><del>之后没有选择官方的标签插件是因为，在编辑markdown时无法看到预览效果所以安装<code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code>，在文章中使用markdown语法引用<code>![logo](&lt;title_name&gt;/a.png)</code>使用。</del></p>\n</li>\n<li>选择官方的标签插件<code><img src=\"/hexo%E6%90%AD%E5%BB%BA%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E4%BC%98%E5%8C%96/a.png\" class title=\"test\"></code>引用图片。</li>\n</ul>\n<h3 id=\"关于优化\"><a href=\"#关于优化\" class=\"headerlink\" title=\"关于优化\"></a>关于优化</h3><h4 id=\"在右上角或者左上角实现fork-me-on-github\"><a href=\"#在右上角或者左上角实现fork-me-on-github\" class=\"headerlink\" title=\"在右上角或者左上角实现fork me on github\"></a>在右上角或者左上角实现fork me on github</h4><p>在<a href=\"http://tholman.com/github-corners/\" target=\"_blank\" rel=\"noopener\">这里</a>选择喜欢的样式。这里选择的是</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"https://your-url\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"github-corner\"</span> <span class=\"attr\">aria-label</span>=<span class=\"string\">\"View source on Github\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">svg</span> <span class=\"attr\">width</span>=<span class=\"string\">\"80\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"80\"</span> <span class=\"attr\">viewBox</span>=<span class=\"string\">\"0 0 250 250\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;\"</span> <span class=\"attr\">aria-hidden</span>=<span class=\"string\">\"true\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">d</span>=<span class=\"string\">\"M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">path</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">d</span>=<span class=\"string\">\"M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2\"</span> <span class=\"attr\">fill</span>=<span class=\"string\">\"currentColor\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"transform-origin: 130px 106px;\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"octo-arm\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">path</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">d</span>=<span class=\"string\">\"M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z\"</span> <span class=\"attr\">fill</span>=<span class=\"string\">\"currentColor\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"octo-body\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">path</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">svg</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"css\"><span class=\"selector-class\">.github-corner</span><span class=\"selector-pseudo\">:hover</span> <span class=\"selector-class\">.octo-arm</span>&#123;<span class=\"attribute\">animation</span>:octocat-wave <span class=\"number\">560ms</span> ease-in-out&#125;<span class=\"keyword\">@keyframes</span> octocat-wave&#123;0%,100%&#123;<span class=\"attribute\">transform</span>:<span class=\"built_in\">rotate</span>(<span class=\"number\">0</span>)&#125;20%,60%&#123;<span class=\"attribute\">transform</span>:<span class=\"built_in\">rotate</span>(-<span class=\"number\">25deg</span>)&#125;40%,80%&#123;<span class=\"attribute\">transform</span>:<span class=\"built_in\">rotate</span>(<span class=\"number\">10deg</span>)&#125;&#125;<span class=\"keyword\">@media</span> (<span class=\"attribute\">max-width:</span><span class=\"number\">500px</span>)&#123;<span class=\"selector-class\">.github-corner</span><span class=\"selector-pseudo\">:hover</span> <span class=\"selector-class\">.octo-arm</span>&#123;<span class=\"attribute\">animation</span>:none&#125;<span class=\"selector-class\">.github-corner</span> <span class=\"selector-class\">.octo-arm</span>&#123;<span class=\"attribute\">animation</span>:octocat-wave <span class=\"number\">560ms</span> ease-in-out&#125;&#125;</span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>将其粘贴到<code>themes/next/layout/_layout.swig</code>中，放在<code>div class=&quot;headhand&quot;&gt;&lt;/div&gt;</code>下面。</p>\n<h4 id=\"修改文章底部的那个带-号的标签\"><a href=\"#修改文章底部的那个带-号的标签\" class=\"headerlink\" title=\"修改文章底部的那个带#号的标签\"></a>修改文章底部的那个带#号的标签</h4><p>修改模板<code>/themes/next/layout/_macro/post.swig</code>，搜索<code>rel=&quot;tag&quot;&gt;#</code>，将#换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></p>\n<h4 id=\"侧边栏社交小图标设置\"><a href=\"#侧边栏社交小图标设置\" class=\"headerlink\" title=\"侧边栏社交小图标设置\"></a>侧边栏社交小图标设置</h4><p>在配置文件搜索<code>social_icons</code>，把值换成喜欢的图标名字<br>，这里列出了<a href=\"http://fontawesome.io/icons/\" target=\"_blank\" rel=\"noopener\">图标库</a></p>\n<h4 id=\"在网站底部加上访问量\"><a href=\"#在网站底部加上访问量\" class=\"headerlink\" title=\"在网站底部加上访问量\"></a>在网站底部加上访问量</h4><p>打开<code>/themes/next/layout/_partials/footer.swig</code>文件添加红框内的代码</p>\n<img src=\"/hexo%E6%90%AD%E5%BB%BA%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E4%BC%98%E5%8C%96/a.png\" class title=\"location\">\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script <span class=\"keyword\">async</span> src=<span class=\"string\">\"https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"</span>&gt;&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<p>添加统计代码如下位置<br><img src=\"/hexo%E6%90%AD%E5%BB%BA%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E4%BC%98%E5%8C%96/count.png\" class title=\"also use pv\"></p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div class=\"powered-by\"&gt;</span><br><span class=\"line\">&lt;i class=\"fa fa-user-md\"&gt;&lt;/i&gt;&lt;span id=\"busuanzi_container_site_uv\"&gt;</span><br><span class=\"line\">  本站访客数:&lt;span id=\"busuanzi_value_site_uv\"&gt;&lt;/span&gt;</span><br><span class=\"line\">&lt;/span&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"网站底部字数统计\"><a href=\"#网站底部字数统计\" class=\"headerlink\" title=\"网站底部字数统计\"></a>网站底部字数统计</h4><p>根目录安装<code>npm install hexo-wordcount --save</code><br>然后再<code>/themes/next/layout/_partials/footer.swig</code>文件最后加上</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div class&#x3D;&quot;theme-info&quot;&gt;</span><br><span class=\"line\">  &lt;div class&#x3D;&quot;powered-by&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class=\"line\">  &lt;span class&#x3D;&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;&#x2F;span&gt;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"添加顶部加载条\"><a href=\"#添加顶部加载条\" class=\"headerlink\" title=\"添加顶部加载条\"></a>添加顶部加载条</h4><p><code>_config.yml</code>设置中<code>pace:true</code></p>\n<h4 id=\"在文章底部增加版权信息\"><a href=\"#在文章底部增加版权信息\" class=\"headerlink\" title=\"在文章底部增加版权信息\"></a>在文章底部增加版权信息</h4><p>在目录<code>themes/next/layout/_macro/</code>下添加<code>my-copyright.swig</code>:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;% <span class=\"keyword\">if</span> page.copyright %&#125;</span><br><span class=\"line\">&lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"my_post_copyright\"</span>&gt;</span><br><span class=\"line\">  &lt;script src=<span class=\"string\">\"//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js\"</span>&gt;&lt;<span class=\"regexp\">/script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  </span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;!-- JS库 sweetalert 可修改路径 --&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;script src=\"https:/</span><span class=\"regexp\">/cdn.bootcss.com/</span>jquery/<span class=\"number\">2.0</span><span class=\"number\">.0</span>/jquery.min.js<span class=\"string\">\"&gt;&lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;script src=\"</span>https:<span class=\"comment\">//unpkg.com/sweetalert/dist/sweetalert.min.js\"&gt;&lt;/script&gt;</span></span><br><span class=\"line\">  &lt;p&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>本文标题:<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"&#123;&#123; url_for(page.path) &#125;&#125;\"</span>&gt;</span>&#123;&#123; page.title &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span>&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;p&gt;&lt;span&gt;文章作者:&lt;/</span>span&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"/\"</span> <span class=\"attr\">title</span>=<span class=\"string\">\"访问 &#123;&#123; theme.author &#125;&#125; 的个人博客\"</span>&gt;</span>&#123;&#123; theme.author &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span>&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;p&gt;&lt;span&gt;发布时间:&lt;/</span>span&gt;&#123;&#123; page.date.format(<span class=\"string\">\"YYYY年MM月DD日 - HH:MM\"</span>) &#125;&#125;&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;p&gt;&lt;span&gt;最后更新:&lt;/</span>span&gt;&#123;&#123; page.updated.format(<span class=\"string\">\"YYYY年MM月DD日 - HH:MM\"</span>) &#125;&#125;&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;p&gt;&lt;span&gt;原始链接:&lt;/</span>span&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"&#123;&#123; url_for(page.path) &#125;&#125;\"</span> <span class=\"attr\">title</span>=<span class=\"string\">\"&#123;&#123; page.title &#125;&#125;\"</span>&gt;</span>&#123;&#123; page.permalink &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span></span><br><span class=\"line\">    &lt;span <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"copy-path\"</span>  title=<span class=\"string\">\"点击复制文章链接\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">i</span> <span class=\"attr\">class</span>=<span class=\"string\">\"fa fa-clipboard\"</span> <span class=\"attr\">data-clipboard-text</span>=<span class=\"string\">\"&#123;&#123; page.permalink &#125;&#125;\"</span>  <span class=\"attr\">aria-label</span>=<span class=\"string\">\"复制成功！\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">i</span>&gt;</span></span>&lt;<span class=\"regexp\">/span&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;/</span>p&gt;</span><br><span class=\"line\">  &lt;p&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>许可协议:<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">i</span> <span class=\"attr\">class</span>=<span class=\"string\">\"fa fa-creative-commons\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">i</span>&gt;</span></span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"license\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"https://creativecommons.org/licenses/by-nc-nd/4.0/\"</span> <span class=\"attr\">target</span>=<span class=\"string\">\"_blank\"</span> <span class=\"attr\">title</span>=<span class=\"string\">\"Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)\"</span>&gt;</span>署名-非商业性使用-禁止演绎 4.0 国际<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span> 转载请保留原文链接及作者。&lt;<span class=\"regexp\">/p&gt;  </span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>div&gt;</span><br><span class=\"line\">&lt;script&gt; </span><br><span class=\"line\">    <span class=\"keyword\">var</span> clipboard = <span class=\"keyword\">new</span> Clipboard(<span class=\"string\">'.fa-clipboard'</span>);</span><br><span class=\"line\">    $(<span class=\"string\">\".fa-clipboard\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      clipboard.on(<span class=\"string\">'success'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        swal(&#123;   </span><br><span class=\"line\">          title: <span class=\"string\">\"\"</span>,   </span><br><span class=\"line\">          text: <span class=\"string\">'复制成功'</span>,</span><br><span class=\"line\">          icon: <span class=\"string\">\"success\"</span>, </span><br><span class=\"line\">          showConfirmButton: <span class=\"literal\">true</span></span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">    &#125;);  </span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure>\n<p>在目录<code>themes/next/source/css/_common/components/post/</code>下添加<code>my-post-copyright.styl</code>:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.my_post_copyright</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">85%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">max-width</span>: <span class=\"number\">45em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">2.8em</span> auto <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">0.5em</span> <span class=\"number\">1.0em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#d3d3d3</span>;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">0.93rem</span>;</span><br><span class=\"line\">  <span class=\"attribute\">line-height</span>: <span class=\"number\">1.6em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">word-break</span>: break-all;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">rgba</span>(<span class=\"number\">255</span>,<span class=\"number\">255</span>,<span class=\"number\">255</span>,<span class=\"number\">0.4</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.my_post_copyright</span> <span class=\"selector-tag\">p</span>&#123;<span class=\"attribute\">margin</span>:<span class=\"number\">0</span>;&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.my_post_copyright</span> <span class=\"selector-tag\">span</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: inline-block;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">5.2em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#b5b5b5</span>;</span><br><span class=\"line\">  <span class=\"attribute\">font-weight</span>: bold;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.my_post_copyright</span> <span class=\"selector-class\">.raw</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">margin-left</span>: <span class=\"number\">1em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">5em</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.my_post_copyright</span> <span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#808080</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-bottom</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.my_post_copyright</span> <span class=\"selector-tag\">a</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#a3d2a3</span>;</span><br><span class=\"line\">  <span class=\"attribute\">text-decoration</span>: underline;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.my_post_copyright</span><span class=\"selector-pseudo\">:hover</span> <span class=\"selector-class\">.fa-clipboard</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#000</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.my_post_copyright</span> <span class=\"selector-class\">.post-url</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-weight</span>: normal;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.my_post_copyright</span> <span class=\"selector-class\">.copy-path</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">margin-left</span>: <span class=\"number\">1em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">1em</span>;</span><br><span class=\"line\">  +mobile()&#123;display:none;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.my_post_copyright</span> <span class=\"selector-class\">.copy-path</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#808080</span>;</span><br><span class=\"line\">  <span class=\"attribute\">cursor</span>: pointer;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>修改<code>/themes/next/layout/_macro/post.swig</code><br>在如下位置<br><img src=\"/hexo%E6%90%AD%E5%BB%BA%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E4%BC%98%E5%8C%96/my_copyright.png\" class></p>\n<p>添加代码：(注意和之前的教程不一样，这里可能是next的更新了，所以要把代码放到外面，否则在wechat_subscriber未开启时会导致失效。)</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"selector-tag\">div</span>&gt;</span><br><span class=\"line\">      &#123;% if not is_index %&#125;</span><br><span class=\"line\">        &#123;% include 'my-copyright.swig' %&#125;</span><br><span class=\"line\">      &#123;% endif %&#125;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>修改<code>themes/next/source/css/_common/components/post/post.styl</code>末尾增加一行<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@import &quot;my-post-copyright&quot;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"博文置顶\"><a href=\"#博文置顶\" class=\"headerlink\" title=\"博文置顶\"></a>博文置顶</h4><p>替换<code>node_modules/hexo-generator-index/lib/generator.js</code>所有的代码为：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">'use strict'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> pagination = <span class=\"built_in\">require</span>(<span class=\"string\">'hexo-pagination'</span>);</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">locals</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> config = <span class=\"keyword\">this</span>.config;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> posts = locals.posts;</span><br><span class=\"line\">    posts.data = posts.data.sort(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a.top &amp;&amp; b.top) &#123; <span class=\"comment\">// 两篇文章top都有定义</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a.top == b.top) <span class=\"keyword\">return</span> b.date - a.date; <span class=\"comment\">// 若top值一样则按照文章日期降序排</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> b.top - a.top; <span class=\"comment\">// 否则按照top值降序排</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(a.top &amp;&amp; !b.top) &#123; <span class=\"comment\">// 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(!a.top &amp;&amp; b.top) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> b.date - a.date; <span class=\"comment\">// 都没定义按照文章日期降序排</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> paginationDir = config.pagination_dir || <span class=\"string\">'page'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pagination(<span class=\"string\">''</span>, posts, &#123;</span><br><span class=\"line\">    perPage: config.index_generator.per_page,</span><br><span class=\"line\">    layout: [<span class=\"string\">'index'</span>, <span class=\"string\">'archive'</span>],</span><br><span class=\"line\">    format: paginationDir + <span class=\"string\">'/%d/'</span>,</span><br><span class=\"line\">    data: &#123;</span><br><span class=\"line\">      __index: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>使用：在头部添加top</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: </span><br><span class=\"line\">date: 2017-05-22 22:45:48</span><br><span class=\"line\">tags: 技巧</span><br><span class=\"line\">categories: 技巧</span><br><span class=\"line\">copyright: true</span><br><span class=\"line\">top: 100</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<h4 id=\"修改字体大小\"><a href=\"#修改字体大小\" class=\"headerlink\" title=\"修改字体大小\"></a>修改字体大小</h4><p><code>/themes/next/source/css/_variables/base.styl</code>搜索<code>font-size-base</code></p>\n<h4 id=\"设置阅读次数\"><a href=\"#设置阅读次数\" class=\"headerlink\" title=\"设置阅读次数\"></a>设置阅读次数</h4><p><a href=\"https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud\" target=\"_blank\" rel=\"noopener\">添加阅读量统计</a></p>\n<h4 id=\"添加搜索\"><a href=\"#添加搜索\" class=\"headerlink\" title=\"添加搜索\"></a>添加搜索</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">local_search: </span><br><span class=\"line\">  enable: true</span><br></pre></td></tr></table></figure>\n<h4 id=\"SEO优化\"><a href=\"#SEO优化\" class=\"headerlink\" title=\"SEO优化\"></a>SEO优化</h4><h5 id=\"两个搜索引擎入口：\"><a href=\"#两个搜索引擎入口：\" class=\"headerlink\" title=\"两个搜索引擎入口：\"></a>两个搜索引擎入口：</h5><ul>\n<li><a href=\"https://www.google.com/webmasters/tools/home?hl=zh-CN\" target=\"_blank\" rel=\"noopener\">谷歌搜索引擎验证</a></li>\n<li><a href=\"http://www.baidu.com/search/url_submit.htm\" target=\"_blank\" rel=\"noopener\">百度搜索引擎验证</a></li>\n</ul>\n<p>这里选择用下载文件的方式，将文件放到<code>source/</code>目录下，注意一点应该在文件前添加两行代码，防止hexo将其格式化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">layout: false</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<h5 id=\"生成站点地图-sitemap\"><a href=\"#生成站点地图-sitemap\" class=\"headerlink\" title=\"生成站点地图 sitemap\"></a>生成站点地图 sitemap</h5><blockquote>\n<p>站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知Google和其他搜索引擎。Googlebot等搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-generator-sitemap --save</span><br><span class=\"line\">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure>\n<p>更改配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 自动生成sitemap</span><br><span class=\"line\">sitemap: </span><br><span class=\"line\">  path: sitemap.xml</span><br><span class=\"line\">baidusitemap: </span><br><span class=\"line\">  path: baidusitemap.xml</span><br></pre></td></tr></table></figure>\n<h5 id=\"使搜索引擎收录我们的博客\"><a href=\"#使搜索引擎收录我们的博客\" class=\"headerlink\" title=\"使搜索引擎收录我们的博客\"></a>使搜索引擎收录我们的博客</h5><ul>\n<li>谷歌比较简单向<a href=\"https://www.google.com/webmasters/tools\" target=\"_blank\" rel=\"noopener\">谷歌站长工具</a>提交sitemap</li>\n<li>百度。参考<a href=\"http://hui-wang.info/2016/10/23/Hexo%E6%8F%92%E4%BB%B6%E4%B9%8B%E7%99%BE%E5%BA%A6%E4%B8%BB%E5%8A%A8%E6%8F%90%E4%BA%A4%E9%93%BE%E6%8E%A5/\" target=\"_blank\" rel=\"noopener\">Hexo插件之百度主动提交链接</a></li>\n</ul>\n<h5 id=\"网站自身优化\"><a href=\"#网站自身优化\" class=\"headerlink\" title=\"网站自身优化\"></a>网站自身优化</h5><p>给出站链接添加 “nofollow” 标签<br><code>/themes/next/layout/_partials/footer.swig</code>找到下面两行，分别在a标签中添加<code>rel=&quot;texternal nofollow&quot;</code>属性</p>\n<img src=\"/hexo%E6%90%AD%E5%BB%BA%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E4%BC%98%E5%8C%96/nofollow.png\" class>\n<p>同样在<code>/themes/next/layout/_macor/sidebar.swig</code>中添加这个属性</p>\n<img src=\"/hexo%E6%90%AD%E5%BB%BA%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E4%BC%98%E5%8C%96/nofollow_1.png\" class>\n<img src=\"/hexo%E6%90%AD%E5%BB%BA%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E4%BC%98%E5%8C%96/nofollow_2.png\" class>\n<img src=\"/hexo%E6%90%AD%E5%BB%BA%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E4%BC%98%E5%8C%96/nofollow_3.png\" class>\n<h5 id=\"设置更改属性\"><a href=\"#设置更改属性\" class=\"headerlink\" title=\"设置更改属性\"></a>设置更改属性</h5><p><code>seo: true</code></p>\n<h5 id=\"缩短文章链接\"><a href=\"#缩短文章链接\" class=\"headerlink\" title=\"缩短文章链接\"></a>缩短文章链接</h5><p>编辑配置文件<br><code>permalink: :title.html</code></p>\n<h4 id=\"添加文章更新时间\"><a href=\"#添加文章更新时间\" class=\"headerlink\" title=\"添加文章更新时间\"></a>添加文章更新时间</h4><p>参考了<a href=\"https://blog.csdn.net/ganzhilin520/article/details/79053399\" target=\"_blank\" rel=\"noopener\">hexo添加文章更新时间</a></p>\n<p>首先找到<code>/themes/next/layout/_macro/post.swig</code>文件，在<code>&lt;span class=&quot;post-time&quot;&gt;...&lt;/span&gt;</code>后添加：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;%<span class=\"keyword\">if</span> post.updated and post.updated &gt; post.date%&#125;</span><br><span class=\"line\">  &lt;span <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"post-updated\"</span>&gt;</span><br><span class=\"line\">    &amp;nbsp; | &amp;nbsp; &#123;&#123; __(<span class=\"string\">'Updated on'</span>) &#125;&#125;</span><br><span class=\"line\">    &lt;time itemprop=<span class=\"string\">\"dateUpdated\"</span> datetime=<span class=\"string\">\"&#123;&#123; moment(post.updated).format() &#125;&#125;\"</span> content=<span class=\"string\">\"&#123;&#123; date(post.updated, config.date_format) &#125;&#125;\"</span>&gt;</span><br><span class=\"line\">      &#123;&#123; date(post.updated, config.date_format) &#125;&#125;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/time&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;/</span>span&gt;</span><br><span class=\"line\">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"/hexo%E6%90%AD%E5%BB%BA%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E4%BC%98%E5%8C%96/update_time.jpeg\" class>\n<p>博主这里改了一下显式的文本，后面的语言配置没有配，如果想手动更改文章更新时间在文章前加上：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">updated: 2018-01-01 12:00:00</span><br></pre></td></tr></table></figure>\n<p>默认使用md的修改时间。</p>\n<h4 id=\"文章添加阴影效果\"><a href=\"#文章添加阴影效果\" class=\"headerlink\" title=\"文章添加阴影效果\"></a>文章添加阴影效果</h4><p>找到文件<code>themes/next/source/css/_custom/custom.styl</code>，添加如下代码。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 主页文章添加阴影效果</span><br><span class=\"line\"><span class=\"selector-class\">.post</span> &#123;</span><br><span class=\"line\">   <span class=\"attribute\">margin-top</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">   <span class=\"attribute\">margin-bottom</span>: <span class=\"number\">60px</span>;</span><br><span class=\"line\">   <span class=\"attribute\">padding</span>: <span class=\"number\">25px</span>;</span><br><span class=\"line\">   <span class=\"attribute\">-webkit-box-shadow</span>: <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">5px</span> <span class=\"built_in\">rgba</span>(<span class=\"number\">202</span>, <span class=\"number\">203</span>, <span class=\"number\">203</span>, .<span class=\"number\">5</span>);</span><br><span class=\"line\">   <span class=\"attribute\">-moz-box-shadow</span>: <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">5px</span> <span class=\"built_in\">rgba</span>(<span class=\"number\">202</span>, <span class=\"number\">203</span>, <span class=\"number\">204</span>, .<span class=\"number\">5</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["Hexo"],"tags":["Hexo","next"]},{"title":"矩阵中单词的路径，很多人都错了","url":"/%E7%9F%A9%E9%98%B5%E4%B8%AD%E5%8D%95%E8%AF%8D%E7%9A%84%E8%B7%AF%E5%BE%84%EF%BC%8C%E5%BE%88%E5%A4%9A%E4%BA%BA%E9%83%BD%E9%94%99%E4%BA%86/","content":"<p>刷过《剑指Offer》的同学，想必都会对这道题有印象，但是如果你之前是在牛客网或者AcWing其他的网站做这道题，那么即便AC通过了所有的测试，你的答案也可能是错误的。我自己之前也是被这个答案误导过，下面我来详细地解释一下自己曾经写过的错误代码，以免以后再次犯同样的错误。</p>\n<a id=\"more\"></a>\n<blockquote>\n<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>\n</blockquote>\n<p><a href=\"https://leetcode.com/problems/word-search/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></p>\n<p><a href=\"https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc?tpId=13&amp;tqId=11218&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking\" target=\"_blank\" rel=\"noopener\">牛客网传送门</a></p>\n<p>我从Python的排行榜中复制出来了一个比较“流行”的写法。代码如下，这个代码有两处错误。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hasPath</span><span class=\"params\">(self, matrix, rows, cols, path)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># write code here</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(rows):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(cols):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> matrix[i*cols+j]==path[<span class=\"number\">0</span>]:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> self.find(list(matrix),rows,cols,path[<span class=\"number\">1</span>:],i,j):</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">find</span><span class=\"params\">(self,matrix,rows,cols,path,i,j)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> path:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    matrix[i*cols+j]=<span class=\"string\">'-'</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> j+<span class=\"number\">1</span>&lt;cols <span class=\"keyword\">and</span> matrix[i*cols+(j+<span class=\"number\">1</span>)]==path[<span class=\"number\">0</span>]:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.find(matrix,rows,cols,path[<span class=\"number\">1</span>:],i,j+<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> j<span class=\"number\">-1</span>&gt;=<span class=\"number\">0</span> <span class=\"keyword\">and</span> matrix[i*cols+(j<span class=\"number\">-1</span>)]==path[<span class=\"number\">0</span>]:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.find(matrix,rows,cols,path[<span class=\"number\">1</span>:],i,j<span class=\"number\">-1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> i+<span class=\"number\">1</span>&lt;rows <span class=\"keyword\">and</span> matrix[(i+<span class=\"number\">1</span>)*cols+j]==path[<span class=\"number\">0</span>]:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.find(matrix,rows,cols,path[<span class=\"number\">1</span>:],i+<span class=\"number\">1</span>,j)</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> i<span class=\"number\">-1</span>&gt;=<span class=\"number\">0</span> <span class=\"keyword\">and</span> matrix[(i<span class=\"number\">-1</span>)*cols+j]==path[<span class=\"number\">0</span>]:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.find(matrix,rows,cols,path[<span class=\"number\">1</span>:],i<span class=\"number\">-1</span>,j)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<p>其中一处错误很明显。在函数<code>find</code>中，他选择了右左下上的顺序，那么如果右边开始匹配，并且右边匹配上了一个字符，那么会继续递归，最后结果如果返回了<code>False</code>，那么接下来的左下上就会被跳过，错误地返回了<code>False</code>。我们来举个栗子🌰。</p>\n<img src=\"/%E7%9F%A9%E9%98%B5%E4%B8%AD%E5%8D%95%E8%AF%8D%E7%9A%84%E8%B7%AF%E5%BE%84%EF%BC%8C%E5%BE%88%E5%A4%9A%E4%BA%BA%E9%83%BD%E9%94%99%E4%BA%86/path_0.png\" class width=\"200\" height=\"150\">\n<p>如果矩阵如上图中那样，并且开始寻找字符转<code>SEE</code>。根据上述算法，当找到<code>S</code>时，先选择往下走，找到了一个<code>E</code>，然后返回了<code>False</code>，忽略了上面的<code>SEE</code>。</p>\n<p>于是我将<code>find</code>方法改成了下面这样。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">find</span><span class=\"params\">(matrix, rows, cols, path, i, j)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> path:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    matrix[i*cols + j] = <span class=\"string\">'-'</span></span><br><span class=\"line\">    up, down, left, right = <span class=\"literal\">False</span>, <span class=\"literal\">False</span>, <span class=\"literal\">False</span>, <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> j + <span class=\"number\">1</span> &lt; cols <span class=\"keyword\">and</span> matrix[i * cols + j + <span class=\"number\">1</span>] == path[<span class=\"number\">0</span>]:</span><br><span class=\"line\">        down = spread(matrix, rows, cols, path[<span class=\"number\">1</span>:], i, j + <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> j - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> matrix[i * cols + j - <span class=\"number\">1</span>] == path[<span class=\"number\">0</span>]:</span><br><span class=\"line\">        left = spread(matrix, rows, cols, path[<span class=\"number\">1</span>:], i, j - <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> i + <span class=\"number\">1</span> &lt; rows <span class=\"keyword\">and</span> matrix[(i + <span class=\"number\">1</span>) * cols + j] == path[<span class=\"number\">0</span>]:</span><br><span class=\"line\">        right = spread(matrix, rows, cols, path[<span class=\"number\">1</span>:], i + <span class=\"number\">1</span>, j)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> i - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> matrix[(i - <span class=\"number\">1</span>) * cols + j] == path[<span class=\"number\">0</span>]:</span><br><span class=\"line\">        up = spread(matrix, rows, cols, path[<span class=\"number\">1</span>:], i - <span class=\"number\">1</span>, j)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> up <span class=\"keyword\">or</span> down <span class=\"keyword\">or</span> left <span class=\"keyword\">or</span> right</span><br></pre></td></tr></table></figure>\n<p>这之后的很长一段时间，我一直以为这个写法是正确的。直到我在LeetCode上发现这道原题，自信满满地提交自己认为正确的答案，被这个TestCase教做人。我当时提交的完整答案是这样的。<em>这个输入参数有一些不一样的地方，LeetCode输入的是二维数组，牛客是一个字符串，这里写的是LeetCode的写法</em>。这里因为是二维数组，所以要做深拷贝。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">exist</span><span class=\"params\">(self, g: List[List[str]], word: str)</span> -&gt; bool:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> copy <span class=\"keyword\">import</span> deepcopy</span><br><span class=\"line\">    R, C = len(g), len(g[<span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">spread</span><span class=\"params\">(g, i, j, w)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> w:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        g[i][j] = <span class=\"string\">'-'</span></span><br><span class=\"line\">        spreaded = <span class=\"literal\">False</span></span><br><span class=\"line\">        print(<span class=\"string\">'cur -&gt; (&#123;&#125;, &#123;&#125;) &#123;&#125;, &#123;&#125;'</span>.format(i, j, w, g))</span><br><span class=\"line\">        <span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> ((i<span class=\"number\">-1</span>, j), (i+<span class=\"number\">1</span>, j), (i, j<span class=\"number\">-1</span>), (i, j+<span class=\"number\">1</span>)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=x&lt;R <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=y&lt;C <span class=\"keyword\">and</span> w[<span class=\"number\">0</span>]==g[x][y]:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> spread(g, x, y, w[<span class=\"number\">1</span>:]):</span><br><span class=\"line\">                    spreaded = <span class=\"literal\">True</span></span><br><span class=\"line\">        print(<span class=\"string\">'spreaded &#123;&#125;, recover (&#123;&#125;, &#123;&#125;), after &#123;&#125;'</span>.format(spreaded, i, j, g))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> spreaded</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(R):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(C):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> g[i][j] == word[<span class=\"number\">0</span>]:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> spread(deepcopy(g), i, j, word[<span class=\"number\">1</span>:]):</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<p>未通过的TestCase为：目标字符串为<code>ABCESEEEFS</code>。</p>\n<img src=\"/%E7%9F%A9%E9%98%B5%E4%B8%AD%E5%8D%95%E8%AF%8D%E7%9A%84%E8%B7%AF%E5%BE%84%EF%BC%8C%E5%BE%88%E5%A4%9A%E4%BA%BA%E9%83%BD%E9%94%99%E4%BA%86/path_1.png\" class width=\"200\" height=\"150\">\n<p>为了方便观察问题，我加了两行输出。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cur -&gt; (0, 0) BCESEEEFS, [[&#39;-&#39;, &#39;B&#39;, &#39;C&#39;, &#39;E&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;E&#39;, &#39;S&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;E&#39;, &#39;E&#39;]]</span><br><span class=\"line\">cur -&gt; (0, 1) CESEEEFS, [[&#39;-&#39;, &#39;-&#39;, &#39;C&#39;, &#39;E&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;E&#39;, &#39;S&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;E&#39;, &#39;E&#39;]]</span><br><span class=\"line\">cur -&gt; (0, 2) ESEEEFS, [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;E&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;E&#39;, &#39;S&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;E&#39;, &#39;E&#39;]]</span><br><span class=\"line\">cur -&gt; (1, 2) SEEEFS, [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;E&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;-&#39;, &#39;S&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;E&#39;, &#39;E&#39;]]</span><br><span class=\"line\">cur -&gt; (1, 3) EEEFS, [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;E&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;E&#39;, &#39;E&#39;]]</span><br><span class=\"line\">cur -&gt; (0, 3) EEFS, [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;E&#39;, &#39;E&#39;]]</span><br><span class=\"line\">spreaded False, g [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;E&#39;, &#39;E&#39;]]</span><br><span class=\"line\">cur -&gt; (2, 3) EEFS, [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;E&#39;, &#39;-&#39;]]</span><br><span class=\"line\">cur -&gt; (2, 2) EFS, [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;-&#39;, &#39;-&#39;]]</span><br><span class=\"line\">spreaded False, g [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;-&#39;, &#39;-&#39;]]</span><br><span class=\"line\">spreaded False, g [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;-&#39;, &#39;-&#39;]]</span><br><span class=\"line\">spreaded False, g [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;-&#39;, &#39;-&#39;]]</span><br><span class=\"line\">spreaded False, g [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;-&#39;, &#39;-&#39;]]</span><br><span class=\"line\">spreaded False, g [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;-&#39;, &#39;-&#39;]]</span><br><span class=\"line\">spreaded False, g [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;-&#39;, &#39;-&#39;]]</span><br><span class=\"line\">spreaded False, g [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;-&#39;, &#39;-&#39;]]</span><br><span class=\"line\">cur -&gt; (2, 0) BCESEEEFS, [[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;E&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;E&#39;, &#39;S&#39;], [&#39;-&#39;, &#39;D&#39;, &#39;E&#39;, &#39;E&#39;]]</span><br><span class=\"line\">spreaded False, g [[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;E&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;E&#39;, &#39;S&#39;], [&#39;-&#39;, &#39;D&#39;, &#39;E&#39;, &#39;E&#39;]]</span><br></pre></td></tr></table></figure>\n<p>这个稍微看一下就明白了，虽然每次匹配第一个字符串<code>A</code>的时候传入了一个新的二维数组，但是在找A之后的路径时，每次返回<code>False</code>的时候没有将<code>-</code>恢复成原来的字母。下面请记住我代码中写的方向顺序为<code>上下左右</code>。</p>\n<img src=\"/%E7%9F%A9%E9%98%B5%E4%B8%AD%E5%8D%95%E8%AF%8D%E7%9A%84%E8%B7%AF%E5%BE%84%EF%BC%8C%E5%BE%88%E5%A4%9A%E4%BA%BA%E9%83%BD%E9%94%99%E4%BA%86/path_wrong_0.png\" class>\n<p>在上面的几步延伸之后，回到了<code>ABC</code>然后右边的字母没有恢复，所以返回了<code>False</code>。于是我们可以先记录一下之前的字母，然后在得到结果后将其恢复。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">exist</span><span class=\"params\">(self, g: List[List[str]], word: str)</span> -&gt; bool:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> copy <span class=\"keyword\">import</span> deepcopy</span><br><span class=\"line\">    R, C = len(g), len(g[<span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">spread</span><span class=\"params\">(g, i, j, w)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> w:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        original, g[i][j] = g[i][j], <span class=\"string\">'-'</span></span><br><span class=\"line\">        spreaded = <span class=\"literal\">False</span></span><br><span class=\"line\">        print(<span class=\"string\">'cur -&gt; (&#123;&#125;, &#123;&#125;) &#123;&#125;, &#123;&#125;'</span>.format(i, j, w, g))</span><br><span class=\"line\">        <span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> ((i<span class=\"number\">-1</span>, j), (i+<span class=\"number\">1</span>, j), (i, j<span class=\"number\">-1</span>), (i, j+<span class=\"number\">1</span>)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=x&lt;R <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=y&lt;C <span class=\"keyword\">and</span> w[<span class=\"number\">0</span>]==g[x][y]:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> spread(g, x, y, w[<span class=\"number\">1</span>:]):</span><br><span class=\"line\">                    spreaded = <span class=\"literal\">True</span></span><br><span class=\"line\">        g[i][j] = original</span><br><span class=\"line\">        print(<span class=\"string\">'spreaded &#123;&#125;, recover (&#123;&#125;, &#123;&#125;), after &#123;&#125;'</span>.format(spreaded, i, j, g))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> spreaded</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(R):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(C):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> g[i][j] == word[<span class=\"number\">0</span>]:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> spread(deepcopy(g), i, j, word[<span class=\"number\">1</span>:]):</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<p>输出为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cur -&gt; (0, 0) BCESEEEFS, [[&#39;-&#39;, &#39;B&#39;, &#39;C&#39;, &#39;E&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;E&#39;, &#39;S&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;E&#39;, &#39;E&#39;]]</span><br><span class=\"line\">cur -&gt; (0, 1) CESEEEFS, [[&#39;-&#39;, &#39;-&#39;, &#39;C&#39;, &#39;E&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;E&#39;, &#39;S&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;E&#39;, &#39;E&#39;]]</span><br><span class=\"line\">cur -&gt; (0, 2) ESEEEFS, [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;E&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;E&#39;, &#39;S&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;E&#39;, &#39;E&#39;]]</span><br><span class=\"line\">cur -&gt; (1, 2) SEEEFS, [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;E&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;-&#39;, &#39;S&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;E&#39;, &#39;E&#39;]]</span><br><span class=\"line\">cur -&gt; (1, 3) EEEFS, [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;E&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;E&#39;, &#39;E&#39;]]</span><br><span class=\"line\">cur -&gt; (0, 3) EEFS, [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;E&#39;, &#39;E&#39;]]</span><br><span class=\"line\">spreaded False, recover (0, 3), after [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;E&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;E&#39;, &#39;E&#39;]]</span><br><span class=\"line\">cur -&gt; (2, 3) EEFS, [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;E&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;E&#39;, &#39;-&#39;]]</span><br><span class=\"line\">cur -&gt; (2, 2) EFS, [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;E&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;-&#39;, &#39;-&#39;]]</span><br><span class=\"line\">spreaded False, recover (2, 2), after [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;E&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;E&#39;, &#39;-&#39;]]</span><br><span class=\"line\">spreaded False, recover (2, 3), after [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;E&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;E&#39;, &#39;E&#39;]]</span><br><span class=\"line\">spreaded False, recover (1, 3), after [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;E&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;-&#39;, &#39;S&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;E&#39;, &#39;E&#39;]]</span><br><span class=\"line\">spreaded False, recover (1, 2), after [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;E&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;E&#39;, &#39;S&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;E&#39;, &#39;E&#39;]]</span><br><span class=\"line\">cur -&gt; (0, 3) SEEEFS, [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;E&#39;, &#39;S&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;E&#39;, &#39;E&#39;]]</span><br><span class=\"line\">cur -&gt; (1, 3) EEEFS, [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;E&#39;, &#39;-&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;E&#39;, &#39;E&#39;]]</span><br><span class=\"line\">cur -&gt; (2, 3) EEFS, [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;E&#39;, &#39;-&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;E&#39;, &#39;-&#39;]]</span><br><span class=\"line\">cur -&gt; (2, 2) EFS, [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;E&#39;, &#39;-&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;-&#39;, &#39;-&#39;]]</span><br><span class=\"line\">cur -&gt; (1, 2) FS, [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;-&#39;, &#39;-&#39;]]</span><br><span class=\"line\">cur -&gt; (1, 1) S, [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;S&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;-&#39;, &#39;-&#39;]]</span><br><span class=\"line\">spreaded True, recover (1, 1), after [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;-&#39;, &#39;-&#39;]]</span><br><span class=\"line\">spreaded True, recover (1, 2), after [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;E&#39;, &#39;-&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;-&#39;, &#39;-&#39;]]</span><br><span class=\"line\">spreaded True, recover (2, 2), after [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;E&#39;, &#39;-&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;E&#39;, &#39;-&#39;]]</span><br><span class=\"line\">spreaded True, recover (2, 3), after [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;E&#39;, &#39;-&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;E&#39;, &#39;E&#39;]]</span><br><span class=\"line\">cur -&gt; (1, 2) EEFS, [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;E&#39;, &#39;E&#39;]]</span><br><span class=\"line\">cur -&gt; (2, 2) EFS, [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;-&#39;, &#39;E&#39;]]</span><br><span class=\"line\">cur -&gt; (2, 3) FS, [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;-&#39;, &#39;-&#39;]]</span><br><span class=\"line\">spreaded False, recover (2, 3), after [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;-&#39;, &#39;E&#39;]]</span><br><span class=\"line\">spreaded False, recover (2, 2), after [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;E&#39;, &#39;E&#39;]]</span><br><span class=\"line\">spreaded False, recover (1, 2), after [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;E&#39;, &#39;-&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;E&#39;, &#39;E&#39;]]</span><br><span class=\"line\">spreaded True, recover (1, 3), after [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;E&#39;, &#39;S&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;E&#39;, &#39;E&#39;]]</span><br><span class=\"line\">spreaded True, recover (0, 3), after [[&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;E&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;E&#39;, &#39;S&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;E&#39;, &#39;E&#39;]]</span><br><span class=\"line\">spreaded True, recover (0, 2), after [[&#39;-&#39;, &#39;-&#39;, &#39;C&#39;, &#39;E&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;E&#39;, &#39;S&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;E&#39;, &#39;E&#39;]]</span><br><span class=\"line\">spreaded True, recover (0, 1), after [[&#39;-&#39;, &#39;B&#39;, &#39;C&#39;, &#39;E&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;E&#39;, &#39;S&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;E&#39;, &#39;E&#39;]]</span><br><span class=\"line\">spreaded True, recover (0, 0), after [[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;E&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;E&#39;, &#39;S&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;E&#39;, &#39;E&#39;]]</span><br></pre></td></tr></table></figure>\n<p>这个例子非常复杂也非常棒，由衷感谢提交这个TestCase的人让我意识到自己的愚蠢，此例子一共做了4次尝试，让我们用图解的方式来还原一下。因为是<code>上下左右</code>这个顺序，所以尝试过程如下：</p>\n<img src=\"/%E7%9F%A9%E9%98%B5%E4%B8%AD%E5%8D%95%E8%AF%8D%E7%9A%84%E8%B7%AF%E5%BE%84%EF%BC%8C%E5%BE%88%E5%A4%9A%E4%BA%BA%E9%83%BD%E9%94%99%E4%BA%86/path_wrong_1.png\" class>\n<p>这一次，我们代码可能通过功能测试了，但是想想如果每个匹配第一个字符串都深拷贝一个数组，如果数组特别大，那么将耗费大量时间，其实我们在做好恢复工作后就不需要在拷贝数组了。将其去掉后：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">exist</span><span class=\"params\">(self, g: List[List[str]], word: str)</span> -&gt; bool:</span></span><br><span class=\"line\">    R, C = len(g), len(g[<span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">spread</span><span class=\"params\">(i, j, w)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> w:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        original, g[i][j] = g[i][j], <span class=\"string\">'-'</span></span><br><span class=\"line\">        spreaded = <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> ((i<span class=\"number\">-1</span>, j), (i+<span class=\"number\">1</span>, j), (i, j<span class=\"number\">-1</span>), (i, j+<span class=\"number\">1</span>)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=x&lt;R <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=y&lt;C <span class=\"keyword\">and</span> w[<span class=\"number\">0</span>]==g[x][y]:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> spread(x, y, w[<span class=\"number\">1</span>:]):</span><br><span class=\"line\">                    spreaded = <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">        g[i][j] = original</span><br><span class=\"line\">        <span class=\"keyword\">return</span> spreaded</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(R):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(C):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> g[i][j] == word[<span class=\"number\">0</span>]:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> spread(i, j, word[<span class=\"number\">1</span>:]):</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<p>自信提交后，又被这样一个TestCase教育了，返回超时。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a...</span><br><span class=\"line\">&quot;baaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;</span><br></pre></td></tr></table></figure>\n<p>想了半天终于明白，我在四个方向寻找是否可以延伸时，只要有一个方向可以，那么我就无需再判断其他方向了。</p>\n<p>所以这里加一个<code>break</code>即可。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">exist</span><span class=\"params\">(self, g: List[List[str]], word: str)</span> -&gt; bool:</span></span><br><span class=\"line\">    R, C = len(g), len(g[<span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">spread</span><span class=\"params\">(i, j, w)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> w:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        original, g[i][j] = g[i][j], <span class=\"string\">'-'</span></span><br><span class=\"line\">        spreaded = <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> ((i<span class=\"number\">-1</span>, j), (i+<span class=\"number\">1</span>, j), (i, j<span class=\"number\">-1</span>), (i, j+<span class=\"number\">1</span>)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"number\">0</span>&lt;=x&lt;R <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=y&lt;C <span class=\"keyword\">and</span> w[<span class=\"number\">0</span>]==g[x][y]</span><br><span class=\"line\">                    <span class=\"keyword\">and</span> spread(x, y, w[<span class=\"number\">1</span>:])):</span><br><span class=\"line\">                spreaded = <span class=\"literal\">True</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">        g[i][j] = original</span><br><span class=\"line\">        <span class=\"keyword\">return</span> spreaded</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(R):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(C):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> g[i][j] == word[<span class=\"number\">0</span>] <span class=\"keyword\">and</span> spread(i, j, word[<span class=\"number\">1</span>:]):</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<p>以上就是最终的代码，试了一下LeetCode评论区的高票代码，其中有一个写法，将主循环的<code>g[i][j]==word[0]</code>移到了<code>spread</code>中判断，个人觉得这个是为什么比它快了100ms以上的原因。此文中的最终方法AC<code>188ms</code>，而那个代码需要<code>336ms</code>。</p>\n<p>通过一番深入的分析，自己对于回溯有了更深一步的认识，同时也明白了一个深刻的道理，<strong>不要轻信他人的代码</strong>，包括此文中的也是。</p>\n","categories":["算法"],"tags":["Python","Algorithm","剑指Offer"]},{"title":"LeetCode算法题整理（栈篇）Stack","url":"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%A0%88%E7%AF%87%EF%BC%89Stack/","content":"<h3 id=\"1021-Remove-Outermost-Parentheses\"><a href=\"#1021-Remove-Outermost-Parentheses\" class=\"headerlink\" title=\"1021. Remove Outermost Parentheses\"></a>1021. Remove Outermost Parentheses</h3><h4 id=\"删除最外层的括号。原题\"><a href=\"#删除最外层的括号。原题\" class=\"headerlink\" title=\"删除最外层的括号。原题\"></a>删除最外层的括号。<a href=\"https://leetcode.com/problems/remove-outermost-parentheses/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: &quot;(()())(())&quot;</span><br><span class=\"line\">Output: &quot;()()()&quot;</span><br><span class=\"line\">The input string is &quot;(()())(())&quot;, with primitive decomposition &quot;(()())&quot; + &quot;(())&quot;.</span><br><span class=\"line\">After removing outer parentheses of each part, this is &quot;()()&quot; + &quot;()&quot; &#x3D; &quot;()()()&quot;.</span><br><span class=\"line\">Input: &quot;(()())(())(()(()))&quot;</span><br><span class=\"line\">Output: &quot;()()()()(())&quot;</span><br><span class=\"line\">The input string is &quot;(()())(())(()(()))&quot;, with primitive decomposition &quot;(()())&quot; + &quot;(())&quot; + &quot;(()(()))&quot;.</span><br><span class=\"line\">After removing outer parentheses of each part, this is &quot;()()&quot; + &quot;()&quot; + &quot;()(())&quot; &#x3D; &quot;()()()()(())&quot;.</span><br><span class=\"line\">Input: &quot;()()&quot;</span><br><span class=\"line\">Output: &quot;&quot;</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>方法一：比赛时的丑陋写法。使用索引记录位置坐切片。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removeOuterParentheses</span><span class=\"params\">(self, S: str)</span> -&gt; str:</span></span><br><span class=\"line\">    l = <span class=\"number\">0</span></span><br><span class=\"line\">    left = right = <span class=\"number\">0</span></span><br><span class=\"line\">    ans = <span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, p <span class=\"keyword\">in</span> enumerate(S):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> p ==<span class=\"string\">'('</span>:</span><br><span class=\"line\">            left += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> left == <span class=\"number\">1</span>:</span><br><span class=\"line\">                l = i</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            right += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> left == right:</span><br><span class=\"line\">                ans += S[l+<span class=\"number\">1</span>:i]</span><br><span class=\"line\">                l = i + <span class=\"number\">1</span></span><br><span class=\"line\">                left = right = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"comment\"># print(ans)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：优化。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removeOuterParentheses</span><span class=\"params\">(self, S: str)</span> -&gt; str:</span></span><br><span class=\"line\">    ans, opened = [], <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> S:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> s == <span class=\"string\">'('</span> <span class=\"keyword\">and</span> opened &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            ans.append(s)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> s == <span class=\"string\">')'</span> <span class=\"keyword\">and</span> opened &gt; <span class=\"number\">1</span>:</span><br><span class=\"line\">            ans.append(s)</span><br><span class=\"line\">        opened += <span class=\"number\">1</span> <span class=\"keyword\">if</span> s==<span class=\"string\">'('</span> <span class=\"keyword\">else</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(ans)</span><br></pre></td></tr></table></figure>\n<h3 id=\"1047-Remove-All-Adjacent-Duplicates-In-String\"><a href=\"#1047-Remove-All-Adjacent-Duplicates-In-String\" class=\"headerlink\" title=\"1047. Remove All Adjacent Duplicates In String\"></a>1047. Remove All Adjacent Duplicates In String</h3><h4 id=\"每两个相邻的相同字符串可以消掉。类似于连连看。原题\"><a href=\"#每两个相邻的相同字符串可以消掉。类似于连连看。原题\" class=\"headerlink\" title=\"每两个相邻的相同字符串可以消掉。类似于连连看。原题\"></a>每两个相邻的相同字符串可以消掉。类似于连连看。<a href=\"https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removeDuplicates</span><span class=\"params\">(self, S: str)</span> -&gt; str:</span></span><br><span class=\"line\">    stack = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> S:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> stack <span class=\"keyword\">and</span> stack[<span class=\"number\">-1</span>] == c:</span><br><span class=\"line\">            stack.pop()</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            stack.append(c)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(stack)</span><br></pre></td></tr></table></figure>\n<h3 id=\"1172-Dinner-Plate-Stacks\"><a href=\"#1172-Dinner-Plate-Stacks\" class=\"headerlink\" title=\"1172. Dinner Plate Stacks\"></a>1172. Dinner Plate Stacks</h3><h4 id=\"有这样一堆栈，每个栈有个容量，可以在指定索引下删除某个栈，每次push时需要在最左的不满的栈。原题\"><a href=\"#有这样一堆栈，每个栈有个容量，可以在指定索引下删除某个栈，每次push时需要在最左的不满的栈。原题\" class=\"headerlink\" title=\"有这样一堆栈，每个栈有个容量，可以在指定索引下删除某个栈，每次push时需要在最左的不满的栈。原题\"></a>有这样一堆栈，每个栈有个容量，可以在指定索引下删除某个栈，每次push时需要在最左的不满的栈。<a href=\"https://leetcode.com/problems/dinner-plate-stacks/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: </span><br><span class=\"line\">[&quot;DinnerPlates&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;popAtStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;popAtStack&quot;,&quot;popAtStack&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;]</span><br><span class=\"line\">[[2],[1],[2],[3],[4],[5],[0],[20],[21],[0],[2],[],[],[],[],[]]</span><br><span class=\"line\">Output: </span><br><span class=\"line\">[null,null,null,null,null,null,2,null,null,20,21,5,4,3,1,-1]</span><br></pre></td></tr></table></figure>\n<p>方法一：一开始被题吓到了，竞赛时没做出来，核心思想在于维护一个堆，记录不满的栈。以便插入时可以找到该索引。</p>\n<p>class DinnerPlates:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, capacity: int)</span>:</span></span><br><span class=\"line\">    self.c = capacity</span><br><span class=\"line\">    self.q = []</span><br><span class=\"line\">    self.emp = []</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">push</span><span class=\"params\">(self, val: int)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> self.emp:</span><br><span class=\"line\">        index = heapq.heappop(self.emp)</span><br><span class=\"line\">        self.q[index].append(val)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.q <span class=\"keyword\">and</span> len(self.q[<span class=\"number\">-1</span>])!=self.c:</span><br><span class=\"line\">            self.q[<span class=\"number\">-1</span>].append(val)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            self.q.append([val])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pop</span><span class=\"params\">(self)</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> self.q:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.q[<span class=\"number\">-1</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.q[<span class=\"number\">-1</span>].pop()</span><br><span class=\"line\">        self.q.pop()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">popAtStack</span><span class=\"params\">(self, index: int)</span> -&gt; int:</span></span><br><span class=\"line\">    heapq.heappush(self.emp, index)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> self.q[index]:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.q[index].pop()</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"901-Online-Stock-Span\"><a href=\"#901-Online-Stock-Span\" class=\"headerlink\" title=\"901. Online Stock Span\"></a>901. Online Stock Span</h3><h4 id=\"实时找出数据流中连续的比不大于当前值的个数。原题\"><a href=\"#实时找出数据流中连续的比不大于当前值的个数。原题\" class=\"headerlink\" title=\"实时找出数据流中连续的比不大于当前值的个数。原题\"></a>实时找出数据流中连续的比不大于当前值的个数。<a href=\"https://leetcode.com/problems/online-stock-span/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [&quot;StockSpanner&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;], [[],[100],[80],[60],[70],[60],[75],[85]]</span><br><span class=\"line\">Output: [null,1,1,1,2,1,4,6]</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">First, S &#x3D; StockSpanner() is initialized.  Then:</span><br><span class=\"line\">S.next(100) is called and returns 1,</span><br><span class=\"line\">S.next(80) is called and returns 1,</span><br><span class=\"line\">S.next(60) is called and returns 1,</span><br><span class=\"line\">S.next(70) is called and returns 2,</span><br><span class=\"line\">S.next(60) is called and returns 1,</span><br><span class=\"line\">S.next(75) is called and returns 4,</span><br><span class=\"line\">S.next(85) is called and returns 6.</span><br><span class=\"line\"></span><br><span class=\"line\">Note that (for example) S.next(75) returned 4, because the last 4 prices</span><br><span class=\"line\">(including today&#39;s price of 75) were less than or equal to today&#39;s price.</span><br></pre></td></tr></table></figure>\n<p>方法一：<code>&lt;=</code>可以累加。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StockSpanner</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.stack = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">next</span><span class=\"params\">(self, price: int)</span> -&gt; int:</span></span><br><span class=\"line\">        cnt = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> self.stack <span class=\"keyword\">and</span> self.stack[<span class=\"number\">-1</span>][<span class=\"number\">0</span>] &lt;= price:</span><br><span class=\"line\">            cnt += self.stack.pop()[<span class=\"number\">1</span>]</span><br><span class=\"line\">        self.stack.append((price, cnt))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cnt</span><br></pre></td></tr></table></figure>\n<h3 id=\"907-Sum-of-Subarray-Minimums\"><a href=\"#907-Sum-of-Subarray-Minimums\" class=\"headerlink\" title=\"907. Sum of Subarray Minimums\"></a><a href=\"https://leetcode.com/problems/sum-of-subarray-minimums/\" target=\"_blank\" rel=\"noopener\">907. Sum of Subarray Minimums</a></h3><h4 id=\"一个数组所有子数组的最小值的和。\"><a href=\"#一个数组所有子数组的最小值的和。\" class=\"headerlink\" title=\"一个数组所有子数组的最小值的和。\"></a>一个数组所有子数组的最小值的和。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [3,1,2,4]</span><br><span class=\"line\">Output: 17</span><br><span class=\"line\">Explanation: Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. </span><br><span class=\"line\">Minimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.  Sum is 17.</span><br></pre></td></tr></table></figure>\n<p>方法一：by@Lee, 没想到可以用stack，实际上和901问题是一样的，对于一个数而言，找到左侧和右侧比它大的数，代表着左侧和右侧所能组成的子数组的长度，就是它在最小值计算里出现的次数。本来想封装一下这个方法，但是计算左侧时条件是<code>&gt;</code>，其实终点不在于顺序，而是=只能有一个，因为如果都按<code>&gt;=</code>计算，相同数字的就会有子数组计算重复了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sumSubarrayMins</span><span class=\"params\">(self, A: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    n, mod = len(A), <span class=\"number\">10</span>**<span class=\"number\">9</span>+<span class=\"number\">7</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    left, right, s1, s2 = [<span class=\"number\">0</span>] * n, [<span class=\"number\">0</span>] * n, [], []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">        count = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> s1 <span class=\"keyword\">and</span> s1[<span class=\"number\">-1</span>][<span class=\"number\">0</span>] &gt; A[i]: count += s1.pop()[<span class=\"number\">1</span>]</span><br><span class=\"line\">        left[i] = count</span><br><span class=\"line\">        s1.append([A[i], count])</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n)[::<span class=\"number\">-1</span>]:</span><br><span class=\"line\">        count = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> s2 <span class=\"keyword\">and</span> s2[<span class=\"number\">-1</span>][<span class=\"number\">0</span>] &gt;= A[i]: count += s2.pop()[<span class=\"number\">1</span>]</span><br><span class=\"line\">        right[i] = count</span><br><span class=\"line\">        s2.append([A[i], count])</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(a*l*r <span class=\"keyword\">for</span> a, l, r <span class=\"keyword\">in</span> zip(A, left, right)) % mod</span><br></pre></td></tr></table></figure>\n<p>方法二：Lee又将它写成了一次遍历的形式。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sumSubarrayMins</span><span class=\"params\">(self, A)</span>:</span></span><br><span class=\"line\">    res = <span class=\"number\">0</span></span><br><span class=\"line\">    s = []</span><br><span class=\"line\">    A = [<span class=\"number\">0</span>] + A + [<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, x <span class=\"keyword\">in</span> enumerate(A):</span><br><span class=\"line\">        <span class=\"keyword\">while</span> s <span class=\"keyword\">and</span> A[s[<span class=\"number\">-1</span>]] &gt; x:</span><br><span class=\"line\">            j = s.pop()</span><br><span class=\"line\">            k = s[<span class=\"number\">-1</span>]</span><br><span class=\"line\">            res += A[j] * (i - j) * (j - k)</span><br><span class=\"line\">        s.append(i)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res % (<span class=\"number\">10</span>**<span class=\"number\">9</span> + <span class=\"number\">7</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"1299-Replace-Elements-with-Greatest-Element-on-Right-Side\"><a href=\"#1299-Replace-Elements-with-Greatest-Element-on-Right-Side\" class=\"headerlink\" title=\"1299. Replace Elements with Greatest Element on Right Side\"></a>1299. Replace Elements with Greatest Element on Right Side</h3><h4 id=\"根据数组重新生成一个数组，每个元素对应原数组右侧最大的数字。原题\"><a href=\"#根据数组重新生成一个数组，每个元素对应原数组右侧最大的数字。原题\" class=\"headerlink\" title=\"根据数组重新生成一个数组，每个元素对应原数组右侧最大的数字。原题\"></a>根据数组重新生成一个数组，每个元素对应原数组右侧最大的数字。<a href=\"https://leetcode.com/problems/replace-elements-with-greatest-element-on-right-side/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: arr &#x3D; [17,18,5,4,6,1]</span><br><span class=\"line\">Output: [18,6,6,6,1,-1]</span><br></pre></td></tr></table></figure>\n<p>方法一：栈</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">replaceElements</span><span class=\"params\">(self, arr: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    stack = [<span class=\"number\">-1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(arr)<span class=\"number\">-1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> arr[i] &lt; stack[<span class=\"number\">-1</span>]:</span><br><span class=\"line\">            stack.append(stack[<span class=\"number\">-1</span>])</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            stack.append(arr[i])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stack[::<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：Lee215.</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">replaceElements</span><span class=\"params\">(self, arr: List[int], mx=<span class=\"number\">-1</span>)</span> -&gt; List[int]:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(arr)<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">        arr[i], mx = mx, max(mx, arr[i])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr</span><br></pre></td></tr></table></figure>\n<h3 id=\"1249-Minimum-Remove-to-Make-Valid-Parentheses\"><a href=\"#1249-Minimum-Remove-to-Make-Valid-Parentheses\" class=\"headerlink\" title=\"1249. Minimum Remove to Make Valid Parentheses\"></a>1249. Minimum Remove to Make Valid Parentheses</h3><h4 id=\"删除字符串中多余的括号。原题\"><a href=\"#删除字符串中多余的括号。原题\" class=\"headerlink\" title=\"删除字符串中多余的括号。原题\"></a>删除字符串中多余的括号。<a href=\"https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;lee(t(c)o)de)&quot;</span><br><span class=\"line\">Output: &quot;lee(t(c)o)de&quot;</span><br><span class=\"line\">Explanation: &quot;lee(t(co)de)&quot; , &quot;lee(t(c)ode)&quot; would also be accepted.</span><br></pre></td></tr></table></figure>\n<p>方法一：比较笨的方法，遍历了两次。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minRemoveToMakeValid</span><span class=\"params\">(self, s: str)</span> -&gt; str:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">helper</span><span class=\"params\">(arr, sig)</span>:</span></span><br><span class=\"line\">        ans, opened = [], <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> arr:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> opened &lt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> c==sig[<span class=\"number\">1</span>]:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> c == sig[<span class=\"number\">0</span>]:</span><br><span class=\"line\">                opened += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> c == sig[<span class=\"number\">1</span>]:</span><br><span class=\"line\">                opened -= <span class=\"number\">1</span></span><br><span class=\"line\">            ans.append(c)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(reversed(helper(reversed(helper(list(s), (<span class=\"string\">'('</span>, <span class=\"string\">')'</span>))), (<span class=\"string\">')'</span>, <span class=\"string\">'('</span>))))</span><br></pre></td></tr></table></figure>\n<p>方法二：stack、这个方法有点不好理解， 最后的while 循环时为了防止末尾有过多的<code>(</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minRemoveToMakeValid</span><span class=\"params\">(self, s: str)</span> -&gt; str:</span></span><br><span class=\"line\">    stack, cur = [], <span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> c == <span class=\"string\">'('</span>:</span><br><span class=\"line\">            stack.append(cur)</span><br><span class=\"line\">            cur = <span class=\"string\">''</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> c == <span class=\"string\">')'</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> stack:</span><br><span class=\"line\">                cur = <span class=\"string\">'&#123;&#125;(&#123;&#125;)'</span>.format(stack.pop(), cur)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            cur += c</span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"keyword\">while</span> stack:</span><br><span class=\"line\">        cur = stack.pop() + cur</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cur</span><br></pre></td></tr></table></figure>\n<h3 id=\"1190-Reverse-Substrings-Between-Each-Pair-of-Parentheses\"><a href=\"#1190-Reverse-Substrings-Between-Each-Pair-of-Parentheses\" class=\"headerlink\" title=\"1190. Reverse Substrings Between Each Pair of Parentheses\"></a>1190. Reverse Substrings Between Each Pair of Parentheses</h3><h4 id=\"将括号内的字符串反转。原题\"><a href=\"#将括号内的字符串反转。原题\" class=\"headerlink\" title=\"将括号内的字符串反转。原题\"></a>将括号内的字符串反转。<a href=\"https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;(u(love)i)&quot;</span><br><span class=\"line\">Output: &quot;iloveu&quot;</span><br><span class=\"line\">Explanation: The substring &quot;love&quot; is reversed first, then the whole string is reversed.</span><br></pre></td></tr></table></figure>\n<p>方法一：用了和1249一样的解法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseParentheses</span><span class=\"params\">(self, s: str)</span> -&gt; str:</span></span><br><span class=\"line\">    stack, cur = [], <span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> c == <span class=\"string\">'('</span>:</span><br><span class=\"line\">            stack.append(cur)</span><br><span class=\"line\">            cur = <span class=\"string\">''</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> c == <span class=\"string\">')'</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> stack:</span><br><span class=\"line\">                cur = <span class=\"string\">'&#123;&#125;&#123;&#125;'</span>.format(stack.pop(), cur[::<span class=\"number\">-1</span>])</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            cur += c</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cur</span><br></pre></td></tr></table></figure>\n<h3 id=\"1209-Remove-All-Adjacent-Duplicates-in-String-II\"><a href=\"#1209-Remove-All-Adjacent-Duplicates-in-String-II\" class=\"headerlink\" title=\"1209. Remove All Adjacent Duplicates in String II\"></a>1209. Remove All Adjacent Duplicates in String II</h3><h4 id=\"将字符串中连续的k的字母全部删除，返回剩余的字符串。原题\"><a href=\"#将字符串中连续的k的字母全部删除，返回剩余的字符串。原题\" class=\"headerlink\" title=\"将字符串中连续的k的字母全部删除，返回剩余的字符串。原题\"></a>将字符串中连续的k的字母全部删除，返回剩余的字符串。<a href=\"https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;abcd&quot;, k &#x3D; 2</span><br><span class=\"line\">Output: &quot;abcd&quot;</span><br><span class=\"line\">Explanation: There&#39;s nothing to delete.</span><br></pre></td></tr></table></figure>\n<p>方法一：这道题虽然ac了，但是复杂度太高了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removeDuplicates</span><span class=\"params\">(self, s: str, k: int)</span> -&gt; str:</span></span><br><span class=\"line\">    stack = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(stack)&gt;=k<span class=\"number\">-1</span> <span class=\"keyword\">and</span> all(a==c <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> stack[-k+<span class=\"number\">1</span>:]):</span><br><span class=\"line\">            stack = stack[:-k+<span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            stack.append(c)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(stack)</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：相同字符的记录个数。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removeDuplicates</span><span class=\"params\">(self, s: str, k: int)</span> -&gt; str:</span></span><br><span class=\"line\">    stack = [[<span class=\"string\">'#'</span>, <span class=\"number\">0</span>]]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> stack[<span class=\"number\">-1</span>][<span class=\"number\">0</span>] == c:</span><br><span class=\"line\">            stack[<span class=\"number\">-1</span>][<span class=\"number\">1</span>] += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> stack[<span class=\"number\">-1</span>][<span class=\"number\">1</span>] == k:</span><br><span class=\"line\">                stack.pop()</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            stack.append([c, <span class=\"number\">1</span>])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(c*k <span class=\"keyword\">for</span> c, k <span class=\"keyword\">in</span> stack)</span><br></pre></td></tr></table></figure>\n<h3 id=\"1475-Final-Prices-With-a-Special-Discount-in-a-Shop\"><a href=\"#1475-Final-Prices-With-a-Special-Discount-in-a-Shop\" class=\"headerlink\" title=\"1475. Final Prices With a Special Discount in a Shop\"></a>1475. Final Prices With a Special Discount in a Shop</h3><h4 id=\"找出数组中后面元素比当前元素小的差。原题\"><a href=\"#找出数组中后面元素比当前元素小的差。原题\" class=\"headerlink\" title=\"找出数组中后面元素比当前元素小的差。原题\"></a>找出数组中后面元素比当前元素小的差。<a href=\"https://leetcode.com/problems/final-prices-with-a-special-discount-in-a-shop/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: prices &#x3D; [8,4,6,2,3]</span><br><span class=\"line\">Output: [4,2,4,2,3]</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">For item 0 with price[0]&#x3D;8 you will receive a discount equivalent to prices[1]&#x3D;4, therefore, the final price you will pay is 8 - 4 &#x3D; 4. </span><br><span class=\"line\">For item 1 with price[1]&#x3D;4 you will receive a discount equivalent to prices[3]&#x3D;2, therefore, the final price you will pay is 4 - 2 &#x3D; 2. </span><br><span class=\"line\">For item 2 with price[2]&#x3D;6 you will receive a discount equivalent to prices[3]&#x3D;2, therefore, the final price you will pay is 6 - 2 &#x3D; 4. </span><br><span class=\"line\">For items 3 and 4 you will not receive any discount at all.</span><br></pre></td></tr></table></figure>\n<p>方法一：暴力法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">finalPrices</span><span class=\"params\">(self, prices: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    n = len(prices)</span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i+<span class=\"number\">1</span>, n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> prices[j] &lt;= prices[i]:</span><br><span class=\"line\">                ans.append(prices[i]-prices[j])</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            ans.append(prices[i])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：stack. by lee215 </font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">finalPrices</span><span class=\"params\">(self, A: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    stack = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, a <span class=\"keyword\">in</span> enumerate(A):</span><br><span class=\"line\">        <span class=\"keyword\">while</span> stack <span class=\"keyword\">and</span> A[stack[<span class=\"number\">-1</span>]] &gt;= a:</span><br><span class=\"line\">            A[stack.pop()] -= a</span><br><span class=\"line\">        stack.append(i)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> A</span><br></pre></td></tr></table></figure>\n<h3 id=\"739-Daily-Temperature\"><a href=\"#739-Daily-Temperature\" class=\"headerlink\" title=\"739. Daily Temperature\"></a>739. Daily Temperature</h3><h4 id=\"找出比当前元素之后的大的值，计算索引差，没有则是0。原题\"><a href=\"#找出比当前元素之后的大的值，计算索引差，没有则是0。原题\" class=\"headerlink\" title=\"找出比当前元素之后的大的值，计算索引差，没有则是0。原题\"></a>找出比当前元素之后的大的值，计算索引差，没有则是0。<a href=\"https://leetcode.com/problems/daily-temperatures/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：刚刚做完1475的题，一样的解法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dailyTemperatures</span><span class=\"params\">(self, T: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    stack = []</span><br><span class=\"line\">    ans = [<span class=\"number\">0</span>] * len(T)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, t <span class=\"keyword\">in</span> enumerate(T):</span><br><span class=\"line\">        <span class=\"keyword\">while</span> stack <span class=\"keyword\">and</span> T[stack[<span class=\"number\">-1</span>]] &lt; t:</span><br><span class=\"line\">            j = stack.pop()</span><br><span class=\"line\">            ans[j] = i - j</span><br><span class=\"line\">        stack.append(i)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"394-Decode-String\"><a href=\"#394-Decode-String\" class=\"headerlink\" title=\"394. Decode String\"></a>394. Decode String</h3><h4 id=\"就是根据括号来重复字符串。原题\"><a href=\"#就是根据括号来重复字符串。原题\" class=\"headerlink\" title=\"就是根据括号来重复字符串。原题\"></a>就是根据括号来重复字符串。<a href=\"https://leetcode.com/problems/decode-string/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;3[a]2[bc]&quot;</span><br><span class=\"line\">Output: &quot;aaabcbc&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">Input: s &#x3D; &quot;3[a2[c]]&quot;</span><br><span class=\"line\">Output: &quot;accaccacc&quot;</span><br></pre></td></tr></table></figure>\n<p>方法一：使用了两个栈，分别存储数字和字母。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decodeString</span><span class=\"params\">(self, s: str)</span> -&gt; str:</span></span><br><span class=\"line\">    stack, cur, digit, d = [], <span class=\"string\">''</span>, [], <span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> c == <span class=\"string\">'['</span>:</span><br><span class=\"line\">            digit.append(d)</span><br><span class=\"line\">            d = <span class=\"string\">''</span></span><br><span class=\"line\">            stack.append(cur)</span><br><span class=\"line\">            cur = <span class=\"string\">''</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> c == <span class=\"string\">']'</span>:</span><br><span class=\"line\">            cur = stack.pop() + int(digit.pop()) * cur</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> c.isdigit():</span><br><span class=\"line\">            d += c</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            cur += c</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cur</span><br></pre></td></tr></table></figure>\n<p>方法二：使用一个stack，因为这个规律是有保证的，左括号前一定是数字。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decodeString</span><span class=\"params\">(self, s: str)</span> -&gt; str:</span></span><br><span class=\"line\">    stack, cur, d = [], <span class=\"string\">''</span>, <span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> c == <span class=\"string\">'['</span>:</span><br><span class=\"line\">            stack.append(cur)</span><br><span class=\"line\">            stack.append(d)</span><br><span class=\"line\">            d = <span class=\"string\">''</span></span><br><span class=\"line\">            cur = <span class=\"string\">''</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> c == <span class=\"string\">']'</span>:</span><br><span class=\"line\">            num = stack.pop()</span><br><span class=\"line\">            cur = stack.pop() + int(num) * cur</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> c.isdigit():</span><br><span class=\"line\">            d += c</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            cur += c</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cur</span><br></pre></td></tr></table></figure>\n<h3 id=\"1541-Minimum-Insertions-to-Balance-a-Parentheses-String\"><a href=\"#1541-Minimum-Insertions-to-Balance-a-Parentheses-String\" class=\"headerlink\" title=\"1541. Minimum Insertions to Balance a Parentheses String\"></a>1541. Minimum Insertions to Balance a Parentheses String</h3><h4 id=\"平衡一个括号对，最少需要插入多少次，括号对为一个-对应2个-。原题\"><a href=\"#平衡一个括号对，最少需要插入多少次，括号对为一个-对应2个-。原题\" class=\"headerlink\" title=\"平衡一个括号对，最少需要插入多少次，括号对为一个(对应2个)。原题\"></a>平衡一个括号对，最少需要插入多少次，括号对为一个(对应2个)。<a href=\"https://leetcode.com/problems/minimum-insertions-to-balance-a-parentheses-string/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;(()))&quot;</span><br><span class=\"line\">Output: 1</span><br><span class=\"line\">Explanation: The second &#39;(&#39; has two matching &#39;))&#39;, but the first &#39;(&#39; has only &#39;)&#39; matching. We need to to add one more &#39;)&#39; at the end of the string to be &quot;(())))&quot; which is balanced.</span><br></pre></td></tr></table></figure>\n<p>方法一：比赛时卡住了。这是Lee215的解法。想到了用栈和这种方式，但是没想好如何内部处理。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minInsertions</span><span class=\"params\">(self, s: str)</span> -&gt; int:</span></span><br><span class=\"line\">    ans = right = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> c == <span class=\"string\">'('</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> right&amp;<span class=\"number\">1</span> == <span class=\"number\">1</span>:</span><br><span class=\"line\">                right -= <span class=\"number\">1</span></span><br><span class=\"line\">                ans += <span class=\"number\">1</span></span><br><span class=\"line\">            right += <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            right -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> right &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                right += <span class=\"number\">2</span></span><br><span class=\"line\">                ans += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans + right</span><br></pre></td></tr></table></figure>\n<h3 id=\"856-Score-of-Parentheses\"><a href=\"#856-Score-of-Parentheses\" class=\"headerlink\" title=\"856. Score of Parentheses\"></a>856. Score of Parentheses</h3><h4 id=\"括号的分数，根据规则计算括号的分数。-表示1分；AB表示A-B，-A-表示A-2。原题\"><a href=\"#括号的分数，根据规则计算括号的分数。-表示1分；AB表示A-B，-A-表示A-2。原题\" class=\"headerlink\" title=\"括号的分数，根据规则计算括号的分数。()表示1分；AB表示A+B，(A)表示A*2。原题\"></a>括号的分数，根据规则计算括号的分数。<code>()</code>表示1分；AB表示A+B，<code>(A)</code>表示A*2。<a href=\"https://leetcode.com/problems/score-of-parentheses/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: &quot;()&quot;</span><br><span class=\"line\">Output: 1</span><br><span class=\"line\">Input: &quot;(())&quot;</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Input: &quot;(()(()))&quot;</span><br><span class=\"line\">Output: 6</span><br></pre></td></tr></table></figure>\n<p>方法一：首次AC的方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">scoreOfParentheses</span><span class=\"params\">(self, S: str)</span> -&gt; int:</span></span><br><span class=\"line\">    stack = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> S:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> c == <span class=\"string\">'('</span>:</span><br><span class=\"line\">            stack.append(c)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> stack[<span class=\"number\">-1</span>] == <span class=\"string\">'('</span>:</span><br><span class=\"line\">                stack.pop()</span><br><span class=\"line\">                stack.append(<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                v = <span class=\"number\">0</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> stack[<span class=\"number\">-1</span>] != <span class=\"string\">'('</span>:</span><br><span class=\"line\">                    v += stack.pop()</span><br><span class=\"line\">                stack.pop()</span><br><span class=\"line\">                stack.append(<span class=\"number\">2</span> * v)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(stack)</span><br></pre></td></tr></table></figure>\n<p>方法二：Lee的方法太盖了，但是不知道咋想的，这个思路的过程我还是没想明白。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">scoreOfParentheses</span><span class=\"params\">(self, S: str)</span> -&gt; int:</span></span><br><span class=\"line\">    stack, cur = [], <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> S:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == <span class=\"string\">'('</span>:</span><br><span class=\"line\">            stack.append(cur)</span><br><span class=\"line\">            cur = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            cur += stack.pop() + max(cur, <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cur</span><br></pre></td></tr></table></figure>\n<p>方法三：O(1)space的方法，同样牛逼。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">scoreOfParentheses</span><span class=\"params\">(self, S)</span>:</span></span><br><span class=\"line\">    res = l = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> itertools.izip(S, S[<span class=\"number\">1</span>:]):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> a + b == <span class=\"string\">'()'</span>: res += <span class=\"number\">2</span> ** l</span><br><span class=\"line\">        l += <span class=\"number\">1</span> <span class=\"keyword\">if</span> a == <span class=\"string\">'('</span> <span class=\"keyword\">else</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<p>方法四：这个方法倒是没想到。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">scoreOfParentheses</span><span class=\"params\">(self, S)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> eval(S.replace(<span class=\"string\">')('</span>, <span class=\"string\">')+('</span>).replace(<span class=\"string\">'()'</span>, <span class=\"string\">'1'</span>).replace(<span class=\"string\">')'</span>, <span class=\"string\">')*2'</span>))</span><br></pre></td></tr></table></figure>\n<h4 id=\"面试题-08-06-汉诺塔问题\"><a href=\"#面试题-08-06-汉诺塔问题\" class=\"headerlink\" title=\"面试题 08.06. 汉诺塔问题\"></a><a href=\"https://leetcode-cn.com/problems/hanota-lcci/\" target=\"_blank\" rel=\"noopener\">面试题 08.06. 汉诺塔问题</a></h4><h4 id=\"经典的汉诺塔问题，一个三个柱子，将盘子从A移动到C。\"><a href=\"#经典的汉诺塔问题，一个三个柱子，将盘子从A移动到C。\" class=\"headerlink\" title=\"经典的汉诺塔问题，一个三个柱子，将盘子从A移动到C。\"></a>经典的汉诺塔问题，一个三个柱子，将盘子从A移动到C。</h4><p>方法一：分治思想。</p>\n<p>n = 1 时，直接把盘子从 A 移到 C；<br>n &gt; 1 时，<br>先把上面 n - 1 个盘子从 A 移到 B（子问题，递归）；<br>再将最大的盘子从 A 移到 C；<br>再将 B 上 n - 1 个盘子从 B 移到 C（子问题，递归）。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hanota</span><span class=\"params\">(self, A: List[int], B: List[int], C: List[int])</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> A: <span class=\"keyword\">return</span></span><br><span class=\"line\">    n = len(A)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">move</span><span class=\"params\">(n, a, b, c)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">1</span>:</span><br><span class=\"line\">            c.append(a.pop())</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            move(n<span class=\"number\">-1</span>, a, c, b)</span><br><span class=\"line\">            c.append(a.pop())</span><br><span class=\"line\">            move(n<span class=\"number\">-1</span>, b, a, c)</span><br><span class=\"line\"></span><br><span class=\"line\">    move(n, A, B, C)</span><br></pre></td></tr></table></figure>\n<h3 id=\"316-Remove-Duplicate-Letters\"><a href=\"#316-Remove-Duplicate-Letters\" class=\"headerlink\" title=\"316. Remove Duplicate Letters\"></a><a href=\"https://leetcode.com/problems/remove-duplicate-letters/\" target=\"_blank\" rel=\"noopener\">316. Remove Duplicate Letters</a></h3><h4 id=\"移除重复的字符，保证最后结果是字典序最小的。\"><a href=\"#移除重复的字符，保证最后结果是字典序最小的。\" class=\"headerlink\" title=\"移除重复的字符，保证最后结果是字典序最小的。\"></a>移除重复的字符，保证最后结果是字典序最小的。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;bcabc&quot;</span><br><span class=\"line\">Output: &quot;abc&quot;</span><br><span class=\"line\">Input: s &#x3D; &quot;cbacdcbc&quot;</span><br><span class=\"line\">Output: &quot;acdb&quot;</span><br></pre></td></tr></table></figure>\n<p>方法一：使用stack来辅助判断。Lee的方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removeDuplicateLetters</span><span class=\"params\">(self, s: str)</span> -&gt; str:</span></span><br><span class=\"line\">    idx = &#123;c: i <span class=\"keyword\">for</span> i, c <span class=\"keyword\">in</span> enumerate(s)&#125;</span><br><span class=\"line\">    stack = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, c <span class=\"keyword\">in</span> enumerate(s):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> c <span class=\"keyword\">in</span> stack: <span class=\"keyword\">continue</span>  <span class=\"comment\"># 这句别忘了 \"cbacdcbc\"</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> stack <span class=\"keyword\">and</span> stack[<span class=\"number\">-1</span>]&gt;c <span class=\"keyword\">and</span> idx[stack[<span class=\"number\">-1</span>]]&gt;i:</span><br><span class=\"line\">            stack.pop()</span><br><span class=\"line\">        stack.append(c)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(stack)</span><br></pre></td></tr></table></figure>\n<h3 id=\"503-Next-Greater-Element-II\"><a href=\"#503-Next-Greater-Element-II\" class=\"headerlink\" title=\"503. Next Greater Element II\"></a>503. Next Greater Element II</h3><h4 id=\"下一个比当前元素大的元素，数组首位连接。原题\"><a href=\"#下一个比当前元素大的元素，数组首位连接。原题\" class=\"headerlink\" title=\"下一个比当前元素大的元素，数组首位连接。原题\"></a>下一个比当前元素大的元素，数组首位连接。<a href=\"https://leetcode.com/problems/next-greater-element-ii/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>和1030题相似。方法一：首位连接，所以要遍历两次。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">nextGreaterElements</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    ans, stack = [], []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums * <span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> stack <span class=\"keyword\">and</span> stack[<span class=\"number\">-1</span>][<span class=\"number\">1</span>] &lt; num:</span><br><span class=\"line\">            ans[stack.pop()[<span class=\"number\">0</span>]] = num</span><br><span class=\"line\">        stack.append((len(ans), num))</span><br><span class=\"line\">        ans.append(<span class=\"number\">-1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans[:len(nums)]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：实际并不需要保存数字。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">nextGreaterElements</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    ans, stack = [<span class=\"number\">-1</span>]*len(nums), []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> list(range(len(nums)))*<span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> stack <span class=\"keyword\">and</span> nums[stack[<span class=\"number\">-1</span>]] &lt; nums[i]:</span><br><span class=\"line\">            ans[stack.pop()] = nums[i]</span><br><span class=\"line\">        stack.append(i)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"946-Validate-Stack-Sequences\"><a href=\"#946-Validate-Stack-Sequences\" class=\"headerlink\" title=\"946. Validate Stack Sequences\"></a>946. Validate Stack Sequences</h3><h4 id=\"给定一个入栈和出栈的顺序，判断是否最后可以清空该栈。原题\"><a href=\"#给定一个入栈和出栈的顺序，判断是否最后可以清空该栈。原题\" class=\"headerlink\" title=\"给定一个入栈和出栈的顺序，判断是否最后可以清空该栈。原题\"></a>给定一个入栈和出栈的顺序，判断是否最后可以清空该栈。<a href=\"https://leetcode.com/problems/validate-stack-sequences/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,5,3,2,1]</span><br><span class=\"line\">Output: true</span><br><span class=\"line\">Explanation: We might do the following sequence:</span><br><span class=\"line\">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class=\"line\">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br><span class=\"line\"></span><br><span class=\"line\">Input: pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,3,5,1,2]</span><br><span class=\"line\">Output: false</span><br><span class=\"line\">Explanation: 1 cannot be popped before 2.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">validateStackSequences</span><span class=\"params\">(self, pushed: <span class=\"string\">'List[int]'</span>, popped: <span class=\"string\">'List[int]'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\">    stack = []</span><br><span class=\"line\">    j = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> pushed:</span><br><span class=\"line\">        stack.append(num)</span><br><span class=\"line\">        <span class=\"keyword\">while</span> stack <span class=\"keyword\">and</span> stack[<span class=\"number\">-1</span>] == popped[j]:</span><br><span class=\"line\">            stack.pop()</span><br><span class=\"line\">            j += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> j == len(popped)</span><br></pre></td></tr></table></figure>\n<h3 id=\"735-Asteroid-Collision\"><a href=\"#735-Asteroid-Collision\" class=\"headerlink\" title=\"735. Asteroid Collision\"></a><a href=\"https://leetcode.com/problems/asteroid-collision/\" target=\"_blank\" rel=\"noopener\">735. Asteroid Collision</a></h3><h4 id=\"行星碰撞，在一个横轴上有些数字表示行星的质量，正负表示方向，所有的行星以相同的速度运行，两个行星碰撞后质量小的会消失，相同则都消失，问最后剩余的行星。\"><a href=\"#行星碰撞，在一个横轴上有些数字表示行星的质量，正负表示方向，所有的行星以相同的速度运行，两个行星碰撞后质量小的会消失，相同则都消失，问最后剩余的行星。\" class=\"headerlink\" title=\"行星碰撞，在一个横轴上有些数字表示行星的质量，正负表示方向，所有的行星以相同的速度运行，两个行星碰撞后质量小的会消失，相同则都消失，问最后剩余的行星。\"></a>行星碰撞，在一个横轴上有些数字表示行星的质量，正负表示方向，所有的行星以相同的速度运行，两个行星碰撞后质量小的会消失，相同则都消失，问最后剩余的行星。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: asteroids &#x3D; [5,10,-5]</span><br><span class=\"line\">Output: [5,10]</span><br><span class=\"line\">Explanation: The 10 and -5 collide resulting in 10.  The 5 and 10 never collide</span><br></pre></td></tr></table></figure>\n<p>方法一：很容易想到stack来解决，15分钟AC，需要注意内部也需要使用循环，因为有<code>[10, 1, -5]</code>这种情况，所以需要内循环不停地比较和碰撞。自认为比最高票答案写得简洁一些。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">asteroidCollision</span><span class=\"params\">(self, asteroids: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    stack = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> asteroids:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> stack <span class=\"keyword\">and</span> a&lt;<span class=\"number\">0</span> <span class=\"keyword\">and</span> stack[<span class=\"number\">-1</span>]&gt;<span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> stack[<span class=\"number\">-1</span>] &gt; -a:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                last = stack.pop()</span><br><span class=\"line\">                <span class=\"keyword\">if</span> last == -a:</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            stack.append(a)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stack</span><br></pre></td></tr></table></figure>\n<h3 id=\"456-132-Pattern\"><a href=\"#456-132-Pattern\" class=\"headerlink\" title=\"456. 132 Pattern\"></a><a href=\"https://leetcode.com/problems/132-pattern/\" target=\"_blank\" rel=\"noopener\">456. 132 Pattern</a></h3><p>是否有子序列是13,2的模式，即存在i&lt;j&lt;k，nums[i]&lt;nums[j]&lt;nums[k]</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [1,2,3,4]</span><br><span class=\"line\">Output: false</span><br><span class=\"line\">Explanation: There is no 132 pattern in the sequence.</span><br></pre></td></tr></table></figure>\n<p>方法一：栈，挺难想的，看了答案才明白。third表示在当前值之后的小于当前数中最大的一个。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">find132pattern</span><span class=\"params\">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class=\"line\">    stack = []</span><br><span class=\"line\">    third = float(<span class=\"string\">'-inf'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> reversed(nums):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> num &lt; third: <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> stack <span class=\"keyword\">and</span> stack[<span class=\"number\">-1</span>]&lt;num:</span><br><span class=\"line\">            third = stack.pop()</span><br><span class=\"line\">        stack.append(num)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1673-Find-the-Most-Competitive-Subsequence\"><a href=\"#1673-Find-the-Most-Competitive-Subsequence\" class=\"headerlink\" title=\"1673. Find the Most Competitive Subsequence\"></a><a href=\"https://leetcode.com/problems/find-the-most-competitive-subsequence/\" target=\"_blank\" rel=\"noopener\">1673. Find the Most Competitive Subsequence</a></h3><h4 id=\"找到一个长度为k的最小的子序列。\"><a href=\"#找到一个长度为k的最小的子序列。\" class=\"headerlink\" title=\"找到一个长度为k的最小的子序列。\"></a>找到一个长度为k的最小的子序列。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [3,5,2,6], k &#x3D; 2</span><br><span class=\"line\">Output: [2,6]</span><br><span class=\"line\">Explanation: Among the set of every possible subsequence: &#123;[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]&#125;, [2,6] is the most competitive.</span><br></pre></td></tr></table></figure>\n<p>方法一：竞赛时用了一个比较暴力+tricky方法过了5000个0的case。这题有些贪心的思想在里。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mostCompetitive</span><span class=\"params\">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class=\"line\">    stack, N = [], len(nums)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> sorted(nums) == nums:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[:k]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, num <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">        <span class=\"keyword\">while</span> stack <span class=\"keyword\">and</span> stack[<span class=\"number\">-1</span>] &gt; num <span class=\"keyword\">and</span> len(stack)+N-i &gt; k:</span><br><span class=\"line\">            stack.pop()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(stack) &lt; k:</span><br><span class=\"line\">            stack.append(num)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stack</span><br></pre></td></tr></table></figure>\n<h3 id=\"84-Largest-Rectangle-in-Histogram\"><a href=\"#84-Largest-Rectangle-in-Histogram\" class=\"headerlink\" title=\"84. Largest Rectangle in Histogram\"></a><a href=\"https://leetcode.com/problems/largest-rectangle-in-histogram/\" target=\"_blank\" rel=\"noopener\">84. Largest Rectangle in Histogram</a></h3><h4 id=\"柱形图里最大的矩形面积。\"><a href=\"#柱形图里最大的矩形面积。\" class=\"headerlink\" title=\"柱形图里最大的矩形面积。\"></a>柱形图里最大的矩形面积。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [2,1,5,6,2,3]</span><br><span class=\"line\">Output: 10</span><br></pre></td></tr></table></figure>\n<p>方法一：单调栈，维护一个单调递增的栈，出栈时计算此高度的最大宽度，从而得出面积。一个难想的地方在于，这里每次出栈都更新一次结果。栈初始化为[-1]和尾部添0是一套操作，避免特殊情况的判断。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">largestRectangleArea</span><span class=\"params\">(self, heights: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    heights.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">    stack, res = [<span class=\"number\">-1</span>], <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, h <span class=\"keyword\">in</span> enumerate(heights):</span><br><span class=\"line\">        <span class=\"keyword\">while</span> heights[stack[<span class=\"number\">-1</span>]] &gt; h:</span><br><span class=\"line\">            hh = heights[stack.pop()]</span><br><span class=\"line\">            w = i - stack[<span class=\"number\">-1</span>] - <span class=\"number\">1</span></span><br><span class=\"line\">            res = max(res, hh * w)</span><br><span class=\"line\">        stack.append(i)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"895-Maximum-Frequency-Stack\"><a href=\"#895-Maximum-Frequency-Stack\" class=\"headerlink\" title=\"895. Maximum Frequency Stack\"></a><a href=\"https://leetcode.com/problems/maximum-frequency-stack/\" target=\"_blank\" rel=\"noopener\">895. Maximum Frequency Stack</a></h3><h4 id=\"最大频率栈，每次返回频率最多的数。\"><a href=\"#最大频率栈，每次返回频率最多的数。\" class=\"headerlink\" title=\"最大频率栈，每次返回频率最多的数。\"></a>最大频率栈，每次返回频率最多的数。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: </span><br><span class=\"line\">[&quot;FreqStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;],</span><br><span class=\"line\">[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]</span><br><span class=\"line\">Output: [null,null,null,null,null,null,null,5,7,5,4]</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">After making six .push operations, the stack is [5,7,5,7,4,5] from bottom to top.  Then:</span><br><span class=\"line\"></span><br><span class=\"line\">pop() -&gt; returns 5, as 5 is the most frequent.</span><br><span class=\"line\">The stack becomes [5,7,5,7,4].</span><br><span class=\"line\"></span><br><span class=\"line\">pop() -&gt; returns 7, as 5 and 7 is the most frequent, but 7 is closest to the top.</span><br><span class=\"line\">The stack becomes [5,7,5,4].</span><br><span class=\"line\"></span><br><span class=\"line\">pop() -&gt; returns 5.</span><br><span class=\"line\">The stack becomes [5,7,4].</span><br><span class=\"line\"></span><br><span class=\"line\">pop() -&gt; returns 4.</span><br><span class=\"line\">The stack becomes [5,7].</span><br></pre></td></tr></table></figure>\n<p>方法一：这题的关键是要想明白数据冗余。每个频率上都保存一次数据。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FreqStack</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.cnt = Counter()</span><br><span class=\"line\">        self.freq = defaultdict(list)</span><br><span class=\"line\">        self.max_freq = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">push</span><span class=\"params\">(self, x: int)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        self.cnt[x] += <span class=\"number\">1</span></span><br><span class=\"line\">        self.max_freq = max(self.max_freq, self.cnt[x])</span><br><span class=\"line\">        self.freq[self.cnt[x]].append(x)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pop</span><span class=\"params\">(self)</span> -&gt; int:</span></span><br><span class=\"line\">        d = self.freq[self.max_freq].pop()</span><br><span class=\"line\">        self.cnt[d] -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self.freq[self.max_freq]:</span><br><span class=\"line\">            self.max_freq -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> d</span><br></pre></td></tr></table></figure>\n<h3 id=\"1776-Car-Fleet-II\"><a href=\"#1776-Car-Fleet-II\" class=\"headerlink\" title=\"1776. Car Fleet II\"></a><a href=\"https://leetcode.com/problems/car-fleet-ii/\" target=\"_blank\" rel=\"noopener\">1776. Car Fleet II</a></h3><h4 id=\"车队，同853很像，区别在于求每辆车和前面车相撞的时间。\"><a href=\"#车队，同853很像，区别在于求每辆车和前面车相撞的时间。\" class=\"headerlink\" title=\"车队，同853很像，区别在于求每辆车和前面车相撞的时间。\"></a>车队，同853很像，区别在于求每辆车和前面车相撞的时间。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: cars &#x3D; [[1,2],[2,1],[4,3],[7,2]]</span><br><span class=\"line\">Output: [1.00000,-1.00000,3.00000,-1.00000]</span><br><span class=\"line\">Explanation: After exactly one second, the first car will collide with the second car, and form a car fleet with speed 1 m&#x2F;s. After exactly 3 seconds, the third car will collide with the fourth car, and form a car fleet with speed 2 m&#x2F;s.</span><br></pre></td></tr></table></figure>\n<p>方法一：比赛时没有解出来，这是Lee的答案</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getCollisionTimes</span><span class=\"params\">(self, A: List[List[int]])</span> -&gt; List[float]:</span></span><br><span class=\"line\">    stack = []</span><br><span class=\"line\">    N = len(A)</span><br><span class=\"line\">    res = [<span class=\"number\">-1</span>] * N</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(N<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">        p, s = A[i]</span><br><span class=\"line\">        <span class=\"comment\"># 不能是-1， 时间&gt;则不能相撞</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> stack <span class=\"keyword\">and</span> (s&lt;=A[stack[<span class=\"number\">-1</span>]][<span class=\"number\">1</span>] <span class=\"keyword\">or</span> (A[stack[<span class=\"number\">-1</span>]][<span class=\"number\">0</span>]-p) / (s-A[stack[<span class=\"number\">-1</span>]][<span class=\"number\">1</span>]) &gt;= res[stack[<span class=\"number\">-1</span>]]&gt;<span class=\"number\">0</span>):</span><br><span class=\"line\">            stack.pop()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> stack:</span><br><span class=\"line\">            res[i] = (A[stack[<span class=\"number\">-1</span>]][<span class=\"number\">0</span>]-p) / (s-A[stack[<span class=\"number\">-1</span>]][<span class=\"number\">1</span>])</span><br><span class=\"line\">        stack.append(i)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"150-Evaluate-Reverse-Polish-Notation\"><a href=\"#150-Evaluate-Reverse-Polish-Notation\" class=\"headerlink\" title=\"150. Evaluate Reverse Polish Notation\"></a><a href=\"https://leetcode.com/problems/evaluate-reverse-polish-notation/\" target=\"_blank\" rel=\"noopener\">150. Evaluate Reverse Polish Notation</a></h3><h4 id=\"计算逆波兰表达式。\"><a href=\"#计算逆波兰表达式。\" class=\"headerlink\" title=\"计算逆波兰表达式。\"></a>计算逆波兰表达式。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: tokens &#x3D; [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]</span><br><span class=\"line\">Output: 9</span><br><span class=\"line\">Explanation: ((2 + 1) * 3) &#x3D; 9</span><br></pre></td></tr></table></figure>\n<p>方法一：提本身不难，Python有2个坑。一个是<code>isdigit(&quot;-1&quot;)</code>居然返回False。另一个是<code>6//-13</code>值为<code>-1</code>是向下取整。这和golang表现不一样。golang会输出0.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">evalRPN</span><span class=\"params\">(self, tokens: List[str])</span> -&gt; int:</span></span><br><span class=\"line\">    stack = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> token <span class=\"keyword\">in</span> tokens:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> token[<span class=\"number\">-1</span>].isdigit():</span><br><span class=\"line\">            stack.append(int(token))</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> token == <span class=\"string\">\"+\"</span>:</span><br><span class=\"line\">            stack.append(stack.pop() + stack.pop())</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> token == <span class=\"string\">\"-\"</span>:</span><br><span class=\"line\">            a, b = stack.pop(), stack.pop()</span><br><span class=\"line\">            stack.append(b - a)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> token == <span class=\"string\">\"*\"</span>:</span><br><span class=\"line\">            stack.append(stack.pop() * stack.pop())</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            a, b = stack.pop(), stack.pop()</span><br><span class=\"line\">            stack.append(int(b / a))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stack[<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"224-Basic-Calculator\"><a href=\"#224-Basic-Calculator\" class=\"headerlink\" title=\"224. Basic Calculator\"></a><a href=\"https://leetcode.com/problems/basic-calculator/\" target=\"_blank\" rel=\"noopener\">224. Basic Calculator</a></h3><h4 id=\"实现一个计算带有括号的，只包含-的算式。\"><a href=\"#实现一个计算带有括号的，只包含-的算式。\" class=\"headerlink\" title=\"实现一个计算带有括号的，只包含+-的算式。\"></a>实现一个计算带有括号的，只包含+-的算式。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;(1+(4+5+2)-3)+(6+8)&quot;</span><br><span class=\"line\">Output: 23</span><br></pre></td></tr></table></figure>\n<p>方法一：栈，sign初始化2个1，是因为本身算式算一个+，如果是左括号开头又算一个+。这里我想到的差了一个1.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">calculate</span><span class=\"params\">(self, s: str)</span> -&gt; int:</span></span><br><span class=\"line\">    sign = [<span class=\"number\">1</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\">    res = i = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> i &lt; len(s):</span><br><span class=\"line\">        c = s[i]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> c.isdigit():</span><br><span class=\"line\">            start = i</span><br><span class=\"line\">            <span class=\"keyword\">while</span> i&lt;len(s) <span class=\"keyword\">and</span> s[i].isdigit():</span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">            res += sign.pop() * int(s[start:i])  </span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>  c <span class=\"keyword\">in</span> <span class=\"string\">\"+(-\"</span>:</span><br><span class=\"line\">            sign.append(sign[<span class=\"number\">-1</span>]*([<span class=\"number\">1</span>, <span class=\"number\">-1</span>][c==<span class=\"string\">\"-\"</span>]))</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> c == <span class=\"string\">\")\"</span>:</span><br><span class=\"line\">            sign.pop()</span><br><span class=\"line\">        i += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"1856-Maximum-Subarray-Min-Product\"><a href=\"#1856-Maximum-Subarray-Min-Product\" class=\"headerlink\" title=\"1856. Maximum Subarray Min-Product\"></a><a href=\"https://leetcode.com/problems/maximum-subarray-min-product/\" target=\"_blank\" rel=\"noopener\">1856. Maximum Subarray Min-Product</a></h3><h4 id=\"找到子数组，使得子数组的和与最小值的积最大。\"><a href=\"#找到子数组，使得子数组的和与最小值的积最大。\" class=\"headerlink\" title=\"找到子数组，使得子数组的和与最小值的积最大。\"></a>找到子数组，使得子数组的和与最小值的积最大。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [1,2,3,2]</span><br><span class=\"line\">Output: 14</span><br><span class=\"line\">Explanation: The maximum min-product is achieved with the subarray [2,3,2] (minimum value is 2).</span><br><span class=\"line\">2 * (2+3+2) &#x3D; 2 * 7 &#x3D; 14.</span><br></pre></td></tr></table></figure>\n<p>方法一：比赛时思路对了，没有写出代码，其实枚举最小值就行，然后通过前缀和来找到，对于这个最小值，最侧第一个比它小的，和右侧第一个比它小的。使用单调递增栈来实现。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxSumMinProduct</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    MOD = <span class=\"number\">10</span> ** <span class=\"number\">9</span> + <span class=\"number\">7</span></span><br><span class=\"line\">    N = len(nums)</span><br><span class=\"line\">    left = [<span class=\"number\">0</span>] * N</span><br><span class=\"line\">    right = [N] * N</span><br><span class=\"line\">    stack = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, num <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">        <span class=\"keyword\">while</span> stack <span class=\"keyword\">and</span> nums[stack[<span class=\"number\">-1</span>]]&gt;=num:</span><br><span class=\"line\">            right[stack[<span class=\"number\">-1</span>]] = i</span><br><span class=\"line\">            stack.pop()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> stack:</span><br><span class=\"line\">            left[i] = stack[<span class=\"number\">-1</span>] + <span class=\"number\">1</span></span><br><span class=\"line\">        stack.append(i)</span><br><span class=\"line\">    pre_sum = list(accumulate([<span class=\"number\">0</span>]+nums))</span><br><span class=\"line\">    res = max((pre_sum[right[i]]-pre_sum[left[i]])*num <span class=\"keyword\">for</span> i, num <span class=\"keyword\">in</span> enumerate(nums))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res % MOD</span><br></pre></td></tr></table></figure>\n<h3 id=\"1944-Number-of-Visible-People-in-a-Queue\"><a href=\"#1944-Number-of-Visible-People-in-a-Queue\" class=\"headerlink\" title=\"1944. Number of Visible People in a Queue\"></a><a href=\"https://leetcode.com/problems/number-of-visible-people-in-a-queue/\" target=\"_blank\" rel=\"noopener\">1944. Number of Visible People in a Queue</a></h3><h4 id=\"右侧可以看见多少个人，可以看到比自己矮的。\"><a href=\"#右侧可以看见多少个人，可以看到比自己矮的。\" class=\"headerlink\" title=\"右侧可以看见多少个人，可以看到比自己矮的。\"></a>右侧可以看见多少个人，可以看到比自己矮的。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: heights &#x3D; [10,6,8,5,11,9]</span><br><span class=\"line\">Output: [3,1,2,1,1,0]</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">Person 0 can see person 1, 2, and 4.</span><br><span class=\"line\">Person 1 can see person 2.</span><br><span class=\"line\">Person 2 can see person 3 and 4.</span><br><span class=\"line\">Person 3 can see person 4.</span><br><span class=\"line\">Person 4 can see person 5.</span><br><span class=\"line\">Person 5 can see no one since nobody is to the right of them.</span><br></pre></td></tr></table></figure>\n<p>方法一：比赛的时候想到单调栈，但是不知道怎么写，这是比较简单的题了。<br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">canSeePersonsCount</span><span class=\"params\">(self, heights: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    N = len(heights)</span><br><span class=\"line\">    res = [<span class=\"number\">0</span>] * N</span><br><span class=\"line\">    stack = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(N<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">while</span> stack:</span><br><span class=\"line\">            res[i] += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> heights[i] &gt; heights[stack[<span class=\"number\">-1</span>]]:</span><br><span class=\"line\">                stack.pop()</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">        stack.append(i)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure></p>\n","categories":["算法"],"tags":["LeetCode","Python","Algorithm"]},{"title":"记一次淘宝接口sign签名破解","url":"/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%B7%98%E5%AE%9D%E6%8E%A5%E5%8F%A3sign%E7%AD%BE%E5%90%8D%E7%A0%B4%E8%A7%A3/","content":"<h3 id=\"淘宝H5页面接口Sign签名破解\"><a href=\"#淘宝H5页面接口Sign签名破解\" class=\"headerlink\" title=\"淘宝H5页面接口Sign签名破解\"></a>淘宝H5页面接口Sign签名破解</h3><p>前言：由于公司业务需求，需要显示淘宝商品详情页面的图文详情部分。之前原业务逻辑是根据<code>https://world.taobao.com/item/{num_iid}.htm</code>，在得到html文本后全量通过图片前缀名如<code>https://img.alicdn.com/imgextra</code>进行抓取，返回给客户端。</p>\n<a id=\"more\"></a>\n<p>由于header中的UA传的一个PC端的UA，所以获取的H5数据中，可能含有一些广告，商家之类自己的布局，从而无法在客户端正常展示。另一方面，该接口为高频接口，打开htm页面每次耗时70~80%，严重影响客户端体验，所以对此将接口进行升级。</p>\n<p>后来发现手机上打开该页面是不显示一些无关的广告的，而且布局也正常。于是将UA改为了手机端的UA，然后通过抓包分析，返回的页面是一个不包含图片的html，图文详情是根据js接口调用动态渲染。接口为<code>https://h5api.m.taobao.com/h5/mtop.wdetail.getitemdescx/4.9/?jsv=2.4.11&amp;appKey=12574478&amp;t=1544165283634&amp;sign=c691925755f2ff429c950f7b00903a23&amp;api=mtop.wdetail.getItemDescx&amp;v=4.9&amp;type=jsonp&amp;dataType=jsonp&amp;callback=mtopjsonp6&amp;data=%7B%22item_num_id%22%3A%22554401452734%22%7D</code>。看到参数中包含了<code>sign</code>，所以是根据某种规则算出来的签名。</p>\n<p>接着就是找到<code>sign</code>的签名算法了，将页面中的js格式化了一下。找到关于sign签名的部分。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">s.prototype.__processRequestUrl = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">    &#123;<span class=\"keyword\">var</span> e = <span class=\"keyword\">this</span>.params,</span><br><span class=\"line\">    r = <span class=\"keyword\">this</span>.options;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r.hostSetting &amp;&amp; r.hostSetting[t.location.hostname]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> o = r.hostSetting[t.location.hostname];</span><br><span class=\"line\">        o.prefix &amp;&amp; (r.prefix = o.prefix),</span><br><span class=\"line\">        o.subDomain &amp;&amp; (r.subDomain = o.subDomain),</span><br><span class=\"line\">        o.mainDomain &amp;&amp; (r.mainDomain = o.mainDomain)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"number\">0</span> === r.H5Request) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> i = <span class=\"string\">\"//\"</span> + (r.prefix ? r.prefix + <span class=\"string\">\".\"</span>: <span class=\"string\">\"\"</span>) + (r.subDomain ? r.subDomain + <span class=\"string\">\".\"</span>: <span class=\"string\">\"\"</span>) + r.mainDomain + <span class=\"string\">\"/h5/\"</span> + e.api.toLowerCase() + <span class=\"string\">\"/\"</span> + e.v.toLowerCase() + <span class=\"string\">\"/\"</span>,</span><br><span class=\"line\">        a = e.appKey || (<span class=\"string\">\"waptest\"</span> === r.subDomain ? <span class=\"string\">\"4272\"</span>: <span class=\"string\">\"12574478\"</span>),</span><br><span class=\"line\">        c = (<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>).getTime(),</span><br><span class=\"line\">        u = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">t</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">n</span>(<span class=\"params\">t, n</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> t &lt;&lt; n | t &gt;&gt;&gt; <span class=\"number\">32</span> - n</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">e</span>(<span class=\"params\">t, n</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> e, r, o, i, a;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> o = <span class=\"number\">2147483648</span> &amp; t,</span><br><span class=\"line\">                i = <span class=\"number\">2147483648</span> &amp; n,</span><br><span class=\"line\">                a = (<span class=\"number\">1073741823</span> &amp; t) + (<span class=\"number\">1073741823</span> &amp; n),</span><br><span class=\"line\">                (e = <span class=\"number\">1073741824</span> &amp; t) &amp; (r = <span class=\"number\">1073741824</span> &amp; n) ? <span class=\"number\">2147483648</span> ^ a ^ o ^ i: e | r ? <span class=\"number\">1073741824</span> &amp; a ? <span class=\"number\">3221225472</span> ^ a ^ o ^ i: <span class=\"number\">1073741824</span> ^ a ^ o ^ i: a ^ o ^ i</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">r</span>(<span class=\"params\">t, r, o, i, a, c, u</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> e(n(t = e(t, e(e(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">t, n, e</span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> t &amp; n | ~t &amp; e</span><br><span class=\"line\">                &#125; (r, o, i), a), u)), c), r)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">o</span>(<span class=\"params\">t, r, o, i, a, c, u</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> e(n(t = e(t, e(e(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">t, n, e</span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> t &amp; e | n &amp; ~e</span><br><span class=\"line\">                &#125; (r, o, i), a), u)), c), r)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">i</span>(<span class=\"params\">t, r, o, i, a, c, u</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> e(n(t = e(t, e(e(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">t, n, e</span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> t ^ n ^ e</span><br><span class=\"line\">                &#125; (r, o, i), a), u)), c), r)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\">t, r, o, i, a, c, u</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> e(n(t = e(t, e(e(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">t, n, e</span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> n ^ (t | ~e)</span><br><span class=\"line\">                &#125; (r, o, i), a), u)), c), r)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">c</span>(<span class=\"params\">t</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> n, e = <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">                r = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (n = <span class=\"number\">0</span>; <span class=\"number\">3</span> &gt;= n; n++) e += (r = <span class=\"string\">\"0\"</span> + (t &gt;&gt;&gt; <span class=\"number\">8</span> * n &amp; <span class=\"number\">255</span>).toString(<span class=\"number\">16</span>)).substr(r.length - <span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> e</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> u, s, f, l, p, d, h, v, m, g;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (g = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">t</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> n, e = t.length,</span><br><span class=\"line\">                r = e + <span class=\"number\">8</span>,</span><br><span class=\"line\">                o = <span class=\"number\">16</span> * ((r - r % <span class=\"number\">64</span>) / <span class=\"number\">64</span> + <span class=\"number\">1</span>), i = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(o - <span class=\"number\">1</span>), a = <span class=\"number\">0</span>, c = <span class=\"number\">0</span>; e &gt; c;) a = c % <span class=\"number\">4</span> * <span class=\"number\">8</span>,</span><br><span class=\"line\">                i[n = (c - c % <span class=\"number\">4</span>) / <span class=\"number\">4</span>] = i[n] | t.charCodeAt(c) &lt;&lt; a,</span><br><span class=\"line\">                c++;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> a = c % <span class=\"number\">4</span> * <span class=\"number\">8</span>,</span><br><span class=\"line\">                i[n = (c - c % <span class=\"number\">4</span>) / <span class=\"number\">4</span>] = i[n] | <span class=\"number\">128</span> &lt;&lt; a,</span><br><span class=\"line\">                i[o - <span class=\"number\">2</span>] = e &lt;&lt; <span class=\"number\">3</span>,</span><br><span class=\"line\">                i[o - <span class=\"number\">1</span>] = e &gt;&gt;&gt; <span class=\"number\">29</span>,</span><br><span class=\"line\">                i</span><br><span class=\"line\">            &#125; (t = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">t</span>) </span>&#123;</span><br><span class=\"line\">                t = t.replace(<span class=\"regexp\">/\\r\\n/g</span>, <span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> n = <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">                e = <span class=\"number\">0</span>; e &lt; t.length; e++) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> r = t.charCodeAt(e);</span><br><span class=\"line\">                    <span class=\"number\">128</span> &gt; r ? n += <span class=\"built_in\">String</span>.fromCharCode(r) : r &gt; <span class=\"number\">127</span> &amp;&amp; <span class=\"number\">2048</span> &gt; r ? (n += <span class=\"built_in\">String</span>.fromCharCode(r &gt;&gt; <span class=\"number\">6</span> | <span class=\"number\">192</span>), n += <span class=\"built_in\">String</span>.fromCharCode(<span class=\"number\">63</span> &amp; r | <span class=\"number\">128</span>)) : (n += <span class=\"built_in\">String</span>.fromCharCode(r &gt;&gt; <span class=\"number\">12</span> | <span class=\"number\">224</span>), n += <span class=\"built_in\">String</span>.fromCharCode(r &gt;&gt; <span class=\"number\">6</span> &amp; <span class=\"number\">63</span> | <span class=\"number\">128</span>), n += <span class=\"built_in\">String</span>.fromCharCode(<span class=\"number\">63</span> &amp; r | <span class=\"number\">128</span>))</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> n</span><br><span class=\"line\">            &#125; (t)), d = <span class=\"number\">1732584193</span>, h = <span class=\"number\">4023233417</span>, v = <span class=\"number\">2562383102</span>, m = <span class=\"number\">271733878</span>, u = <span class=\"number\">0</span>; u &lt; g.length; u += <span class=\"number\">16</span>) s = d,</span><br><span class=\"line\">            f = h,</span><br><span class=\"line\">            l = v,</span><br><span class=\"line\">            p = m,</span><br><span class=\"line\">            h = a(h = a(h = a(h = a(h = i(h = i(h = i(h = i(h = o(h = o(h = o(h = o(h = r(h = r(h = r(h = r(h, v = r(v, m = r(m, d = r(d, h, v, m, g[u + <span class=\"number\">0</span>], <span class=\"number\">7</span>, <span class=\"number\">3614090360</span>), h, v, g[u + <span class=\"number\">1</span>], <span class=\"number\">12</span>, <span class=\"number\">3905402710</span>), d, h, g[u + <span class=\"number\">2</span>], <span class=\"number\">17</span>, <span class=\"number\">606105819</span>), m, d, g[u + <span class=\"number\">3</span>], <span class=\"number\">22</span>, <span class=\"number\">3250441966</span>), v = r(v, m = r(m, d = r(d, h, v, m, g[u + <span class=\"number\">4</span>], <span class=\"number\">7</span>, <span class=\"number\">4118548399</span>), h, v, g[u + <span class=\"number\">5</span>], <span class=\"number\">12</span>, <span class=\"number\">1200080426</span>), d, h, g[u + <span class=\"number\">6</span>], <span class=\"number\">17</span>, <span class=\"number\">2821735955</span>), m, d, g[u + <span class=\"number\">7</span>], <span class=\"number\">22</span>, <span class=\"number\">4249261313</span>), v = r(v, m = r(m, d = r(d, h, v, m, g[u + <span class=\"number\">8</span>], <span class=\"number\">7</span>, <span class=\"number\">1770035416</span>), h, v, g[u + <span class=\"number\">9</span>], <span class=\"number\">12</span>, <span class=\"number\">2336552879</span>), d, h, g[u + <span class=\"number\">10</span>], <span class=\"number\">17</span>, <span class=\"number\">4294925233</span>), m, d, g[u + <span class=\"number\">11</span>], <span class=\"number\">22</span>, <span class=\"number\">2304563134</span>), v = r(v, m = r(m, d = r(d, h, v, m, g[u + <span class=\"number\">12</span>], <span class=\"number\">7</span>, <span class=\"number\">1804603682</span>), h, v, g[u + <span class=\"number\">13</span>], <span class=\"number\">12</span>, <span class=\"number\">4254626195</span>), d, h, g[u + <span class=\"number\">14</span>], <span class=\"number\">17</span>, <span class=\"number\">2792965006</span>), m, d, g[u + <span class=\"number\">15</span>], <span class=\"number\">22</span>, <span class=\"number\">1236535329</span>), v = o(v, m = o(m, d = o(d, h, v, m, g[u + <span class=\"number\">1</span>], <span class=\"number\">5</span>, <span class=\"number\">4129170786</span>), h, v, g[u + <span class=\"number\">6</span>], <span class=\"number\">9</span>, <span class=\"number\">3225465664</span>), d, h, g[u + <span class=\"number\">11</span>], <span class=\"number\">14</span>, <span class=\"number\">643717713</span>), m, d, g[u + <span class=\"number\">0</span>], <span class=\"number\">20</span>, <span class=\"number\">3921069994</span>), v = o(v, m = o(m, d = o(d, h, v, m, g[u + <span class=\"number\">5</span>], <span class=\"number\">5</span>, <span class=\"number\">3593408605</span>), h, v, g[u + <span class=\"number\">10</span>], <span class=\"number\">9</span>, <span class=\"number\">38016083</span>), d, h, g[u + <span class=\"number\">15</span>], <span class=\"number\">14</span>, <span class=\"number\">3634488961</span>), m, d, g[u + <span class=\"number\">4</span>], <span class=\"number\">20</span>, <span class=\"number\">3889429448</span>), v = o(v, m = o(m, d = o(d, h, v, m, g[u + <span class=\"number\">9</span>], <span class=\"number\">5</span>, <span class=\"number\">568446438</span>), h, v, g[u + <span class=\"number\">14</span>], <span class=\"number\">9</span>, <span class=\"number\">3275163606</span>), d, h, g[u + <span class=\"number\">3</span>], <span class=\"number\">14</span>, <span class=\"number\">4107603335</span>), m, d, g[u + <span class=\"number\">8</span>], <span class=\"number\">20</span>, <span class=\"number\">1163531501</span>), v = o(v, m = o(m, d = o(d, h, v, m, g[u + <span class=\"number\">13</span>], <span class=\"number\">5</span>, <span class=\"number\">2850285829</span>), h, v, g[u + <span class=\"number\">2</span>], <span class=\"number\">9</span>, <span class=\"number\">4243563512</span>), d, h, g[u + <span class=\"number\">7</span>], <span class=\"number\">14</span>, <span class=\"number\">1735328473</span>), m, d, g[u + <span class=\"number\">12</span>], <span class=\"number\">20</span>, <span class=\"number\">2368359562</span>), v = i(v, m = i(m, d = i(d, h, v, m, g[u + <span class=\"number\">5</span>], <span class=\"number\">4</span>, <span class=\"number\">4294588738</span>), h, v, g[u + <span class=\"number\">8</span>], <span class=\"number\">11</span>, <span class=\"number\">2272392833</span>), d, h, g[u + <span class=\"number\">11</span>], <span class=\"number\">16</span>, <span class=\"number\">1839030562</span>), m, d, g[u + <span class=\"number\">14</span>], <span class=\"number\">23</span>, <span class=\"number\">4259657740</span>), v = i(v, m = i(m, d = i(d, h, v, m, g[u + <span class=\"number\">1</span>], <span class=\"number\">4</span>, <span class=\"number\">2763975236</span>), h, v, g[u + <span class=\"number\">4</span>], <span class=\"number\">11</span>, <span class=\"number\">1272893353</span>), d, h, g[u + <span class=\"number\">7</span>], <span class=\"number\">16</span>, <span class=\"number\">4139469664</span>), m, d, g[u + <span class=\"number\">10</span>], <span class=\"number\">23</span>, <span class=\"number\">3200236656</span>), v = i(v, m = i(m, d = i(d, h, v, m, g[u + <span class=\"number\">13</span>], <span class=\"number\">4</span>, <span class=\"number\">681279174</span>), h, v, g[u + <span class=\"number\">0</span>], <span class=\"number\">11</span>, <span class=\"number\">3936430074</span>), d, h, g[u + <span class=\"number\">3</span>], <span class=\"number\">16</span>, <span class=\"number\">3572445317</span>), m, d, g[u + <span class=\"number\">6</span>], <span class=\"number\">23</span>, <span class=\"number\">76029189</span>), v = i(v, m = i(m, d = i(d, h, v, m, g[u + <span class=\"number\">9</span>], <span class=\"number\">4</span>, <span class=\"number\">3654602809</span>), h, v, g[u + <span class=\"number\">12</span>], <span class=\"number\">11</span>, <span class=\"number\">3873151461</span>), d, h, g[u + <span class=\"number\">15</span>], <span class=\"number\">16</span>, <span class=\"number\">530742520</span>), m, d, g[u + <span class=\"number\">2</span>], <span class=\"number\">23</span>, <span class=\"number\">3299628645</span>), v = a(v, m = a(m, d = a(d, h, v, m, g[u + <span class=\"number\">0</span>], <span class=\"number\">6</span>, <span class=\"number\">4096336452</span>), h, v, g[u + <span class=\"number\">7</span>], <span class=\"number\">10</span>, <span class=\"number\">1126891415</span>), d, h, g[u + <span class=\"number\">14</span>], <span class=\"number\">15</span>, <span class=\"number\">2878612391</span>), m, d, g[u + <span class=\"number\">5</span>], <span class=\"number\">21</span>, <span class=\"number\">4237533241</span>), v = a(v, m = a(m, d = a(d, h, v, m, g[u + <span class=\"number\">12</span>], <span class=\"number\">6</span>, <span class=\"number\">1700485571</span>), h, v, g[u + <span class=\"number\">3</span>], <span class=\"number\">10</span>, <span class=\"number\">2399980690</span>), d, h, g[u + <span class=\"number\">10</span>], <span class=\"number\">15</span>, <span class=\"number\">4293915773</span>), m, d, g[u + <span class=\"number\">1</span>], <span class=\"number\">21</span>, <span class=\"number\">2240044497</span>), v = a(v, m = a(m, d = a(d, h, v, m, g[u + <span class=\"number\">8</span>], <span class=\"number\">6</span>, <span class=\"number\">1873313359</span>), h, v, g[u + <span class=\"number\">15</span>], <span class=\"number\">10</span>, <span class=\"number\">4264355552</span>), d, h, g[u + <span class=\"number\">6</span>], <span class=\"number\">15</span>, <span class=\"number\">2734768916</span>), m, d, g[u + <span class=\"number\">13</span>], <span class=\"number\">21</span>, <span class=\"number\">1309151649</span>), v = a(v, m = a(m, d = a(d, h, v, m, g[u + <span class=\"number\">4</span>], <span class=\"number\">6</span>, <span class=\"number\">4149444226</span>), h, v, g[u + <span class=\"number\">11</span>], <span class=\"number\">10</span>, <span class=\"number\">3174756917</span>), d, h, g[u + <span class=\"number\">2</span>], <span class=\"number\">15</span>, <span class=\"number\">718787259</span>), m, d, g[u + <span class=\"number\">9</span>], <span class=\"number\">21</span>, <span class=\"number\">3951481745</span>),</span><br><span class=\"line\">            d = e(d, s),</span><br><span class=\"line\">            h = e(h, f),</span><br><span class=\"line\">            v = e(v, l),</span><br><span class=\"line\">            m = e(m, p);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (c(d) + c(h) + c(v) + c(m)).toLowerCase()</span><br><span class=\"line\">        &#125; (r.token + <span class=\"string\">\"&amp;\"</span> + c + <span class=\"string\">\"&amp;\"</span> + a + <span class=\"string\">\"&amp;\"</span> + e.data),</span><br><span class=\"line\">        s = &#123;</span><br><span class=\"line\">            jsv: <span class=\"string\">\"2.4.11\"</span>,</span><br><span class=\"line\">            appKey: a,</span><br><span class=\"line\">            t: c,</span><br><span class=\"line\">            sign: u</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        f = &#123;</span><br><span class=\"line\">            data: e.data,</span><br><span class=\"line\">            ua: e.ua</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"built_in\">Object</span>.keys(e).forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">t</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"string\">\"undefined\"</span> == <span class=\"keyword\">typeof</span> s[t] &amp;&amp; <span class=\"string\">\"undefined\"</span> == <span class=\"keyword\">typeof</span> f[t] &amp;&amp; <span class=\"string\">\"headers\"</span> !== t &amp;&amp; <span class=\"string\">\"ext_headers\"</span> !== t &amp;&amp; <span class=\"string\">\"ext_querys\"</span> !== t &amp;&amp; (s[t] = e[t])</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">        e.ext_querys &amp;&amp; <span class=\"built_in\">Object</span>.keys(e.ext_querys).forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">t</span>) </span>&#123;</span><br><span class=\"line\">            s[t] = e.ext_querys[t]</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">        r.getJSONP ? s.type = <span class=\"string\">\"jsonp\"</span>: r.getOriginalJSONP ? s.type = <span class=\"string\">\"originaljsonp\"</span>: (r.getJSON || r.postJSON) &amp;&amp; (s.type = <span class=\"string\">\"originaljson\"</span>),</span><br><span class=\"line\">        <span class=\"string\">\"undefined\"</span> != <span class=\"keyword\">typeof</span> e.valueType &amp;&amp; (<span class=\"string\">\"original\"</span> === e.valueType ? r.getJSONP || r.getOriginalJSONP ? s.type = <span class=\"string\">\"originaljsonp\"</span>: (r.getJSON || r.postJSON) &amp;&amp; (s.type = <span class=\"string\">\"originaljson\"</span>) : <span class=\"string\">\"string\"</span> === e.valueType &amp;&amp; (r.getJSONP || r.getOriginalJSONP ? s.type = <span class=\"string\">\"jsonp\"</span>: (r.getJSON || r.postJSON) &amp;&amp; (s.type = <span class=\"string\">\"json\"</span>))),</span><br><span class=\"line\">        !<span class=\"number\">0</span> === r.useJsonpResultType &amp;&amp; <span class=\"string\">\"originaljson\"</span> === s.type &amp;&amp; <span class=\"keyword\">delete</span> s.type,</span><br><span class=\"line\">        r.dangerouslySetProtocol &amp;&amp; (i = r.dangerouslySetProtocol + <span class=\"string\">\":\"</span> + i),</span><br><span class=\"line\">        r.querystring = s,</span><br><span class=\"line\">        r.postdata = f,</span><br><span class=\"line\">        r.path = i</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    n()</span><br><span class=\"line\">&#125;,&#125;</span><br></pre></td></tr></table></figure>\n<p>看到这里应该是一个加密后的js，后来找到一篇文章。<a href=\"https://zhuanlan.zhihu.com/p/42053431\" target=\"_blank\" rel=\"noopener\">淘宝sign加密算法</a>。根据抓包的参数，按照公式来计算sign，验证算法是否正确。可能由于时间戳没有取整，或者一些其他的原因如编码问题等，导致sign的值没有和正确值对上，又看到文中贴的代码比我找到的js更加简单，以为淘宝更新了算法。再后来一位知友提示说算法没有问题，（在此特别感谢知友Jaho及文章作者小歪）才又抓包试了一次，这次将毫秒时间戳转为了int，并将字符串进行utf8编码，算出来的sign值和抓包中的匹配。后来证实通过js断点调试也可以验证公式的正确性。sign生成公式为：<code>md5Hex(token&amp;t&amp;appKey&amp;data)</code>t表示毫秒时间戳，appKey一般为固定值。data为参数。本文中的例子为<code>6b2310e47a950f1c8c3fe6ec792f356a&amp;1544165283634&amp;12574478&amp;{&quot;item_num_id&quot;:&quot;554401452734&quot;}</code>再进行md5转换。</p>\n<p>知道了sign算法，接下来就是token的获取，根据知乎文中作者所说，第一次请求是会设置cookie，于是使用Postman清理cookie后请求，此时sign的值传任何值均无影响，接口会返回</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">mtopjsonp2(&#123;</span><br><span class=\"line\">\t\"api\": \"mtop.wdetail.getItemDescx\",</span><br><span class=\"line\">\t\"v\": \"4.9\",</span><br><span class=\"line\">\t\"ret\": [\"FAIL_SYS_TOKEN_EXOIRED::令牌过期\"],</span><br><span class=\"line\">\t\"data\": &#123;&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>并设置两个cookie，一个是<code>_m_h5_tk</code>值为<code>6b2310e47a950f1c8c3fe6ec792f356a_1544173923544</code>，另一个是<code>_m_h5_tk_enc</code>，这个目前用不到，我们要的token就是前者<code>_</code>分割的前部分。这样一来，我们请求两次接口，第一次拿到token，第二次请求拿到数据。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"api\"</span>: <span class=\"string\">\"mtop.wdetail.getItemDescx\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"data\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"pages\"</span>: [</span><br><span class=\"line\">      <span class=\"string\">\"&lt;txt&gt;特别提醒：此款收纳箱尺寸测量方法：（盖上盖子测量长宽高）长度=盖子+把手。手工量的，稍许误差，谢谢谅解！ 注意：不要把本店的L数跟超市的比较，本店的L数是网上笼统的叫法，以箱子实际尺寸为主，介意的亲请勿拍！建议：店长推荐拍套装几个套在一起 可以抗摔 。。10L不建议购买只能装一些小东西人工测量会有2cm左右误差属于正常现象温馨提醒：塑料属于易碎品，为了免去亲的麻烦，请亲在收货时先拆开检查后在签收，如有破损请直接拒收&lt;/txt&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i3/2651141793/TB2kQKqbgsSMeJjSspcXXXjFXXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i1/2651141793/TB2UkPszC8mpuFjSZFMXXaxpVXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i3/2651141793/TB2dJSBzstnpuFjSZFKXXalFFXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i4/2651141793/TB2U3i5zxxmpuFjSZFNXXXrRXXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i1/2651141793/TB22qfEzr4npuFjSZFmXXXl4FXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i2/2651141793/TB2_8HcvbJkpuFjy1zcXXa5FFXa_!!2651141793.jpg&lt;/img&gt;\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"&lt;img&gt;https://img.alicdn.com/imgextra/i1/2651141793/TB2f7YszC8mpuFjSZFMXXaxpVXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i3/2651141793/TB2B600zrBnpuFjSZFGXXX51pXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i4/2651141793/TB2C.HmvgFkpuFjSspnXXb4qFXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i3/2651141793/TB25AYszC8mpuFjSZFMXXaxpVXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i3/2651141793/TB2Tt1BzstnpuFjSZFKXXalFFXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i3/2651141793/TB2FNPgvgxlpuFjSszbXXcSVpXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i2/2651141793/TB26j40zrBnpuFjSZFGXXX51pXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i4/2651141793/TB2uDGozCVmpuFjSZFFXXcZApXa_!!2651141793.jpg&lt;/img&gt;\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"&lt;img&gt;https://img.alicdn.com/imgextra/i1/2651141793/TB2Bx9ntxRDOuFjSZFzXXcIipXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i2/2651141793/TB2nSblvm0jpuFjy0FlXXc0bpXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i2/2651141793/TB2wtaQvbXlpuFjSszfXXcSGXXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i4/2651141793/TB2k1vfvl4lpuFjy1zjXXcAKpXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i1/2651141793/TB26HbQvbFkpuFjy1XcXXclapXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i3/2651141793/TB24miYzypnpuFjSZFIXXXh2VXa_!!2651141793.jpg&lt;/img&gt;&lt;txt&gt;.................welcome20160618152824&lt;/txt&gt;\"</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"attr\">\"images\"</span>: [</span><br><span class=\"line\">      <span class=\"string\">\"https://img.alicdn.com/imgextra/i3/2651141793/TB2kQKqbgsSMeJjSspcXXXjFXXa_!!2651141793.jpg\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"https://img.alicdn.com/imgextra/i1/2651141793/TB2UkPszC8mpuFjSZFMXXaxpVXa_!!2651141793.jpg\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"https://img.alicdn.com/imgextra/i3/2651141793/TB2dJSBzstnpuFjSZFKXXalFFXa_!!2651141793.jpg\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"https://img.alicdn.com/imgextra/i4/2651141793/TB2U3i5zxxmpuFjSZFNXXXrRXXa_!!2651141793.jpg\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"https://img.alicdn.com/imgextra/i1/2651141793/TB22qfEzr4npuFjSZFmXXXl4FXa_!!2651141793.jpg\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"https://img.alicdn.com/imgextra/i2/2651141793/TB2_8HcvbJkpuFjy1zcXXa5FFXa_!!2651141793.jpg\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"https://img.alicdn.com/imgextra/i1/2651141793/TB2f7YszC8mpuFjSZFMXXaxpVXa_!!2651141793.jpg\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"https://img.alicdn.com/imgextra/i3/2651141793/TB2B600zrBnpuFjSZFGXXX51pXa_!!2651141793.jpg\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"https://img.alicdn.com/imgextra/i4/2651141793/TB2C.HmvgFkpuFjSspnXXb4qFXa_!!2651141793.jpg\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"https://img.alicdn.com/imgextra/i3/2651141793/TB25AYszC8mpuFjSZFMXXaxpVXa_!!2651141793.jpg\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"https://img.alicdn.com/imgextra/i3/2651141793/TB2Tt1BzstnpuFjSZFKXXalFFXa_!!2651141793.jpg\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"https://img.alicdn.com/imgextra/i3/2651141793/TB2FNPgvgxlpuFjSszbXXcSVpXa_!!2651141793.jpg\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"https://img.alicdn.com/imgextra/i2/2651141793/TB26j40zrBnpuFjSZFGXXX51pXa_!!2651141793.jpg\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"https://img.alicdn.com/imgextra/i4/2651141793/TB2uDGozCVmpuFjSZFFXXcZApXa_!!2651141793.jpg\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"https://img.alicdn.com/imgextra/i1/2651141793/TB2Bx9ntxRDOuFjSZFzXXcIipXa_!!2651141793.jpg\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"https://img.alicdn.com/imgextra/i2/2651141793/TB2nSblvm0jpuFjy0FlXXc0bpXa_!!2651141793.jpg\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"https://img.alicdn.com/imgextra/i2/2651141793/TB2wtaQvbXlpuFjSszfXXcSGXXa_!!2651141793.jpg\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"https://img.alicdn.com/imgextra/i4/2651141793/TB2k1vfvl4lpuFjy1zjXXcAKpXa_!!2651141793.jpg\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"https://img.alicdn.com/imgextra/i1/2651141793/TB26HbQvbFkpuFjy1XcXXclapXa_!!2651141793.jpg\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"https://img.alicdn.com/imgextra/i3/2651141793/TB24miYzypnpuFjSZFIXXXh2VXa_!!2651141793.jpg\"</span></span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"ret\"</span>: [</span><br><span class=\"line\">    <span class=\"string\">\"SUCCESS::接口调用成功\"</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"attr\">\"v\"</span>: <span class=\"string\">\"4.9\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中的images数组就是我想要的数据，这里返回值不是标准的json，套了一层mtopjsonp2({JSON})，于是获取结果后还要根据正则截取一下json的文本。</p>\n<p>附上部分相关代码，python版本</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_images_from_mtop</span><span class=\"params\">(num_iid)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    APPKEY = <span class=\"string\">'12574478'</span></span><br><span class=\"line\">    DATA = <span class=\"string\">'&#123;\"item_num_id\":\"%s\"&#125;'</span> % num_iid</span><br><span class=\"line\">    URL = <span class=\"string\">'https://h5api.m.taobao.com/h5/mtop.wdetail.getitemdescx/4.9/'</span></span><br><span class=\"line\">    params = &#123;<span class=\"string\">'jsv'</span>: <span class=\"string\">'2.4.11'</span>, <span class=\"string\">'appKey'</span>: APPKEY, <span class=\"string\">'t'</span>: int(time.time()*<span class=\"number\">1000</span>),</span><br><span class=\"line\">              <span class=\"string\">'sign'</span>: <span class=\"string\">'FAKE_SIGN_WITH_ANYTHING'</span>, <span class=\"string\">'api'</span>: <span class=\"string\">'mtop.wdetail.getItemDescx'</span>, <span class=\"string\">'v'</span>: <span class=\"string\">'4.9'</span>,</span><br><span class=\"line\">              <span class=\"string\">'type'</span>: <span class=\"string\">'jsonp'</span>, <span class=\"string\">'dataType'</span>: <span class=\"string\">'jsonp'</span>, <span class=\"string\">'callback'</span>: <span class=\"string\">'mtopjsonp2'</span>,</span><br><span class=\"line\">              <span class=\"string\">'data'</span>: DATA&#125;</span><br><span class=\"line\">    headers = &#123;</span><br><span class=\"line\">        <span class=\"string\">'User-Agent'</span>: <span class=\"string\">'Mozilla/5.0 (iPhone; CPU iPhone OS 9_3_4 like Mac OS X) AppleWebKit/601.1.46 '</span> + \\</span><br><span class=\"line\">                      <span class=\"string\">'(KHTML, like Gecko) Version/9.0 Mobile/13G35 Safari/601.1'</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    images = []</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"comment\"># get token in first request</span></span><br><span class=\"line\">        r1 = requests.get(URL, params=params, headers=headers)</span><br><span class=\"line\">        token_with_time = r1.cookies.get(<span class=\"string\">'_m_h5_tk'</span>)</span><br><span class=\"line\">        token = token_with_time.split(<span class=\"string\">'_'</span>)[<span class=\"number\">0</span>]</span><br><span class=\"line\">        enc_token = r1.cookies.get(<span class=\"string\">'_m_h5_tk_enc'</span>)</span><br><span class=\"line\">        logger.debug(r1.cookies)</span><br><span class=\"line\">        <span class=\"comment\"># get results in second request</span></span><br><span class=\"line\">        t2 = str(int(time.time() * <span class=\"number\">1000</span>))</span><br><span class=\"line\">        c = <span class=\"string\">'&amp;'</span>.join([token, t2, APPKEY, DATA])</span><br><span class=\"line\">        m = hashlib.md5()</span><br><span class=\"line\">        m.update(c.encode(<span class=\"string\">'utf-8'</span>))</span><br><span class=\"line\">        params.update(&#123;<span class=\"string\">'t'</span>: t2, <span class=\"string\">'sign'</span>: m.hexdigest()&#125;)</span><br><span class=\"line\">        cookies = &#123;<span class=\"string\">'_m_h5_tk'</span>: token_with_time, <span class=\"string\">'_m_h5_tk_enc'</span>: enc_token&#125;</span><br><span class=\"line\">        r2 = requests.get(URL, params=params, headers=headers, cookies=cookies)</span><br><span class=\"line\">        logger.debug(r2.text)</span><br><span class=\"line\">        json_text = re.match(<span class=\"string\">r'(.*\\()(.*)(\\))'</span>, r2.text).group(<span class=\"number\">2</span>)</span><br><span class=\"line\">        images = dict(json.loads(json_text))[<span class=\"string\">'data'</span>][<span class=\"string\">'images'</span>]</span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        logger.warning(e)</span><br><span class=\"line\">    <span class=\"keyword\">finally</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> images</span><br></pre></td></tr></table></figure>\n<p>可以看到，接口响应时间有了大幅度提升。</p>\n<img src=\"/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%B7%98%E5%AE%9D%E6%8E%A5%E5%8F%A3sign%E7%AD%BE%E5%90%8D%E7%A0%B4%E8%A7%A3/optimize.png\" class>\n","categories":["逆向工程"],"tags":["Sign签名"]},{"title":"LeetCode算法题整理（二分法篇）Binary Search","url":"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%E5%88%86%E6%B3%95%E7%AF%87%EF%BC%89Binary-Search/","content":"<h3 id=\"704-Binary-Search\"><a href=\"#704-Binary-Search\" class=\"headerlink\" title=\"704. Binary Search\"></a>704. Binary Search</h3><h4 id=\"二分法在有序数组中查找元素。原题\"><a href=\"#二分法在有序数组中查找元素。原题\" class=\"headerlink\" title=\"二分法在有序数组中查找元素。原题\"></a>二分法在有序数组中查找元素。<a href=\"https://leetcode.com/problems/binary-search/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 9</span><br><span class=\"line\">Output: 4</span><br><span class=\"line\">Explanation: 9 exists in nums and its index is 4</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<font color=\"#32CD32\" size=\"3\"><strong>方法一：实现原理。</strong></font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">binary_search</span><span class=\"params\">(nums, target)</span>:</span></span><br><span class=\"line\">    l, r = <span class=\"number\">0</span>, len(nums)<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> l &lt;= r:</span><br><span class=\"line\">        mid = (l+r) // <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[mid] &gt; target:</span><br><span class=\"line\">            r = mid - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> nums[mid] &lt; target:</span><br><span class=\"line\">            l = mid + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<p>方法二：使用标准库。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">search</span><span class=\"params\">(self, nums, target)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> bisect <span class=\"keyword\">import</span> bisect_left </span><br><span class=\"line\">    index = bisect_left(nums, target)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> index <span class=\"keyword\">if</span> index &lt; len(nums) <span class=\"keyword\">and</span> nums[index] == target <span class=\"keyword\">else</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"35-Search-Insert-Position\"><a href=\"#35-Search-Insert-Position\" class=\"headerlink\" title=\"35. Search Insert Position\"></a>35. Search Insert Position</h3><h4 id=\"给定一个target，插入到一个有序数组中，假定数组中无重复元素。原题\"><a href=\"#给定一个target，插入到一个有序数组中，假定数组中无重复元素。原题\" class=\"headerlink\" title=\"给定一个target，插入到一个有序数组中，假定数组中无重复元素。原题\"></a>给定一个target，插入到一个有序数组中，假定数组中无重复元素。<a href=\"https://leetcode.com/problems/search-insert-position/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [1,3,5,6], 5</span><br><span class=\"line\">Output: 2</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\"><strong>方法一：实现原理。</strong></font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">binary_insert</span><span class=\"params\">(nums, target)</span>:</span></span><br><span class=\"line\">    l, r = <span class=\"number\">0</span>, len(nums)<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> l &lt;= r:</span><br><span class=\"line\">        mid = (l+r) // <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[mid] &gt; target:</span><br><span class=\"line\">            r = mid - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> nums[mid] &lt; target:</span><br><span class=\"line\">            l = mid + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">    <span class=\"keyword\">return</span> l</span><br></pre></td></tr></table></figure>\n<p>方法二：使用标准库。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">searchInsert</span><span class=\"params\">(self, nums, target)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> bisect <span class=\"keyword\">import</span> bisect_left</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bisect_left(nums, target)</span><br></pre></td></tr></table></figure>\n<h3 id=\"153-Find-Minimum-in-Rotated-Sorted-Array\"><a href=\"#153-Find-Minimum-in-Rotated-Sorted-Array\" class=\"headerlink\" title=\"153. Find Minimum in Rotated Sorted Array\"></a>153. Find Minimum in Rotated Sorted Array</h3><h4 id=\"通过一个排序数组旋转后的结果，找出最小元素。原题\"><a href=\"#通过一个排序数组旋转后的结果，找出最小元素。原题\" class=\"headerlink\" title=\"通过一个排序数组旋转后的结果，找出最小元素。原题\"></a>通过一个排序数组旋转后的结果，找出最小元素。<a href=\"https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [3,4,5,1,2] </span><br><span class=\"line\">Output: 1</span><br></pre></td></tr></table></figure>\n<p>思路：通过二分法不断缩小范围，由于mid是整除，最后l==mid，并且nums[mid] &gt; nums[r]的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findMin</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    l, r = <span class=\"number\">0</span>, len(nums)<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> l &lt; r:</span><br><span class=\"line\">        mid = (l+r) // <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[mid] &lt;= nums[r]:</span><br><span class=\"line\">            r = mid </span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            l = mid + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums[l]</span><br></pre></td></tr></table></figure>\n<h3 id=\"34-Find-First-and-Last-Position-of-Element-in-Sorted-Array\"><a href=\"#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array\" class=\"headerlink\" title=\"34. Find First and Last Position of Element in Sorted Array\"></a>34. Find First and Last Position of Element in Sorted Array</h3><h4 id=\"有序数组中查找数组，返回数字的索引范围。原题\"><a href=\"#有序数组中查找数组，返回数字的索引范围。原题\" class=\"headerlink\" title=\"有序数组中查找数组，返回数字的索引范围。原题\"></a>有序数组中查找数组，返回数字的索引范围。<a href=\"https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class=\"line\">Output: [3,4]</span><br><span class=\"line\">Input: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class=\"line\">Output: [-1,-1]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">searchRange</span><span class=\"params\">(self, nums, target)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    left_idx = self.search_edge(nums, target, <span class=\"literal\">True</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> left_idx == len(nums) <span class=\"keyword\">or</span> nums[left_idx] != target:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [<span class=\"number\">-1</span>, <span class=\"number\">-1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [left_idx, self.search_edge(nums, target, <span class=\"literal\">False</span>)<span class=\"number\">-1</span>]</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">search_edge</span><span class=\"params\">(self, nums, target, left)</span>:</span></span><br><span class=\"line\">    l, r = <span class=\"number\">0</span>, len(nums)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> l &lt; r:</span><br><span class=\"line\">        mid = (l+r) // <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[mid] &gt; target <span class=\"keyword\">or</span> (left <span class=\"keyword\">and</span> nums[mid]==target):</span><br><span class=\"line\">            r = mid</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            l = mid + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> l</span><br></pre></td></tr></table></figure>\n<h3 id=\"278-First-Bad-Version\"><a href=\"#278-First-Bad-Version\" class=\"headerlink\" title=\"278. First Bad Version\"></a>278. First Bad Version</h3><h4 id=\"找出提交版本中的bad-version。原题\"><a href=\"#找出提交版本中的bad-version。原题\" class=\"headerlink\" title=\"找出提交版本中的bad version。原题\"></a>找出提交版本中的bad version。<a href=\"https://leetcode.com/problems/first-bad-version\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Given n &#x3D; 5, and version &#x3D; 4 is the first bad version.</span><br><span class=\"line\"></span><br><span class=\"line\">call isBadVersion(3) -&gt; false</span><br><span class=\"line\">call isBadVersion(5) -&gt; true</span><br><span class=\"line\">call isBadVersion(4) -&gt; true</span><br><span class=\"line\"></span><br><span class=\"line\">Then 4 is the first bad version.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">firstBadVersion</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">    l, r = <span class=\"number\">1</span>, n</span><br><span class=\"line\">    <span class=\"keyword\">while</span> l &lt;= r:</span><br><span class=\"line\">        mid = (l+r) // <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> isBadVersion(mid):</span><br><span class=\"line\">            r = mid - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            l = mid + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> l</span><br></pre></td></tr></table></figure>\n<h3 id=\"374-Guess-Number-Higher-or-Lower\"><a href=\"#374-Guess-Number-Higher-or-Lower\" class=\"headerlink\" title=\"374. Guess Number Higher or Lower\"></a>374. Guess Number Higher or Lower</h3><h4 id=\"猜数游戏1-n，每猜一次会告诉你答案是更小还是更大。原题\"><a href=\"#猜数游戏1-n，每猜一次会告诉你答案是更小还是更大。原题\" class=\"headerlink\" title=\"猜数游戏1~n，每猜一次会告诉你答案是更小还是更大。原题\"></a>猜数游戏1~n，每猜一次会告诉你答案是更小还是更大。<a href=\"https://leetcode.com/problems/guess-number-higher-or-lower/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">def guess(num):</span><br><span class=\"line\">    return</span><br><span class=\"line\">    -1 : My number is lower</span><br><span class=\"line\">     1 : My number is higher</span><br><span class=\"line\">     0 : Congrats! You got it!</span><br><span class=\"line\">     </span><br><span class=\"line\">Input: n &#x3D; 10, pick &#x3D; 6</span><br><span class=\"line\">Output: 6</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\"><strong>方法一：实现原理。</strong></font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">guessNumber</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">    l, r = <span class=\"number\">1</span>, n</span><br><span class=\"line\">    <span class=\"keyword\">while</span> l &lt;= r:</span><br><span class=\"line\">        mid = (l+r) // <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> guess(mid) == <span class=\"number\">-1</span>:</span><br><span class=\"line\">            r = mid - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> guess(mid) == <span class=\"number\">1</span>:</span><br><span class=\"line\">            l = mid + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid</span><br></pre></td></tr></table></figure>\n<p>方法二：使用标准库。此答案受stefan大神启发。核心思想为将guess返回的结果转为一个数组，然后使用二分法查找。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">guessNumber</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> bisect <span class=\"keyword\">import</span> bisect, bisect_left</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span>:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__getitem__</span><span class=\"params\">(self, x)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> -guess(x)</span><br><span class=\"line\">    <span class=\"comment\"># return bisect(C(), -1, 1, n)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> bisect_left(C(), <span class=\"number\">0</span>, <span class=\"number\">1</span>, n)</span><br></pre></td></tr></table></figure>\n<p>解析：以n=10, pick=6为例。实际上C class相当于:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ary &#x3D; map(lambda x: -guess(x), range(1, n+1))</span><br><span class=\"line\">ary.insert(0, None)</span><br><span class=\"line\"># ary &#x3D; [None, -1, -1, -1, -1, -1, 0, 1, 1, 1, 1]</span><br><span class=\"line\">return bisect(ary, -1, 1, n)</span><br></pre></td></tr></table></figure>\n<p>而索引又是从1开始，所以这里在前面添加了一个None，实际上将题转为了查找<code>ary</code>的<code>0</code>，问题便迎刃而解。值得注意的是，如果使用了map，会导致空间，时间复杂度增加，而使用class的方法，并没有求出整个的<code>list</code>，所以效率更高。</p>\n<h3 id=\"744-Find-Smallest-Letter-Greater-Than-Target\"><a href=\"#744-Find-Smallest-Letter-Greater-Than-Target\" class=\"headerlink\" title=\"744. Find Smallest Letter Greater Than Target\"></a>744. Find Smallest Letter Greater Than Target</h3><h4 id=\"找出比目标大的最小字母，没有的返回首字母。原题\"><a href=\"#找出比目标大的最小字母，没有的返回首字母。原题\" class=\"headerlink\" title=\"找出比目标大的最小字母，没有的返回首字母。原题\"></a>找出比目标大的最小字母，没有的返回首字母。<a href=\"https://leetcode.com/problems/find-smallest-letter-greater-than-target/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">letters &#x3D; [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]</span><br><span class=\"line\">target &#x3D; &quot;d&quot;</span><br><span class=\"line\">Output: &quot;f&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">Input:</span><br><span class=\"line\">letters &#x3D; [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]</span><br><span class=\"line\">target &#x3D; &quot;g&quot;</span><br><span class=\"line\">Output: &quot;j&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">Input:</span><br><span class=\"line\">letters &#x3D; [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]</span><br><span class=\"line\">target &#x3D; &quot;j&quot;</span><br><span class=\"line\">Output: &quot;c&quot;</span><br></pre></td></tr></table></figure>\n<p>方法一：二分法实现。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">nextGreatestLetter</span><span class=\"params\">(self, letters: <span class=\"string\">'List[str]'</span>, target: <span class=\"string\">'str'</span>)</span> -&gt; 'str':</span></span><br><span class=\"line\">    lo, hi = <span class=\"number\">0</span>, len(letters)<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> lo &lt;= hi:</span><br><span class=\"line\">        mid = (lo + hi) // <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> letters[mid] &gt; target:</span><br><span class=\"line\">            hi = mid <span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> letters[mid] &lt;= target:</span><br><span class=\"line\">            lo = mid + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> letters[lo % len(letters)]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：使用库。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">nextGreatestLetter</span><span class=\"params\">(self, letters: <span class=\"string\">'List[str]'</span>, target: <span class=\"string\">'str'</span>)</span> -&gt; 'str':</span></span><br><span class=\"line\">    index = bisect.bisect(letters, target)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> letters[index % len(letters)]</span><br></pre></td></tr></table></figure>\n<h3 id=\"852-Peak-Index-in-a-Mountain-Array\"><a href=\"#852-Peak-Index-in-a-Mountain-Array\" class=\"headerlink\" title=\"852. Peak Index in a Mountain Array\"></a>852. Peak Index in a Mountain Array</h3><h4 id=\"找到数组中的峰值。假设峰值一定存在。原题\"><a href=\"#找到数组中的峰值。假设峰值一定存在。原题\" class=\"headerlink\" title=\"找到数组中的峰值。假设峰值一定存在。原题\"></a>找到数组中的峰值。假设峰值一定存在。<a href=\"https://leetcode.com/problems/peak-index-in-a-mountain-array/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [0,2,1,0]</span><br><span class=\"line\">Output: 1</span><br></pre></td></tr></table></figure>\n<p>方法一：Linear Scan. Time: O(N)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">peakIndexInMountainArray</span><span class=\"params\">(self, A: <span class=\"string\">'List[int]'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(A)<span class=\"number\">-1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> A[i] &gt; A[i+<span class=\"number\">1</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> i</span><br></pre></td></tr></table></figure>\n<p>方法二：one-line.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">peakIndexInMountainArray</span><span class=\"params\">(self, A: <span class=\"string\">'List[int]'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> A.index(max(A))</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：看到Solution才想到二分法。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">peakIndexInMountainArray</span><span class=\"params\">(self, A: <span class=\"string\">'List[int]'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    lo, hi = <span class=\"number\">0</span>, len(A)<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> lo &lt; hi:</span><br><span class=\"line\">        mid = (lo + hi) // <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> A[mid] &gt; A[mid+<span class=\"number\">1</span>]:</span><br><span class=\"line\">            hi = mid</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            lo = mid + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> lo</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法四：黄金分割法，应用在单峰函数求极值，速度比二分法要快。</font>\n\n<img src=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%E5%88%86%E6%B3%95%E7%AF%87%EF%BC%89Binary-Search/gold.gif\" class>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">peakIndexInMountainArray</span><span class=\"params\">(self, A: <span class=\"string\">'List[int]'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">gold1</span><span class=\"params\">(i, j)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> i + int(round((j-i) * <span class=\"number\">0.382</span>))</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">gold2</span><span class=\"params\">(i, j)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> i + int(round((j-i) * <span class=\"number\">0.618</span>))</span><br><span class=\"line\">    </span><br><span class=\"line\">    l, r = <span class=\"number\">0</span>, len(A) - <span class=\"number\">1</span></span><br><span class=\"line\">    x1, x2 = gold1(l, r), gold2(l, r)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> x1 &lt; x2:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> A[x1] &lt; A[x2]:</span><br><span class=\"line\">            l = x1</span><br><span class=\"line\">            x1 = x2</span><br><span class=\"line\">            x2 = gold1(x1, r)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            r = x2</span><br><span class=\"line\">            x2 = x1</span><br><span class=\"line\">            x1 = gold2(l, x2)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x1</span><br></pre></td></tr></table></figure>\n<h3 id=\"1014-Capacity-To-Ship-Packages-Within-D-Days\"><a href=\"#1014-Capacity-To-Ship-Packages-Within-D-Days\" class=\"headerlink\" title=\"1014. Capacity To Ship Packages Within D Days\"></a>1014. Capacity To Ship Packages Within D Days</h3><h4 id=\"n天内轮船运送的最小容量。原题\"><a href=\"#n天内轮船运送的最小容量。原题\" class=\"headerlink\" title=\"n天内轮船运送的最小容量。原题\"></a>n天内轮船运送的最小容量。<a href=\"https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: weights &#x3D; [1,2,3,4,5,6,7,8,9,10], D &#x3D; 5</span><br><span class=\"line\">Output: 15</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">A ship capacity of 15 is the minimum to ship all the packages in 5 days like this:</span><br><span class=\"line\">1st day: 1, 2, 3, 4, 5</span><br><span class=\"line\">2nd day: 6, 7</span><br><span class=\"line\">3rd day: 8</span><br><span class=\"line\">4th day: 9</span><br><span class=\"line\">5th day: 10</span><br><span class=\"line\"></span><br><span class=\"line\">Note that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed.</span><br></pre></td></tr></table></figure>\n<p>贴一下竞赛时AC的丑陋写法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">shipWithinDays</span><span class=\"params\">(self, weights: List[int], D: int)</span> -&gt; int:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">can_ship</span><span class=\"params\">(capacity, D)</span>:</span></span><br><span class=\"line\">        l = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(D):</span><br><span class=\"line\">            each = <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> r <span class=\"keyword\">in</span> range(l, len(weights)):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> weights[r]+each &lt;= capacity:</span><br><span class=\"line\">                    each += weights[r]</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    l = r</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    lo, hi = max(weights), sum(weights)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> lo &lt;= hi:</span><br><span class=\"line\">        mid = (lo + hi) // <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> can_ship(mid, D):</span><br><span class=\"line\">            hi = mid - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            lo = mid + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> lo</span><br></pre></td></tr></table></figure>\n<p>优化。遇见一个诡异的现象，同样的代码用python比python3快了60ms，和3MB的内存。这解法也没涉及两者的区别。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">shipWithinDays</span><span class=\"params\">(self, weights: List[int], D: int)</span> -&gt; int:</span></span><br><span class=\"line\">    lo, hi = max(weights), sum(weights)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> lo &lt;= hi:</span><br><span class=\"line\">        mid, days, cur = (lo + hi) // <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> weights:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> cur+w &gt; mid:</span><br><span class=\"line\">                days += <span class=\"number\">1</span></span><br><span class=\"line\">                cur = <span class=\"number\">0</span></span><br><span class=\"line\">            cur += w</span><br><span class=\"line\">        <span class=\"keyword\">if</span> days &gt; D:</span><br><span class=\"line\">            lo = mid + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            hi = mid - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"comment\"># print(lo, mid, hi)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> lo</span><br></pre></td></tr></table></figure>\n<h3 id=\"875-Koko-Eating-Bananas\"><a href=\"#875-Koko-Eating-Bananas\" class=\"headerlink\" title=\"875. Koko Eating Bananas\"></a>875. Koko Eating Bananas</h3><h4 id=\"这道题思路和1014一样。不同的是，如果当前堆的香蕉小于吃的速度，那么也不能吃下一堆。原题\"><a href=\"#这道题思路和1014一样。不同的是，如果当前堆的香蕉小于吃的速度，那么也不能吃下一堆。原题\" class=\"headerlink\" title=\"这道题思路和1014一样。不同的是，如果当前堆的香蕉小于吃的速度，那么也不能吃下一堆。原题\"></a>这道题思路和1014一样。不同的是，如果当前堆的香蕉小于吃的速度，那么也不能吃下一堆。<a href=\"https://leetcode.com/problems/koko-eating-bananas/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: piles &#x3D; [3,6,7,11], H &#x3D; 8</span><br><span class=\"line\">Output: 4</span><br></pre></td></tr></table></figure>\n<p>方法一：写习惯了Python3，老是想写<code>//</code>，注意是<code>p/mid</code>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minEatingSpeed</span><span class=\"params\">(self, piles: List[int], H: int)</span> -&gt; int:</span></span><br><span class=\"line\">    lo, hi = <span class=\"number\">1</span>, max(piles) </span><br><span class=\"line\">    <span class=\"keyword\">while</span> lo &lt;= hi:</span><br><span class=\"line\">        mid = (lo + hi ) &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"comment\"># needs = sum(math.ceil(p/mid) for p in piles)   # slower</span></span><br><span class=\"line\">        needs = sum((p<span class=\"number\">-1</span>)//mid+<span class=\"number\">1</span> <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> piles)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> needs &gt; H:</span><br><span class=\"line\">            lo = mid + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            hi = mid - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> lo</span><br></pre></td></tr></table></figure>\n<h3 id=\"1145-Binary-Tree-Coloring-Game\"><a href=\"#1145-Binary-Tree-Coloring-Game\" class=\"headerlink\" title=\"1145. Binary Tree Coloring Game\"></a>1145. Binary Tree Coloring Game</h3><h4 id=\"二叉树染色游戏。两个人轮流给二叉树染色，每次只能染相邻位的节点，给定第一个人染色的位置，问第二个人是否能够必胜。原题\"><a href=\"#二叉树染色游戏。两个人轮流给二叉树染色，每次只能染相邻位的节点，给定第一个人染色的位置，问第二个人是否能够必胜。原题\" class=\"headerlink\" title=\"二叉树染色游戏。两个人轮流给二叉树染色，每次只能染相邻位的节点，给定第一个人染色的位置，问第二个人是否能够必胜。原题\"></a>二叉树染色游戏。两个人轮流给二叉树染色，每次只能染相邻位的节点，给定第一个人染色的位置，问第二个人是否能够必胜。<a href=\"https://leetcode.com/problems/binary-tree-coloring-game/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：关键的一点需要想明白，从第一个人染色的地方，有三个分支，如果有一个分支可以大于整个节点的一半，那么第二个人选择这个分支，就能赢得比赛</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">btreeGameWinningMove</span><span class=\"params\">(self, root: TreeNode, n: int, x: int)</span> -&gt; bool:</span></span><br><span class=\"line\">    count = [<span class=\"number\">0</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        left = dfs(node.left)</span><br><span class=\"line\">        right = dfs(node.right)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.val == x:</span><br><span class=\"line\">            count[<span class=\"number\">0</span>] = left</span><br><span class=\"line\">            count[<span class=\"number\">1</span>] = right</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left + right + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    dfs(root)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(max(count), n - sum(count) - <span class=\"number\">1</span>) &gt; n // <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"33-Search-in-Rotated-Sorted-Array\"><a href=\"#33-Search-in-Rotated-Sorted-Array\" class=\"headerlink\" title=\"33. Search in Rotated Sorted Array\"></a>33. Search in Rotated Sorted Array</h3><h4 id=\"在有序数组旋转后查找目标索引。原题\"><a href=\"#在有序数组旋转后查找目标索引。原题\" class=\"headerlink\" title=\"在有序数组旋转后查找目标索引。原题\"></a>在有序数组旋转后查找目标索引。<a href=\"https://leetcode.com/problems/search-in-rotated-sorted-array/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class=\"line\">Output: 4</span><br></pre></td></tr></table></figure>\n<p>方法一：这个题开始的时候结合两个题，一个是旋转数组中的最小值，然后重组成一个原数组，最后在二分搜索加上原来偏移的索引值。但是这样使用了两次二分法，所以效率不高。看了stefan的答案后明白了，需要找到另一个比较的值就是<code>nums[0]</code>。这里分了两种情况，一种是当<code>nums[0]&lt;=nums[mid]</code>，这种情况说明了<code>nums[:mid]</code>是有序的；另一种是<code>nums[mid]&lt;nums[0]</code>，说明<code>nums[:mid]</code>中存在一个下落点，然后又根据target在下落点的左右分为两种情况。记住条件中target始终有<code>=</code>。其实有一个等号可以去掉，但是为了方便好记。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">search</span><span class=\"params\">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class=\"line\">    lo, hi = <span class=\"number\">0</span>, len(nums)<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> lo &lt;= hi:</span><br><span class=\"line\">        mid = (lo+hi) // <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[mid] == target:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> nums[<span class=\"number\">0</span>]&lt;=target&lt;nums[mid] <span class=\"keyword\">or</span> nums[mid]&lt;nums[<span class=\"number\">0</span>]&lt;=target <span class=\"keyword\">or</span> target&lt;=nums[mid]&lt;nums[<span class=\"number\">0</span>]:</span><br><span class=\"line\">            hi = mid - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            lo = mid + <span class=\"number\">1</span></span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"81-Search-in-Rotated-Sorted-Array-II\"><a href=\"#81-Search-in-Rotated-Sorted-Array-II\" class=\"headerlink\" title=\"81. Search in Rotated Sorted Array II\"></a>81. Search in Rotated Sorted Array II</h3><h4 id=\"同33题，区别在于数组中可能有重复的数字，返回是否存在即可。\"><a href=\"#同33题，区别在于数组中可能有重复的数字，返回是否存在即可。\" class=\"headerlink\" title=\"同33题，区别在于数组中可能有重复的数字，返回是否存在即可。\"></a>同33题，区别在于数组中可能有重复的数字，返回是否存在即可。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 0</span><br><span class=\"line\">Output: true</span><br></pre></td></tr></table></figure>\n<p>方法一：核心代码在于七八行，当左边界和中间相等时，左边界递增。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">search</span><span class=\"params\">(self, nums: List[int], target: int)</span> -&gt; bool:</span></span><br><span class=\"line\">    lo, hi = <span class=\"number\">0</span>, len(nums)<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> lo &lt;= hi:</span><br><span class=\"line\">        mid = (lo+hi) &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[mid] == target:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> lo&lt;mid <span class=\"keyword\">and</span> nums[lo]==nums[mid]:</span><br><span class=\"line\">            lo += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[lo] &lt;= nums[mid]: <span class=\"comment\"># 左侧有序</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[lo] &lt;= target &lt; nums[mid]:</span><br><span class=\"line\">                hi = mid - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                lo = mid + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:                     <span class=\"comment\"># 右侧有序，因为下落点在左侧</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[mid] &lt; target &lt;= nums[hi]:</span><br><span class=\"line\">                lo = mid + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                hi = mid - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1283-Find-the-Smallest-Divisor-Given-a-Threshold\"><a href=\"#1283-Find-the-Smallest-Divisor-Given-a-Threshold\" class=\"headerlink\" title=\"1283. Find the Smallest Divisor Given a Threshold\"></a>1283. Find the Smallest Divisor Given a Threshold</h3><h4 id=\"找到一个除数，用数组所有元素除它得到的天花板数和刚好小于等于阈值。求这个数最小是多少。原题\"><a href=\"#找到一个除数，用数组所有元素除它得到的天花板数和刚好小于等于阈值。求这个数最小是多少。原题\" class=\"headerlink\" title=\"找到一个除数，用数组所有元素除它得到的天花板数和刚好小于等于阈值。求这个数最小是多少。原题\"></a>找到一个除数，用数组所有元素除它得到的天花板数和刚好小于等于阈值。求这个数最小是多少。<a href=\"https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [1,2,5,9], threshold &#x3D; 6</span><br><span class=\"line\">Output: 5</span><br><span class=\"line\">Explanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1. </span><br><span class=\"line\">If the divisor is 4 we can get a sum to 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2).</span><br></pre></td></tr></table></figure>\n<p>方法一：这道题和大佬的解法差不多。区别在于我用了math的库，而他用了一个式子来求的天花板数。知识点<code>(a + b - 1) // b == math.ceil(a/b)</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">smallestDivisor</span><span class=\"params\">(self, nums: List[int], threshold: int)</span> -&gt; int:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    lo, hi = <span class=\"number\">1</span>, max(nums)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> lo &lt;= hi:</span><br><span class=\"line\">        mid = (lo + hi) // <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"comment\"># if sum(math.ceil(i/mid) for i in nums) &lt;= threshold:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> sum((i+mid<span class=\"number\">-1</span>) // mid <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nums) &lt;= threshold:</span><br><span class=\"line\">            hi = mid - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            lo = mid + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> lo</span><br></pre></td></tr></table></figure>\n<h3 id=\"1268-Search-Suggestions-System\"><a href=\"#1268-Search-Suggestions-System\" class=\"headerlink\" title=\"1268. Search Suggestions System\"></a>1268. Search Suggestions System</h3><h4 id=\"单词推荐系统。原题\"><a href=\"#单词推荐系统。原题\" class=\"headerlink\" title=\"单词推荐系统。原题\"></a>单词推荐系统。<a href=\"https://leetcode.com/problems/search-suggestions-system/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: products &#x3D; [&quot;mobile&quot;,&quot;mouse&quot;,&quot;moneypot&quot;,&quot;monitor&quot;,&quot;mousepad&quot;], searchWord &#x3D; &quot;mouse&quot;</span><br><span class=\"line\">Output: [</span><br><span class=\"line\">[&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;],</span><br><span class=\"line\">[&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;],</span><br><span class=\"line\">[&quot;mouse&quot;,&quot;mousepad&quot;],</span><br><span class=\"line\">[&quot;mouse&quot;,&quot;mousepad&quot;],</span><br><span class=\"line\">[&quot;mouse&quot;,&quot;mousepad&quot;]</span><br><span class=\"line\">]</span><br><span class=\"line\">Explanation: products sorted lexicographically &#x3D; [&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;,&quot;mouse&quot;,&quot;mousepad&quot;]</span><br><span class=\"line\">After typing m and mo all products match and we show user [&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;]</span><br><span class=\"line\">After typing mou, mous and mouse the system suggests [&quot;mouse&quot;,&quot;mousepad&quot;]</span><br></pre></td></tr></table></figure>\n<p>方法一：二分法。此题暴力法求解也能过。更好的方法还是二分或者Trie，但是Trie的方式实现过于复杂。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">suggestedProducts</span><span class=\"params\">(self, p: List[str], w: str)</span> -&gt; List[List[str]]:</span></span><br><span class=\"line\">    p.sort()</span><br><span class=\"line\">    ans, prefix, i = [], <span class=\"string\">''</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> w:</span><br><span class=\"line\">        prefix += c</span><br><span class=\"line\">        i = bisect.bisect_left(p, prefix, i)</span><br><span class=\"line\">        ans.append([d <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> p[i:i+<span class=\"number\">3</span>] <span class=\"keyword\">if</span> d.startswith(prefix)])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"392-Is-Subsequence\"><a href=\"#392-Is-Subsequence\" class=\"headerlink\" title=\"392. Is Subsequence\"></a>392. Is Subsequence</h3><h4 id=\"判断一个字符串是否是另一个的子序列。原题\"><a href=\"#判断一个字符串是否是另一个的子序列。原题\" class=\"headerlink\" title=\"判断一个字符串是否是另一个的子序列。原题\"></a>判断一个字符串是否是另一个的子序列。<a href=\"https://leetcode.com/problems/is-subsequence/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;abc&quot;, t &#x3D; &quot;ahbgdc&quot;</span><br><span class=\"line\">Output: true</span><br></pre></td></tr></table></figure>\n<p>方法一：生成器。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isSubsequence</span><span class=\"params\">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class=\"line\">    t = iter(t)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> all(c <span class=\"keyword\">in</span> t <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> s)</span><br></pre></td></tr></table></figure>\n<p>方法二：二分法。将每个字符的索引用列表记录下来，每次用二分法找后序出现的匹配的字符。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isSubsequence</span><span class=\"params\">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class=\"line\">    idx = defaultdict(list)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, c <span class=\"keyword\">in</span> enumerate(t):</span><br><span class=\"line\">        idx[c].append(i)</span><br><span class=\"line\">    prev = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, c <span class=\"keyword\">in</span> enumerate(s):            </span><br><span class=\"line\">        j = bisect.bisect_left(idx[c], prev)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> j == len(idx[c]): <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        prev = idx[c][j] + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1482-Minimum-Number-of-Days-to-Make-m-Bouquets\"><a href=\"#1482-Minimum-Number-of-Days-to-Make-m-Bouquets\" class=\"headerlink\" title=\"1482. Minimum Number of Days to Make m Bouquets\"></a>1482. Minimum Number of Days to Make m Bouquets</h3><h4 id=\"花圃里有若干的花束记录了第几天会开花。最小的天数，可以做出m束花，必须使用连续的花才能做成一朵花束。需要k束花。原题\"><a href=\"#花圃里有若干的花束记录了第几天会开花。最小的天数，可以做出m束花，必须使用连续的花才能做成一朵花束。需要k束花。原题\" class=\"headerlink\" title=\"花圃里有若干的花束记录了第几天会开花。最小的天数，可以做出m束花，必须使用连续的花才能做成一朵花束。需要k束花。原题\"></a>花圃里有若干的花束记录了第几天会开花。最小的天数，可以做出m束花，必须使用连续的花才能做成一朵花束。需要k束花。<a href=\"https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: bloomDay &#x3D; [1,10,3,10,2], m &#x3D; 3, k &#x3D; 1</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: Let&#39;s see what happened in the first three days. x means flower bloomed and _ means flower didn&#39;t bloom in the garden.</span><br><span class=\"line\">We need 3 bouquets each should contain 1 flower.</span><br><span class=\"line\">After day 1: [x, _, _, _, _]   &#x2F;&#x2F; we can only make one bouquet.</span><br><span class=\"line\">After day 2: [x, _, _, _, x]   &#x2F;&#x2F; we can only make two bouquets.</span><br><span class=\"line\">After day 3: [x, _, x, _, x]   &#x2F;&#x2F; we can make 3 bouquets. The answer is 3.</span><br></pre></td></tr></table></figure>\n<p>方法一：比赛的时候真是一点都没往二分法想、这个是Lee的答案。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minDays</span><span class=\"params\">(self, A: List[int], m: int, k: int)</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> m * k &gt; len(A): <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    lo, hi = <span class=\"number\">1</span>, max(A)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> lo &lt; hi:</span><br><span class=\"line\">        mid = (lo + hi) // <span class=\"number\">2</span></span><br><span class=\"line\">        flow = bouq = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> A:</span><br><span class=\"line\">            flow = <span class=\"number\">0</span> <span class=\"keyword\">if</span> a &gt; mid <span class=\"keyword\">else</span> flow + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> flow &gt;= k:</span><br><span class=\"line\">                bouq += <span class=\"number\">1</span></span><br><span class=\"line\">                flow = <span class=\"number\">0</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> bouq == m:</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> bouq == m:</span><br><span class=\"line\">            hi = mid</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            lo = mid + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> lo</span><br></pre></td></tr></table></figure>\n<h3 id=\"1201-Ugly-Number-III\"><a href=\"#1201-Ugly-Number-III\" class=\"headerlink\" title=\"1201. Ugly Number III\"></a>1201. Ugly Number III</h3><h4 id=\"找到第n个能被a或b或c整除的数。原题\"><a href=\"#找到第n个能被a或b或c整除的数。原题\" class=\"headerlink\" title=\"找到第n个能被a或b或c整除的数。原题\"></a>找到第n个能被a或b或c整除的数。<a href=\"https://leetcode.com/problems/ugly-number-iii/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 3, a &#x3D; 2, b &#x3D; 3, c &#x3D; 5</span><br><span class=\"line\">Output: 4</span><br><span class=\"line\">Explanation: The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3rd is 4.</span><br></pre></td></tr></table></figure>\n<p>方法一：这题和 丑数2的题不一样，那道题是只能被2，3，5整除的数。这题一开始也是没想到用二分法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">nthUglyNumber</span><span class=\"params\">(self, n: int, a: int, b: int, c: int)</span> -&gt; int:</span></span><br><span class=\"line\">    lo, hi = <span class=\"number\">1</span>, <span class=\"number\">2</span> * <span class=\"number\">10</span>**<span class=\"number\">9</span></span><br><span class=\"line\">    ab = a*b // math.gcd(a, b)</span><br><span class=\"line\">    ac = a*c // math.gcd(a, c)</span><br><span class=\"line\">    bc = b*c // math.gcd(b, c)</span><br><span class=\"line\">    abc = a*bc // math.gcd(a, bc)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> lo &lt;= hi:</span><br><span class=\"line\">        mid = (lo+hi) // <span class=\"number\">2</span></span><br><span class=\"line\">        total = mid//a + mid//b + mid//c - mid//ab - mid//ac - mid//bc + mid//abc</span><br><span class=\"line\">        <span class=\"keyword\">if</span> total &gt;= n:</span><br><span class=\"line\">            hi = mid - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            lo = mid + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> lo</span><br></pre></td></tr></table></figure>\n<h3 id=\"287-Find-the-Duplicate-Number\"><a href=\"#287-Find-the-Duplicate-Number\" class=\"headerlink\" title=\"287. Find the Duplicate Number\"></a>287. Find the Duplicate Number</h3><h4 id=\"找到重复的数字，在1-n中有一个数至少重复了一次，但是其它数可能没有，找到这个重复的数字。原题\"><a href=\"#找到重复的数字，在1-n中有一个数至少重复了一次，但是其它数可能没有，找到这个重复的数字。原题\" class=\"headerlink\" title=\"找到重复的数字，在1~n中有一个数至少重复了一次，但是其它数可能没有，找到这个重复的数字。原题\"></a>找到重复的数字，在1~n中有一个数至少重复了一次，但是其它数可能没有，找到这个重复的数字。<a href=\"https://leetcode.com/problems/find-the-duplicate-number/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><font color=\"#32CD32\" size=\"3\">方法一：用过这个方法，但是没想到能用在这道题上，方法是解环形链表中入口节点的那道题。因为数组中存在重复的数字，所以这样延伸下去一定是有环。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findDuplicate</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    slow = nums[<span class=\"number\">0</span>]</span><br><span class=\"line\">    fast = nums[slow]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> slow != fast:</span><br><span class=\"line\">        slow = nums[slow]</span><br><span class=\"line\">        fast = nums[nums[fast]]</span><br><span class=\"line\">    head = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> head != fast:</span><br><span class=\"line\">        fast = nums[fast]</span><br><span class=\"line\">        head = nums[head]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head</span><br></pre></td></tr></table></figure>\n<p>方法二：二分法。比较的是数字的多少。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findDuplicate</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    lo, hi = <span class=\"number\">1</span>, len(nums)<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> lo &lt; hi:</span><br><span class=\"line\">        mid = (lo + hi) // <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> sum(i&lt;=mid <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nums) &lt;= mid:</span><br><span class=\"line\">            lo = mid + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            hi = mid</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lo</span><br></pre></td></tr></table></figure>\n<h3 id=\"154-Find-Minimum-in-Rotated-Sorted-Array-II\"><a href=\"#154-Find-Minimum-in-Rotated-Sorted-Array-II\" class=\"headerlink\" title=\"154. Find Minimum in Rotated Sorted Array II\"></a>154. Find Minimum in Rotated Sorted Array II</h3><h4 id=\"旋转数组找到最小值，与1不同的是，这里有重复的值。原题\"><a href=\"#旋转数组找到最小值，与1不同的是，这里有重复的值。原题\" class=\"headerlink\" title=\"旋转数组找到最小值，与1不同的是，这里有重复的值。原题\"></a>旋转数组找到最小值，与1不同的是，这里有重复的值。<a href=\"https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：由于重复值的原因，<code>[10, 1, 10, 10, 10]</code>，<code>[10, 10, 10, 1, 10]</code>    </p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findMin</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    lo, hi = <span class=\"number\">0</span>, len(nums)<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> lo &lt; hi:</span><br><span class=\"line\">        mid = (lo+hi) &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[mid] &gt; nums[hi]:</span><br><span class=\"line\">            lo = mid + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> nums[mid] &lt; nums[hi]:</span><br><span class=\"line\">            hi = mid</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            hi -= <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums[lo]</span><br></pre></td></tr></table></figure>\n<h3 id=\"1539-Kth-Missing-Positive-Number\"><a href=\"#1539-Kth-Missing-Positive-Number\" class=\"headerlink\" title=\"1539. Kth Missing Positive Number\"></a>1539. Kth Missing Positive Number</h3><h4 id=\"找到第k个缺失的正数，数组可能会被耗尽。原题\"><a href=\"#找到第k个缺失的正数，数组可能会被耗尽。原题\" class=\"headerlink\" title=\"找到第k个缺失的正数，数组可能会被耗尽。原题\"></a>找到第k个缺失的正数，数组可能会被耗尽。<a href=\"https://leetcode.com/problems/kth-missing-positive-number/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: arr &#x3D; [2,3,4,7,11], k &#x3D; 5</span><br><span class=\"line\">Output: 9</span><br><span class=\"line\">Explanation: The missing positive integers are [1,5,6,8,9,10,12,13,...]. The 5th missing positive integer is 9.</span><br></pre></td></tr></table></figure>\n<p>方法一：用了集合。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findKthPositive</span><span class=\"params\">(self, arr: List[int], k: int)</span> -&gt; int:</span></span><br><span class=\"line\">    s = set(arr)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">2002</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">            k -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> k == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> i</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：二分法by@lee215。lo是什么？是最后的结果里面存在了多少数，那么结果就是lo+k。对于数组<code>[2,3,4,7,11]</code> A[m]-1-m表示缺失了几个数。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findKthPositive</span><span class=\"params\">(self, A: List[int], k: int)</span> -&gt; int:</span></span><br><span class=\"line\">    l, r = <span class=\"number\">0</span>, len(A)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> l &lt; r:</span><br><span class=\"line\">        m = (l + r) // <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> A[m] - <span class=\"number\">1</span> - m &lt; k:</span><br><span class=\"line\">            l = m + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            r = m</span><br><span class=\"line\">    <span class=\"keyword\">return</span> l + k</span><br></pre></td></tr></table></figure>\n<h3 id=\"1552-Magnetic-Force-Between-Two-Balls\"><a href=\"#1552-Magnetic-Force-Between-Two-Balls\" class=\"headerlink\" title=\"1552. Magnetic Force Between Two Balls\"></a>1552. Magnetic Force Between Two Balls</h3><h4 id=\"在若干的指定的位置可以放置球，问如何使球之间最小的距离最大化。原题\"><a href=\"#在若干的指定的位置可以放置球，问如何使球之间最小的距离最大化。原题\" class=\"headerlink\" title=\"在若干的指定的位置可以放置球，问如何使球之间最小的距离最大化。原题\"></a>在若干的指定的位置可以放置球，问如何使球之间最小的距离最大化。<a href=\"https://leetcode.com/problems/magnetic-force-between-two-balls/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: position &#x3D; [1,2,3,4,7], m &#x3D; 3</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: Distributing the 3 balls into baskets 1, 4 and 7 will make the magnetic force between ball pairs [3, 3, 6]. The minimum magnetic force is 3. We cannot achieve a larger minimum magnetic force than 3.</span><br></pre></td></tr></table></figure>\n<p>方法一：比赛的时候想了一下二分法，但是没多想。这里只要想明白这个辅助方法就能实现了。count方法表示距离为d时最多可以放几个球。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxDistance</span><span class=\"params\">(self, position: List[int], m: int)</span> -&gt; int:</span></span><br><span class=\"line\">    position.sort()</span><br><span class=\"line\">    n = len(position)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">count</span><span class=\"params\">(d)</span>:</span></span><br><span class=\"line\">        cnt, cur = <span class=\"number\">0</span>, float(<span class=\"string\">'-inf'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> position:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> p - cur &gt;= d:</span><br><span class=\"line\">                cnt += <span class=\"number\">1</span></span><br><span class=\"line\">                cur = p</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cnt</span><br><span class=\"line\">    </span><br><span class=\"line\">    lo, hi = <span class=\"number\">0</span>, position[<span class=\"number\">-1</span>]-position[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> lo &lt;= hi:</span><br><span class=\"line\">        mid = (lo+hi) // <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> count(mid) &gt;= m:</span><br><span class=\"line\">            lo = mid + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            hi = mid - <span class=\"number\">1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> hi</span><br></pre></td></tr></table></figure>\n<h3 id=\"162-Find-Peak-Element\"><a href=\"#162-Find-Peak-Element\" class=\"headerlink\" title=\"162. Find Peak Element\"></a>162. Find Peak Element</h3><h4 id=\"找到数组中的峰值，数组中元素两个挨着的元素不重复。可能存在多个值，返回任意一个即可。原题\"><a href=\"#找到数组中的峰值，数组中元素两个挨着的元素不重复。可能存在多个值，返回任意一个即可。原题\" class=\"headerlink\" title=\"找到数组中的峰值，数组中元素两个挨着的元素不重复。可能存在多个值，返回任意一个即可。原题\"></a>找到数组中的峰值，数组中元素两个挨着的元素不重复。可能存在多个值，返回任意一个即可。<a href=\"https://leetcode.com/problems/find-peak-element/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [1,2,1,3,5,6,4]</span><br><span class=\"line\">Output: 1 or 5 </span><br><span class=\"line\">Explanation: Your function can return either index number 1 where the peak element is 2, </span><br><span class=\"line\">             or index number 5 where the peak element is 6.</span><br></pre></td></tr></table></figure>\n<p>方法一：因为挨着的元素不重复，所以可以用二分法。比较两个相邻的元素，如果做左小于右说明峰值在右侧。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findPeakElement</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    lo, hi = <span class=\"number\">0</span>, len(nums)<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> lo &lt; hi:</span><br><span class=\"line\">        mid = (lo+hi) // <span class=\"number\">2</span></span><br><span class=\"line\">        mid2 = mid + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[mid] &lt; nums[mid2]:</span><br><span class=\"line\">            lo = mid2</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            hi = mid</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lo</span><br></pre></td></tr></table></figure>\n<h3 id=\"1095-Find-in-Mountain-Array\"><a href=\"#1095-Find-in-Mountain-Array\" class=\"headerlink\" title=\"1095. Find in Mountain Array\"></a>1095. Find in Mountain Array</h3><h4 id=\"查找山峰数组中的元素，优先返回左侧的索引，如果都没有返回-1。原题\"><a href=\"#查找山峰数组中的元素，优先返回左侧的索引，如果都没有返回-1。原题\" class=\"headerlink\" title=\"查找山峰数组中的元素，优先返回左侧的索引，如果都没有返回-1。原题\"></a>查找山峰数组中的元素，优先返回左侧的索引，如果都没有返回-1。<a href=\"https://leetcode.com/problems/find-in-mountain-array/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: array &#x3D; [1,2,3,4,5,3,1], target &#x3D; 3</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: 3 exists in the array, at index&#x3D;2 and index&#x3D;5. Return the minimum index, which is 2.</span><br></pre></td></tr></table></figure>\n<p>方法一：三次二分法，想到了这个方式，犹豫了一下，因为觉得这种方式在最坏的情况下取值会超过100次。</p>\n<p>第一次找到峰值，和162一样。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findInMountainArray</span><span class=\"params\">(self, target: int, A: <span class=\"string\">'MountainArray'</span>)</span> -&gt; int:</span></span><br><span class=\"line\">    lo, hi = <span class=\"number\">0</span>, A.length()<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> lo &lt; hi:</span><br><span class=\"line\">        mid = (lo+hi) // <span class=\"number\">2</span></span><br><span class=\"line\">        mid2 = mid + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> A.get(mid) &lt; A.get(mid2):</span><br><span class=\"line\">            lo = mid2</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            hi = mid</span><br><span class=\"line\">    peak = lo</span><br><span class=\"line\">    lo, hi = <span class=\"number\">0</span>, peak</span><br><span class=\"line\">    <span class=\"keyword\">while</span> lo &lt;= hi:</span><br><span class=\"line\">        mid = (lo+hi) // <span class=\"number\">2</span></span><br><span class=\"line\">        mid_val = A.get(mid)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> mid_val &gt; target:</span><br><span class=\"line\">            hi = mid - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> mid_val &lt; target:</span><br><span class=\"line\">            lo = mid + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">            </span><br><span class=\"line\">    lo, hi = peak, A.length()<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> lo &lt;= hi:</span><br><span class=\"line\">        mid = (lo+hi) // <span class=\"number\">2</span></span><br><span class=\"line\">        mid_val = A.get(mid)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> mid_val &gt; target:</span><br><span class=\"line\">            lo = mid + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> mid_val &lt; target:</span><br><span class=\"line\">            hi = mid - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"74-Search-a-2D-Matrix\"><a href=\"#74-Search-a-2D-Matrix\" class=\"headerlink\" title=\"74. Search a 2D Matrix\"></a>74. Search a 2D Matrix</h3><h4 id=\"在2d数组中搜索目标，把数组抻成一维的也是有序数组。原题\"><a href=\"#在2d数组中搜索目标，把数组抻成一维的也是有序数组。原题\" class=\"headerlink\" title=\"在2d数组中搜索目标，把数组抻成一维的也是有序数组。原题\"></a>在2d数组中搜索目标，把数组抻成一维的也是有序数组。<a href=\"https://leetcode.com/problems/search-a-2d-matrix/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">matrix &#x3D; [</span><br><span class=\"line\">  [1,   3,  5,  7],</span><br><span class=\"line\">  [10, 11, 16, 20],</span><br><span class=\"line\">  [23, 30, 34, 50]</span><br><span class=\"line\">]</span><br><span class=\"line\">target &#x3D; 3</span><br><span class=\"line\">Output: true</span><br></pre></td></tr></table></figure>\n<p>方法一：一开始没想到这个方法，而是先bisect_right找行，然后再在行里二分。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">searchMatrix</span><span class=\"params\">(self, matrix: List[List[int]], target: int)</span> -&gt; bool:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> matrix <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> matrix[<span class=\"number\">0</span>]:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    n = len(matrix[<span class=\"number\">0</span>])</span><br><span class=\"line\">    lo, hi = <span class=\"number\">0</span>, n*len(matrix)<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> lo &lt;= hi:</span><br><span class=\"line\">        mid = (lo+hi) // <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> matrix[mid//n][mid%n] &gt; target:</span><br><span class=\"line\">            hi = mid - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> matrix[mid//n][mid%n] &lt; target:</span><br><span class=\"line\">            lo = mid + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"436-Find-Right-Interval\"><a href=\"#436-Find-Right-Interval\" class=\"headerlink\" title=\"436. Find Right Interval\"></a>436. Find Right Interval</h3><h4 id=\"找到每个段的右侧的段的索引，右侧的段意味着起始点大于等于该段结尾点的并且最近的段。原题\"><a href=\"#找到每个段的右侧的段的索引，右侧的段意味着起始点大于等于该段结尾点的并且最近的段。原题\" class=\"headerlink\" title=\"找到每个段的右侧的段的索引，右侧的段意味着起始点大于等于该段结尾点的并且最近的段。原题\"></a>找到每个段的右侧的段的索引，右侧的段意味着起始点大于等于该段结尾点的并且最近的段。<a href=\"https://leetcode.com/problems/find-right-interval/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [ [3,4], [2,3], [1,2] ]</span><br><span class=\"line\"></span><br><span class=\"line\">Output: [-1, 0, 1]</span><br><span class=\"line\"></span><br><span class=\"line\">Explanation: There is no satisfied &quot;right&quot; interval for [3,4].</span><br><span class=\"line\">For [2,3], the interval [3,4] has minimum-&quot;right&quot; start point;</span><br><span class=\"line\">For [1,2], the interval [2,3] has minimum-&quot;right&quot; start point.</span><br><span class=\"line\">[ [3,4], [6,9], [5,8] ]</span><br><span class=\"line\">[2,-1,-1]</span><br></pre></td></tr></table></figure>\n<p>方法一：二分法。理清题意后挺简单的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findRightInterval</span><span class=\"params\">(self, intervals: <span class=\"string\">'List[Interval]'</span>)</span> -&gt; List[int]:</span></span><br><span class=\"line\">    starts = [(start, i) <span class=\"keyword\">for</span> i, (start, _) <span class=\"keyword\">in</span> enumerate(intervals)]</span><br><span class=\"line\">    starts.append((float(<span class=\"string\">'inf'</span>), <span class=\"number\">-1</span>))</span><br><span class=\"line\">    starts.sort()</span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, end <span class=\"keyword\">in</span> intervals:</span><br><span class=\"line\">        i = bisect.bisect_left(starts, (end, ))</span><br><span class=\"line\">        ans.append(starts[i][<span class=\"number\">-1</span>])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法二：压缩一下。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findRightInterval</span><span class=\"params\">(self, intervals: <span class=\"string\">'List[Interval]'</span>)</span> -&gt; List[int]:</span></span><br><span class=\"line\">    starts = [(start, i) <span class=\"keyword\">for</span> i, (start, _) <span class=\"keyword\">in</span> enumerate(intervals)] + [(float(<span class=\"string\">'inf'</span>), <span class=\"number\">-1</span>)]</span><br><span class=\"line\">    starts.sort()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [starts[bisect.bisect_left(starts, (end, ))][<span class=\"number\">-1</span>] <span class=\"keyword\">for</span> _, end <span class=\"keyword\">in</span> intervals]</span><br></pre></td></tr></table></figure>\n<h3 id=\"911-Online-Election\"><a href=\"#911-Online-Election\" class=\"headerlink\" title=\"911. Online Election\"></a><a href=\"https://leetcode.com/problems/online-election/\" target=\"_blank\" rel=\"noopener\">911. Online Election</a></h3><h4 id=\"找到某一时间的选举票最多的人。\"><a href=\"#找到某一时间的选举票最多的人。\" class=\"headerlink\" title=\"找到某一时间的选举票最多的人。\"></a>找到某一时间的选举票最多的人。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [&quot;TopVotedCandidate&quot;,&quot;q&quot;,&quot;q&quot;,&quot;q&quot;,&quot;q&quot;,&quot;q&quot;,&quot;q&quot;], [[[0,1,1,0,0,1,0],[0,5,10,15,20,25,30]],[3],[12],[25],[15],[24],[8]]</span><br><span class=\"line\">Output: [null,0,1,1,0,0,1]</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">At time 3, the votes are [0], and 0 is leading.</span><br><span class=\"line\">At time 12, the votes are [0,1,1], and 1 is leading.</span><br><span class=\"line\">At time 25, the votes are [0,1,1,0,0,1], and 1 is leading (as ties go to the most recent vote.)</span><br><span class=\"line\">This continues for 3 more queries at time 15, 24, and 8.</span><br></pre></td></tr></table></figure>\n<p>方法一：二分法，挺简单的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TopVotedCandidate</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, persons: List[int], times: List[int])</span>:</span></span><br><span class=\"line\">        self.leading = []</span><br><span class=\"line\">        tickets = collections.defaultdict(int)</span><br><span class=\"line\">        max_votes, candidate = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> p, t <span class=\"keyword\">in</span> zip(persons, times):</span><br><span class=\"line\">            tickets[p] += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> tickets[p] &gt;= max_votes:</span><br><span class=\"line\">                candidate = p</span><br><span class=\"line\">                max_votes = tickets[p]</span><br><span class=\"line\">            self.leading.append((t, candidate))</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">q</span><span class=\"params\">(self, t: int)</span> -&gt; int:</span></span><br><span class=\"line\">        i = bisect.bisect(self.leading, (t, float(<span class=\"string\">'inf'</span>)))        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.leading[i<span class=\"number\">-1</span>][<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：Lee的方法，写法上改进，时间并不需要绑定在一起，可以通过二分时间索引找选举人。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TopVotedCandidate</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, persons: List[int], times: List[int])</span>:</span></span><br><span class=\"line\">        self.leading = []</span><br><span class=\"line\">        self.times = times</span><br><span class=\"line\">        tickets = collections.defaultdict(int)</span><br><span class=\"line\">        lead = <span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> persons:</span><br><span class=\"line\">            tickets[p] += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> tickets[p] &gt;= tickets[lead]:</span><br><span class=\"line\">                lead = p</span><br><span class=\"line\">            self.leading.append(lead)</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">q</span><span class=\"params\">(self, t: int)</span> -&gt; int:</span></span><br><span class=\"line\">        i = bisect.bisect(self.times, t)      </span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.leading[i<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"378-Kth-Smallest-Element-in-a-Sorted-Matrix\"><a href=\"#378-Kth-Smallest-Element-in-a-Sorted-Matrix\" class=\"headerlink\" title=\"378. Kth Smallest Element in a Sorted Matrix\"></a><a href=\"https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/\" target=\"_blank\" rel=\"noopener\">378. Kth Smallest Element in a Sorted Matrix</a></h3><h4 id=\"有个二维矩阵行列都是有序的，找到第K个最小的元素。\"><a href=\"#有个二维矩阵行列都是有序的，找到第K个最小的元素。\" class=\"headerlink\" title=\"有个二维矩阵行列都是有序的，找到第K个最小的元素。\"></a>有个二维矩阵行列都是有序的，找到第K个最小的元素。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">matrix &#x3D; [</span><br><span class=\"line\">   [ 1,  5,  9],</span><br><span class=\"line\">   [10, 11, 13],</span><br><span class=\"line\">   [12, 13, 15]</span><br><span class=\"line\">],</span><br><span class=\"line\">k &#x3D; 8,</span><br><span class=\"line\"></span><br><span class=\"line\">return 13.</span><br></pre></td></tr></table></figure>\n<p>方法一：可以用堆，暴力地解决，效率也很高。不过这样的话，有序的条件相当于没有用上。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">kthSmallest</span><span class=\"params\">(self, matrix: List[List[int]], k: int)</span> -&gt; int:</span></span><br><span class=\"line\">    heap = sum(matrix, [])</span><br><span class=\"line\">    heapq.heapify(heap)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(k):</span><br><span class=\"line\">        ans = heapq.heappop(heap)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：不需要全部都塞到堆里。这里注意只有首行元素需要添加右侧的节点到堆中。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">kthSmallest</span><span class=\"params\">(self, matrix: List[List[int]], k: int)</span> -&gt; int:</span></span><br><span class=\"line\">    heap = [(matrix[<span class=\"number\">0</span>][<span class=\"number\">0</span>], <span class=\"number\">0</span>, <span class=\"number\">0</span>)]</span><br><span class=\"line\">    N = len(matrix)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(k):</span><br><span class=\"line\">        val, i, j = heapq.heappop(heap)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i==<span class=\"number\">0</span> <span class=\"keyword\">and</span> j+<span class=\"number\">1</span>&lt;N:</span><br><span class=\"line\">            heapq.heappush(heap, (matrix[i][j+<span class=\"number\">1</span>], i, j+<span class=\"number\">1</span>))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i + <span class=\"number\">1</span> &lt; N:</span><br><span class=\"line\">            heapq.heappush(heap, (matrix[i+<span class=\"number\">1</span>][j], i+<span class=\"number\">1</span>, j))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> val</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：二分法，找到中间的数和k比较。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">kthSmallest</span><span class=\"params\">(self, matrix: List[List[int]], k: int)</span> -&gt; int:</span></span><br><span class=\"line\">    lo, hi = matrix[<span class=\"number\">0</span>][<span class=\"number\">0</span>], matrix[<span class=\"number\">-1</span>][<span class=\"number\">-1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> lo &lt; hi:</span><br><span class=\"line\">        mid = (lo + hi) // <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> sum(bisect.bisect(row, mid) <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> matrix) &lt; k:</span><br><span class=\"line\">            lo = mid + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            hi = mid</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lo</span><br></pre></td></tr></table></figure>\n<h3 id=\"1157-Online-Majority-Element-In-Subarray\"><a href=\"#1157-Online-Majority-Element-In-Subarray\" class=\"headerlink\" title=\"1157. Online Majority Element In Subarray\"></a>1157. Online Majority Element In Subarray</h3><h4 id=\"实时的最多元素查询。原题\"><a href=\"#实时的最多元素查询。原题\" class=\"headerlink\" title=\"实时的最多元素查询。原题\"></a>实时的最多元素查询。<a href=\"https://leetcode.com/problems/online-majority-element-in-subarray/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">MajorityChecker majorityChecker &#x3D; new MajorityChecker([1,1,2,2,1,1]);</span><br><span class=\"line\">majorityChecker.query(0,5,4); &#x2F;&#x2F; returns 1</span><br><span class=\"line\">majorityChecker.query(0,3,3); &#x2F;&#x2F; returns -1</span><br><span class=\"line\">majorityChecker.query(2,3,2); &#x2F;&#x2F; returns 2</span><br></pre></td></tr></table></figure>\n<p>方法一：竞赛时，用了个<code>dict</code>嵌套，内存溢出了。此题的解法是存索引，然后二分。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MajorityChecker</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, arr: List[int])</span>:</span></span><br><span class=\"line\">        self.c = collections.defaultdict(list)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, x <span class=\"keyword\">in</span> enumerate(arr):</span><br><span class=\"line\">            self.c[x].append(i)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">query</span><span class=\"params\">(self, left: int, right: int, threshold: int)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> k, v <span class=\"keyword\">in</span> self.c.items():</span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(v) &lt; threshold:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\"></span><br><span class=\"line\">            low = bisect.bisect_left(v, left)</span><br><span class=\"line\">            high = bisect.bisect_right(v, right)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> high - low &gt;= threshold:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> k</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1146-Snapshot-Array\"><a href=\"#1146-Snapshot-Array\" class=\"headerlink\" title=\"1146. Snapshot Array\"></a>1146. Snapshot Array</h3><h4 id=\"数组的快照。原题\"><a href=\"#数组的快照。原题\" class=\"headerlink\" title=\"数组的快照。原题\"></a>数组的快照。<a href=\"https://leetcode.com/problems/snapshot-array/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [&quot;SnapshotArray&quot;,&quot;set&quot;,&quot;snap&quot;,&quot;set&quot;,&quot;get&quot;]</span><br><span class=\"line\">[[3],[0,5],[],[0,6],[0,0]]</span><br><span class=\"line\">Output: [null,null,0,null,5]</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">SnapshotArray snapshotArr &#x3D; new SnapshotArray(3); &#x2F;&#x2F; set the length to be 3</span><br><span class=\"line\">snapshotArr.set(0,5);  &#x2F;&#x2F; Set array[0] &#x3D; 5</span><br><span class=\"line\">snapshotArr.snap();  &#x2F;&#x2F; Take a snapshot, return snap_id &#x3D; 0</span><br><span class=\"line\">snapshotArr.set(0,6);</span><br><span class=\"line\">snapshotArr.get(0,0);  &#x2F;&#x2F; Get the value of array[0] with snap_id &#x3D; 0, return 5</span><br></pre></td></tr></table></figure>\n<p>方法一：此题暴力法时，空间复杂度会过高。采用针对每个元素，变化时，记录该变化的历史。再用二分法查找。</p>\n<p>注意查找时，是通过数组查找而不是数字，查找比其大的再-1。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SnapshotArray</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, length: int)</span>:</span></span><br><span class=\"line\">        self.ary = [[[<span class=\"number\">-1</span>, <span class=\"number\">0</span>]] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(length)]</span><br><span class=\"line\">        self.snap_id = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">set</span><span class=\"params\">(self, index: int, val: int)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        self.ary[index].append([self.snap_id, val])</span><br><span class=\"line\">        </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">snap</span><span class=\"params\">(self)</span> -&gt; int:</span></span><br><span class=\"line\">        self.snap_id += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.snap_id - <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get</span><span class=\"params\">(self, index: int, snap_id: int)</span> -&gt; int:</span></span><br><span class=\"line\">        i = bisect.bisect(self.ary[index], [snap_id+<span class=\"number\">1</span>]) - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.ary[index][i][<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"1847-Closest-Room\"><a href=\"#1847-Closest-Room\" class=\"headerlink\" title=\"1847. Closest Room\"></a><a href=\"https://leetcode.com/problems/closest-room/\" target=\"_blank\" rel=\"noopener\">1847. Closest Room</a></h3><h4 id=\"找到满足size的最近id的房间。\"><a href=\"#找到满足size的最近id的房间。\" class=\"headerlink\" title=\"找到满足size的最近id的房间。\"></a>找到满足size的最近id的房间。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: rooms &#x3D; [[2,2],[1,2],[3,2]], queries &#x3D; [[3,1],[3,3],[5,2]]</span><br><span class=\"line\">Output: [3,-1,3]</span><br><span class=\"line\">Explanation: The answers to the queries are as follows:</span><br><span class=\"line\">Query &#x3D; [3,1]: Room number 3 is the closest as abs(3 - 3) &#x3D; 0, and its size of 2 is at least 1. The answer is 3.</span><br><span class=\"line\">Query &#x3D; [3,3]: There are no rooms with a size of at least 3, so the answer is -1.</span><br><span class=\"line\">Query &#x3D; [5,2]: Room number 3 is the closest as abs(3 - 5) &#x3D; 2, and its size of 2 is at least 2. The answer is 3.</span><br></pre></td></tr></table></figure>\n<p>方法一：看数据量很容易能够想到是二分法，但是还需要想到离线算法，这个题要将query顺序打乱。这里是官方的解法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> sortedcontainers</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Event</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    op: 事件的类型，0 表示房间，1 表示询问</span></span><br><span class=\"line\"><span class=\"string\">    size: 房间的 size 或者询问的 minSize</span></span><br><span class=\"line\"><span class=\"string\">    idx: 房间的 roomId 或者询问的 preferred</span></span><br><span class=\"line\"><span class=\"string\">    origin: 房间在数组 room 中的原始编号或者询问在数组 queries 中的原始编号</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, op: int, size: int, idx: int, origin: int)</span>:</span></span><br><span class=\"line\">        self.op = op</span><br><span class=\"line\">        self.size = size</span><br><span class=\"line\">        self.idx = idx</span><br><span class=\"line\">        self.origin = origin</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    自定义比较函数，按照事件的 size 降序排序</span></span><br><span class=\"line\"><span class=\"string\">    如果 size 相同，优先考虑房间</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__lt__</span><span class=\"params\">(self, other: <span class=\"string\">\"Event\"</span>)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.size &gt; other.size <span class=\"keyword\">or</span> (self.size == other.size <span class=\"keyword\">and</span> self.op &lt; other.op)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">closestRoom</span><span class=\"params\">(self, rooms: List[List[int]], queries: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class=\"line\">        N = len(queries)</span><br><span class=\"line\">        res = [<span class=\"number\">-1</span>] * N</span><br><span class=\"line\"></span><br><span class=\"line\">        events = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, (room_id, size) <span class=\"keyword\">in</span> enumerate(rooms):</span><br><span class=\"line\">            events.append(Event(<span class=\"number\">0</span>, size, room_id, i))</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, (preferred_id, min_size) <span class=\"keyword\">in</span> enumerate(queries):</span><br><span class=\"line\">            events.append(Event(<span class=\"number\">1</span>, min_size, preferred_id, i))</span><br><span class=\"line\"></span><br><span class=\"line\">        events.sort()</span><br><span class=\"line\"></span><br><span class=\"line\">        valid = sortedcontainers.SortedList()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> event <span class=\"keyword\">in</span> events:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> event.op == <span class=\"number\">0</span>:</span><br><span class=\"line\">                valid.add(event.idx)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"comment\"># 询问事件</span></span><br><span class=\"line\">                dist = float(<span class=\"string\">\"inf\"</span>)</span><br><span class=\"line\">                <span class=\"comment\"># 查找最小的大于等于 preferred 的元素</span></span><br><span class=\"line\">                x = valid.bisect_left(event.idx)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> x != len(valid):</span><br><span class=\"line\">                    dist = valid[x] - event.idx</span><br><span class=\"line\">                    res[event.origin] = valid[x]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> x != <span class=\"number\">0</span>:</span><br><span class=\"line\">                    <span class=\"comment\"># 查找最大的严格小于 preferred 的元素</span></span><br><span class=\"line\">                    x -= <span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> event.idx - valid[x] &lt;= dist:</span><br><span class=\"line\">                        dist = event.idx - valid[x]</span><br><span class=\"line\">                        res[event.origin] = valid[x]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"2040-Kth-Smallest-Product-of-Two-Sorted-Arrays\"><a href=\"#2040-Kth-Smallest-Product-of-Two-Sorted-Arrays\" class=\"headerlink\" title=\"2040. Kth Smallest Product of Two Sorted Arrays\"></a><a href=\"https://leetcode.com/problems/kth-smallest-product-of-two-sorted-arrays/\" target=\"_blank\" rel=\"noopener\">2040. Kth Smallest Product of Two Sorted Arrays</a></h3><h4 id=\"两个有序数组的第k小的乘积。\"><a href=\"#两个有序数组的第k小的乘积。\" class=\"headerlink\" title=\"两个有序数组的第k小的乘积。\"></a>两个有序数组的第k小的乘积。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums1 &#x3D; [2,5], nums2 &#x3D; [3,4], k &#x3D; 2</span><br><span class=\"line\">Output: 8</span><br><span class=\"line\">Explanation: The 2 smallest products are:</span><br><span class=\"line\">- nums1[0] * nums2[0] &#x3D; 2 * 3 &#x3D; 6</span><br><span class=\"line\">- nums1[0] * nums2[1] &#x3D; 2 * 4 &#x3D; 8</span><br><span class=\"line\">The 2nd smallest product is 8.</span><br></pre></td></tr></table></figure>\n<p>方法一：这题需要转换一下思路来二分，以乘积来二分，如果小于等于x的刚好有k个，那么乘积就是x。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">kthSmallestProduct</span><span class=\"params\">(self, nums1: List[int], nums2: List[int], k: int)</span> -&gt; int:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># 乘积小于等于x的有多少个</span></span><br><span class=\"line\">        total = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> n1 <span class=\"keyword\">in</span> nums1:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> n1 &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                total += bisect.bisect(nums2, x//n1)</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> n1 == <span class=\"number\">0</span>:</span><br><span class=\"line\">                total += (x&gt;=<span class=\"number\">0</span>) * len(nums2)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                total += len(nums2) - bisect_left(nums2, ceil(x/n1))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> total</span><br><span class=\"line\"></span><br><span class=\"line\">    lo, hi = <span class=\"number\">-10</span>**<span class=\"number\">10</span><span class=\"number\">-1</span>, <span class=\"number\">10</span>**<span class=\"number\">10</span>+<span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> lo &lt; hi:</span><br><span class=\"line\">        mid = (lo + hi) // <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> check(mid) &gt;= k:</span><br><span class=\"line\">            hi = mid</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            lo = mid + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> lo</span><br></pre></td></tr></table></figure>\n<h3 id=\"792-Number-of-Matching-Subsequences\"><a href=\"#792-Number-of-Matching-Subsequences\" class=\"headerlink\" title=\"792. Number of Matching Subsequences\"></a><a href=\"https://leetcode.com/problems/number-of-matching-subsequences/\" target=\"_blank\" rel=\"noopener\">792. Number of Matching Subsequences</a></h3><p>求words里是s子序列的个数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;abcde&quot;, words &#x3D; [&quot;a&quot;,&quot;bb&quot;,&quot;acd&quot;,&quot;ace&quot;]</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: There are three strings in words that are a subsequence of s: &quot;a&quot;, &quot;acd&quot;, &quot;ace&quot;.</span><br></pre></td></tr></table></figure>\n<p>方法一：二分法。如果暴力求子序列会超时，这里使用二分法判断是否是子序列</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numMatchingSubseq</span><span class=\"params\">(self, s: str, words: List[str])</span> -&gt; int:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    idx = defaultdict(list)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, c <span class=\"keyword\">in</span> enumerate(s):</span><br><span class=\"line\">        idx[c].append(i)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_subseq</span><span class=\"params\">(t, s)</span>:</span></span><br><span class=\"line\">        prev = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> t:</span><br><span class=\"line\">            i = bisect.bisect_left(idx[c], prev)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i == len(idx[c]): <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">            prev = idx[c][i] + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(is_subseq(word, s) <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> words)</span><br></pre></td></tr></table></figure>\n<p>方法二：这个方法很新颖，分桶</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numMatchingSubseq</span><span class=\"params\">(self, s: str, words: List[str])</span> -&gt; int:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    buckets = defaultdict(list)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> words:</span><br><span class=\"line\">        buckets[word[<span class=\"number\">0</span>]].append(word)</span><br><span class=\"line\"></span><br><span class=\"line\">    res = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">        nxt = buckets[c]</span><br><span class=\"line\">        buckets[c] = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> nxt:</span><br><span class=\"line\">            suffix = w[<span class=\"number\">1</span>:]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> suffix:</span><br><span class=\"line\">                res += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                buckets[suffix[<span class=\"number\">0</span>]].append(suffix)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n","categories":["算法"],"tags":["LeetCode","Python","Algorithm","Binary Search"]},{"title":"LeetCode算法题整理（位运算篇）Bit Manipulation","url":"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AF%87%EF%BC%89Bit-Manipulation/","content":"<h3 id=\"191-Number-of-1-Bits\"><a href=\"#191-Number-of-1-Bits\" class=\"headerlink\" title=\"191. Number of 1 Bits\"></a>191. Number of 1 Bits</h3><h4 id=\"计算数字的二进制中有多少个1。原题\"><a href=\"#计算数字的二进制中有多少个1。原题\" class=\"headerlink\" title=\"计算数字的二进制中有多少个1。原题\"></a>计算数字的二进制中有多少个1。<a href=\"https://leetcode.com/problems/number-of-1-bits/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: 11</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: Integer 11 has binary representation 00000000000000000000000000001011</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>方法一：常规解法，使用1与n作与运算，如果不是0说明，含有一个1。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hamming_weight</span><span class=\"params\">(n)</span>:</span></span><br><span class=\"line\">    bits, mask = <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(<span class=\"number\">32</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n&amp;mask != <span class=\"number\">0</span>:</span><br><span class=\"line\">            bits += <span class=\"number\">1</span></span><br><span class=\"line\">        mask &lt;&lt;= <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> bits</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：关键点是，一个数n和n-1的与运算操作，相当于去掉了最右面的1。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hamming_weigth</span><span class=\"params\">(n)</span>:</span></span><br><span class=\"line\">    bits = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> n:</span><br><span class=\"line\">        bits += <span class=\"number\">1</span></span><br><span class=\"line\">        n = (n<span class=\"number\">-1</span>) &amp; n</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bits</span><br></pre></td></tr></table></figure>\n<h3 id=\"136-Single-Number\"><a href=\"#136-Single-Number\" class=\"headerlink\" title=\"136. Single Number\"></a>136. Single Number</h3><h4 id=\"找出数组中不重复的元素。其它元素出现两次。原题\"><a href=\"#找出数组中不重复的元素。其它元素出现两次。原题\" class=\"headerlink\" title=\"找出数组中不重复的元素。其它元素出现两次。原题\"></a>找出数组中不重复的元素。其它元素出现两次。<a href=\"https://leetcode.com/problems/single-number/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [4,1,2,1,2]</span><br><span class=\"line\">Output: 4</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">single_num</span><span class=\"params\">(nums)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> reduce(<span class=\"keyword\">lambda</span> x, y: x ^ y, nums)</span><br></pre></td></tr></table></figure>\n<h3 id=\"137-Single-Number-II\"><a href=\"#137-Single-Number-II\" class=\"headerlink\" title=\"137. Single Number II\"></a>137. Single Number II</h3><h4 id=\"找出数组中出现一次的元素，其它元素出现三次。原题\"><a href=\"#找出数组中出现一次的元素，其它元素出现三次。原题\" class=\"headerlink\" title=\"找出数组中出现一次的元素，其它元素出现三次。原题\"></a>找出数组中出现一次的元素，其它元素出现三次。<a href=\"https://leetcode.com/problems/single-number-ii/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [2,2,3,2]</span><br><span class=\"line\">Output: 3</span><br></pre></td></tr></table></figure>\n<p>方法一：找出单独元素每一位的值。如果把所有数字的二进制每一位加起来，如果某一位可以被3整除，则表示单独元素的该位为0，否则为1。以下使用<code>count</code>来表示每一位<code>1</code>的个数。假设<code>count%3!=0</code>为True，说明该元素<code>i</code>位为1，然后是用<code>|=</code>更新ans在第<code>i</code>个位置的值，这里也可以使用<code>+=</code>，但是效率稍慢。<code>convert</code>的作用是因为python中的int是个对象，且没有最大限制，不是在第32位使用1来表示负数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">singleNumber</span><span class=\"params\">(self, nums, n=<span class=\"number\">3</span>)</span>:</span></span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">32</span>):</span><br><span class=\"line\">        count = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((num &gt;&gt; i) &amp; <span class=\"number\">1</span>):</span><br><span class=\"line\">                count += <span class=\"number\">1</span></span><br><span class=\"line\">        ans |= ((count%n!=<span class=\"number\">0</span>) &lt;&lt; i)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.convert(ans)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">convert</span><span class=\"params\">(self, x)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> x &gt;= <span class=\"number\">2</span>**<span class=\"number\">31</span>:</span><br><span class=\"line\">        x -= <span class=\"number\">2</span>**<span class=\"number\">32</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x</span><br></pre></td></tr></table></figure>\n<p>这里有个状态机的解法，不明觉厉，留坑。<a href=\"https://leetcode.com/problems/single-number-ii/discuss/43294/Challenge-me-thx?page=2\" target=\"_blank\" rel=\"noopener\">讨论1</a>和<a href=\"https://leetcode.com/problems/single-number-ii/discuss/43295/Detailed-explanation-and-generalization-of-the-bitwise-operation-method-for-single-numbers\" target=\"_blank\" rel=\"noopener\">讨论2</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">singleNumber</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">    ones, twos = <span class=\"number\">0</span>, <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(nums)):</span><br><span class=\"line\">        ones = (ones ^ nums[i]) &amp; ~twos</span><br><span class=\"line\">        twos = (twos ^ nums[i]) &amp; ~ones</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ones</span><br></pre></td></tr></table></figure>\n<h3 id=\"260-Single-Number-III\"><a href=\"#260-Single-Number-III\" class=\"headerlink\" title=\"260. Single Number III\"></a>260. Single Number III</h3><h4 id=\"找出数组中两个唯一出现一次的元素，其余元素均出现两次。原题\"><a href=\"#找出数组中两个唯一出现一次的元素，其余元素均出现两次。原题\" class=\"headerlink\" title=\"找出数组中两个唯一出现一次的元素，其余元素均出现两次。原题\"></a>找出数组中两个唯一出现一次的元素，其余元素均出现两次。<a href=\"https://leetcode.com/problems/single-number-iii/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input:  [1,2,1,3,2,5]</span><br><span class=\"line\">Output: [3,5]</span><br></pre></td></tr></table></figure>\n<p>思想：将这两个元素分到两个组，由于这两个数不相等，所以亦或结果不为0，也就是说二进制中至少有一位1，记为第n位。我们以第n位是否为1，把数组分为两个子数组。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">singleNumber</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">    total_xor = self.get_xor(nums)</span><br><span class=\"line\">    mask = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> total_xor&amp;mask == <span class=\"number\">0</span>:</span><br><span class=\"line\">        mask &lt;&lt;= <span class=\"number\">1</span></span><br><span class=\"line\">    p1 = [num <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums <span class=\"keyword\">if</span> num&amp;mask==<span class=\"number\">0</span>]</span><br><span class=\"line\">    p2 = [num <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums <span class=\"keyword\">if</span> num&amp;mask!=<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [self.get_xor(p1), self.get_xor(p2)]</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_xor</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> functools <span class=\"keyword\">import</span> reduce</span><br><span class=\"line\">    <span class=\"keyword\">return</span> reduce(<span class=\"keyword\">lambda</span> x, y: x ^ y, nums)</span><br></pre></td></tr></table></figure>\n<h4 id=\"面试题-17-19-消失的两个数字\"><a href=\"#面试题-17-19-消失的两个数字\" class=\"headerlink\" title=\"面试题 17.19. 消失的两个数字\"></a><a href=\"https://leetcode-cn.com/problems/missing-two-lcci/\" target=\"_blank\" rel=\"noopener\">面试题 17.19. 消失的两个数字</a></h4><h4 id=\"此题和260很像，不同在于是从1-N消失了两个数字。要求在O-N-时间，O-1-空间实现。\"><a href=\"#此题和260很像，不同在于是从1-N消失了两个数字。要求在O-N-时间，O-1-空间实现。\" class=\"headerlink\" title=\"此题和260很像，不同在于是从1~N消失了两个数字。要求在O(N)时间，O(1)空间实现。\"></a>此题和260很像，不同在于是从1~N消失了两个数字。要求在O(N)时间，O(1)空间实现。</h4><p>方法一：可以使用260的方法，但是这样空间复杂度不符合要求。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">missingTwo</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_missing</span><span class=\"params\">(ary)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> reduce(operator.xor, ary)</span><br><span class=\"line\">    nums = nums + list(range(<span class=\"number\">1</span>, len(nums)+<span class=\"number\">3</span>))</span><br><span class=\"line\">    total = get_missing(nums)</span><br><span class=\"line\">    mask = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> total &amp; mask == <span class=\"number\">0</span>:</span><br><span class=\"line\">        mask &lt;&lt;= <span class=\"number\">1</span></span><br><span class=\"line\">    n1 = (n <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> nums <span class=\"keyword\">if</span> n&amp;mask!=<span class=\"number\">0</span>)</span><br><span class=\"line\">    n2 = (n <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> nums <span class=\"keyword\">if</span> n&amp;mask==<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> get_missing(n1), get_missing(n2)</span><br></pre></td></tr></table></figure>\n<p>方法二：以<code>0~n-1中缺失的数字</code>题为基础来解。写完了发现和方法一不就是同一种方法嘛，只不过用了循环来代替数组产生的空间。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">missingTwo</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    total = reduce(operator.xor, nums)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(nums)+<span class=\"number\">3</span>):</span><br><span class=\"line\">        total ^= i</span><br><span class=\"line\">    mask = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> mask &amp; total == <span class=\"number\">0</span>:</span><br><span class=\"line\">        mask &lt;&lt;= <span class=\"number\">1</span></span><br><span class=\"line\">    one = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> mask &amp; n: one ^= n</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(nums)+<span class=\"number\">3</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> mask &amp; i: one ^= i</span><br><span class=\"line\">    <span class=\"keyword\">return</span> one, total^one</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：将方法一改为常数空间复杂度。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">missingTwo</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_missing</span><span class=\"params\">(ary)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> reduce(operator.xor, ary)</span><br><span class=\"line\"></span><br><span class=\"line\">    a, b, c = itertools.tee(chain(nums, range(<span class=\"number\">1</span>, len(nums)+<span class=\"number\">3</span>)), <span class=\"number\">3</span>)</span><br><span class=\"line\">    total = get_missing(a)</span><br><span class=\"line\">    mask = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> total &amp; mask == <span class=\"number\">0</span>:</span><br><span class=\"line\">        mask &lt;&lt;= <span class=\"number\">1</span></span><br><span class=\"line\">    n1 = (n <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> b <span class=\"keyword\">if</span> n&amp;mask!=<span class=\"number\">0</span>)</span><br><span class=\"line\">    n2 = (n <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> c <span class=\"keyword\">if</span> n&amp;mask==<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> get_missing(n1), get_missing(n2)</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法四：数学方法，根据<code>0~n-1缺失的数字</code>数学方法。使用两数的平均数来讲原数组分为两部分。这样问题就变成了找到一个缺失的数字。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">missingTwo</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    total = sum(range(<span class=\"number\">1</span>, len(nums)+<span class=\"number\">3</span>)) - sum(nums)</span><br><span class=\"line\">    mid = total / <span class=\"number\">2</span></span><br><span class=\"line\">    small = (n <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> nums <span class=\"keyword\">if</span> n &lt;= mid)</span><br><span class=\"line\">    one = sum(range(<span class=\"number\">1</span>, int(mid)+<span class=\"number\">1</span>)) - sum(small)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> one, total-one</span><br></pre></td></tr></table></figure>\n<p>方法五：这个是从评论中学习到的方法，很有意思。将对应索引置为负数，然后最后找正数的索引，就是缺失的两个数字。但是这样空间复杂度貌似不符合要求了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">missingTwo</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    nums += [<span class=\"number\">1</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> nums[:<span class=\"number\">-2</span>]:</span><br><span class=\"line\">        nums[n<span class=\"number\">-1</span>] = <span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [i+<span class=\"number\">1</span> <span class=\"keyword\">for</span> i, n <span class=\"keyword\">in</span> enumerate(nums) <span class=\"keyword\">if</span> n!=<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<p>方法六：很快，我想到了生成器islice，但是用了发现不对，为什么？因为我在循环中改变了nums，导致了n出现了-1的情况。所以我们只改变符号，不改变数字，需要用一个abs。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">missingTwo</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    nums += [<span class=\"number\">1</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> islice(nums, len(nums)<span class=\"number\">-2</span>):</span><br><span class=\"line\">        nums[abs(n)<span class=\"number\">-1</span>] = -nums[abs(n)<span class=\"number\">-1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [i+<span class=\"number\">1</span> <span class=\"keyword\">for</span> i, n <span class=\"keyword\">in</span> enumerate(nums) <span class=\"keyword\">if</span> n&gt;<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"371-Sum-of-Two-Integers\"><a href=\"#371-Sum-of-Two-Integers\" class=\"headerlink\" title=\"371. Sum of Two Integers\"></a>371. Sum of Two Integers</h3><h4 id=\"不用加减乘除做加法。原题\"><a href=\"#不用加减乘除做加法。原题\" class=\"headerlink\" title=\"不用加减乘除做加法。原题\"></a>不用加减乘除做加法。<a href=\"https://leetcode.com/problems/sum-of-two-integers/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>解析<a href=\"/371-Sum-of-Two-Integers-Python/\" title=\"为何Python位运算有些不同\">为何Python位运算有些不同</a></p>\n<p>实际上加法分为三个步骤</p>\n<ol>\n<li>相加但不进位，1^0=1，1^1=0，0^0=0，所以第一步用异或。</li>\n<li>只求进位的结果，只有两个1才会进位，所以用<code>&amp;</code>，然后左移1位，表示要进的位。</li>\n<li>把前两步的结果再重复1，2步，直到没有进位产生，即<code>b=0</code>。</li>\n</ol>\n<img src=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AF%87%EF%BC%89Bit-Manipulation/sum_two.png\" class>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getSum</span><span class=\"params\">(self, a, b)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 32 bits integer max</span></span><br><span class=\"line\">    MAX = <span class=\"number\">0x7FFFFFFF</span>  <span class=\"comment\"># 2**31-1</span></span><br><span class=\"line\">    <span class=\"comment\"># 32 bits interger min  </span></span><br><span class=\"line\">    MIN = <span class=\"number\">0x80000000</span>  <span class=\"comment\"># -2**31</span></span><br><span class=\"line\">    <span class=\"comment\"># mask to get last 32 bits</span></span><br><span class=\"line\">    mask = <span class=\"number\">0xFFFFFFFF</span>  <span class=\"comment\"># 2*32-1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> b != <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"comment\"># ^ get different bits and &amp; gets double 1s, &lt;&lt; moves carry</span></span><br><span class=\"line\">        a, b = (a ^ b) &amp; mask, ((a &amp; b) &lt;&lt; <span class=\"number\">1</span>) &amp; mask</span><br><span class=\"line\">    <span class=\"comment\"># if a is negative, get a's 32 bits complement positive first</span></span><br><span class=\"line\">    <span class=\"comment\"># then get 32-bit positive's Python complement negative</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a <span class=\"keyword\">if</span> a &lt;= MAX <span class=\"keyword\">else</span> ~(a ^ mask)</span><br></pre></td></tr></table></figure>\n<h3 id=\"190-Reverse-Bits\"><a href=\"#190-Reverse-Bits\" class=\"headerlink\" title=\"190. Reverse Bits\"></a>190. Reverse Bits</h3><h4 id=\"返回一个数的二进制的倒序的十进制。原题\"><a href=\"#返回一个数的二进制的倒序的十进制。原题\" class=\"headerlink\" title=\"返回一个数的二进制的倒序的十进制。原题\"></a>返回一个数的二进制的倒序的十进制。<a href=\"https://leetcode.com/problems/reverse-bits/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: 43261596</span><br><span class=\"line\">Output: 964176192</span><br><span class=\"line\">Explanation: 43261596 represented in binary as 00000010100101000001111010011100, </span><br><span class=\"line\">             return 964176192 represented in binary as 00111001011110000010100101000000.</span><br></pre></td></tr></table></figure>\n<p>方法一：使用原生库。<code>ljust</code>表示在右侧补’0’。或者使用<code>format</code>来补0。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseBits</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> int(bin(n)[:<span class=\"number\">1</span>:<span class=\"number\">-1</span>].ljust(<span class=\"number\">32</span>, <span class=\"string\">'0'</span>), <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"comment\"># return int('&#123;:0&lt;32s&#125;'.format(bin(n)[:1:-1]), 2)</span></span><br></pre></td></tr></table></figure>\n<p>方法二：自己实现进制转换，使用位运算优化。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseBits</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">    code = <span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(<span class=\"number\">32</span>):</span><br><span class=\"line\">        code += str(n &amp; <span class=\"number\">1</span>)</span><br><span class=\"line\">        n &gt;&gt;= <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum([int(bit) &lt;&lt; i <span class=\"keyword\">for</span> i, bit <span class=\"keyword\">in</span> enumerate(code[::<span class=\"number\">-1</span>])])</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二改进：这里有个误区，为什么非要将整个二进制完整体现出来，再去遍历它转成int，而不是直接构建这个int。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseBits</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">    code = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(<span class=\"number\">32</span>):</span><br><span class=\"line\">        code = (code&lt;&lt;<span class=\"number\">1</span>) + (n&amp;<span class=\"number\">1</span>)</span><br><span class=\"line\">        n &gt;&gt;= <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> code</span><br></pre></td></tr></table></figure>\n<h3 id=\"389-Find-the-Difference\"><a href=\"#389-Find-the-Difference\" class=\"headerlink\" title=\"389. Find the Difference\"></a>389. Find the Difference</h3><h4 id=\"s和t两个由小写字母组成的字符串，t是由s打乱顺序并再随机添加一个小写字母组成。原题\"><a href=\"#s和t两个由小写字母组成的字符串，t是由s打乱顺序并再随机添加一个小写字母组成。原题\" class=\"headerlink\" title=\"s和t两个由小写字母组成的字符串，t是由s打乱顺序并再随机添加一个小写字母组成。原题\"></a>s和t两个由小写字母组成的字符串，t是由s打乱顺序并再随机添加一个小写字母组成。<a href=\"https://leetcode.com/problems/find-the-difference/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：使用Collection。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findTheDifference</span><span class=\"params\">(self, s, t)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Counter</span><br><span class=\"line\">    <span class=\"keyword\">return</span> next((Counter(t) - Counter(s)).elements())</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\"><strong>方法二：使用异或。</strong></font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findTheDifference</span><span class=\"params\">(self, s, t)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> operator <span class=\"keyword\">import</span> xor</span><br><span class=\"line\">    <span class=\"keyword\">from</span> functools <span class=\"keyword\">import</span> reduce</span><br><span class=\"line\">    <span class=\"keyword\">return</span> chr(reduce(xor, map(ord, s+t)))</span><br></pre></td></tr></table></figure>\n<h3 id=\"401-Binary-Watch\"><a href=\"#401-Binary-Watch\" class=\"headerlink\" title=\"401. Binary Watch\"></a>401. Binary Watch</h3><h4 id=\"有这样一个二进制的手表，输入一个n，表示有几个亮着的灯，返回所有可能出现的时间。时间范围为12小时制，即hours-0-11-，minutes-0-59-。原题\"><a href=\"#有这样一个二进制的手表，输入一个n，表示有几个亮着的灯，返回所有可能出现的时间。时间范围为12小时制，即hours-0-11-，minutes-0-59-。原题\" class=\"headerlink\" title=\"有这样一个二进制的手表，输入一个n，表示有几个亮着的灯，返回所有可能出现的时间。时间范围为12小时制，即hours(0-11)，minutes(0-59)。原题\"></a>有这样一个二进制的手表，输入一个n，表示有几个亮着的灯，返回所有可能出现的时间。时间范围为12小时制，即hours(0-11)，minutes(0-59)。<a href=\"https://leetcode.com/problems/binary-watch/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><img src=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AF%87%EF%BC%89Bit-Manipulation/Binary_clock_samui_moon.jpg\" class>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 1</span><br><span class=\"line\">Return: [&quot;1:00&quot;, &quot;2:00&quot;, &quot;4:00&quot;, &quot;8:00&quot;, &quot;0:01&quot;, &quot;0:02&quot;, &quot;0:04&quot;, &quot;0:08&quot;, &quot;0:16&quot;, &quot;0:32&quot;]</span><br></pre></td></tr></table></figure>\n<font color=\"#FF0000\" size=\"3\"><strong>一开始的思路：这是个错误的解法，因为分钟的灯不应该超过60分钟，因为要进位。类似的4和8的小时灯也不能同时亮起。</strong></font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">readBinaryWatch</span><span class=\"params\">(self, num)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> itertools <span class=\"keyword\">import</span> combinations</span><br><span class=\"line\">    <span class=\"comment\"># transform hours to minutes</span></span><br><span class=\"line\">    minutes = list(map(<span class=\"keyword\">lambda</span> x: x * <span class=\"number\">60</span>, (<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>))) + [<span class=\"number\">32</span>, <span class=\"number\">16</span>, <span class=\"number\">8</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\">    minutes_groups = combinations(minutes, num)</span><br><span class=\"line\">    res = [<span class=\"string\">'&#123;:d&#125;:&#123;:0&gt;2d&#125;'</span>.format(sum(g)//<span class=\"number\">60</span>, sum(g)%<span class=\"number\">60</span>) <span class=\"keyword\">for</span> g <span class=\"keyword\">in</span> minutes_groups]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<p>方法二：正确的写法。需要分开判断小时和分钟，然后再合并。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">readBinaryWatch</span><span class=\"params\">(self, num)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> itertools <span class=\"keyword\">import</span> combinations</span><br><span class=\"line\">    <span class=\"comment\"># transform hours to minutes</span></span><br><span class=\"line\">    hours = list(map(<span class=\"keyword\">lambda</span> x: x*<span class=\"number\">60</span>, (<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>)))</span><br><span class=\"line\">    minutes = (<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>, <span class=\"number\">16</span>, <span class=\"number\">32</span>)</span><br><span class=\"line\">    res = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(num+<span class=\"number\">1</span>):</span><br><span class=\"line\">        get_hours = [x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> list(combinations(hours, i)) <span class=\"keyword\">if</span> sum(x) &lt; <span class=\"number\">12</span> * <span class=\"number\">60</span>]</span><br><span class=\"line\">        get_minutes = [x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> list(combinations(minutes, num-i)) <span class=\"keyword\">if</span> sum(x) &lt; <span class=\"number\">60</span>]</span><br><span class=\"line\">        minutes_groups = [h+m <span class=\"keyword\">for</span> h <span class=\"keyword\">in</span> get_hours <span class=\"keyword\">for</span> m <span class=\"keyword\">in</span> get_minutes]</span><br><span class=\"line\">        res += [<span class=\"string\">'&#123;:d&#125;:&#123;:0&gt;2d&#125;'</span>.format(sum(g)//<span class=\"number\">60</span>, sum(g)%<span class=\"number\">60</span>) <span class=\"keyword\">for</span> g <span class=\"keyword\">in</span> minutes_groups]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：遍历所有可能的时间，找到符合条件的。因为表中的数组都是二进制，所以’1’的个数就是亮灯的个数。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">readBinaryWatch</span><span class=\"params\">(self, num)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"string\">'&#123;:d&#125;:&#123;:0&gt;2d&#125;'</span>.format(h, m)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> h <span class=\"keyword\">in</span> range(<span class=\"number\">12</span>) <span class=\"keyword\">for</span> m <span class=\"keyword\">in</span> range(<span class=\"number\">60</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bin(h)+bin(m)).count(<span class=\"string\">'1'</span>) == num]</span><br></pre></td></tr></table></figure>\n<h3 id=\"405-Convert-a-Number-to-Hexadecimal\"><a href=\"#405-Convert-a-Number-to-Hexadecimal\" class=\"headerlink\" title=\"405. Convert a Number to Hexadecimal\"></a>405. Convert a Number to Hexadecimal</h3><h4 id=\"把一个32位有符号的整数转换成16进制。原题\"><a href=\"#把一个32位有符号的整数转换成16进制。原题\" class=\"headerlink\" title=\"把一个32位有符号的整数转换成16进制。原题\"></a>把一个32位有符号的整数转换成16进制。<a href=\"https://leetcode.com/problems/convert-a-number-to-hexadecimal/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">26</span><br><span class=\"line\">Output:</span><br><span class=\"line\">&quot;1a&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">Input:</span><br><span class=\"line\">-1</span><br><span class=\"line\">Output:</span><br><span class=\"line\">&quot;ffffffff&quot;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">toHex</span><span class=\"params\">(self, num)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join([<span class=\"string\">'0123456789abcdef'</span>[(num &gt;&gt; <span class=\"number\">4</span> * i) &amp; <span class=\"number\">15</span>]</span><br><span class=\"line\">                     <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">8</span>)])[::<span class=\"number\">-1</span>].lstrip(<span class=\"string\">'0'</span>) <span class=\"keyword\">or</span> <span class=\"string\">'0'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"461-Hamming-Distance\"><a href=\"#461-Hamming-Distance\" class=\"headerlink\" title=\"461. Hamming Distance\"></a>461. Hamming Distance</h3><h4 id=\"求两个正数的原码中不同位的个数。原题\"><a href=\"#求两个正数的原码中不同位的个数。原题\" class=\"headerlink\" title=\"求两个正数的原码中不同位的个数。原题\"></a>求两个正数的原码中不同位的个数。<a href=\"https://leetcode.com/problems/hamming-distance/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: x &#x3D; 1, y &#x3D; 4</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">1   (0 0 0 1)</span><br><span class=\"line\">4   (0 1 0 0)</span><br><span class=\"line\">       ↑   ↑</span><br><span class=\"line\">The above arrows point to positions where the corresponding bits are different.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hammingDistance</span><span class=\"params\">(self, x, y)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> bin(x ^ y).count(<span class=\"string\">'1'</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"476-Number-Complement\"><a href=\"#476-Number-Complement\" class=\"headerlink\" title=\"476. Number Complement\"></a>476. Number Complement</h3><h4 id=\"给定一个正数，求其原码的按位取反后的数。原题\"><a href=\"#给定一个正数，求其原码的按位取反后的数。原题\" class=\"headerlink\" title=\"给定一个正数，求其原码的按位取反后的数。原题\"></a>给定一个正数，求其原码的按位取反后的数。<a href=\"https://leetcode.com/problems/number-complement/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: 5</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.</span><br></pre></td></tr></table></figure>\n<p>方法一：暴力的方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findComplement</span><span class=\"params\">(self, num)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> int(<span class=\"string\">''</span>.join([str(<span class=\"number\">1</span> ^ int(d)) <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> bin(num)[<span class=\"number\">2</span>:]]), <span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<p>方法二：其实就是求<code>101</code>和<code>111</code>的异或。所以先找到<code>111</code>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findComplement</span><span class=\"params\">(self, num)</span>:</span></span><br><span class=\"line\">    i = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> i &lt;= num:</span><br><span class=\"line\">        i &lt;&lt;= <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (i<span class=\"number\">-1</span>) ^ num</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：更少的位移。核心思想还是找到<code>111</code>。比如一个8位数，最高代表符号：<code>1000000</code>，先将其右移1位，使得左边两位都变成1。然后再右移2位，使得左边四位变成1，以此类推，8位数最多移动3次就可以得到<code>1111111</code>，32位则还需要再移动2次。</font>\n\n<img src=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AF%87%EF%BC%89Bit-Manipulation/complement.png\" class>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findComplement</span><span class=\"params\">(self, num)</span>:</span></span><br><span class=\"line\">    mask = num</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">5</span>):</span><br><span class=\"line\">        mask |= mask &gt;&gt; (<span class=\"number\">2</span>**i)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> num ^ mask</span><br></pre></td></tr></table></figure>\n<h3 id=\"693-Binary-Number-with-Alternating-Bits\"><a href=\"#693-Binary-Number-with-Alternating-Bits\" class=\"headerlink\" title=\"693. Binary Number with Alternating Bits\"></a>693. Binary Number with Alternating Bits</h3><h4 id=\"二进制是否是交替的0和1。原题\"><a href=\"#二进制是否是交替的0和1。原题\" class=\"headerlink\" title=\"二进制是否是交替的0和1。原题\"></a>二进制是否是交替的0和1。<a href=\"https://leetcode.com/problems/binary-number-with-alternating-bits/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: 5</span><br><span class=\"line\">Output: True</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">The binary representation of 5 is: 101</span><br></pre></td></tr></table></figure>\n<p>方法一：字符串法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hasAlternatingBits</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'00'</span> <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> bin(n) <span class=\"keyword\">and</span> <span class=\"string\">'11'</span> <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> bin(n)</span><br></pre></td></tr></table></figure>\n<p>方法二：除2法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hasAlternatingBits</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">    n, cur = divmod(n, <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> n:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cur == n % <span class=\"number\">2</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        n, cur = divmod(n, <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：异或。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hasAlternatingBits</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> n:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    num = n ^ (n &gt;&gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">not</span> (num &amp; num+<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"762-Prime-Number-of-Set-Bits-in-Binary-Representation\"><a href=\"#762-Prime-Number-of-Set-Bits-in-Binary-Representation\" class=\"headerlink\" title=\"762. Prime Number of Set Bits in Binary Representation\"></a>762. Prime Number of Set Bits in Binary Representation</h3><h4 id=\"求某范围的所有自然数中，二进制中1的个数是质数的个数。原题\"><a href=\"#求某范围的所有自然数中，二进制中1的个数是质数的个数。原题\" class=\"headerlink\" title=\"求某范围的所有自然数中，二进制中1的个数是质数的个数。原题\"></a>求某范围的所有自然数中，二进制中1的个数是质数的个数。<a href=\"https://leetcode.com/problems/prime-number-of-set-bits-in-binary-representation/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: L &#x3D; 10, R &#x3D; 15</span><br><span class=\"line\">Output: 5</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">10 -&gt; 1010 (2 set bits, 2 is prime)</span><br><span class=\"line\">11 -&gt; 1011 (3 set bits, 3 is prime)</span><br><span class=\"line\">12 -&gt; 1100 (2 set bits, 2 is prime)</span><br><span class=\"line\">13 -&gt; 1101 (3 set bits, 3 is prime)</span><br><span class=\"line\">14 -&gt; 1110 (3 set bits, 3 is prime)</span><br><span class=\"line\">15 -&gt; 1111 (4 set bits, 4 is not prime)</span><br></pre></td></tr></table></figure>\n<p>方法一：direct.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countPrimeSetBits</span><span class=\"params\">(self, L: <span class=\"string\">'int'</span>, R: <span class=\"string\">'int'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    primes = &#123;<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>, <span class=\"number\">17</span>, <span class=\"number\">19</span>&#125;</span><br><span class=\"line\">    <span class=\"comment\"># ans = 0</span></span><br><span class=\"line\">    <span class=\"comment\"># for num in range(L, R+1):</span></span><br><span class=\"line\">    <span class=\"comment\">#     if bin(num)[2:].count('1') in primes:</span></span><br><span class=\"line\">    <span class=\"comment\">#         ans += 1</span></span><br><span class=\"line\">    <span class=\"comment\"># return ans</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(bin(n)[<span class=\"number\">2</span>:].count(<span class=\"string\">'1'</span>) <span class=\"keyword\">in</span> primes <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> range(L, R+<span class=\"number\">1</span>))</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：位运算。p 的2，3，5，7。。位是1，其余是0，这样在右移后，可&amp;1就可以判断这个数是否是质数。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countPrimeSetBits</span><span class=\"params\">(self, L: <span class=\"string\">'int'</span>, R: <span class=\"string\">'int'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    p = int(<span class=\"string\">'10100010100010101100'</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(p &gt;&gt; bin(i).count(<span class=\"string\">'1'</span>) &amp; <span class=\"number\">1</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(L, R+<span class=\"number\">1</span>))</span><br></pre></td></tr></table></figure>\n<h3 id=\"868-Binary-Gap\"><a href=\"#868-Binary-Gap\" class=\"headerlink\" title=\"868. Binary Gap\"></a>868. Binary Gap</h3><h4 id=\"二进制两个1的最大距离。原题\"><a href=\"#二进制两个1的最大距离。原题\" class=\"headerlink\" title=\"二进制两个1的最大距离。原题\"></a>二进制两个1的最大距离。<a href=\"https://leetcode.com/problems/binary-gap/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: 22</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">22 in binary is 0b10110.</span><br><span class=\"line\">In the binary representation of 22, there are three ones, and two consecutive pairs of 1&#39;s.</span><br><span class=\"line\">The first consecutive pair of 1&#39;s have distance 2.</span><br><span class=\"line\">The second consecutive pair of 1&#39;s have distance 1.</span><br><span class=\"line\">The answer is the largest of these two distances, which is 2.</span><br></pre></td></tr></table></figure>\n<p>方法一：字符串或是位运算都可以。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">binaryGap</span><span class=\"params\">(self, N: <span class=\"string\">'int'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    ans, last = <span class=\"number\">0</span>, <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"comment\"># for i, b in enumerate(bin(N)[2:]):</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">32</span>):</span><br><span class=\"line\">        <span class=\"comment\"># if b == '1':</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (N &gt;&gt; i) &amp; <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> last <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">                ans = max(ans, i - last)</span><br><span class=\"line\">            last = i</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：列表生成式。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">binaryGap</span><span class=\"params\">(self, N: <span class=\"string\">'int'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    one = [i <span class=\"keyword\">for</span> i, v <span class=\"keyword\">in</span> enumerate(bin(N)) <span class=\"keyword\">if</span> v == <span class=\"string\">'1'</span>]</span><br><span class=\"line\">    <span class=\"comment\"># return max([one[i+1] - one[i] for i in range(len(one)-1)] or [0])</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> max([b-a <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> zip(one, one[<span class=\"number\">1</span>:])] <span class=\"keyword\">or</span> [<span class=\"number\">0</span>])</span><br></pre></td></tr></table></figure>\n<h3 id=\"268-Missing-Number\"><a href=\"#268-Missing-Number\" class=\"headerlink\" title=\"268. Missing Number\"></a>268. Missing Number</h3><h4 id=\"0-n中缺失的数字。原题\"><a href=\"#0-n中缺失的数字。原题\" class=\"headerlink\" title=\"0~n中缺失的数字。原题\"></a>0~n中缺失的数字。<a href=\"https://leetcode.com/problems/missing-number/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：数学公式。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">missingNumber</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">    n = len(nums)</span><br><span class=\"line\">    expected_sum = n*(n+<span class=\"number\">1</span>) // <span class=\"number\">2</span></span><br><span class=\"line\">    actual_sum = sum(nums)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> expected_sum - actual_sum</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：XOR.  </font>\n\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">index</th>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">2</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">value</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">missingNumber</span><span class=\"params\">(self, nums: <span class=\"string\">'List[int]'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    missing = len(nums)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, num <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">        missing ^= i ^ num</span><br><span class=\"line\">    <span class=\"keyword\">return</span> missing</span><br></pre></td></tr></table></figure>\n<h3 id=\"1012-Complement-of-Base-10-Integer\"><a href=\"#1012-Complement-of-Base-10-Integer\" class=\"headerlink\" title=\"1012. Complement of Base 10 Integer\"></a>1012. Complement of Base 10 Integer</h3><h4 id=\"非负数的反码。原题\"><a href=\"#非负数的反码。原题\" class=\"headerlink\" title=\"非负数的反码。原题\"></a>非负数的反码。<a href=\"https://leetcode.com/problems/complement-of-base-10-integer/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bitwiseComplement</span><span class=\"params\">(self, N: int)</span> -&gt; int:</span></span><br><span class=\"line\">    mask = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> mask &lt; N:</span><br><span class=\"line\">        mask = (mask &lt;&lt; <span class=\"number\">1</span>) + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"comment\"># return mask - N</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> N ^ mask</span><br></pre></td></tr></table></figure>\n<h3 id=\"1404-Number-of-Steps-to-Reduce-a-Number-in-Binary-Representation-to-One\"><a href=\"#1404-Number-of-Steps-to-Reduce-a-Number-in-Binary-Representation-to-One\" class=\"headerlink\" title=\"1404. Number of Steps to Reduce a Number in Binary Representation to One\"></a>1404. Number of Steps to Reduce a Number in Binary Representation to One</h3><h4 id=\"几下操作可以将其变为1。偶数除以2，奇数-1-原题\"><a href=\"#几下操作可以将其变为1。偶数除以2，奇数-1-原题\" class=\"headerlink\" title=\"几下操作可以将其变为1。偶数除以2，奇数+1.原题\"></a>几下操作可以将其变为1。偶数除以2，奇数+1.<a href=\"https://leetcode.com/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;1101&quot;</span><br><span class=\"line\">Output: 6</span><br><span class=\"line\">Explanation: &quot;1101&quot; corressponds to number 13 in their decimal representation.</span><br><span class=\"line\">Step 1) 13 is odd, add 1 and obtain 14. </span><br><span class=\"line\">Step 2) 14 is even, divide by 2 and obtain 7.</span><br><span class=\"line\">Step 3) 7 is odd, add 1 and obtain 8.</span><br><span class=\"line\">Step 4) 8 is even, divide by 2 and obtain 4.  </span><br><span class=\"line\">Step 5) 4 is even, divide by 2 and obtain 2. </span><br><span class=\"line\">Step 6) 2 is even, divide by 2 and obtain 1.</span><br></pre></td></tr></table></figure>\n<p>方法一：将其转为数字最简单，但是失去了此题的意义。评论区看到的一个解法</p>\n<p><code>110010</code> -&gt; <code>110100</code> -&gt; <code>111000</code> -&gt; <code>1000000</code> takes <code>2(which is count of mid zeros) + 1</code> moves.<br><code>1000000</code> -&gt; <code>1</code> takes 6 moves because length of <code>s</code> increases 1.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numSteps</span><span class=\"params\">(self, s: str)</span> -&gt; int:</span></span><br><span class=\"line\">    i, mid_0 = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(s)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> s[j] == <span class=\"string\">'1'</span>:</span><br><span class=\"line\">            mid_0 += j - i - <span class=\"number\">1</span></span><br><span class=\"line\">            i = j</span><br><span class=\"line\">    <span class=\"keyword\">if</span> i == <span class=\"number\">0</span>: <span class=\"keyword\">return</span> len(s) - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> mid_0 + <span class=\"number\">1</span> + len(s)</span><br></pre></td></tr></table></figure>\n<h3 id=\"201-Bitwise-AND-of-Numbers-Range\"><a href=\"#201-Bitwise-AND-of-Numbers-Range\" class=\"headerlink\" title=\"201. Bitwise AND of Numbers Range\"></a>201. Bitwise AND of Numbers Range</h3><h4 id=\"范围内的数字求与运算和。原题\"><a href=\"#范围内的数字求与运算和。原题\" class=\"headerlink\" title=\"范围内的数字求与运算和。原题\"></a>范围内的数字求与运算和。<a href=\"https://leetcode.com/problems/bitwise-and-of-numbers-range/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [5,7]</span><br><span class=\"line\">Output: 4</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rangeBitwiseAnd</span><span class=\"params\">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class=\"line\">    i = <span class=\"number\">0</span> </span><br><span class=\"line\">    <span class=\"keyword\">while</span> m != n:</span><br><span class=\"line\">        m &gt;&gt;= <span class=\"number\">1</span></span><br><span class=\"line\">        n &gt;&gt;= <span class=\"number\">1</span></span><br><span class=\"line\">        i += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> n &lt;&lt; i</span><br></pre></td></tr></table></figure>\n<h3 id=\"1442-Count-Triplets-That-Can-Form-Two-Arrays-of-Equal-XOR\"><a href=\"#1442-Count-Triplets-That-Can-Form-Two-Arrays-of-Equal-XOR\" class=\"headerlink\" title=\"1442. Count Triplets That Can Form Two Arrays of Equal XOR\"></a>1442. Count Triplets That Can Form Two Arrays of Equal XOR</h3><h4 id=\"数组中找出两段的异或和相等。原题\"><a href=\"#数组中找出两段的异或和相等。原题\" class=\"headerlink\" title=\"数组中找出两段的异或和相等。原题\"></a>数组中找出两段的异或和相等。<a href=\"https://leetcode.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：此题在竞赛中做出来了，需要找到规律。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countTriplets</span><span class=\"params\">(self, arr: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    m = list(itertools.accumulate([<span class=\"number\">0</span>] + arr, operator.xor))</span><br><span class=\"line\">    count = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(m)):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i+<span class=\"number\">1</span>, len(m)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> m[i] == m[j]:</span><br><span class=\"line\">                count += j-i<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> count</span><br></pre></td></tr></table></figure>\n<h3 id=\"1238-Circular-Permutation-in-Binary-Representation\"><a href=\"#1238-Circular-Permutation-in-Binary-Representation\" class=\"headerlink\" title=\"1238. Circular Permutation in Binary Representation\"></a>1238. Circular Permutation in Binary Representation</h3><h4 id=\"返回指定为位数的二进制环，每两个数的二进制只有1位不同。原题\"><a href=\"#返回指定为位数的二进制环，每两个数的二进制只有1位不同。原题\" class=\"headerlink\" title=\"返回指定为位数的二进制环，每两个数的二进制只有1位不同。原题\"></a>返回指定为位数的二进制环，每两个数的二进制只有1位不同。<a href=\"https://leetcode.com/problems/circular-permutation-in-binary-representation/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 2, start &#x3D; 3</span><br><span class=\"line\">Output: [3,2,0,1]</span><br><span class=\"line\">Explanation: The binary representation of the permutation is (11,10,00,01). </span><br><span class=\"line\">All the adjacent element differ by one bit. Another valid permutation is [3,1,0,2]</span><br></pre></td></tr></table></figure>\n<p>方法一：我想了半天这道题，以为和二进制无关，是个数学题，没想到最后还得用异或来解决。这是个 gray code的问题，有一个公式。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">circularPermutation</span><span class=\"params\">(self, n, start)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [start ^ i ^ i &gt;&gt; <span class=\"number\">1</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span> &lt;&lt; n)]</span><br></pre></td></tr></table></figure>\n<h3 id=\"393-UTF-8-Validation\"><a href=\"#393-UTF-8-Validation\" class=\"headerlink\" title=\"393. UTF-8 Validation\"></a>393. UTF-8 Validation</h3><h4 id=\"题目描述非常之难懂，母语的人看着都看不明白。此题在Leetcode-cn上看的中文描述。针对一些数，它的二进制必须满足几种形式，如果是0开头，就是一个1字节的字符；如果110开头，说明是2字节的字符，其后面的二进制形式必须是10开头；如果1110开头，说明是3字节字符，后面必须跟两个10开头的字符。原题\"><a href=\"#题目描述非常之难懂，母语的人看着都看不明白。此题在Leetcode-cn上看的中文描述。针对一些数，它的二进制必须满足几种形式，如果是0开头，就是一个1字节的字符；如果110开头，说明是2字节的字符，其后面的二进制形式必须是10开头；如果1110开头，说明是3字节字符，后面必须跟两个10开头的字符。原题\" class=\"headerlink\" title=\"题目描述非常之难懂，母语的人看着都看不明白。此题在Leetcode-cn上看的中文描述。针对一些数，它的二进制必须满足几种形式，如果是0开头，就是一个1字节的字符；如果110开头，说明是2字节的字符，其后面的二进制形式必须是10开头；如果1110开头，说明是3字节字符，后面必须跟两个10开头的字符。原题\"></a>题目描述非常之难懂，母语的人看着都看不明白。此题在Leetcode-cn上看的中文描述。针对一些数，它的二进制必须满足几种形式，如果是0开头，就是一个1字节的字符；如果110开头，说明是2字节的字符，其后面的二进制形式必须是10开头；如果1110开头，说明是3字节字符，后面必须跟两个10开头的字符。<a href=\"https://leetcode.com/problems/utf-8-validation/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">data &#x3D; [197, 130, 1], which represents the octet sequence: 11000101 10000010 00000001.</span><br><span class=\"line\"></span><br><span class=\"line\">Return true.</span><br><span class=\"line\">It is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.</span><br></pre></td></tr></table></figure>\n<p>方法一：字符串方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">validUtf8</span><span class=\"params\">(self, data: List[int])</span> -&gt; bool:</span></span><br><span class=\"line\">    b = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> data:</span><br><span class=\"line\">        s = <span class=\"string\">'&#123;:0&gt;8b&#125;'</span>.format(d)[<span class=\"number\">-8</span>:]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> b:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> s.startswith(<span class=\"string\">'10'</span>):</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                b -= <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> s.startswith(<span class=\"string\">'0'</span>): <span class=\"keyword\">continue</span></span><br><span class=\"line\">        head = re.match(<span class=\"string\">r'(^1&#123;2,4&#125;0)*'</span>, s).groups()[<span class=\"number\">0</span>]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> head:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        b = len(head) - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> b == <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<p>方法二：位运算。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">validUtf8</span><span class=\"params\">(self, data: List[int])</span> -&gt; bool:</span></span><br><span class=\"line\">    b = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> data:</span><br><span class=\"line\">        mask1, mask2 = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">7</span>, <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">6</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> b:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span>((d&amp;mask1) <span class=\"keyword\">and</span> (<span class=\"keyword\">not</span> d&amp;mask2)):</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                b -= <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> d&amp;mask1:</span><br><span class=\"line\">            b += <span class=\"number\">1</span></span><br><span class=\"line\">            mask1 &gt;&gt;= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> b==<span class=\"number\">0</span>: <span class=\"keyword\">continue</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> b==<span class=\"number\">1</span> <span class=\"keyword\">or</span> b&gt;<span class=\"number\">4</span>: <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        b -= <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> b == <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"318-Maximum-Product-of-Word-Lengths\"><a href=\"#318-Maximum-Product-of-Word-Lengths\" class=\"headerlink\" title=\"318. Maximum Product of Word Lengths\"></a>318. Maximum Product of Word Lengths</h3><h4 id=\"给你一个单词列表，返回最大的两个没有相同字符的单词长度乘积。原题\"><a href=\"#给你一个单词列表，返回最大的两个没有相同字符的单词长度乘积。原题\" class=\"headerlink\" title=\"给你一个单词列表，返回最大的两个没有相同字符的单词长度乘积。原题\"></a>给你一个单词列表，返回最大的两个没有相同字符的单词长度乘积。<a href=\"https://leetcode.com/problems/maximum-product-of-word-lengths/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [&quot;abcw&quot;,&quot;baz&quot;,&quot;foo&quot;,&quot;bar&quot;,&quot;xtfn&quot;,&quot;abcdef&quot;]</span><br><span class=\"line\">Output: 16 </span><br><span class=\"line\">Explanation: The two words can be &quot;abcw&quot;, &quot;xtfn&quot;.</span><br></pre></td></tr></table></figure>\n<p>方法一：直观解法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxProduct</span><span class=\"params\">(self, words: List[str])</span> -&gt; int:</span></span><br><span class=\"line\">    ws = [(len(word), set(word)) <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> words]</span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(ws)):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i+<span class=\"number\">1</span>, len(ws)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> ws[j][<span class=\"number\">1</span>] &amp; ws[i][<span class=\"number\">1</span>]:</span><br><span class=\"line\">                ans = max(ans, ws[i][<span class=\"number\">0</span>]*ws[j][<span class=\"number\">0</span>])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：位运算。评论区看到的答案，怎么想的呢，单词只包含26个小写字母，又有相同字符判断，从而可以想出这样的解法。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxProduct</span><span class=\"params\">(self, words: List[str])</span> -&gt; int:</span></span><br><span class=\"line\">    d = &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> words:</span><br><span class=\"line\">        mask = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> set(w):</span><br><span class=\"line\">            mask |= <span class=\"number\">1</span>&lt;&lt;(ord(c)-ord(<span class=\"string\">'a'</span>))</span><br><span class=\"line\">        d[mask] = max(d.get(mask, <span class=\"number\">0</span>), len(w))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max([d[i]*d[j] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> d <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> d <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> i&amp;j] <span class=\"keyword\">or</span> [<span class=\"number\">0</span>])</span><br></pre></td></tr></table></figure>\n<h3 id=\"1177-Can-Make-Palindrome-from-Substring\"><a href=\"#1177-Can-Make-Palindrome-from-Substring\" class=\"headerlink\" title=\"1177. Can Make Palindrome from Substring\"></a>1177. Can Make Palindrome from Substring</h3><h4 id=\"给定一个-字符串s，进行一些查询，针对s的切片内容能否将其打乱然后重新排列，在替换k个字符内将其变成回文的。返回这些查询结果。原题\"><a href=\"#给定一个-字符串s，进行一些查询，针对s的切片内容能否将其打乱然后重新排列，在替换k个字符内将其变成回文的。返回这些查询结果。原题\" class=\"headerlink\" title=\"给定一个 字符串s，进行一些查询，针对s的切片内容能否将其打乱然后重新排列，在替换k个字符内将其变成回文的。返回这些查询结果。原题\"></a>给定一个 字符串s，进行一些查询，针对s的切片内容能否将其打乱然后重新排列，在替换k个字符内将其变成回文的。返回这些查询结果。<a href=\"https://leetcode.com/problems/can-make-palindrome-from-substring/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;abcda&quot;, queries &#x3D; [[3,3,0],[1,2,0],[0,3,1],[0,3,2],[0,4,1]]</span><br><span class=\"line\">Output: [true,false,false,true,true]</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">queries[0] : substring &#x3D; &quot;d&quot;, is palidrome.</span><br><span class=\"line\">queries[1] : substring &#x3D; &quot;bc&quot;, is not palidrome.</span><br><span class=\"line\">queries[2] : substring &#x3D; &quot;abcd&quot;, is not palidrome after replacing only 1 character.</span><br><span class=\"line\">queries[3] : substring &#x3D; &quot;abcd&quot;, could be changed to &quot;abba&quot; which is palidrome. Also this can be changed to &quot;baab&quot; first rearrange it &quot;bacd&quot; then replace &quot;cd&quot; with &quot;ab&quot;.</span><br><span class=\"line\">queries[4] : substring &#x3D; &quot;abcda&quot;, could be changed to &quot;abcba&quot; which is palidrome.</span><br></pre></td></tr></table></figure>\n<p>方法一：bit mask。我学会了，开始的时候想用Counter来计算，虽然通过了但是效率很慢。这样只包含字母的题可以用位运算异或来进行。思路和榜一大神不谋而合。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">canMakePaliQueries</span><span class=\"params\">(self, s: str, queries: List[List[int]])</span> -&gt; List[bool]:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    d = [<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">        d.append(d[<span class=\"number\">-1</span>] ^ (<span class=\"number\">1</span> &lt;&lt; (ord(c)-ord(<span class=\"string\">'a'</span>))))</span><br><span class=\"line\"></span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, j, k <span class=\"keyword\">in</span> queries:</span><br><span class=\"line\">        cur = d[j+<span class=\"number\">1</span>] ^ d[i]</span><br><span class=\"line\">        <span class=\"comment\"># print(count_one(cur), i, j, format(cur, 'b'))</span></span><br><span class=\"line\">        ans.append(format(cur, <span class=\"string\">'b'</span>).count(<span class=\"string\">'1'</span>)//<span class=\"number\">2</span> &lt;= k)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：整理一下方法一。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">canMakePaliQueries</span><span class=\"params\">(self, s: str, queries: List[List[int]])</span> -&gt; List[bool]:</span></span><br><span class=\"line\">    d = [<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">        d.append(d[<span class=\"number\">-1</span>] ^ (<span class=\"number\">1</span> &lt;&lt; (ord(c)-ord(<span class=\"string\">'a'</span>))))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [bin(d[j+<span class=\"number\">1</span>] ^ d[i]).count(<span class=\"string\">'1'</span>)//<span class=\"number\">2</span> &lt;= k <span class=\"keyword\">for</span> i, j, k <span class=\"keyword\">in</span> queries]</span><br></pre></td></tr></table></figure>\n<h3 id=\"421-Maximum-XOR-of-Two-Numbers-in-an-Array\"><a href=\"#421-Maximum-XOR-of-Two-Numbers-in-an-Array\" class=\"headerlink\" title=\"421. Maximum XOR of Two Numbers in an Array\"></a><a href=\"https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/\" target=\"_blank\" rel=\"noopener\">421. Maximum XOR of Two Numbers in an Array</a></h3><h4 id=\"数组中两个数最大的异或值时多少。线性时间复杂度实现。\"><a href=\"#数组中两个数最大的异或值时多少。线性时间复杂度实现。\" class=\"headerlink\" title=\"数组中两个数最大的异或值时多少。线性时间复杂度实现。\"></a>数组中两个数最大的异或值时多少。线性时间复杂度实现。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [3, 10, 5, 25, 2, 8]</span><br><span class=\"line\"></span><br><span class=\"line\">Output: 28</span><br><span class=\"line\"></span><br><span class=\"line\">Explanation: The maximum result is 5 ^ 25 &#x3D; 28.</span><br></pre></td></tr></table></figure>\n<p>方法一：Stefan的方法研究了半天。改成循环其实更容易理解。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findMaximumXOR</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">32</span>)[::<span class=\"number\">-1</span>]:</span><br><span class=\"line\">        ans &lt;&lt;= <span class=\"number\">1</span></span><br><span class=\"line\">        prefixes = &#123;num&gt;&gt;i <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums&#125;</span><br><span class=\"line\">        ans += any(ans^<span class=\"number\">1</span>^p <span class=\"keyword\">in</span> prefixes <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> prefixes)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>如何实现的呢？首先我们1位1位来更新ans，从最高位开始，尽可能让它为1，那么ans就会越大。</p>\n<p>改成循环容易观察。每次我们想尽量获得nxt，然后找是否有另一个q，满足<code>q ^ p = nxt</code>。所以看到<code>ans^1</code>就是<code>nxt</code>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findMaximumXOR</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">32</span>)[::<span class=\"number\">-1</span>]:</span><br><span class=\"line\">        ans &lt;&lt;= <span class=\"number\">1</span></span><br><span class=\"line\">        prefixes = &#123;num&gt;&gt;i <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums&#125;</span><br><span class=\"line\">        nxt = ans + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> prefixes:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> p ^ nxt <span class=\"keyword\">in</span> prefixes:</span><br><span class=\"line\">                ans = nxt</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"面试题-05-04-下一个数\"><a href=\"#面试题-05-04-下一个数\" class=\"headerlink\" title=\"面试题 05.04. 下一个数\"></a><a href=\"https://leetcode-cn.com/problems/closed-number-lcci/\" target=\"_blank\" rel=\"noopener\">面试题 05.04. 下一个数</a></h3><h4 id=\"找出与其二进制表达式中1的个数相同且大小最接近的那两个数（一个略大，一个略小）\"><a href=\"#找出与其二进制表达式中1的个数相同且大小最接近的那两个数（一个略大，一个略小）\" class=\"headerlink\" title=\"找出与其二进制表达式中1的个数相同且大小最接近的那两个数（一个略大，一个略小）\"></a>找出与其二进制表达式中1的个数相同且大小最接近的那两个数（一个略大，一个略小）</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：num &#x3D; 2（或者0b10）</span><br><span class=\"line\">输出：[4, 1] 或者（[0b100, 0b1]）</span><br></pre></td></tr></table></figure>\n<p>方法一：先用字符串来解。较大的数通过翻转最低位的01，然后重排后面的数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findClosedNumbers</span><span class=\"params\">(self, num: int)</span> -&gt; List[int]:</span></span><br><span class=\"line\">    nb = format(num, <span class=\"string\">'b'</span>)</span><br><span class=\"line\">    i, j, n = nb.rfind(<span class=\"string\">'01'</span>), nb.rfind(<span class=\"string\">'10'</span>), len(nb)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> i &gt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">        tail = nb[:i] + <span class=\"string\">'10'</span> + <span class=\"string\">''</span>.join(sorted(nb[i+<span class=\"number\">2</span>:]))</span><br><span class=\"line\">        big = int(tail, <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        big = int(<span class=\"string\">'10'</span> + nb[<span class=\"number\">1</span>:], <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> j &gt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">        tail = nb[:j] + <span class=\"string\">'01'</span> + <span class=\"string\">''</span>.join(sorted(nb[j+<span class=\"number\">2</span>:], reverse=<span class=\"literal\">True</span>))</span><br><span class=\"line\">        small = int(tail, <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        small = <span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> big, small</span><br></pre></td></tr></table></figure>\n<p>方法二：位运算，这个方法没怎么看懂。评论区大佬的答案。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findClosedNumbers</span><span class=\"params\">(self, num: int)</span> -&gt; List[int]:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> num == <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [<span class=\"number\">2</span>, <span class=\"number\">-1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">next_combo</span><span class=\"params\">(num)</span>:</span></span><br><span class=\"line\">        t = num &amp; -num</span><br><span class=\"line\">        y = num + t</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ((num &amp; ~y)//t &gt;&gt; <span class=\"number\">1</span>)|y</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [next_combo(num), ~next_combo(~num)]</span><br></pre></td></tr></table></figure>\n<h3 id=\"1029-Binary-Prefix-Divisible-By-5\"><a href=\"#1029-Binary-Prefix-Divisible-By-5\" class=\"headerlink\" title=\"1029. Binary Prefix Divisible By 5\"></a>1029. Binary Prefix Divisible By 5</h3><h4 id=\"二进制前缀能否被5整除。原题\"><a href=\"#二进制前缀能否被5整除。原题\" class=\"headerlink\" title=\"二进制前缀能否被5整除。原题\"></a>二进制前缀能否被5整除。<a href=\"https://leetcode.com/problems/binary-prefix-divisible-by-5/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [0,1,1,1,1,1]</span><br><span class=\"line\">Output: [true,false,false,false,true,false]</span><br></pre></td></tr></table></figure>\n<p>方法一：首次AC的方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">prefixesDivBy5</span><span class=\"params\">(self, A: List[int])</span> -&gt; List[bool]:</span></span><br><span class=\"line\">    num, ans = <span class=\"number\">0</span>, []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> A:</span><br><span class=\"line\">        num &lt;&lt;= <span class=\"number\">1</span></span><br><span class=\"line\">        num |= d </span><br><span class=\"line\">        ans.append(<span class=\"keyword\">not</span> bool(num%<span class=\"number\">5</span>))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：取余操作具有累加性，简单的优化提升了3倍的速度。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">prefixesDivBy5</span><span class=\"params\">(self, A: List[int])</span> -&gt; List[bool]:</span></span><br><span class=\"line\">    num, ans = <span class=\"number\">0</span>, []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> A:</span><br><span class=\"line\">        num &lt;&lt;= <span class=\"number\">1</span></span><br><span class=\"line\">        num |= d </span><br><span class=\"line\">        num %= <span class=\"number\">5</span></span><br><span class=\"line\">        ans.append(<span class=\"keyword\">not</span> bool(num))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"645-Set-Mismatch\"><a href=\"#645-Set-Mismatch\" class=\"headerlink\" title=\"645. Set Mismatch\"></a>645. Set Mismatch</h3><h4 id=\"1-n数组中包含一个重复的元素和一个缺失的元素。找出这两个元素。原题\"><a href=\"#1-n数组中包含一个重复的元素和一个缺失的元素。找出这两个元素。原题\" class=\"headerlink\" title=\"1~n数组中包含一个重复的元素和一个缺失的元素。找出这两个元素。原题\"></a>1~n数组中包含一个重复的元素和一个缺失的元素。找出这两个元素。<a href=\"https://leetcode.com/problems/set-mismatch/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [1,2,2,4]</span><br><span class=\"line\">Output: [2,3]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法一：开始还想着用<code>Counter</code>实现，有些愚蠢。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findErrorNums</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">    diff_sum = sum(set(nums))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(nums)-diff_sum, sum(range(<span class=\"number\">1</span>, len(nums)+<span class=\"number\">1</span>))-diff_sum</span><br></pre></td></tr></table></figure>\n<p>方法二：在原数组元素*-1记录。空间复杂度为常数，但是改变了原数组，时间复杂度稍微高一点，因为迭代两次。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findErrorNums</span><span class=\"params\">(self, nums: <span class=\"string\">'List[int]'</span>)</span> -&gt; 'List[int]':</span></span><br><span class=\"line\">    dup, miss = <span class=\"number\">-1</span>, <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[abs(num)<span class=\"number\">-1</span>] &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            dup = abs(num)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            nums[abs(num)<span class=\"number\">-1</span>] *= <span class=\"number\">-1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(nums)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[i] &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            miss = i + <span class=\"number\">1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> dup, miss</span><br></pre></td></tr></table></figure>\n<p>方法三：XOR。</p>\n<h3 id=\"1734-Decode-XORed-Permutation\"><a href=\"#1734-Decode-XORed-Permutation\" class=\"headerlink\" title=\"1734. Decode XORed Permutation\"></a><a href=\"https://leetcode.com/problems/decode-xored-permutation/\" target=\"_blank\" rel=\"noopener\">1734. Decode XORed Permutation</a></h3><h4 id=\"说有个奇数长度的数组是，从1到n的全排列的一种。将每两个相邻的数做异或运算。得到一个新的数组encoded。给你这个encoded，让你还原原数组。\"><a href=\"#说有个奇数长度的数组是，从1到n的全排列的一种。将每两个相邻的数做异或运算。得到一个新的数组encoded。给你这个encoded，让你还原原数组。\" class=\"headerlink\" title=\"说有个奇数长度的数组是，从1到n的全排列的一种。将每两个相邻的数做异或运算。得到一个新的数组encoded。给你这个encoded，让你还原原数组。\"></a>说有个奇数长度的数组是，从1到n的全排列的一种。将每两个相邻的数做异或运算。得到一个新的数组encoded。给你这个encoded，让你还原原数组。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: encoded &#x3D; [6,5,4,6]</span><br><span class=\"line\">Output: [2,4,1,5,3]</span><br></pre></td></tr></table></figure>\n<p>方法一：这题并不算难，只是竞赛没时间做了。首先从题中获取条件，可以得到1~n的异或和，然后考虑奇数条件如何使用。这点没有想到，我们可以跳跃切分来用，比如4^1=5，5^3=6，这样我们可以通过总的异或和求出第一个数是多少。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decode</span><span class=\"params\">(self, encoded: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    xor_sum = reduce(xor, range(<span class=\"number\">1</span>, len(encoded)+<span class=\"number\">2</span>))</span><br><span class=\"line\">    first = reduce(xor, encoded[<span class=\"number\">1</span>::<span class=\"number\">2</span>]) ^ xor_sum</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list(accumulate([first] + encoded, xor))</span><br></pre></td></tr></table></figure>\n<h3 id=\"1178-Number-of-Valid-Words-for-Each-Puzzle\"><a href=\"#1178-Number-of-Valid-Words-for-Each-Puzzle\" class=\"headerlink\" title=\"1178. Number of Valid Words for Each Puzzle\"></a>1178. Number of Valid Words for Each Puzzle</h3><h4 id=\"找到每个谜面符合条件的单词数，谜面的第一个字符在单词中，单词的所有字符均在谜面中出现过。\"><a href=\"#找到每个谜面符合条件的单词数，谜面的第一个字符在单词中，单词的所有字符均在谜面中出现过。\" class=\"headerlink\" title=\"找到每个谜面符合条件的单词数，谜面的第一个字符在单词中，单词的所有字符均在谜面中出现过。\"></a>找到每个谜面符合条件的单词数，谜面的第一个字符在单词中，单词的所有字符均在谜面中出现过。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">words &#x3D; [&quot;aaaa&quot;,&quot;asas&quot;,&quot;able&quot;,&quot;ability&quot;,&quot;actt&quot;,&quot;actor&quot;,&quot;access&quot;], </span><br><span class=\"line\">puzzles &#x3D; [&quot;aboveyz&quot;,&quot;abrodyz&quot;,&quot;abslute&quot;,&quot;absoryz&quot;,&quot;actresz&quot;,&quot;gaswxyz&quot;]</span><br><span class=\"line\">Output: [1,1,3,2,4,0]</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">1 valid word for &quot;aboveyz&quot; : &quot;aaaa&quot; </span><br><span class=\"line\">1 valid word for &quot;abrodyz&quot; : &quot;aaaa&quot;</span><br><span class=\"line\">3 valid words for &quot;abslute&quot; : &quot;aaaa&quot;, &quot;asas&quot;, &quot;able&quot;</span><br><span class=\"line\">2 valid words for &quot;absoryz&quot; : &quot;aaaa&quot;, &quot;asas&quot;</span><br><span class=\"line\">4 valid words for &quot;actresz&quot; : &quot;aaaa&quot;, &quot;asas&quot;, &quot;actt&quot;, &quot;access&quot;</span><br><span class=\"line\">There&#39;re no valid words for &quot;gaswxyz&quot; cause none of the words in the list contains letter &#39;g&#39;.</span><br></pre></td></tr></table></figure>\n<p>方法一：状态压缩+哈希。对于每个单词根据是否出现可以压缩成一个26的数字。对于每个puzzle来说，只要<code>puzzle[0] 和puzzle[1:]字符串的一个子集</code>压缩后时相等的，那么就有一个word是符合条件的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findNumOfValidWords</span><span class=\"params\">(self, words: List[str], puzzles: List[str])</span> -&gt; List[int]:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">compress_word</span><span class=\"params\">(w)</span>:</span></span><br><span class=\"line\">        bit = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> w:</span><br><span class=\"line\">            bit |= <span class=\"number\">1</span> &lt;&lt; (ord(c)-ord(<span class=\"string\">'a'</span>))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bit</span><br><span class=\"line\"></span><br><span class=\"line\">    freq = Counter()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> words:</span><br><span class=\"line\">        freq[compress_word(word)] += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    res = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> puzzle <span class=\"keyword\">in</span> puzzles:</span><br><span class=\"line\">        total = <span class=\"number\">0</span></span><br><span class=\"line\">        bit = <span class=\"number\">1</span> &lt;&lt; (ord(puzzle[<span class=\"number\">0</span>])-ord(<span class=\"string\">'a'</span>))</span><br><span class=\"line\">        <span class=\"keyword\">for</span> sub <span class=\"keyword\">in</span> self.subsets(puzzle[<span class=\"number\">1</span>:]):</span><br><span class=\"line\">            bit2 = bit</span><br><span class=\"line\">            bit2 |= compress_word(<span class=\"string\">''</span>.join(sub))</span><br><span class=\"line\">            total += freq[bit2]</span><br><span class=\"line\">        res.append(total)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">subsets</span><span class=\"params\">(self, word)</span>:</span></span><br><span class=\"line\">    ans = [[]]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> word:</span><br><span class=\"line\">        ans += [pre+[c] <span class=\"keyword\">for</span> pre <span class=\"keyword\">in</span> ans]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"2354-Number-of-Excellent-Pairs\"><a href=\"#2354-Number-of-Excellent-Pairs\" class=\"headerlink\" title=\"2354. Number of Excellent Pairs\"></a><a href=\"https://leetcode.com/problems/number-of-excellent-pairs/\" target=\"_blank\" rel=\"noopener\">2354. Number of Excellent Pairs</a></h3><h4 id=\"找到优质数对。如果弯转过来了很简单。比赛是忽略了是与运算和或运算的和。所以其实就是统计两个数1的个数。\"><a href=\"#找到优质数对。如果弯转过来了很简单。比赛是忽略了是与运算和或运算的和。所以其实就是统计两个数1的个数。\" class=\"headerlink\" title=\"找到优质数对。如果弯转过来了很简单。比赛是忽略了是与运算和或运算的和。所以其实就是统计两个数1的个数。\"></a>找到优质数对。如果弯转过来了很简单。比赛是忽略了是与运算和或运算的和。所以其实就是统计两个数1的个数。</h4><p>方法一：Lee的方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countExcellentPairs</span><span class=\"params\">(self, A: List[int], k: int)</span> -&gt; int:</span></span><br><span class=\"line\">    c = Counter(map(int.bit_count, set(A)))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(c[k1] * c[k2] <span class=\"keyword\">for</span> k1 <span class=\"keyword\">in</span> c <span class=\"keyword\">for</span> k2 <span class=\"keyword\">in</span> c <span class=\"keyword\">if</span> k1 + k2 &gt;= k)</span><br></pre></td></tr></table></figure>\n<h3 id=\"779-K-th-Symbol-in-Grammar\"><a href=\"#779-K-th-Symbol-in-Grammar\" class=\"headerlink\" title=\"779. K-th Symbol in Grammar\"></a><a href=\"https://leetcode.com/problems/k-th-symbol-in-grammar/\" target=\"_blank\" rel=\"noopener\">779. K-th Symbol in Grammar</a></h3><p>我们构建了一个包含 n 行( 索引从 1  开始 )的表。首先在第一行我们写上一个 0。接下来的每一行，将前一行中的0替换为01，1替换为10。</p>\n<p>例如，对于 n = 3 ，第 1 行是 0 ，第 2 行是 01 ，第3行是 0110 。<br>给定行数 n 和序数 k，返回第 n 行中第 k 个字符。（ k 从索引 1 开始）</p>\n<p>方法一：自己想的递归。规律为每一行新增了上一行的反码。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">kthGrammar</span><span class=\"params\">(self, n: int, k: int)</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> k &gt; <span class=\"number\">2</span>**(n<span class=\"number\">-2</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.kthGrammar(n<span class=\"number\">-1</span>, k<span class=\"number\">-2</span>**(n<span class=\"number\">-2</span>)) ^ <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.kthGrammar(n<span class=\"number\">-1</span>, k)</span><br></pre></td></tr></table></figure>\n<p>方法二：位运算，由于k从1开始，我们将它-1.一行中的第 i个字符，会在第 2i和第 2<em>i</em>+1 个位置产生两个字符。如果第 i 个字符是 00，那么在位置2i 和 2i+1 产生的字符分别是 0 和1；如果第 i 个字符是 1，产生的字符是 1和 0。</p>\n<p>可以发现，第 2i （偶数位）个字符总是和第 i个字符相同，而第 2i+1 （奇数位）个字符是第 i 个字符的反转。也就是说，奇数位上的字符总是发生了一次反转而来的。反转偶数次，字符不变；反转奇数次，相当于反转了一次。</p>\n<p>因此，我们只需要看 k 这个数字是否是奇数，若是，累计一次反转。然后将 k 除以 2，继续判断，并累计反转次数，直至 k 为 0。</p>\n<p>最后判断反转的次数是否为奇数，是则答案为 1，否则为 0。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">kthGrammar</span><span class=\"params\">(self, n: int, k: int)</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (k - <span class=\"number\">1</span>).bit_count() &amp; <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n","categories":["算法"],"tags":["LeetCode","Python","Algorithm","Bit Manipulation"]},{"title":"LeetCode算法题整理（哈希篇）hashtable","url":"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%93%88%E5%B8%8C%E7%AF%87%EF%BC%89hashtable/","content":"<h3 id=\"1-Two-Sum\"><a href=\"#1-Two-Sum\" class=\"headerlink\" title=\"1. Two Sum\"></a>1. Two Sum</h3><h4 id=\"给定一个数组，找出数组两个元素相加为目标值，假定只有唯一解。原题\"><a href=\"#给定一个数组，找出数组两个元素相加为目标值，假定只有唯一解。原题\" class=\"headerlink\" title=\"给定一个数组，找出数组两个元素相加为目标值，假定只有唯一解。原题\"></a>给定一个数组，找出数组两个元素相加为目标值，假定只有唯一解。<a href=\"https://leetcode.com/problems/two-sum/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Given nums &#x3D; [2, 7, 11, 15], target &#x3D; 9,</span><br><span class=\"line\">Because nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9,</span><br><span class=\"line\">return [0, 1].</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">two_sum</span><span class=\"params\">(nums, target)</span>:</span></span><br><span class=\"line\">    buff_dict = &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, num <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> num <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> buff_dict:</span><br><span class=\"line\">            buff_dict[target-num] = i</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [buff_dict[num], i]</span><br></pre></td></tr></table></figure>\n<h3 id=\"15-3Sum\"><a href=\"#15-3Sum\" class=\"headerlink\" title=\"15. 3Sum\"></a><a href=\"https://leetcode.com/problems/3sum/\" target=\"_blank\" rel=\"noopener\">15. 3Sum</a></h3><h4 id=\"找出3个数相加为0的所有组合。\"><a href=\"#找出3个数相加为0的所有组合。\" class=\"headerlink\" title=\"找出3个数相加为0的所有组合。\"></a>找出3个数相加为0的所有组合。</h4><p>方法一：固定一个数，再通过双指针找另外两个。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">threeSum</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">    nums.sort()</span><br><span class=\"line\">    ans, n = [], len(nums)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n<span class=\"number\">-2</span>):</span><br><span class=\"line\">        a = nums[i]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> a &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i <span class=\"keyword\">and</span> a == nums[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        lo, hi = i+<span class=\"number\">1</span>, n<span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> lo &lt; hi:</span><br><span class=\"line\">            total = nums[lo] + nums[hi]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> total &gt; -a:</span><br><span class=\"line\">                hi -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> total &lt; -a:</span><br><span class=\"line\">                lo += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">while</span> lo&lt;hi <span class=\"keyword\">and</span> nums[lo]==nums[lo+<span class=\"number\">1</span>]:</span><br><span class=\"line\">                    lo += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> lo&lt;hi <span class=\"keyword\">and</span> nums[hi]==nums[hi<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                    hi -= <span class=\"number\">1</span></span><br><span class=\"line\">                ans.append((a, nums[lo], nums[hi]))</span><br><span class=\"line\">                lo += <span class=\"number\">1</span></span><br><span class=\"line\">                hi -= <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"18-4Sum\"><a href=\"#18-4Sum\" class=\"headerlink\" title=\"18. 4Sum\"></a><a href=\"https://leetcode.com/problems/4sum/\" target=\"_blank\" rel=\"noopener\">18. 4Sum</a></h3><h4 id=\"找出4个数和为target的组合。\"><a href=\"#找出4个数和为target的组合。\" class=\"headerlink\" title=\"找出4个数和为target的组合。\"></a>找出4个数和为target的组合。</h4><p>方法一：还是根据3sum的方法进行修改。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fourSum</span><span class=\"params\">(self, nums: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">three_sum</span><span class=\"params\">(ary, target)</span>:</span></span><br><span class=\"line\">        res, N = [], len(ary)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(N<span class=\"number\">-2</span>):</span><br><span class=\"line\">            a = ary[i]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i!=<span class=\"number\">0</span> <span class=\"keyword\">and</span> a==ary[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            lo, hi = i+<span class=\"number\">1</span>, N<span class=\"number\">-1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> lo &lt; hi:</span><br><span class=\"line\">                total = ary[lo] + ary[hi]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> total &lt; target-a:</span><br><span class=\"line\">                    lo += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">elif</span> total &gt; target-a:</span><br><span class=\"line\">                    hi -= <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> lo&lt;hi <span class=\"keyword\">and</span> ary[lo]==ary[lo+<span class=\"number\">1</span>]:</span><br><span class=\"line\">                        lo += <span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">while</span> lo&lt;hi <span class=\"keyword\">and</span> ary[hi]==ary[hi<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                        hi -= <span class=\"number\">1</span></span><br><span class=\"line\">                    res.append([a, ary[lo], ary[hi]])</span><br><span class=\"line\">                    lo += <span class=\"number\">1</span></span><br><span class=\"line\">                    hi -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br><span class=\"line\">    </span><br><span class=\"line\">    nums.sort()</span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, d <span class=\"keyword\">in</span> enumerate(nums[:<span class=\"number\">-3</span>]):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == <span class=\"number\">0</span> <span class=\"keyword\">or</span> nums[i] != nums[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">            three_res = three_sum(nums[i+<span class=\"number\">1</span>:], target-d)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> res <span class=\"keyword\">in</span> three_res:</span><br><span class=\"line\">                ans.append([d] + res)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"454-4Sum-II\"><a href=\"#454-4Sum-II\" class=\"headerlink\" title=\"454. 4Sum II\"></a><a href=\"https://leetcode.com/problems/4sum-ii/\" target=\"_blank\" rel=\"noopener\">454. 4Sum II</a></h3><h4 id=\"在四个数组中每个各选出一个，使得它们所有的和为0。\"><a href=\"#在四个数组中每个各选出一个，使得它们所有的和为0。\" class=\"headerlink\" title=\"在四个数组中每个各选出一个，使得它们所有的和为0。\"></a>在四个数组中每个各选出一个，使得它们所有的和为0。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">A &#x3D; [ 1, 2]</span><br><span class=\"line\">B &#x3D; [-2,-1]</span><br><span class=\"line\">C &#x3D; [-1, 2]</span><br><span class=\"line\">D &#x3D; [ 0, 2]</span><br><span class=\"line\"></span><br><span class=\"line\">Output:</span><br><span class=\"line\">2</span><br><span class=\"line\"></span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">The two tuples are:</span><br><span class=\"line\">1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] &#x3D; 1 + (-2) + (-1) + 2 &#x3D; 0</span><br><span class=\"line\">2. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] &#x3D; 2 + (-1) + (-1) + 0 &#x3D; 0</span><br></pre></td></tr></table></figure>\n<p>方法一：和18题不同，这里不需要想3Sum之后怎么怎么样，因为3Sum的方法需要排序，而这里没法处理两个数组排序，双指针也比较麻烦了。换一个思路，拆成2个2Sum的子问题。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fourSumCount</span><span class=\"params\">(self, A: List[int], B: List[int], C: List[int], D: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    ab = defaultdict(int)</span><br><span class=\"line\">    res = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> A:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> B:</span><br><span class=\"line\">            ab[-a-b] += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> C:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> D:</span><br><span class=\"line\">            res += ab[c+d]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：和Stenfan学习。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fourSumCount</span><span class=\"params\">(self, A: List[int], B: List[int], C: List[int], D: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    ab = Counter(-a-b <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> A <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> B)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(ab[c+d] <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> C <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> D)</span><br></pre></td></tr></table></figure>\n<h3 id=\"720-Longest-Word-in-Dictionary\"><a href=\"#720-Longest-Word-in-Dictionary\" class=\"headerlink\" title=\"720. Longest Word in Dictionary\"></a>720. Longest Word in Dictionary</h3><h4 id=\"字典中的最长单词，找出一个列表中的一个单词，该单词的子单词也必须在字典中。相同长度的单词，返回字典序最前的一个。原题\"><a href=\"#字典中的最长单词，找出一个列表中的一个单词，该单词的子单词也必须在字典中。相同长度的单词，返回字典序最前的一个。原题\" class=\"headerlink\" title=\"字典中的最长单词，找出一个列表中的一个单词，该单词的子单词也必须在字典中。相同长度的单词，返回字典序最前的一个。原题\"></a>字典中的最长单词，找出一个列表中的一个单词，该单词的子单词也必须在字典中。相同长度的单词，返回字典序最前的一个。<a href=\"https://leetcode.com/problems/longest-word-in-dictionary/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: </span><br><span class=\"line\">words &#x3D; [&quot;w&quot;,&quot;wo&quot;,&quot;wor&quot;,&quot;worl&quot;, &quot;world&quot;]</span><br><span class=\"line\">Output: &quot;world&quot;</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">The word &quot;world&quot; can be built one character at a time by &quot;w&quot;, &quot;wo&quot;, &quot;wor&quot;, and &quot;worl&quot;.</span><br></pre></td></tr></table></figure>\n<p>方法一：Brute Force.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestWord</span><span class=\"params\">(self, words)</span>:</span></span><br><span class=\"line\">    res = <span class=\"string\">''</span></span><br><span class=\"line\">    wordset = set(words)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> words:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(word)&gt;len(res) <span class=\"keyword\">or</span> len(word)==len(res) <span class=\"keyword\">and</span> word&lt;res:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> all(word[:k] <span class=\"keyword\">in</span> wordset <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(word))):</span><br><span class=\"line\">                res = word         </span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<p>方法二：trie. 暂且留坑。</p>\n<h3 id=\"748-Shortest-Completing-Word\"><a href=\"#748-Shortest-Completing-Word\" class=\"headerlink\" title=\"748. Shortest Completing Word\"></a>748. Shortest Completing Word</h3><h4 id=\"最短的完整匹配单词。包含licensePlate中的所有字母，大小写不敏感。假设答案一定存在。原题\"><a href=\"#最短的完整匹配单词。包含licensePlate中的所有字母，大小写不敏感。假设答案一定存在。原题\" class=\"headerlink\" title=\"最短的完整匹配单词。包含licensePlate中的所有字母，大小写不敏感。假设答案一定存在。原题\"></a>最短的完整匹配单词。包含<code>licensePlate</code>中的所有字母，大小写不敏感。假设答案一定存在。<a href=\"https://leetcode.com/problems/shortest-completing-word/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: licensePlate &#x3D; &quot;1s3 PSt&quot;, words &#x3D; [&quot;step&quot;, &quot;steps&quot;, &quot;stripe&quot;, &quot;stepple&quot;]</span><br><span class=\"line\">Output: &quot;steps&quot;</span><br><span class=\"line\">Explanation: The smallest length word that contains the letters &quot;S&quot;, &quot;P&quot;, &quot;S&quot;, and &quot;T&quot;.</span><br><span class=\"line\">Note that the answer is not &quot;step&quot;, because the letter &quot;s&quot; must occur in the word twice.</span><br><span class=\"line\">Also note that we ignored case for the purposes of comparing whether a letter exists in the word.</span><br></pre></td></tr></table></figure>\n<p>方法一：先排序。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">shortestCompletingWord</span><span class=\"params\">(self, licensePlate: <span class=\"string\">'str'</span>, words: <span class=\"string\">'List[str]'</span>)</span> -&gt; 'str':</span></span><br><span class=\"line\">    lp = <span class=\"string\">''</span>.join(x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> licensePlate.lower() <span class=\"keyword\">if</span> x.isalpha())</span><br><span class=\"line\">    c1 = collections.Counter(lp)</span><br><span class=\"line\">    words.sort(key=len)</span><br><span class=\"line\">    words = map(str.lower, words)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> words:</span><br><span class=\"line\">        diff = c1 - collections.Counter(word)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> diff:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> word</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：more elegant. </font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">shortestCompletingWord</span><span class=\"params\">(self, licensePlate: <span class=\"string\">'str'</span>, words: <span class=\"string\">'List[str]'</span>)</span> -&gt; 'str':</span></span><br><span class=\"line\">    lp = <span class=\"string\">''</span>.join(x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> licensePlate.lower() <span class=\"keyword\">if</span> x.isalpha())</span><br><span class=\"line\">    c1 = collections.Counter(lp)</span><br><span class=\"line\">    words = map(str.lower, words)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min((word <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> words </span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> c1-collections.Counter(word)), key=len)</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：most efficient. 认为方法二是在计算<code>-</code>的操作时，涉及一些无关的key导致效率过低。 </font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">shortestCompletingWord</span><span class=\"params\">(self, licensePlate: <span class=\"string\">'str'</span>, words: <span class=\"string\">'List[str]'</span>)</span> -&gt; 'str':</span></span><br><span class=\"line\">    ans = <span class=\"string\">''</span></span><br><span class=\"line\">    lp = <span class=\"string\">''</span>.join(x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> licensePlate.lower() <span class=\"keyword\">if</span> x.isalpha())</span><br><span class=\"line\">    <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> words:</span><br><span class=\"line\">        temp = list(w.lower())</span><br><span class=\"line\">        <span class=\"keyword\">for</span> l <span class=\"keyword\">in</span> lp:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> l <span class=\"keyword\">in</span> temp:</span><br><span class=\"line\">                temp.remove(l)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(w)&lt;len(ans) <span class=\"keyword\">or</span> ans==<span class=\"string\">''</span>:</span><br><span class=\"line\">                ans = w</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"811-Subdomain-Visit-Count\"><a href=\"#811-Subdomain-Visit-Count\" class=\"headerlink\" title=\"811. Subdomain Visit Count\"></a>811. Subdomain Visit Count</h3><h4 id=\"子域名访问量。给定一个三级或二级域名列表，统计所有三级、二级和顶级域名的访问量。原题\"><a href=\"#子域名访问量。给定一个三级或二级域名列表，统计所有三级、二级和顶级域名的访问量。原题\" class=\"headerlink\" title=\"子域名访问量。给定一个三级或二级域名列表，统计所有三级、二级和顶级域名的访问量。原题\"></a>子域名访问量。给定一个三级或二级域名列表，统计所有三级、二级和顶级域名的访问量。<a href=\"https://leetcode.com/problems/subdomain-visit-count/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Example 1:</span><br><span class=\"line\">Input: </span><br><span class=\"line\">[&quot;9001 discuss.leetcode.com&quot;]</span><br><span class=\"line\">Output: </span><br><span class=\"line\">[&quot;9001 discuss.leetcode.com&quot;, &quot;9001 leetcode.com&quot;, &quot;9001 com&quot;]</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">We only have one website domain: &quot;discuss.leetcode.com&quot;. As discussed above, the subdomain &quot;leetcode.com&quot; and &quot;com&quot; will also be visited. So they will all be visited 9001 times.</span><br></pre></td></tr></table></figure>\n<p>方法一：Solution中用了Counter，个人认为defaultdict.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">subdomainVisits</span><span class=\"params\">(self, cpdomains: <span class=\"string\">'List[str]'</span>)</span> -&gt; 'List[str]':</span></span><br><span class=\"line\">    ans = collections.defaultdict(int)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> domain <span class=\"keyword\">in</span> cpdomains:</span><br><span class=\"line\">        count, d = domain.split()</span><br><span class=\"line\">        count = int(count)</span><br><span class=\"line\">        frags = d.split(<span class=\"string\">'.'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(frags)):</span><br><span class=\"line\">            ans[<span class=\"string\">'.'</span>.join(frags[i:])] += count</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"string\">'&#123;&#125; &#123;&#125;'</span>.format(c, d) <span class=\"keyword\">for</span> d, c <span class=\"keyword\">in</span> ans.items()]</span><br></pre></td></tr></table></figure>\n<h3 id=\"884-Uncommon-Words-from-Two-Sentences\"><a href=\"#884-Uncommon-Words-from-Two-Sentences\" class=\"headerlink\" title=\"884. Uncommon Words from Two Sentences\"></a>884. Uncommon Words from Two Sentences</h3><h4 id=\"求两句话中的单词，在本句中出现一次，并不在另一句中的单词。也就是在两句中出现一次。原题\"><a href=\"#求两句话中的单词，在本句中出现一次，并不在另一句中的单词。也就是在两句中出现一次。原题\" class=\"headerlink\" title=\"求两句话中的单词，在本句中出现一次，并不在另一句中的单词。也就是在两句中出现一次。原题\"></a>求两句话中的单词，在本句中出现一次，并不在另一句中的单词。也就是在两句中出现一次。<a href=\"https://leetcode.com/problems/uncommon-words-from-two-sentences/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: A &#x3D; &quot;this apple is sweet&quot;, B &#x3D; &quot;this apple is sour&quot;</span><br><span class=\"line\">Output: [&quot;sweet&quot;,&quot;sour&quot;]</span><br></pre></td></tr></table></figure>\n<p>方法一：Counter</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">uncommonFromSentences</span><span class=\"params\">(self, A: <span class=\"string\">'str'</span>, B: <span class=\"string\">'str'</span>)</span> -&gt; 'List[str]':</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Counter</span><br><span class=\"line\">    count = Counter((A + <span class=\"string\">' '</span> + B).split())</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [word <span class=\"keyword\">for</span> word, c <span class=\"keyword\">in</span> count.items() <span class=\"keyword\">if</span> c == <span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"1010-Pairs-of-Songs-With-Total-Durations-Divisible-by-60\"><a href=\"#1010-Pairs-of-Songs-With-Total-Durations-Divisible-by-60\" class=\"headerlink\" title=\"1010. Pairs of Songs With Total Durations Divisible by 60\"></a>1010. Pairs of Songs With Total Durations Divisible by 60</h3><h4 id=\"和能被60整除的为一对，求有多少对。原题\"><a href=\"#和能被60整除的为一对，求有多少对。原题\" class=\"headerlink\" title=\"和能被60整除的为一对，求有多少对。原题\"></a>和能被60整除的为一对，求有多少对。<a href=\"https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [30,20,150,100,40]</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: Three pairs have a total duration divisible by 60:</span><br><span class=\"line\">(time[0] &#x3D; 30, time[2] &#x3D; 150): total duration 180</span><br><span class=\"line\">(time[1] &#x3D; 20, time[3] &#x3D; 100): total duration 120</span><br><span class=\"line\">(time[1] &#x3D; 20, time[4] &#x3D; 40): total duration 60</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numPairsDivisibleBy60</span><span class=\"params\">(self, time: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    c = collections.defaultdict(int)</span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> time:</span><br><span class=\"line\">        <span class=\"comment\"># ans += c[(60-t%60)%60]</span></span><br><span class=\"line\">        ans += c[-t % <span class=\"number\">60</span>]</span><br><span class=\"line\">        c[t%<span class=\"number\">60</span>] += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"1138-Alphabet-Board-Path\"><a href=\"#1138-Alphabet-Board-Path\" class=\"headerlink\" title=\"1138. Alphabet Board Path\"></a>1138. Alphabet Board Path</h3><h4 id=\"小写字母排列的键盘，要打出目标字母需要移动的操作。原题\"><a href=\"#小写字母排列的键盘，要打出目标字母需要移动的操作。原题\" class=\"headerlink\" title=\"小写字母排列的键盘，要打出目标字母需要移动的操作。原题\"></a>小写字母排列的键盘，要打出目标字母需要移动的操作。<a href=\"https://leetcode.com/problems/alphabet-board-path/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: target &#x3D; &quot;leet&quot;</span><br><span class=\"line\">Output: &quot;DDR!UURRR!!DDD!&quot;</span><br></pre></td></tr></table></figure>\n<p>方法一：此题需要注意z，然后按照一个优先的顺序移动即可。另外使用字典可以快速定位坐标，而不用每个字符做比较</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">alphabetBoardPath</span><span class=\"params\">(self, target: str)</span> -&gt; str:</span></span><br><span class=\"line\">    <span class=\"keyword\">import</span> string</span><br><span class=\"line\">    m = &#123;c: (i//<span class=\"number\">5</span>, i%<span class=\"number\">5</span>) <span class=\"keyword\">for</span> i, c <span class=\"keyword\">in</span> enumerate(string.ascii_lowercase)&#125;</span><br><span class=\"line\">    ans = <span class=\"string\">''</span></span><br><span class=\"line\">    x0 = y0 = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> target:</span><br><span class=\"line\">        x, y = m[c]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> y &lt; y0: ans += <span class=\"string\">'L'</span> * (y0-y)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> x &lt; x0: ans += <span class=\"string\">'U'</span> * (x0-x)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> y &gt; y0: ans += <span class=\"string\">'R'</span> * (y-y0)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> x &gt; x0: ans += <span class=\"string\">'D'</span> * (x-x0)</span><br><span class=\"line\">        x0, y0 = x, y</span><br><span class=\"line\">        ans += <span class=\"string\">'!'</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"1072-Flip-Columns-For-Maximum-Number-of-Equal-Rows\"><a href=\"#1072-Flip-Columns-For-Maximum-Number-of-Equal-Rows\" class=\"headerlink\" title=\"1072. Flip Columns For Maximum Number of Equal Rows\"></a>1072. Flip Columns For Maximum Number of Equal Rows</h3><h4 id=\"二维数组，翻转某几列可以最多使多少行内的元素都相同。原题\"><a href=\"#二维数组，翻转某几列可以最多使多少行内的元素都相同。原题\" class=\"headerlink\" title=\"二维数组，翻转某几列可以最多使多少行内的元素都相同。原题\"></a>二维数组，翻转某几列可以最多使多少行内的元素都相同。<a href=\"https://leetcode.com/problems/flip-columns-for-maximum-number-of-equal-rows/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [[0,1],[1,1]]</span><br><span class=\"line\">Output: 1</span><br><span class=\"line\">Explanation: After flipping no values, 1 row has all values equal.</span><br><span class=\"line\"></span><br><span class=\"line\">Input: [[0,0,0],[0,0,1],[1,1,0]]</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: After flipping values in the first two columns, the last two rows have equal values.</span><br></pre></td></tr></table></figure>\n<p>方法一：核心思想在于找到每行的模式，具有相同模式的行，最终可变成同样的数值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxEqualRowsAfterFlips</span><span class=\"params\">(self, matrix: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    c = collections.Counter()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> matrix:</span><br><span class=\"line\">        c[tuple([x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> row])] += <span class=\"number\">1</span></span><br><span class=\"line\">        c[tuple([<span class=\"number\">1</span>-x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> row])] += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(c.values())</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：使用异或。方法一中其实有多余的部分，模式与反模式都求了出来，其实没有必要。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxEqualRowsAfterFlips</span><span class=\"params\">(self, matrix: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(collections.Counter(tuple(r ^ row[<span class=\"number\">0</span>] <span class=\"keyword\">for</span> r <span class=\"keyword\">in</span> row) <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> matrix).values())</span><br></pre></td></tr></table></figure>\n<h3 id=\"1160-Find-Words-That-Can-Be-Formed-by-Characters\"><a href=\"#1160-Find-Words-That-Can-Be-Formed-by-Characters\" class=\"headerlink\" title=\"1160. Find Words That Can Be Formed by Characters\"></a>1160. Find Words That Can Be Formed by Characters</h3><h4 id=\"找出能被目标字符串组成的子串长度和。原题\"><a href=\"#找出能被目标字符串组成的子串长度和。原题\" class=\"headerlink\" title=\"找出能被目标字符串组成的子串长度和。原题\"></a>找出能被目标字符串组成的子串长度和。<a href=\"https://leetcode.com/problems/find-words-that-can-be-formed-by-characters/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countCharacters</span><span class=\"params\">(self, words: List[str], chars: str)</span> -&gt; int:</span></span><br><span class=\"line\">    ma = collections.Counter(chars)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(len(w) <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> words <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> collections.Counter(w)-ma)</span><br></pre></td></tr></table></figure>\n<h3 id=\"525-Contiguous-Array\"><a href=\"#525-Contiguous-Array\" class=\"headerlink\" title=\"525. Contiguous Array\"></a>525. Contiguous Array</h3><h4 id=\"找出二进制数组中拥有相等个数0和1的最长子串的长度。原题\"><a href=\"#找出二进制数组中拥有相等个数0和1的最长子串的长度。原题\" class=\"headerlink\" title=\"找出二进制数组中拥有相等个数0和1的最长子串的长度。原题\"></a>找出二进制数组中拥有相等个数0和1的最长子串的长度。<a href=\"https://leetcode.com/problems/contiguous-array/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [0,1]</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.</span><br></pre></td></tr></table></figure>\n<p>方法一：此题解法类似于买卖股票，维护一个<code>count</code>如果是0减一，如果是1加一，那么当count值相等的时候，说明这个子串中有相等1和0。使用一个字典来记录每次count的最小索引。需要注意的是索引从1开始。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findMaxLength</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    count = ans = <span class=\"number\">0</span></span><br><span class=\"line\">    table = &#123;<span class=\"number\">0</span>: <span class=\"number\">0</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, num <span class=\"keyword\">in</span> enumerate(nums, <span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> num == <span class=\"number\">0</span>:</span><br><span class=\"line\">            count -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            count += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> count <span class=\"keyword\">in</span> table:</span><br><span class=\"line\">            ans = max(ans, i-table[count])</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            table[count] = i</span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"560-Subarray-Sum-Equals-K\"><a href=\"#560-Subarray-Sum-Equals-K\" class=\"headerlink\" title=\"560. Subarray Sum Equals K\"></a>560. Subarray Sum Equals K</h3><h4 id=\"子数组和为k的个数。原题\"><a href=\"#子数组和为k的个数。原题\" class=\"headerlink\" title=\"子数组和为k的个数。原题\"></a>子数组和为k的个数。<a href=\"https://leetcode.com/problems/subarray-sum-equals-k/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input:nums &#x3D; [1,1,1], k &#x3D; 2</span><br><span class=\"line\">Output: 2</span><br></pre></td></tr></table></figure>\n<p>方法一：累加一开始想到了，补0也想到了，没想到用哈希，而是用循环去迭代，这样时间超时了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">subarraySum</span><span class=\"params\">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class=\"line\">    total = ans = <span class=\"number\">0</span></span><br><span class=\"line\">    d = collections.defaultdict(int)</span><br><span class=\"line\">    d[<span class=\"number\">0</span>] = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        total += x</span><br><span class=\"line\">        ans += d[total-k]</span><br><span class=\"line\">        d[total] += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"1074-Number-of-Submatrices-That-Sum-to-Target\"><a href=\"#1074-Number-of-Submatrices-That-Sum-to-Target\" class=\"headerlink\" title=\"1074. Number of Submatrices That Sum to Target\"></a><a href=\"https://leetcode.com/problems/number-of-submatrices-that-sum-to-target/\" target=\"_blank\" rel=\"noopener\">1074. Number of Submatrices That Sum to Target</a></h3><h4 id=\"和为目标值的子矩阵个数。\"><a href=\"#和为目标值的子矩阵个数。\" class=\"headerlink\" title=\"和为目标值的子矩阵个数。\"></a>和为目标值的子矩阵个数。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: matrix &#x3D; [[0,1,0],[1,1,1],[0,1,0]], target &#x3D; 0</span><br><span class=\"line\">Output: 4</span><br><span class=\"line\">Explanation: The four 1x1 submatrices that only contain 0.</span><br></pre></td></tr></table></figure>\n<p>方法一：560的升级版。需要先求出每行的前缀和。然后选定两个列（可以相同），以这两个列为宽度，高度逐渐递增，寻找这个宽度的子矩阵的和。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numSubmatrixSumTarget</span><span class=\"params\">(self, matrix: List[List[int]], target: int)</span> -&gt; int:</span></span><br><span class=\"line\">    M, N = len(matrix), len(matrix[<span class=\"number\">0</span>])</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, row <span class=\"keyword\">in</span> enumerate(matrix):</span><br><span class=\"line\">        matrix[i][:] = accumulate(row)</span><br><span class=\"line\">    res = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(N):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i, N):</span><br><span class=\"line\">            cur, d = <span class=\"number\">0</span>, defaultdict(int)</span><br><span class=\"line\">            d[<span class=\"number\">0</span>] = <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(M):</span><br><span class=\"line\">                cur += matrix[k][j] - (matrix[k][i<span class=\"number\">-1</span>] <span class=\"keyword\">if</span> i&gt;<span class=\"number\">0</span> <span class=\"keyword\">else</span> <span class=\"number\">0</span>)</span><br><span class=\"line\">                res += d[cur-target]</span><br><span class=\"line\">                d[cur] += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"1311-Get-Watched-Videos-by-Your-Friends\"><a href=\"#1311-Get-Watched-Videos-by-Your-Friends\" class=\"headerlink\" title=\"1311. Get Watched Videos by Your Friends\"></a>1311. Get Watched Videos by Your Friends</h3><h4 id=\"找到你的level级别的朋友看的电影，按照频率字母排序。原题\"><a href=\"#找到你的level级别的朋友看的电影，按照频率字母排序。原题\" class=\"headerlink\" title=\"找到你的level级别的朋友看的电影，按照频率字母排序。原题\"></a>找到你的level级别的朋友看的电影，按照频率字母排序。<a href=\"https://leetcode.com/problems/get-watched-videos-by-your-friends/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: watchedVideos &#x3D; [[&quot;A&quot;,&quot;B&quot;],[&quot;C&quot;],[&quot;B&quot;,&quot;C&quot;],[&quot;D&quot;]], friends &#x3D; [[1,2],[0,3],[0,3],[1,2]], id &#x3D; 0, level &#x3D; 1</span><br><span class=\"line\">Output: [&quot;B&quot;,&quot;C&quot;] </span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">You have id &#x3D; 0 (green color in the figure) and your friends are (yellow color in the figure):</span><br><span class=\"line\">Person with id &#x3D; 1 -&gt; watchedVideos &#x3D; [&quot;C&quot;] </span><br><span class=\"line\">Person with id &#x3D; 2 -&gt; watchedVideos &#x3D; [&quot;B&quot;,&quot;C&quot;] </span><br><span class=\"line\">The frequencies of watchedVideos by your friends are: </span><br><span class=\"line\">B -&gt; 1 </span><br><span class=\"line\">C -&gt; 2</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">watchedVideosByFriends</span><span class=\"params\">(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int)</span> -&gt; List[str]:</span></span><br><span class=\"line\">    bfs, seen = &#123;id&#125;, &#123;id&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(level):</span><br><span class=\"line\">        bfs = &#123;j <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> bfs <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> friends[i] <span class=\"keyword\">if</span> j <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> seen&#125;</span><br><span class=\"line\">        seen |= bfs</span><br><span class=\"line\">    videos=collections.Counter([v <span class=\"keyword\">for</span> idx <span class=\"keyword\">in</span> bfs <span class=\"keyword\">for</span> v <span class=\"keyword\">in</span> watchedVideos[idx]])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sorted(videos, key=<span class=\"keyword\">lambda</span> x: (videos[x], x))</span><br></pre></td></tr></table></figure>\n<h3 id=\"388-Longest-Absolute-File-Path\"><a href=\"#388-Longest-Absolute-File-Path\" class=\"headerlink\" title=\"388. Longest Absolute File Path\"></a>388. Longest Absolute File Path</h3><h4 id=\"最长的绝对路径。原题\"><a href=\"#最长的绝对路径。原题\" class=\"headerlink\" title=\"最长的绝对路径。原题\"></a>最长的绝对路径。<a href=\"https://leetcode.com/problems/longest-absolute-file-path/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：自己用栈实现的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lengthLongestPath</span><span class=\"params\">(self, input: str)</span> -&gt; int:</span></span><br><span class=\"line\">    stack = []</span><br><span class=\"line\">    path = input.split(<span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">    ans = [<span class=\"string\">''</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> path:</span><br><span class=\"line\">        t = p.count(<span class=\"string\">'\\t'</span>)</span><br><span class=\"line\">        p = p[t:]</span><br><span class=\"line\">        <span class=\"keyword\">while</span> t &lt; len(stack):</span><br><span class=\"line\">            stack.pop()</span><br><span class=\"line\">        stack.append(p)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"string\">'.'</span> <span class=\"keyword\">in</span> p:</span><br><span class=\"line\">            ans.append(<span class=\"string\">'/'</span>.join(stack))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> len(max(ans, key=len))</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：用字典记录深度。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lengthLongestPath</span><span class=\"params\">(self, input: str)</span> -&gt; int:</span></span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    path_len = &#123;<span class=\"number\">0</span>: <span class=\"number\">0</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> input.splitlines():</span><br><span class=\"line\">        name = line.lstrip(<span class=\"string\">'\\t'</span>)</span><br><span class=\"line\">        depth = len(line) - len(name)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"string\">'.'</span> <span class=\"keyword\">in</span> name:</span><br><span class=\"line\">            ans = max(ans, path_len[depth] + len(name))</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            path_len[depth+<span class=\"number\">1</span>] = path_len[depth] + len(name) + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"1224-Maximum-Equal-Frequency\"><a href=\"#1224-Maximum-Equal-Frequency\" class=\"headerlink\" title=\"1224. Maximum Equal Frequency\"></a>1224. Maximum Equal Frequency</h3><h4 id=\"给定一个数组，返回这个数组最长的前缀，前缀中刚好有删除一个元素使其它元素的频率相等。原题\"><a href=\"#给定一个数组，返回这个数组最长的前缀，前缀中刚好有删除一个元素使其它元素的频率相等。原题\" class=\"headerlink\" title=\"给定一个数组，返回这个数组最长的前缀，前缀中刚好有删除一个元素使其它元素的频率相等。原题\"></a>给定一个数组，返回这个数组最长的前缀，前缀中刚好有删除一个元素使其它元素的频率相等。<a href=\"https://leetcode.com/problems/maximum-equal-frequency/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [2,2,1,1,5,3,3,5]</span><br><span class=\"line\">Output: 7</span><br><span class=\"line\">Explanation: For the subarray [2,2,1,1,5,3,3] of length 7, if we remove nums[4]&#x3D;5, we will get [2,2,1,1,3,3], so that each number will appear exactly twice.</span><br></pre></td></tr></table></figure>\n<p>方法一：Lee215的答案，一共分为两种情况，一种情况是将当前元素删除，那么前面的元素具有相同的频率。如果不删除当前的元素，那么这个元素出现了c次，我们用<code>freq</code>来记录出现i次的有多少个数。那么删除的元素只能是出现c+1次或者1次，并且这个数只有一个。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxEqualFreq</span><span class=\"params\">(self, A: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    count = collections.defaultdict(int)</span><br><span class=\"line\">    freq = [<span class=\"number\">0</span>] * (len(A)+<span class=\"number\">1</span>)</span><br><span class=\"line\">    res = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> n, a <span class=\"keyword\">in</span> enumerate(A, <span class=\"number\">1</span>):</span><br><span class=\"line\">        freq[count[a]+<span class=\"number\">1</span>] += <span class=\"number\">1</span></span><br><span class=\"line\">        freq[count[a]] -= <span class=\"number\">1</span></span><br><span class=\"line\">        c = count[a] = count[a] + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> freq[c]*c==n <span class=\"keyword\">and</span> n &lt; len(A):</span><br><span class=\"line\">            res = n + <span class=\"number\">1</span></span><br><span class=\"line\">        d = n - freq[c]*c</span><br><span class=\"line\">        <span class=\"keyword\">if</span> d <span class=\"keyword\">in</span> (c+<span class=\"number\">1</span>, <span class=\"number\">1</span>) <span class=\"keyword\">and</span> freq[d]==<span class=\"number\">1</span>:</span><br><span class=\"line\">            res = n</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"957-Prison-Cells-After-N-Days\"><a href=\"#957-Prison-Cells-After-N-Days\" class=\"headerlink\" title=\"957. Prison Cells After N Days\"></a>957. Prison Cells After N Days</h3><h4 id=\"有8个监狱，如果两边的监狱是相同的，那么次日这个监狱会有人，否则为空。求N天之后的监狱原题\"><a href=\"#有8个监狱，如果两边的监狱是相同的，那么次日这个监狱会有人，否则为空。求N天之后的监狱原题\" class=\"headerlink\" title=\"有8个监狱，如果两边的监狱是相同的，那么次日这个监狱会有人，否则为空。求N天之后的监狱原题\"></a>有8个监狱，如果两边的监狱是相同的，那么次日这个监狱会有人，否则为空。求N天之后的监狱<a href=\"https://leetcode.com/problems/prison-cells-after-n-days/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: cells &#x3D; [0,1,0,1,1,0,0,1], N &#x3D; 7</span><br><span class=\"line\">Output: [0,0,1,1,0,0,0,0]</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">The following table summarizes the state of the prison on each day:</span><br><span class=\"line\">Day 0: [0, 1, 0, 1, 1, 0, 0, 1]</span><br><span class=\"line\">Day 1: [0, 1, 1, 0, 0, 0, 0, 0]</span><br><span class=\"line\">Day 2: [0, 0, 0, 0, 1, 1, 1, 0]</span><br><span class=\"line\">Day 3: [0, 1, 1, 0, 0, 1, 0, 0]</span><br><span class=\"line\">Day 4: [0, 0, 0, 0, 0, 1, 0, 0]</span><br><span class=\"line\">Day 5: [0, 1, 1, 1, 0, 1, 0, 0]</span><br><span class=\"line\">Day 6: [0, 0, 1, 0, 1, 1, 0, 0]</span><br><span class=\"line\">Day 7: [0, 0, 1, 1, 0, 0, 0, 0]</span><br></pre></td></tr></table></figure>\n<p>方法一：看了提示用hash但是还是没想到，总共有8个监狱，首位肯定是0，那么还有6个，6个监狱一共有多少种情况呢，2**6，也就是说最多这些天形成一种循环。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">prisonAfterNDays</span><span class=\"params\">(self, cells: List[int], N: int)</span> -&gt; List[int]:</span></span><br><span class=\"line\">    seen = &#123;str(cells): N&#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> N:</span><br><span class=\"line\">        seen[str(cells)] = N</span><br><span class=\"line\">        N -= <span class=\"number\">1</span></span><br><span class=\"line\">        cells = [<span class=\"number\">0</span>] + [cells[i - <span class=\"number\">1</span>] ^ cells[i + <span class=\"number\">1</span>] ^ <span class=\"number\">1</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">7</span>)] + [<span class=\"number\">0</span>]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> str(cells) <span class=\"keyword\">in</span> seen:</span><br><span class=\"line\">            N %= seen[str(cells)] - N</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cells</span><br></pre></td></tr></table></figure>\n<p>方法二：Lee发现了规律，有三个情况一种是1，7，14的时候循环。那么，每14次进行一次循环。但是不能直接进行取余，因为当过了一天，才会进入14天循环中的一天，所以如果当N能被14整除时，并且首位不为0，那么实际上他需要进行变换，而不是直接返回。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">prisonAfterNDays</span><span class=\"params\">(self, cells: List[int], N: int)</span> -&gt; List[int]:</span></span><br><span class=\"line\">    N -= max(N - <span class=\"number\">1</span>, <span class=\"number\">0</span>) // <span class=\"number\">14</span> * <span class=\"number\">14</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(N):</span><br><span class=\"line\">        cells = [<span class=\"number\">0</span>] + [cells[i - <span class=\"number\">1</span>] ^ cells[i + <span class=\"number\">1</span>] ^ <span class=\"number\">1</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">7</span>)] + [<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cells</span><br></pre></td></tr></table></figure>\n<h3 id=\"1546-Maximum-Number-of-Non-Overlapping-Subarrays-With-Sum-Equals-Target\"><a href=\"#1546-Maximum-Number-of-Non-Overlapping-Subarrays-With-Sum-Equals-Target\" class=\"headerlink\" title=\"1546. Maximum Number of Non-Overlapping Subarrays With Sum Equals Target\"></a>1546. Maximum Number of Non-Overlapping Subarrays With Sum Equals Target</h3><h4 id=\"和为目标值的子数组最多有多少个，子数组不能重复。原题\"><a href=\"#和为目标值的子数组最多有多少个，子数组不能重复。原题\" class=\"headerlink\" title=\"和为目标值的子数组最多有多少个，子数组不能重复。原题\"></a>和为目标值的子数组最多有多少个，子数组不能重复。<a href=\"https://leetcode.com/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [1,1,1,1,1], target &#x3D; 2</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: There are 2 non-overlapping subarrays [1,1,1,1,1] with sum equals to target(2).</span><br></pre></td></tr></table></figure>\n<p>方法一：题目分类为dp。但我感觉更适合哈希，比赛的时候想到了一下TwoSum的思路，但是重置seen为空那步没想到。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxNonOverlapping</span><span class=\"params\">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class=\"line\">    acc = [<span class=\"number\">0</span>] + list(itertools.accumulate(nums))</span><br><span class=\"line\">    n = len(nums)</span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    seen = set()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> pre_sum <span class=\"keyword\">in</span> acc:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> pre_sum - target <span class=\"keyword\">in</span> seen:</span><br><span class=\"line\">            ans += <span class=\"number\">1</span></span><br><span class=\"line\">            seen = set()</span><br><span class=\"line\">        seen.add(pre_sum)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"1577-Number-of-Ways-Where-Square-of-Number-Is-Equal-to-Product-of-Two-Numbers\"><a href=\"#1577-Number-of-Ways-Where-Square-of-Number-Is-Equal-to-Product-of-Two-Numbers\" class=\"headerlink\" title=\"1577. Number of Ways Where Square of Number Is Equal to Product of Two Numbers\"></a>1577. Number of Ways Where Square of Number Is Equal to Product of Two Numbers</h3><h4 id=\"找到一个数组中两个元素乘积等于另一个数组的平方，求总共的个数。原题\"><a href=\"#找到一个数组中两个元素乘积等于另一个数组的平方，求总共的个数。原题\" class=\"headerlink\" title=\"找到一个数组中两个元素乘积等于另一个数组的平方，求总共的个数。原题\"></a>找到一个数组中两个元素乘积等于另一个数组的平方，求总共的个数。<a href=\"https://leetcode.com/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums1 &#x3D; [7,7,8,3], nums2 &#x3D; [1,2,9,7]</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: There are 2 valid triplets.</span><br><span class=\"line\">Type 1: (3,0,2).  nums1[3]^2 &#x3D; nums2[0] * nums2[2].</span><br><span class=\"line\">Type 2: (3,0,1).  nums2[3]^2 &#x3D; nums1[0] * nums1[1].</span><br></pre></td></tr></table></figure>\n<p>方法一：比赛时想复杂了，但还是做出来了。比赛时想的是Counter原数组，根据平方找值。实际上通过combine方法可以反过来算简单。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numTriplets</span><span class=\"params\">(self, nums1: List[int], nums2: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    c1 = Counter(n**<span class=\"number\">2</span> <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> nums1)</span><br><span class=\"line\">    c2 = Counter(n**<span class=\"number\">2</span> <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> nums2)</span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> itertools.combinations(nums1, <span class=\"number\">2</span>):</span><br><span class=\"line\">        ans += c2[x*y]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> itertools.combinations(nums2, <span class=\"number\">2</span>):</span><br><span class=\"line\">        ans += c1[x*y]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"916-Word-Subsets\"><a href=\"#916-Word-Subsets\" class=\"headerlink\" title=\"916. Word Subsets\"></a>916. Word Subsets</h3><h4 id=\"给两个单词列表，返回A中满足这样条件的单词：B中的所有单词都是此单词的子集。原题\"><a href=\"#给两个单词列表，返回A中满足这样条件的单词：B中的所有单词都是此单词的子集。原题\" class=\"headerlink\" title=\"给两个单词列表，返回A中满足这样条件的单词：B中的所有单词都是此单词的子集。原题\"></a>给两个单词列表，返回A中满足这样条件的单词：B中的所有单词都是此单词的子集。<a href=\"https://leetcode.com/problems/word-subsets/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: A &#x3D; [&quot;amazon&quot;,&quot;apple&quot;,&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;], B &#x3D; [&quot;e&quot;,&quot;oo&quot;]</span><br><span class=\"line\">Output: [&quot;facebook&quot;,&quot;google&quot;]</span><br></pre></td></tr></table></figure>\n<p>方法一：Counter 比较简单。效率不咋高。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wordSubsets</span><span class=\"params\">(self, A: List[str], B: List[str])</span> -&gt; List[str]:</span></span><br><span class=\"line\">    c_a = [Counter(w) <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> A]</span><br><span class=\"line\">    c_b = reduce(operator.or_, [Counter(w) <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> B])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [word <span class=\"keyword\">for</span> i, word <span class=\"keyword\">in</span> enumerate(A) <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> c_b-c_a[i]]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：一的基础上改进。&amp; 比较貌似快一丢丢？</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wordSubsets</span><span class=\"params\">(self, A: List[str], B: List[str])</span> -&gt; List[str]:</span></span><br><span class=\"line\">    c_b = reduce(operator.or_, (Counter(w) <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> B))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [a <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> A <span class=\"keyword\">if</span> c_b &amp; Counter(a) == c_b]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：直接查字符会比较快。快了一倍左右</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wordSubsets</span><span class=\"params\">(self, A: List[str], B: List[str])</span> -&gt; List[str]:</span></span><br><span class=\"line\">    subset = &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> B:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> char <span class=\"keyword\">in</span> b:</span><br><span class=\"line\">            subset[char] = max(subset.get(char, <span class=\"number\">0</span>), b.count(char))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [a <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> A <span class=\"keyword\">if</span> all(a.count(c) &gt;= subset[c] <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> subset.keys())]</span><br></pre></td></tr></table></figure>\n<h3 id=\"974-Subarray-Sums-Divisible-by-K\"><a href=\"#974-Subarray-Sums-Divisible-by-K\" class=\"headerlink\" title=\"974. Subarray Sums Divisible by K\"></a>974. Subarray Sums Divisible by K</h3><h4 id=\"连续的子数组的和能被K整除的个数。原题\"><a href=\"#连续的子数组的和能被K整除的个数。原题\" class=\"headerlink\" title=\"连续的子数组的和能被K整除的个数。原题\"></a>连续的子数组的和能被K整除的个数。<a href=\"https://leetcode.com/problems/subarray-sums-divisible-by-k/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: A &#x3D; [4,5,0,-2,-3,1], K &#x3D; 5</span><br><span class=\"line\">Output: 7</span><br><span class=\"line\">Explanation: There are 7 subarrays with a sum divisible by K &#x3D; 5:</span><br><span class=\"line\">[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]</span><br></pre></td></tr></table></figure>\n<p>方法一：这道题没有在规定时间内完成，此答案参考了排名第一的大佬，然后使用<code>defaultdict</code>进行了改进。</p>\n<p><a href=\"https://www.geeksforgeeks.org/count-sub-arrays-sum-divisible-k/\" target=\"_blank\" rel=\"noopener\">这里</a>有一个详细的解答。不过那里给出的答案没有这个简单，不过思路大体相同。</p>\n<p>假设通过<code>sum(i, j)</code>表示切片[i: j]的总和，如果<code>sum(i, j)</code>能被K整除，则说明<code>sum(0, j) - sum(0, i)</code>也能被K整除，即对<code>sum(0, j) % K == sum(0, i) % K</code>。下面的解法使用一个字典记录了余数的个数。<strong>当余数第二次出现的时候，开始计数，但0的时候除外，因为整除了就产生结果了。</strong></p>\n<p>然后再看累加的方法以下文第3行log为例，mod又为4，这时它和之前余数为4的的数组都可以产生一个结果即<code>[4, 5, 0] - [4] = [5, 0]</code> 和<code>[4 , 5, 0] - [4, 5] = [0]</code>所以要累加原来的和。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">subarraysDivByK</span><span class=\"params\">(self, A, K)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> defaultdict</span><br><span class=\"line\">    m = defaultdict(int)</span><br><span class=\"line\">    m[<span class=\"number\">0</span>] = <span class=\"number\">1</span></span><br><span class=\"line\">    total, ans = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, num <span class=\"keyword\">in</span> enumerate(A):</span><br><span class=\"line\">        total += num</span><br><span class=\"line\">        sum_p = total % K</span><br><span class=\"line\">        ans += m[sum_p]</span><br><span class=\"line\">        m[sum_p] += <span class=\"number\">1</span></span><br><span class=\"line\">        print(<span class=\"string\">'sum subarray &#123;&#125; total is &#123;&#125;,  mod is &#123;&#125;,  ans is &#123;&#125;,  &#123;&#125;'</span>.format(</span><br><span class=\"line\">            A[:i+<span class=\"number\">1</span>], total, sum_p, ans, m</span><br><span class=\"line\">        ))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sum subarray [4] total is 4,  mod is 4,  ans is 0,  defaultdict(&lt;class &#39;int&#39;&gt;, &#123;0: 1, 4: 1&#125;)</span><br><span class=\"line\">sum subarray [4, 5] total is 9,  mod is 4,  ans is 1,  defaultdict(&lt;class &#39;int&#39;&gt;, &#123;0: 1, 4: 2&#125;)</span><br><span class=\"line\">sum subarray [4, 5, 0] total is 9,  mod is 4,  ans is 3,  defaultdict(&lt;class &#39;int&#39;&gt;, &#123;0: 1, 4: 3&#125;)</span><br><span class=\"line\">sum subarray [4, 5, 0, -2] total is 7,  mod is 2,  ans is 3,  defaultdict(&lt;class &#39;int&#39;&gt;, &#123;0: 1, 4: 3, 2: 1&#125;)</span><br><span class=\"line\">sum subarray [4, 5, 0, -2, -3] total is 4,  mod is 4,  ans is 6,  defaultdict(&lt;class &#39;int&#39;&gt;, &#123;0: 1, 4: 4, 2: 1&#125;)</span><br><span class=\"line\">sum subarray [4, 5, 0, -2, -3, 1] total is 5,  mod is 0,  ans is 7,  defaultdict(&lt;class &#39;int&#39;&gt;, &#123;0: 2, 4: 4, 2: 1&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"1590-Make-Sum-Divisible-by-P\"><a href=\"#1590-Make-Sum-Divisible-by-P\" class=\"headerlink\" title=\"1590. Make Sum Divisible by P\"></a><a href=\"https://leetcode.com/problems/make-sum-divisible-by-p/\" target=\"_blank\" rel=\"noopener\">1590. Make Sum Divisible by P</a></h3><h4 id=\"删除最小的连续子数组，使得整个数组和能被P整除。\"><a href=\"#删除最小的连续子数组，使得整个数组和能被P整除。\" class=\"headerlink\" title=\"删除最小的连续子数组，使得整个数组和能被P整除。\"></a>删除最小的连续子数组，使得整个数组和能被P整除。</h4><p>方法一：此题作为竞赛第三题，比二题简单，但是竞赛的时候没有做。首先可以用总和%p看余几，然后就是找到最小的子数组能让余数等于这个，就把这个删除，这一点很好想。剩下的和974一样。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minSubarray</span><span class=\"params\">(self, nums: List[int], p: int)</span> -&gt; int:</span></span><br><span class=\"line\">    m = sum(nums) % p</span><br><span class=\"line\">    dp = &#123;<span class=\"number\">0</span>: <span class=\"number\">-1</span>&#125;</span><br><span class=\"line\">    mod = <span class=\"number\">0</span></span><br><span class=\"line\">    ans = len(nums)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, a <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">        mod = (mod+a) % p</span><br><span class=\"line\">        dp[mod] = i</span><br><span class=\"line\">        want = (mod-m) % p</span><br><span class=\"line\">        <span class=\"keyword\">if</span> want <span class=\"keyword\">in</span> dp:</span><br><span class=\"line\">            ans = min(ans, i-dp[want])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans <span class=\"keyword\">if</span> ans &lt; len(nums) <span class=\"keyword\">else</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"692-Top-K-Frequent-Words\"><a href=\"#692-Top-K-Frequent-Words\" class=\"headerlink\" title=\"692. Top K Frequent Words\"></a><a href=\"https://leetcode.com/problems/top-k-frequent-words/\" target=\"_blank\" rel=\"noopener\">692. Top K Frequent Words</a></h3><h4 id=\"最高频的K个单词，相同频率，优先返回字符顺序优先。\"><a href=\"#最高频的K个单词，相同频率，优先返回字符顺序优先。\" class=\"headerlink\" title=\"最高频的K个单词，相同频率，优先返回字符顺序优先。\"></a>最高频的K个单词，相同频率，优先返回字符顺序优先。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [&quot;i&quot;, &quot;love&quot;, &quot;leetcode&quot;, &quot;i&quot;, &quot;love&quot;, &quot;coding&quot;], k &#x3D; 2</span><br><span class=\"line\">Output: [&quot;i&quot;, &quot;love&quot;]</span><br><span class=\"line\">Explanation: &quot;i&quot; and &quot;love&quot; are the two most frequent words.</span><br><span class=\"line\">    Note that &quot;i&quot; comes before &quot;love&quot; due to a lower alphabetical order.</span><br></pre></td></tr></table></figure>\n<p>方法一：记录写法，nsmallest 也能接受key函数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">topKFrequent</span><span class=\"params\">(self, words: List[str], k: int)</span> -&gt; List[str]:</span>  </span><br><span class=\"line\">    c = Counter(words)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [w <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> heapq.nsmallest(k, c.keys(), key=<span class=\"keyword\">lambda</span> x: (-c[x], x))]</span><br></pre></td></tr></table></figure>\n<h3 id=\"1399-Count-Largest-Group\"><a href=\"#1399-Count-Largest-Group\" class=\"headerlink\" title=\"1399. Count Largest Group\"></a>1399. Count Largest Group</h3><h4 id=\"以数字和为分组，求最大组的个数。原题\"><a href=\"#以数字和为分组，求最大组的个数。原题\" class=\"headerlink\" title=\"以数字和为分组，求最大组的个数。原题\"></a>以数字和为分组，求最大组的个数。<a href=\"https://leetcode.com/problems/count-largest-group/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 13</span><br><span class=\"line\">Output: 4</span><br><span class=\"line\">Explanation: There are 9 groups in total, they are grouped according sum of its digits of numbers from 1 to 13:</span><br><span class=\"line\">[1,10], [2,11], [3,12], [4,13], [5], [6], [7], [8], [9]. There are 4 groups with largest size</span><br></pre></td></tr></table></figure>\n<p>方法一：Counter</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countLargestGroup</span><span class=\"params\">(self, n: int)</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Counter</span><br><span class=\"line\">    c = Counter()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n+<span class=\"number\">1</span>):</span><br><span class=\"line\">        c[sum(int(d) <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> str(i))] += <span class=\"number\">1</span></span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    largest_size = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> s, cnt <span class=\"keyword\">in</span> c.most_common():</span><br><span class=\"line\">        <span class=\"keyword\">if</span> largest_size!=<span class=\"number\">0</span> <span class=\"keyword\">and</span> cnt!=largest_size:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            largest_size = cnt</span><br><span class=\"line\">            ans += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法二：标准库。<code>statistics.multimode</code>返回一个可迭代对象中出现次数最多的元素。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countLargestGroup</span><span class=\"params\">(self, n: int)</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">import</span> statistics</span><br><span class=\"line\">    <span class=\"keyword\">return</span> len(statistics.multimode(sum(map(int, str(d))) <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n+<span class=\"number\">1</span>)))</span><br></pre></td></tr></table></figure>\n<h3 id=\"1394-Find-Lucky-Integer-in-an-Array\"><a href=\"#1394-Find-Lucky-Integer-in-an-Array\" class=\"headerlink\" title=\"1394. Find Lucky Integer in an Array\"></a>1394. Find Lucky Integer in an Array</h3><h4 id=\"找到数组中数字和出现次数一致的最大的数。原题\"><a href=\"#找到数组中数字和出现次数一致的最大的数。原题\" class=\"headerlink\" title=\"找到数组中数字和出现次数一致的最大的数。原题\"></a>找到数组中数字和出现次数一致的最大的数。<a href=\"https://leetcode.com/problems/find-lucky-integer-in-an-array/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: arr &#x3D; [2,2,3,4]</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: The only lucky number in the array is 2 because frequency[2] &#x3D;&#x3D; 2.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findLucky</span><span class=\"params\">(self, arr: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Counter</span><br><span class=\"line\">    c = Counter(arr)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> d, f <span class=\"keyword\">in</span> c.most_common():</span><br><span class=\"line\">        <span class=\"keyword\">if</span> d == f:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> d</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1128-Number-of-Equivalent-Domino-Pairs\"><a href=\"#1128-Number-of-Equivalent-Domino-Pairs\" class=\"headerlink\" title=\"1128. Number of Equivalent Domino Pairs\"></a>1128. Number of Equivalent Domino Pairs</h3><h4 id=\"相等的多米诺骨牌对数。原题\"><a href=\"#相等的多米诺骨牌对数。原题\" class=\"headerlink\" title=\"相等的多米诺骨牌对数。原题\"></a>相等的多米诺骨牌对数。<a href=\"https://leetcode.com/problems/number-of-equivalent-domino-pairs/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：把牌翻转成一样的，然后组合。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numEquivDominoPairs</span><span class=\"params\">(self, dominoes: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    dominoes = collections.Counter(tuple(sorted(d)) <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> dominoes)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(v*(v<span class=\"number\">-1</span>)//<span class=\"number\">2</span> <span class=\"keyword\">for</span> v <span class=\"keyword\">in</span> dominoes.values())</span><br></pre></td></tr></table></figure>\n<h3 id=\"1002-Find-Common-Characters\"><a href=\"#1002-Find-Common-Characters\" class=\"headerlink\" title=\"1002. Find Common Characters\"></a>1002. Find Common Characters</h3><h4 id=\"在给定的单词列表中找到公共字符。原题\"><a href=\"#在给定的单词列表中找到公共字符。原题\" class=\"headerlink\" title=\"在给定的单词列表中找到公共字符。原题\"></a>在给定的单词列表中找到公共字符。<a href=\"https://leetcode.com/problems/find-common-characters/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [&quot;bella&quot;,&quot;label&quot;,&quot;roller&quot;]</span><br><span class=\"line\">Output: [&quot;e&quot;,&quot;l&quot;,&quot;l&quot;]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">commonChars</span><span class=\"params\">(self, A: List[str])</span> -&gt; List[str]:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> list(reduce(and_, map(Counter, A)).elements())</span><br></pre></td></tr></table></figure>\n<h3 id=\"697-Degree-of-an-Array\"><a href=\"#697-Degree-of-an-Array\" class=\"headerlink\" title=\"697. Degree of an Array\"></a>697. Degree of an Array</h3><h4 id=\"degree这里表示数组最常见的元素的频率，然后在连续的子数组中寻找同样的degree，求最小子数组的长度。原题\"><a href=\"#degree这里表示数组最常见的元素的频率，然后在连续的子数组中寻找同样的degree，求最小子数组的长度。原题\" class=\"headerlink\" title=\"degree这里表示数组最常见的元素的频率，然后在连续的子数组中寻找同样的degree，求最小子数组的长度。原题\"></a>degree这里表示数组最常见的元素的频率，然后在连续的子数组中寻找同样的degree，求最小子数组的长度。<a href=\"https://leetcode.com/problems/degree-of-an-array/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [1, 2, 2, 3, 1]</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">The input array has a degree of 2 because both elements 1 and 2 appear twice.</span><br><span class=\"line\">Of the subarrays that have the same degree:</span><br><span class=\"line\">[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]</span><br><span class=\"line\">The shortest length is 2. So return 2.</span><br></pre></td></tr></table></figure>\n<p>方法一：使用Counter 和index. 600ms有点慢。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findShortestSubArray</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Counter</span><br><span class=\"line\">    c = Counter(nums)</span><br><span class=\"line\">    degree = <span class=\"literal\">None</span></span><br><span class=\"line\">    res = n = len(nums)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> num, count <span class=\"keyword\">in</span> c.most_common():</span><br><span class=\"line\">        <span class=\"keyword\">if</span> degree <span class=\"keyword\">and</span> count != degree:</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        min_len = n - nums[::<span class=\"number\">-1</span>].index(num) - <span class=\"number\">1</span> - nums.index(num) + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"comment\"># print(min_len, num)</span></span><br><span class=\"line\">        res = min(res, min_len)</span><br><span class=\"line\">        degree = count</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：使用dict记录索引。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findShortestSubArray</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">    c = collections.defaultdict(int)</span><br><span class=\"line\">    left, right = &#123;&#125;, &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, num <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> num <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> left:</span><br><span class=\"line\">            left[num] = i</span><br><span class=\"line\">        right[num] = i</span><br><span class=\"line\">        c[num] += <span class=\"number\">1</span></span><br><span class=\"line\">    res = len(nums)</span><br><span class=\"line\">    degree = max(c.values())</span><br><span class=\"line\">    <span class=\"keyword\">for</span> num, count <span class=\"keyword\">in</span> c.items():</span><br><span class=\"line\">        <span class=\"keyword\">if</span> count == degree:</span><br><span class=\"line\">            res = min(res, right[num]-left[num]+<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：使用Counter + dict. </font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findShortestSubArray</span><span class=\"params\">(self, nums: <span class=\"string\">'List[int]'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    c = collections.Counter(nums)</span><br><span class=\"line\">    left, right = &#123;&#125;, &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, num <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> num <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> left:</span><br><span class=\"line\">            left[num] = i</span><br><span class=\"line\">        right[num] = i</span><br><span class=\"line\">    degree, res = <span class=\"number\">0</span>, len(nums)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> num, count <span class=\"keyword\">in</span> c.most_common():</span><br><span class=\"line\">        <span class=\"keyword\">if</span> degree <span class=\"keyword\">and</span> count != degree:</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        res = min(res, right[num]-left[num]+<span class=\"number\">1</span>)</span><br><span class=\"line\">        degree = count</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"187-Repeated-DNA-Sequences\"><a href=\"#187-Repeated-DNA-Sequences\" class=\"headerlink\" title=\"187. Repeated DNA Sequences\"></a><a href=\"https://leetcode-cn.com/problems/repeated-dna-sequences/\" target=\"_blank\" rel=\"noopener\">187. Repeated DNA Sequences</a></h3><h4 id=\"找出出现两次以上的DNA连续序列，序列长度为10。\"><a href=\"#找出出现两次以上的DNA连续序列，序列长度为10。\" class=\"headerlink\" title=\"找出出现两次以上的DNA连续序列，序列长度为10。\"></a>找出出现两次以上的DNA连续序列，序列长度为10。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;</span><br><span class=\"line\">Output: [&quot;AAAAACCCCC&quot;,&quot;CCCCCAAAAA&quot;]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法一：此题简单方法用滑动窗口加counter就行了。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findRepeatedDnaSequences</span><span class=\"params\">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class=\"line\">        c = Counter(s[i:i+<span class=\"number\">10</span>] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(s)<span class=\"number\">-9</span>))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [k <span class=\"keyword\">for</span> k, cnt <span class=\"keyword\">in</span> c.items() <span class=\"keyword\">if</span> cnt &gt; <span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n<p>方法二：此题有个位运算的标签，所以试了一下，将DNA序列编码为二进制的形式。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findRepeatedDnaSequences</span><span class=\"params\">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class=\"line\">    d = dict(zip(<span class=\"string\">'ACGT'</span>, range(<span class=\"number\">4</span>)))</span><br><span class=\"line\">    dd = &#123;v: k <span class=\"keyword\">for</span> k, v <span class=\"keyword\">in</span> d.items()&#125;</span><br><span class=\"line\">    dna = reduce(<span class=\"keyword\">lambda</span> x, y: x&lt;&lt;<span class=\"number\">2</span> | d[y], s[:<span class=\"number\">10</span>], <span class=\"number\">0</span>)</span><br><span class=\"line\">    cnt = Counter([dna])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, c <span class=\"keyword\">in</span> enumerate(islice(s, <span class=\"number\">10</span>, <span class=\"literal\">None</span>)):</span><br><span class=\"line\">        dna &lt;&lt;= <span class=\"number\">2</span></span><br><span class=\"line\">        dna &amp;= (<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">20</span>)<span class=\"number\">-1</span>    <span class=\"comment\"># 取出多余的高位</span></span><br><span class=\"line\">        dna |= d[c]</span><br><span class=\"line\">        cnt[dna] += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decode</span><span class=\"params\">(n)</span>:</span></span><br><span class=\"line\">        s = <span class=\"string\">''</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(<span class=\"number\">10</span>):</span><br><span class=\"line\">            s += dd[n % <span class=\"number\">4</span>]</span><br><span class=\"line\">            n &gt;&gt;= <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> s[::<span class=\"number\">-1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [decode(n) <span class=\"keyword\">for</span> n, c <span class=\"keyword\">in</span> cnt.items() <span class=\"keyword\">if</span> c &gt; <span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"1658-Minimum-Operations-to-Reduce-X-to-Zero\"><a href=\"#1658-Minimum-Operations-to-Reduce-X-to-Zero\" class=\"headerlink\" title=\"1658. Minimum Operations to Reduce X to Zero\"></a><a href=\"https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/\" target=\"_blank\" rel=\"noopener\">1658. Minimum Operations to Reduce X to Zero</a></h3><h4 id=\"给定一个数组和一个目标数x，每次可以将x-数组两边的某个数，最少需要多少步可以将x变为0。\"><a href=\"#给定一个数组和一个目标数x，每次可以将x-数组两边的某个数，最少需要多少步可以将x变为0。\" class=\"headerlink\" title=\"给定一个数组和一个目标数x，每次可以将x-数组两边的某个数，最少需要多少步可以将x变为0。\"></a>给定一个数组和一个目标数x，每次可以将x-数组两边的某个数，最少需要多少步可以将x变为0。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [1,1,4,2,3], x &#x3D; 5</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: The optimal solution is to remove the last two elements to reduce x to zero.</span><br><span class=\"line\">Input: nums &#x3D; [3,2,20,1,1,3], x &#x3D; 10</span><br><span class=\"line\">Output: 5</span><br><span class=\"line\">Explanation: The optimal solution is to remove the last three elements and the first two elements (5 operations in total) to reduce x to zero.</span><br></pre></td></tr></table></figure>\n<p>方法一：变长滑动窗口。比赛时没有做出来，想成BFS了，结果超时。这题和1423很像，那题是定长的滑动窗口，此题可以转化为，找到一个最长的窗口使得窗口值的和等于总和-x。1200ms.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minOperations</span><span class=\"params\">(self, nums: List[int], x: int)</span> -&gt; int:</span></span><br><span class=\"line\">    target = sum(nums) - x</span><br><span class=\"line\">    lo, N = <span class=\"number\">0</span>, len(nums)</span><br><span class=\"line\">    cur_sum, res = <span class=\"number\">0</span>, <span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> hi, num <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">        cur_sum += num</span><br><span class=\"line\">        <span class=\"keyword\">while</span> lo+<span class=\"number\">1</span>&lt;N <span class=\"keyword\">and</span> cur_sum&gt;target:</span><br><span class=\"line\">            cur_sum -= nums[lo]</span><br><span class=\"line\">            lo += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> cur_sum == target:</span><br><span class=\"line\">            res = max(res, hi-lo+<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res <span class=\"keyword\">if</span> res&lt;<span class=\"number\">0</span> <span class=\"keyword\">else</span> N-res</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：前缀和+字典，这个写法比较优雅，但是比较难想。<code>i</code>表示从右边减去的数字，<code>mp[x]</code>表示从左边减去的数字。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minOperations</span><span class=\"params\">(self, nums: List[int], x: int)</span> -&gt; int:</span></span><br><span class=\"line\">    mp = &#123;<span class=\"number\">0</span>: <span class=\"number\">0</span>&#125;</span><br><span class=\"line\">    prefix = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, num <span class=\"keyword\">in</span> enumerate(nums, <span class=\"number\">1</span>): </span><br><span class=\"line\">        prefix += num</span><br><span class=\"line\">        mp[prefix] = i </span><br><span class=\"line\">    </span><br><span class=\"line\">    ans = mp.get(x, inf)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, num <span class=\"keyword\">in</span> enumerate(reversed(nums), <span class=\"number\">1</span>): </span><br><span class=\"line\">        x -= num</span><br><span class=\"line\">        <span class=\"keyword\">if</span> x <span class=\"keyword\">in</span> mp <span class=\"keyword\">and</span> mp[x] + i &lt;= len(nums): </span><br><span class=\"line\">            ans = min(ans, i + mp[x])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans <span class=\"keyword\">if</span> ans &lt; inf <span class=\"keyword\">else</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1711-Count-Good-Meals\"><a href=\"#1711-Count-Good-Meals\" class=\"headerlink\" title=\"1711. Count Good Meals\"></a><a href=\"https://leetcode.com/problems/count-good-meals/\" target=\"_blank\" rel=\"noopener\">1711. Count Good Meals</a></h3><h4 id=\"给你一个整数数组-deliciousness-，其中-deliciousness-i-是第-i-道餐品的美味程度，返回你可以用数组中的餐品做出的不同-大餐-的数量。结果需要对-109-7-取余。\"><a href=\"#给你一个整数数组-deliciousness-，其中-deliciousness-i-是第-i-道餐品的美味程度，返回你可以用数组中的餐品做出的不同-大餐-的数量。结果需要对-109-7-取余。\" class=\"headerlink\" title=\"给你一个整数数组 deliciousness ，其中 deliciousness[i] 是第 i 道餐品的美味程度，返回你可以用数组中的餐品做出的不同 大餐 的数量。结果需要对 109 + 7 取余。\"></a>给你一个整数数组 deliciousness ，其中 deliciousness[i] 是第 i 道餐品的美味程度，返回你可以用数组中的餐品做出的不同 大餐 的数量。结果需要对 109 + 7 取余。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: deliciousness &#x3D; [1,3,5,7,9]</span><br><span class=\"line\">Output: 4</span><br><span class=\"line\">Explanation: The good meals are (1,3), (1,7), (3,5) and, (7,9).</span><br><span class=\"line\">Their respective sums are 4, 8, 8, and 16, all of which are powers of 2.</span><br></pre></td></tr></table></figure>\n<p>方法一：哈希。比赛时相出了两数之和的思想，但是想放到Counter中遍历，这样写非常麻烦，直接遍历原数组就好。1400ms</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countPairs</span><span class=\"params\">(self, dis: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    two_powers = &#123;<span class=\"number\">2</span>**i <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">22</span>)&#125;</span><br><span class=\"line\">    res = <span class=\"number\">0</span></span><br><span class=\"line\">    s = Counter()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> dis:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> two_powers:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> c - d <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">                res += s[c - d]</span><br><span class=\"line\">        s[d] += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res % (<span class=\"number\">10</span>**<span class=\"number\">9</span> + <span class=\"number\">7</span>)</span><br></pre></td></tr></table></figure>\n<p>方法二：使用Counter遍历，1176ms。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countPairs</span><span class=\"params\">(self, dis: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    two_powers = &#123;<span class=\"number\">2</span>**i <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">22</span>)&#125;</span><br><span class=\"line\">    res = <span class=\"number\">0</span></span><br><span class=\"line\">    s = Counter()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> d, cnt <span class=\"keyword\">in</span> Counter(dis).items():</span><br><span class=\"line\">        <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> two_powers:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> c - d == d:</span><br><span class=\"line\">                res += comb(cnt, <span class=\"number\">2</span>)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                res += s[c - d] * cnt</span><br><span class=\"line\">        s[d] = cnt</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res % (<span class=\"number\">10</span>**<span class=\"number\">9</span> + <span class=\"number\">7</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"2122-Recover-the-Original-Array\"><a href=\"#2122-Recover-the-Original-Array\" class=\"headerlink\" title=\"2122. Recover the Original Array\"></a><a href=\"https://leetcode.com/problems/recover-the-original-array/\" target=\"_blank\" rel=\"noopener\">2122. Recover the Original Array</a></h3><h4 id=\"恢复原始的数组，给你一个合并后的数组，由原数组每个元素-k和-k形成两个数组后合并。\"><a href=\"#恢复原始的数组，给你一个合并后的数组，由原数组每个元素-k和-k形成两个数组后合并。\" class=\"headerlink\" title=\"恢复原始的数组，给你一个合并后的数组，由原数组每个元素-k和+k形成两个数组后合并。\"></a>恢复原始的数组，给你一个合并后的数组，由原数组每个元素-k和+k形成两个数组后合并。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [2,10,6,4,8,12]</span><br><span class=\"line\">Output: [3,7,11]</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">If arr &#x3D; [3,7,11] and k &#x3D; 1, we get lower &#x3D; [2,6,10] and higher &#x3D; [4,8,12].</span><br><span class=\"line\">Combining lower and higher gives us [2,6,10,4,8,12], which is a permutation of nums.</span><br><span class=\"line\">Another valid possibility is that arr &#x3D; [5,7,9] and k &#x3D; 3. In that case, lower &#x3D; [2,4,6] and higher &#x3D; [8,10,12].</span><br></pre></td></tr></table></figure>\n<p>方法一：竞赛时险过，有两个地方想复杂了，其实没必要用堆，本来复制数组就用了O(N)的复杂度。思路是先找<code>2k</code>，然后判断这个是否可行。找的过程也是需要O(N)。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">recoverArray</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check</span><span class=\"params\">(d)</span>:</span></span><br><span class=\"line\">        c, res = Counter(nums), []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> c[num] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> c[num+d] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span>, []</span><br><span class=\"line\">            c[num] -= <span class=\"number\">1</span></span><br><span class=\"line\">            c[num+d] -= <span class=\"number\">1</span></span><br><span class=\"line\">            res.append(num+d//<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span>, res</span><br><span class=\"line\"></span><br><span class=\"line\">    N = len(nums)</span><br><span class=\"line\">    nums.sort()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, N):</span><br><span class=\"line\">        k = nums[i]-nums[<span class=\"number\">0</span>]  <span class=\"comment\"># 对比最小元素</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> k!=<span class=\"number\">0</span> <span class=\"keyword\">and</span> k&amp;<span class=\"number\">1</span>==<span class=\"number\">0</span>:</span><br><span class=\"line\">            valid, res = check(k)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> valid: <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n","categories":["算法"],"tags":["LeetCode","Python","Algorithm","HashTable"]},{"title":"LeetCode算法题整理（链表篇）LinkedList","url":"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E9%93%BE%E8%A1%A8%E7%AF%87%EF%BC%89LinkedList/","content":"<h3 id=\"链表的定义\"><a href=\"#链表的定义\" class=\"headerlink\" title=\"链表的定义\"></a>链表的定义</h3><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ListNode</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, x)</span>:</span></span><br><span class=\"line\">        self.val = x</span><br><span class=\"line\">        self.next = <span class=\"literal\">None</span></span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h3 id=\"2-Add-Two-Numbers\"><a href=\"#2-Add-Two-Numbers\" class=\"headerlink\" title=\"2. Add Two Numbers\"></a>2. Add Two Numbers</h3><h4 id=\"两个链表相加\"><a href=\"#两个链表相加\" class=\"headerlink\" title=\"两个链表相加\"></a><a href=\"https://leetcode.com/problems/add-two-numbers/description/\" target=\"_blank\" rel=\"noopener\">两个链表相加</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class=\"line\">Output: 7 -&gt; 0 -&gt; 8</span><br><span class=\"line\">Explanation: 342 + 465 &#x3D; 807.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addTwoNumbers</span><span class=\"params\">(l1, l2)</span>:</span></span><br><span class=\"line\">    l = head = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">    carry = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> l1 <span class=\"keyword\">or</span> l2 <span class=\"keyword\">or</span> carry:</span><br><span class=\"line\">        v1 = v2 = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> l1:</span><br><span class=\"line\">            v1 = l1.val</span><br><span class=\"line\">            l1 = l1.next</span><br><span class=\"line\">        <span class=\"keyword\">if</span> l2:</span><br><span class=\"line\">            v2 = l2.val</span><br><span class=\"line\">            l2 = l2.next</span><br><span class=\"line\">        carry, val = divmod(v1+v2+carry, <span class=\"number\">10</span>)</span><br><span class=\"line\">        l.next = ListNode(val)</span><br><span class=\"line\">        l = l.next</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head.next</span><br></pre></td></tr></table></figure>\n<h3 id=\"445-Add-Two-Numbers-II\"><a href=\"#445-Add-Two-Numbers-II\" class=\"headerlink\" title=\"445. Add Two Numbers II\"></a>445. Add Two Numbers II</h3><h4 id=\"跟上题类似，只不过是进位方式不同。原题\"><a href=\"#跟上题类似，只不过是进位方式不同。原题\" class=\"headerlink\" title=\"跟上题类似，只不过是进位方式不同。原题\"></a>跟上题类似，只不过是进位方式不同。<a href=\"https://leetcode.com/problems/add-two-numbers-ii/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class=\"line\">Output: 7 -&gt; 8 -&gt; 0 -&gt; 7</span><br></pre></td></tr></table></figure>\n<p>方法一：先reverse再相加，最后再reverse。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addTwoNumbers</span><span class=\"params\">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverse</span><span class=\"params\">(head)</span>:</span></span><br><span class=\"line\">        prev = <span class=\"literal\">None</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> head:</span><br><span class=\"line\">            head.next, prev, head = prev, head, head.next</span><br><span class=\"line\">        <span class=\"keyword\">return</span> prev</span><br><span class=\"line\">    </span><br><span class=\"line\">    ans = head = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">    l1, l2 = reverse(l1), reverse(l2)</span><br><span class=\"line\">    carry = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> l1 <span class=\"keyword\">or</span> l2 <span class=\"keyword\">or</span> carry:</span><br><span class=\"line\">        v1 = v2 = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> l1:</span><br><span class=\"line\">            v1 = l1.val</span><br><span class=\"line\">            l1 = l1.next</span><br><span class=\"line\">        <span class=\"keyword\">if</span> l2:</span><br><span class=\"line\">            v2 = l2.val</span><br><span class=\"line\">            l2 = l2.next</span><br><span class=\"line\">        carry, val = divmod(v1+v2+carry, <span class=\"number\">10</span>)</span><br><span class=\"line\">        head.next = ListNode(val)</span><br><span class=\"line\">        head = head.next</span><br><span class=\"line\">    <span class=\"keyword\">return</span> reverse(ans.next)</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：由于Python int没有限制，所以可以遍历相加，再从尾到头还原节点。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addTwoNumbers</span><span class=\"params\">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class=\"line\">    v1 = v2 = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> l1:</span><br><span class=\"line\">        v1 = v1*<span class=\"number\">10</span> + l1.val</span><br><span class=\"line\">        l1 = l1.next</span><br><span class=\"line\">    <span class=\"keyword\">while</span> l2:</span><br><span class=\"line\">        v2 = v2*<span class=\"number\">10</span> + l2.val</span><br><span class=\"line\">        l2 = l2.next</span><br><span class=\"line\">    val = v1 + v2</span><br><span class=\"line\">    tail, head = <span class=\"literal\">None</span>, <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> val &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">        head = ListNode(val % <span class=\"number\">10</span>)</span><br><span class=\"line\">        head.next = tail</span><br><span class=\"line\">        tail = head</span><br><span class=\"line\">        val //= <span class=\"number\">10</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> head <span class=\"keyword\">if</span> head <span class=\"keyword\">else</span> ListNode(<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"21-Merge-Two-Sorted-Lists\"><a href=\"#21-Merge-Two-Sorted-Lists\" class=\"headerlink\" title=\"21. Merge Two Sorted Lists\"></a>21. Merge Two Sorted Lists</h3><h4 id=\"合并两个有序链表。原题\"><a href=\"#合并两个有序链表。原题\" class=\"headerlink\" title=\"合并两个有序链表。原题\"></a>合并两个有序链表。<a href=\"https://leetcode.com/problems/merge-two-sorted-lists/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class=\"line\">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>\n<p>方法1：iteratively 迭代</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergeTwoLists</span><span class=\"params\">(l1, l2)</span>:</span></span><br><span class=\"line\">    l = head = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> l1 <span class=\"keyword\">and</span> l2:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> l1.val &lt;= l2.val:</span><br><span class=\"line\">            l.next, l1 = l1, l1.next</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            l.next, l2 = l2, l2.next</span><br><span class=\"line\">        l = l.next</span><br><span class=\"line\">    l.next = l1 <span class=\"keyword\">or</span> l2</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head.next</span><br></pre></td></tr></table></figure>\n<p>方法2：recursively 递归</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergeTwoLists</span><span class=\"params\">(l1, l2)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 判断是否存在None</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> l1 <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> l2:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l1 <span class=\"keyword\">or</span> l2</span><br><span class=\"line\">    <span class=\"keyword\">if</span> l1.val &lt; l2.val:</span><br><span class=\"line\">        l1.next = mergeTwoLists(l1.next, l2)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l1</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        l2.next = mergeTwoLists(l1, l2.next)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l2</span><br></pre></td></tr></table></figure>\n<h3 id=\"23-Merge-k-Sorted-Lists\"><a href=\"#23-Merge-k-Sorted-Lists\" class=\"headerlink\" title=\"23. Merge k Sorted Lists\"></a>23. Merge k Sorted Lists</h3><h4 id=\"合并k个有序列表。原题\"><a href=\"#合并k个有序列表。原题\" class=\"headerlink\" title=\"合并k个有序列表。原题\"></a>合并k个有序列表。<a href=\"https://leetcode.com/problems/merge-k-sorted-lists/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">[</span><br><span class=\"line\">  1-&gt;4-&gt;5,</span><br><span class=\"line\">  1-&gt;3-&gt;4,</span><br><span class=\"line\">  2-&gt;6</span><br><span class=\"line\">]</span><br><span class=\"line\">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure>\n<p>方法一：Brute Force. time: O(NlogN)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergeKLists</span><span class=\"params\">(self, lists: List[ListNode])</span> -&gt; ListNode:</span></span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> l <span class=\"keyword\">in</span> lists:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> l:</span><br><span class=\"line\">            ans.append(l.val)</span><br><span class=\"line\">            l = l.next</span><br><span class=\"line\">    h = head = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> v <span class=\"keyword\">in</span> sorted(ans):</span><br><span class=\"line\">        h.next = ListNode(v)</span><br><span class=\"line\">        h = h.next</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head.next</span><br></pre></td></tr></table></figure>\n<p>方法二：优先级队列。本来优先级就没有方法一快，再加上Python3中的比较符机制不同，导致要实现<code>__lt__</code>方法，就更慢了。不过理论时间复杂度是比方法一小的。Time: O(Nlogk)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CmpNode</span>:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, node)</span>:</span></span><br><span class=\"line\">        self.node = node</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__lt__</span><span class=\"params\">(self, other)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.node.val &lt; other.node.val</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergeKLists</span><span class=\"params\">(self, lists: List[ListNode])</span> -&gt; ListNode:</span></span><br><span class=\"line\">        <span class=\"keyword\">from</span> queue <span class=\"keyword\">import</span> PriorityQueue</span><br><span class=\"line\">        head = h = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        q = PriorityQueue()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> l <span class=\"keyword\">in</span> lists:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> l:</span><br><span class=\"line\">                q.put(CmpNode(l))</span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> q.empty():</span><br><span class=\"line\">            to_add = q.get().node</span><br><span class=\"line\">            h.next = to_add</span><br><span class=\"line\">            h = h.next</span><br><span class=\"line\">            <span class=\"keyword\">if</span> to_add.next:</span><br><span class=\"line\">                q.put(CmpNode(to_add.next))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head.next</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：规避<code>ListNode</code>的比较，以解决上述问题。只要加上该链表在原数组中的索引位置，就一定不会重复，从而忽略对<code>ListNode</code>的比较。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergeKLists</span><span class=\"params\">(self, lists: List[ListNode])</span> -&gt; ListNode:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> queue <span class=\"keyword\">import</span> PriorityQueue</span><br><span class=\"line\">    q = PriorityQueue()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> idx, l <span class=\"keyword\">in</span> enumerate(lists):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> l:</span><br><span class=\"line\">            q.put((l.val, idx, l))</span><br><span class=\"line\">    h = head = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> q.empty():</span><br><span class=\"line\">        val, idx, node = q.get()</span><br><span class=\"line\">        h.next = node</span><br><span class=\"line\">        h, node = h.next, node.next</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            q.put((node.val, idx, node))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head.next</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法四：俩俩合并。Time: O(Nlogk)</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergeKLists</span><span class=\"params\">(self, lists: List[ListNode])</span> -&gt; ListNode:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge_two</span><span class=\"params\">(l1, l2)</span>:</span></span><br><span class=\"line\">        dummy = h = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">while</span> l1 <span class=\"keyword\">and</span> l2:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> l1.val &lt;= l2.val:</span><br><span class=\"line\">                h.next = l1</span><br><span class=\"line\">                l1 = l1.next</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                h.next = l2</span><br><span class=\"line\">                l2 = l2.next</span><br><span class=\"line\">            h = h.next</span><br><span class=\"line\">        h.next = l1 <span class=\"keyword\">or</span> l2</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummy.next</span><br><span class=\"line\"></span><br><span class=\"line\">    pairs = lists</span><br><span class=\"line\">    <span class=\"keyword\">while</span> len(pairs) &gt; <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(pairs) &amp; <span class=\"number\">1</span>: pairs.append(<span class=\"literal\">None</span>)</span><br><span class=\"line\">        pairs = [merge_two(pairs[i], pairs[~i]) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(pairs)//<span class=\"number\">2</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pairs[<span class=\"number\">0</span>] <span class=\"keyword\">if</span> pairs <span class=\"keyword\">else</span> <span class=\"literal\">None</span></span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法五：和优先队列一样，使用堆实现。个人觉得比优先级队列好写一点。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergeKLists</span><span class=\"params\">(self, lists: List[ListNode])</span> -&gt; ListNode:</span></span><br><span class=\"line\">    dummy = h = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">    heap = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, l <span class=\"keyword\">in</span> enumerate(lists):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> l: heapq.heappush(heap, (l.val, i, l))</span><br><span class=\"line\">    <span class=\"keyword\">while</span> heap:</span><br><span class=\"line\">        val, i, l = heapq.heappop(heap)</span><br><span class=\"line\">        h.next, l = l, l.next</span><br><span class=\"line\">        <span class=\"keyword\">if</span> l: heapq.heappush(heap, (l.val, i, l))</span><br><span class=\"line\">        h = h.next</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dummy.next</span><br></pre></td></tr></table></figure>\n<h3 id=\"141-Linked-List-Cycle\"><a href=\"#141-Linked-List-Cycle\" class=\"headerlink\" title=\"141. Linked List Cycle\"></a>141. Linked List Cycle</h3><h4 id=\"判断一个链表是否有环。原题\"><a href=\"#判断一个链表是否有环。原题\" class=\"headerlink\" title=\"判断一个链表是否有环。原题\"></a>判断一个链表是否有环。<a href=\"https://leetcode.com/problems/linked-list-cycle/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>经典的一道题，看成两个人在赛跑，如果有环，快的人会和慢的人相遇</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hasCycle</span><span class=\"params\">(self, head)</span>:</span></span><br><span class=\"line\">    slow = fast = head:</span><br><span class=\"line\">    <span class=\"keyword\">while</span> fast <span class=\"keyword\">and</span> fast.next:</span><br><span class=\"line\">        slow, fast = slow.next, fast.next.next</span><br><span class=\"line\">        <span class=\"keyword\">if</span> fast <span class=\"keyword\">is</span> slow:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"142-Linked-List-Cycle-II\"><a href=\"#142-Linked-List-Cycle-II\" class=\"headerlink\" title=\"142. Linked List Cycle II\"></a>142. Linked List Cycle II</h3><h4 id=\"求链表中环的入口节点。原题\"><a href=\"#求链表中环的入口节点。原题\" class=\"headerlink\" title=\"求链表中环的入口节点。原题\"></a>求链表中环的入口节点。<a href=\"https://leetcode.com/problems/linked-list-cycle-ii/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><ul>\n<li>首先判断此链表是否有环。</li>\n<li>然后在相交点和头结点一起走，一定会在入口相遇。</li>\n</ul>\n<blockquote>\n<pre><code>Consider the following linked list, where E is the cylce entry and X, the crossing point of fast and slow.\nH: distance from head to cycle entry E\nD: distance from E to X\nL: cycle length\n  ​                _____\n  ​               /     \\\nhead_____H______E       \\\n  ​              \\       /\n  ​               X_____/   \n</code></pre></blockquote>\n<blockquote>\n<pre><code>   If fast and slow both start at head, when fast catches slow, slow has traveled H+D and fast 2(H+D). \nAssume fast has traveled n loops in the cycle, we have:\n2H + 2D = H + D + L  --&gt;  H + D = nL  --&gt; H = nL - D\nThus if two pointers start from head and X, respectively, one first reaches E, the other also reaches E. \nIn my solution, since fast starts at head.next, we need to move slow one step forward in the beginning of part 2\n</code></pre></blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">detectCycle</span><span class=\"params\">(self, head)</span>:</span>        </span><br><span class=\"line\">    fast = slow = head</span><br><span class=\"line\">    <span class=\"comment\"># 检测是否有环</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> fast <span class=\"keyword\">and</span> fast.next:</span><br><span class=\"line\">        slow, fast = slow.next, fast.next.next</span><br><span class=\"line\">        <span class=\"keyword\">if</span> slow <span class=\"keyword\">is</span> fast:</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"comment\"># 找出入口节点</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> head <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> slow:</span><br><span class=\"line\">        head, slow = head.next, slow.next</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head</span><br></pre></td></tr></table></figure>\n<h3 id=\"206-Reverse-Linked-List\"><a href=\"#206-Reverse-Linked-List\" class=\"headerlink\" title=\"206. Reverse Linked List\"></a>206. Reverse Linked List</h3><h4 id=\"倒置一个链表。原题\"><a href=\"#倒置一个链表。原题\" class=\"headerlink\" title=\"倒置一个链表。原题\"></a>倒置一个链表。<a href=\"https://leetcode.com/problems/reverse-linked-list/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class=\"line\">Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>\n<p>方法一： iteratively</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseList</span><span class=\"params\">(head)</span>:</span></span><br><span class=\"line\">    prev = <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> head:</span><br><span class=\"line\">        cur = head</span><br><span class=\"line\">        head = head.next</span><br><span class=\"line\">        cur.next = prev</span><br><span class=\"line\">        prev = cur</span><br><span class=\"line\">    <span class=\"keyword\">return</span> prev</span><br></pre></td></tr></table></figure>\n<p>方法二：使用一行赋值</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseList</span><span class=\"params\">(self, head)</span>:</span></span><br><span class=\"line\">    prev = <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> head:</span><br><span class=\"line\">        head.next, prev, head = prev, head, head.next</span><br><span class=\"line\">    <span class=\"keyword\">return</span> prev</span><br></pre></td></tr></table></figure>\n<a href=\"/Python-%E5%A4%9A%E4%B8%AA%E5%8F%98%E9%87%8F%E5%90%8C%E6%97%B6%E8%B5%8B%E5%80%BC/\" title=\"Python同时给多个变量赋值。\">Python同时给多个变量赋值。</a>\n<p>方法三：递归</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseList</span><span class=\"params\">(self, head, prev=None)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> head:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> prev</span><br><span class=\"line\">  </span><br><span class=\"line\">    cur, head.next = head.next, prev</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.reverseList(cur, head)</span><br></pre></td></tr></table></figure>\n<h3 id=\"92-Reverse-Linked-List-II\"><a href=\"#92-Reverse-Linked-List-II\" class=\"headerlink\" title=\"92. Reverse Linked List II\"></a>92. Reverse Linked List II</h3><h4 id=\"跟上题不同的是，只倒置指定区间的部分。原题\"><a href=\"#跟上题不同的是，只倒置指定区间的部分。原题\" class=\"headerlink\" title=\"跟上题不同的是，只倒置指定区间的部分。原题\"></a>跟上题不同的是，只倒置指定区间的部分。<a href=\"https://leetcode.com/problems/reverse-linked-list-ii/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m &#x3D; 2, n &#x3D; 4</span><br><span class=\"line\">Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseBetween</span><span class=\"params\">(self, head: ListNode, m: int, n: int)</span> -&gt; ListNode:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    root = h = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">    h.next = head</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(m<span class=\"number\">-1</span>):</span><br><span class=\"line\">        h = h.next</span><br><span class=\"line\">    cur_head = h</span><br><span class=\"line\">    p1 = p2 = cur_head.next</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n-m):</span><br><span class=\"line\">        p2 = p2.next</span><br><span class=\"line\">    prev = p2.next <span class=\"keyword\">if</span> p2 <span class=\"keyword\">else</span> <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> p2:</span><br><span class=\"line\">        p2.next = <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> p1:</span><br><span class=\"line\">        p1.next, prev, p1 = prev, p1, p1.next</span><br><span class=\"line\">    cur_head.next = prev</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root.next</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：遍历一次。</font><br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseBetween</span><span class=\"params\">(self, head: ListNode, m: int, n: int)</span> -&gt; ListNode:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    dummy = p = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">    dummy.next = head</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(m<span class=\"number\">-1</span>): p = p.next</span><br><span class=\"line\">    tail = p.next</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n-m):</span><br><span class=\"line\">        tmp = p.next</span><br><span class=\"line\">        p.next = tail.next</span><br><span class=\"line\">        tail.next = tail.next.next</span><br><span class=\"line\">        p.next.next = tmp</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dummy.next</span><br></pre></td></tr></table></figure><br>### 160. Intersection of Two Linked Lists<br>#### 两个链表求相交。<a href=\"https://leetcode.com/problems/intersection-of-two-linked-lists/description/\" target=\"_blank\" rel=\"noopener\">原题</a><br><br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getIntersectionNode</span><span class=\"params\">(self, headA, headB)</span>:</span></span><br><span class=\"line\">    p1, p2 = headA, headB</span><br><span class=\"line\">    <span class=\"keyword\">while</span> p1 <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> p2:</span><br><span class=\"line\">        p1 = p1.next <span class=\"keyword\">if</span> p1 <span class=\"keyword\">else</span> headB</span><br><span class=\"line\">        p2 = p2.next <span class=\"keyword\">if</span> p2 <span class=\"keyword\">else</span> headA</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p1</span><br></pre></td></tr></table></figure><br><br>### 138. Copy List with Random Pointer<br><br>#### 深拷贝一个复杂链表，链表多包含了一个随机指针。<a href=\"https://leetcode.com/problems/copy-list-with-random-pointer/description/\" target=\"_blank\" rel=\"noopener\">原题</a><br><br><em> Time-O(2n), Memory-O(n).<br><br>    <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">copyRandomList</span><span class=\"params\">(self, head)</span>:</span></span><br><span class=\"line\">    cp_map = &#123;&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    m = n = head</span><br><span class=\"line\">    <span class=\"keyword\">while</span> m:</span><br><span class=\"line\">        cp_map[m] = RandomListNode(m.label)</span><br><span class=\"line\">        m = m.next</span><br><span class=\"line\">    <span class=\"keyword\">while</span> n:</span><br><span class=\"line\">        cp_map[n].next = cp_map.get(n.next)</span><br><span class=\"line\">        cp_map[n].random = cp_map.get(n.random)</span><br><span class=\"line\">        n = n.next</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> cp_map.get(head)</span><br></pre></td></tr></table></figure>\n\n</em> Time-O(n), Memory-O(n). 这种方式是相当于把第一次迭代的过程委托给了<code>defaultdict</code>，通过创建一个默认的对象，再去修改它的label值。<br><br>    <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">copyRandomList</span><span class=\"params\">(self, head)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> defaultdict</span><br><span class=\"line\">    cp = defaultdict(<span class=\"keyword\">lambda</span>: RandomListNode(<span class=\"number\">0</span>))</span><br><span class=\"line\">    cp[<span class=\"literal\">None</span>] = <span class=\"literal\">None</span></span><br><span class=\"line\">    n = head</span><br><span class=\"line\">    <span class=\"keyword\">while</span> n:</span><br><span class=\"line\">        cp[n].label = n.label</span><br><span class=\"line\">        cp[n].next = cp[n.next]</span><br><span class=\"line\">        cp[n].random = cp[n.random]</span><br><span class=\"line\">        n = n.next</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cp[head]</span><br></pre></td></tr></table></figure><br><br><br>### 237. Delete Node in a Linked List<br>#### 在链表中删除节点。给定的节点不是尾节点。<a href=\"https://leetcode.com/problems/delete-node-in-a-linked-list/description/\" target=\"_blank\" rel=\"noopener\">原题</a><br><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: head &#x3D; [4,5,1,9], node &#x3D; 5</span><br><span class=\"line\">Output: [4,1,9]</span><br></pre></td></tr></table></figure><br>开始看到这题的思路是，要是能拿到父节点就好了，然后这道题需要别的思路，其关键在于复制<br><br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">deleteNode</span><span class=\"params\">(self, node)</span>:</span></span><br><span class=\"line\">    node.val = node.next.val  <span class=\"comment\"># 4-&gt;1-&gt;1-&gt;9</span></span><br><span class=\"line\">    node.next = node.next.next  <span class=\"comment\"># 4-&gt;1-&gt;9</span></span><br></pre></td></tr></table></figure><br><br>### 203. Remove Linked List Elements<br>#### 删除链表中值为val的元素。<a href=\"https://leetcode.com/problems/remove-linked-list-elements/\" target=\"_blank\" rel=\"noopener\">原题</a><br>方法一：遍历<code>head</code>并构建新的<code>ListNode</code>。<br><br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removeElements</span><span class=\"params\">(self, head, val)</span>:</span></span><br><span class=\"line\">    l = res = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> head:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> head.val != val:</span><br><span class=\"line\">            l.next = ListNode(head.val)</span><br><span class=\"line\">            l = l.next</span><br><span class=\"line\">        head = head.next</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res.next</span><br></pre></td></tr></table></figure><br><font color=\"#32CD32\" size=\"3\">方法二：更喜欢这个方法。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removeElements</span><span class=\"params\">(self, head: <span class=\"string\">'ListNode'</span>, val: <span class=\"string\">'int'</span>)</span> -&gt; 'ListNode':</span></span><br><span class=\"line\">    l = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">    l.next, ans = head, l</span><br><span class=\"line\">    <span class=\"keyword\">while</span> l <span class=\"keyword\">and</span> l.next:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> l.next.val == val:</span><br><span class=\"line\">            l.next = l.next.next</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            l = l.next</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans.next</span><br></pre></td></tr></table></figure>\n<h3 id=\"83-Remove-Duplicates-from-Sorted-List\"><a href=\"#83-Remove-Duplicates-from-Sorted-List\" class=\"headerlink\" title=\"83. Remove Duplicates from Sorted List\"></a>83. Remove Duplicates from Sorted List</h3><h4 id=\"删除有序链表中重复的节点。原题\"><a href=\"#删除有序链表中重复的节点。原题\" class=\"headerlink\" title=\"删除有序链表中重复的节点。原题\"></a>删除有序链表中重复的节点。<a href=\"https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">delete_duplicates</span><span class=\"params\">(head)</span>:</span></span><br><span class=\"line\">    root = head</span><br><span class=\"line\">    <span class=\"keyword\">while</span> head <span class=\"keyword\">and</span> head.next:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> head.val == head.next.val:</span><br><span class=\"line\">            head.next = head.next.next</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            head = head.next</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br></pre></td></tr></table></figure>\n<h3 id=\"82-Remove-Duplicates-from-Sorted-List-II\"><a href=\"#82-Remove-Duplicates-from-Sorted-List-II\" class=\"headerlink\" title=\"82. Remove Duplicates from Sorted List II\"></a>82. Remove Duplicates from Sorted List II</h3><h4 id=\"和上题不同的是，重复的节点要全部删除。原题\"><a href=\"#和上题不同的是，重复的节点要全部删除。原题\" class=\"headerlink\" title=\"和上题不同的是，重复的节点要全部删除。原题\"></a>和上题不同的是，重复的节点要全部删除。<a href=\"https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</span><br><span class=\"line\">Output: 1-&gt;2-&gt;5</span><br></pre></td></tr></table></figure>\n<p>方法一：首次AC的方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">deleteDuplicates</span><span class=\"params\">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class=\"line\">    prev = ans = ListNode(<span class=\"number\">0</span>)        </span><br><span class=\"line\">    prev.next = h = head</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span> h <span class=\"keyword\">and</span> h.next:</span><br><span class=\"line\">        remove = <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> h.next <span class=\"keyword\">and</span> h.val == h.next.val:</span><br><span class=\"line\">            h.next = h.next.next</span><br><span class=\"line\">            remove = <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> remove:</span><br><span class=\"line\">            prev.next = h.next</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            prev = prev.next</span><br><span class=\"line\">        h = h.next</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans.next</span><br></pre></td></tr></table></figure>\n<h3 id=\"876-Middle-of-the-Linked-List\"><a href=\"#876-Middle-of-the-Linked-List\" class=\"headerlink\" title=\"876. Middle of the Linked List\"></a>876. Middle of the Linked List</h3><h4 id=\"链表中点，如果偶数个，则返回第二个节点。原题\"><a href=\"#链表中点，如果偶数个，则返回第二个节点。原题\" class=\"headerlink\" title=\"链表中点，如果偶数个，则返回第二个节点。原题\"></a>链表中点，如果偶数个，则返回第二个节点。<a href=\"https://leetcode.com/problems/middle-of-the-linked-list/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [1,2,3,4,5]</span><br><span class=\"line\">Output: Node 3 from this list (Serialization: [3,4,5])</span><br><span class=\"line\">The returned node has value 3.  (The judge&#39;s serialization of this node is [3,4,5]).</span><br><span class=\"line\">Note that we returned a ListNode object ans, such that:</span><br><span class=\"line\">ans.val &#x3D; 3, ans.next.val &#x3D; 4, ans.next.next.val &#x3D; 5, and ans.next.next.next &#x3D; NULL.</span><br><span class=\"line\"></span><br><span class=\"line\">Output: Node 4 from this list (Serialization: [4,5,6])</span><br><span class=\"line\">Since the list has two middle nodes with values 3 and 4, we return the second one.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">middleNode</span><span class=\"params\">(self, head: <span class=\"string\">'ListNode'</span>)</span> -&gt; 'ListNode':</span></span><br><span class=\"line\">    fast = slow = head</span><br><span class=\"line\">    <span class=\"keyword\">while</span> fast <span class=\"keyword\">and</span> fast.next:</span><br><span class=\"line\">        slow, fast = slow.next, fast.next.next</span><br><span class=\"line\">    <span class=\"keyword\">return</span> slow</span><br></pre></td></tr></table></figure>\n<h3 id=\"234-Palindrome-Linked-List\"><a href=\"#234-Palindrome-Linked-List\" class=\"headerlink\" title=\"234. Palindrome Linked List\"></a>234. Palindrome Linked List</h3><h4 id=\"判断一个链表是否是回文链表。原题\"><a href=\"#判断一个链表是否是回文链表。原题\" class=\"headerlink\" title=\"判断一个链表是否是回文链表。原题\"></a>判断一个链表是否是回文链表。<a href=\"https://leetcode.com/problems/palindrome-linked-list/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: 1-&gt;2-&gt;2-&gt;1</span><br><span class=\"line\">Output: true</span><br></pre></td></tr></table></figure>\n<p>方法一：此题为倒置链表和快慢指针的总和应用。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(self, head: <span class=\"string\">'ListNode'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\">    rev = <span class=\"literal\">None</span></span><br><span class=\"line\">    slow = fast = head</span><br><span class=\"line\">    <span class=\"keyword\">while</span> fast <span class=\"keyword\">and</span> fast.next:</span><br><span class=\"line\">        fast = fast.next.next</span><br><span class=\"line\">        slow.next, rev, slow = rev, slow, slow.next</span><br><span class=\"line\">    <span class=\"keyword\">if</span> fast:</span><br><span class=\"line\">        slow = slow.next</span><br><span class=\"line\">    <span class=\"keyword\">while</span> rev <span class=\"keyword\">and</span> rev.val == slow.val:</span><br><span class=\"line\">        rev, slow = rev.next, slow.next</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rev <span class=\"keyword\">is</span> <span class=\"literal\">None</span></span><br></pre></td></tr></table></figure>\n<p>方法二：上述方法有一个缺点就是改变了原始的head，这里进行一些改进。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(self, head)</span>:</span></span><br><span class=\"line\">    rev = <span class=\"literal\">None</span></span><br><span class=\"line\">    fast = head</span><br><span class=\"line\">    <span class=\"keyword\">while</span> fast <span class=\"keyword\">and</span> fast.next:</span><br><span class=\"line\">        fast = fast.next.next</span><br><span class=\"line\">        rev, rev.next, head = head, rev, head.next</span><br><span class=\"line\">    tail = head.next <span class=\"keyword\">if</span> fast <span class=\"keyword\">else</span> head</span><br><span class=\"line\">    isPali = <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> rev:</span><br><span class=\"line\">        isPali = isPali <span class=\"keyword\">and</span> rev.val == tail.val</span><br><span class=\"line\">        head, head.next, rev = rev, head, rev.next</span><br><span class=\"line\">        tail = tail.next</span><br><span class=\"line\">    <span class=\"keyword\">return</span> isPali</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"24-Swap-Nodes-in-Pairs\"><a href=\"#24-Swap-Nodes-in-Pairs\" class=\"headerlink\" title=\"24. Swap Nodes in Pairs\"></a>24. Swap Nodes in Pairs</h3><h4 id=\"成对转换链表。原题\"><a href=\"#成对转换链表。原题\" class=\"headerlink\" title=\"成对转换链表。原题\"></a>成对转换链表。<a href=\"https://leetcode.com/problems/swap-nodes-in-pairs/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">swapPairs</span><span class=\"params\">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class=\"line\">    prev, prev.next = self, head</span><br><span class=\"line\">    <span class=\"keyword\">while</span> prev.next <span class=\"keyword\">and</span> prev.next.next:</span><br><span class=\"line\">        a = prev.next    <span class=\"comment\"># current</span></span><br><span class=\"line\">        b = a.next</span><br><span class=\"line\">        prev.next, b.next, a.next = b, a, b.next</span><br><span class=\"line\">        prev = a</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.next</span><br></pre></td></tr></table></figure>\n<p>方法二：这里有个阴间写法，只创建一个变量。注意复制顺序，不能将p.next放到前面。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">swapPairs</span><span class=\"params\">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class=\"line\">    p, p.next = self, head</span><br><span class=\"line\">    <span class=\"keyword\">while</span> p.next <span class=\"keyword\">and</span> p.next.next:</span><br><span class=\"line\">        p.next.next.next, p.next.next, p.next = p.next, p.next.next.next, p.next.next</span><br><span class=\"line\">        p = p.next.next</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.next</span><br></pre></td></tr></table></figure>\n<h3 id=\"19-Remove-Nth-Node-From-End-of-List\"><a href=\"#19-Remove-Nth-Node-From-End-of-List\" class=\"headerlink\" title=\"19. Remove Nth Node From End of List\"></a>19. Remove Nth Node From End of List</h3><h4 id=\"删除倒数第N个节点。原题\"><a href=\"#删除倒数第N个节点。原题\" class=\"headerlink\" title=\"删除倒数第N个节点。原题\"></a>删除倒数第N个节点。<a href=\"https://leetcode.com/problems/remove-nth-node-from-end-of-list/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n &#x3D; 2.</span><br><span class=\"line\"></span><br><span class=\"line\">After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(self, head: ListNode, n: int)</span> -&gt; ListNode:</span></span><br><span class=\"line\">    slow = dummy = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">    dummy.next = fast = head</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">        fast = fast.next</span><br><span class=\"line\">    <span class=\"keyword\">while</span> fast:</span><br><span class=\"line\">        slow, fast = slow.next, fast.next</span><br><span class=\"line\">    slow.next = slow.next.next</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dummy.next</span><br></pre></td></tr></table></figure>\n<h3 id=\"328-Odd-Even-Linked-List\"><a href=\"#328-Odd-Even-Linked-List\" class=\"headerlink\" title=\"328. Odd Even Linked List\"></a>328. Odd Even Linked List</h3><h4 id=\"重排链表，使奇数位节点在前，偶数位节点在后，就地排序。原题\"><a href=\"#重排链表，使奇数位节点在前，偶数位节点在后，就地排序。原题\" class=\"headerlink\" title=\"重排链表，使奇数位节点在前，偶数位节点在后，就地排序。原题\"></a>重排链表，使奇数位节点在前，偶数位节点在后，就地排序。<a href=\"https://leetcode.com/problems/odd-even-linked-list/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class=\"line\">Output: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure>\n<img src=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E9%93%BE%E8%A1%A8%E7%AF%87%EF%BC%89LinkedList/328_Odd_Even.svg\" class>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">oddEvenList</span><span class=\"params\">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> head:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">    odd = head</span><br><span class=\"line\">    even_h = even = head.next</span><br><span class=\"line\">    <span class=\"keyword\">while</span> even <span class=\"keyword\">and</span> even.next:</span><br><span class=\"line\">        odd.next = odd.next.next</span><br><span class=\"line\">        odd = odd.next</span><br><span class=\"line\">        even.next = even.next.next</span><br><span class=\"line\">        even = even.next</span><br><span class=\"line\">    odd.next = even_h</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head</span><br></pre></td></tr></table></figure>\n<h3 id=\"Sort-a-linked-list-that-is-sorted-alternating-asc-and-desc\"><a href=\"#Sort-a-linked-list-that-is-sorted-alternating-asc-and-desc\" class=\"headerlink\" title=\"***. Sort  a linked list that is sorted alternating asc and desc\"></a>***. Sort  a linked list that is sorted alternating asc and desc</h3><h4 id=\"这题不是LC上的，是面经里的，要求将一个奇数位升序，偶数位降序的链表转成一个升序的链表。\"><a href=\"#这题不是LC上的，是面经里的，要求将一个奇数位升序，偶数位降序的链表转成一个升序的链表。\" class=\"headerlink\" title=\"这题不是LC上的，是面经里的，要求将一个奇数位升序，偶数位降序的链表转成一个升序的链表。\"></a>这题不是LC上的，是面经里的，要求将一个奇数位升序，偶数位降序的链表转成一个升序的链表。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input List:   10-&gt;40-&gt;53-&gt;30-&gt;67-&gt;12-&gt;89-&gt;NULL</span><br><span class=\"line\">Output List:  10-&gt;12-&gt;30-&gt;40-&gt;53-&gt;67-&gt;89-&gt;NULL</span><br></pre></td></tr></table></figure>\n<p>方法一：分别参考了328，206，21三题，但是有一个副作用，就是将输入的链表改变了，一开始我是想针对链表就地修改，但是发现最后合并的时候又不太好实现。</p>\n <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sort_alternating</span><span class=\"params\">(head: ListNode)</span> -&gt; ListNode:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> head:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"comment\"># separate two lists</span></span><br><span class=\"line\">    odd = head</span><br><span class=\"line\">    even_h = even = head.next</span><br><span class=\"line\">    <span class=\"keyword\">while</span> even <span class=\"keyword\">and</span> even.next:</span><br><span class=\"line\">        odd.next = odd.next.next</span><br><span class=\"line\">        odd = odd.next</span><br><span class=\"line\">        even.next = even.next.next</span><br><span class=\"line\">        even = even.next</span><br><span class=\"line\">    odd.next = <span class=\"literal\">None</span>   <span class=\"comment\"># for last even tail ！！</span></span><br><span class=\"line\">    <span class=\"comment\"># reverse the one with descending order</span></span><br><span class=\"line\">    prev = <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> even_h:</span><br><span class=\"line\">        even_h.next, prev, even_h = prev, even_h, even_h.next</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># merge both lists</span></span><br><span class=\"line\">    ans = h = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> head <span class=\"keyword\">and</span> prev:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> head.val &lt;= prev.val:</span><br><span class=\"line\">            h.next, head = head, head.next</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            h.next, prev = prev, prev.next</span><br><span class=\"line\">        h = h.next</span><br><span class=\"line\">    h.next = head <span class=\"keyword\">or</span> prev</span><br><span class=\"line\">    <span class=\"comment\"># head is not head original</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans.next</span><br></pre></td></tr></table></figure>\n<p>方法二：修改了方法一中的不足，在一开始就建立两个链表。两个链表要分开迭代才不会遗漏元素。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sort_alternating</span><span class=\"params\">(head: ListNode)</span> -&gt; ListNode:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> head:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"comment\"># separate two lists</span></span><br><span class=\"line\">    odd_head = odd_h = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">    even_head = even_h = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">    odd = head</span><br><span class=\"line\">    even = head.next</span><br><span class=\"line\">    <span class=\"keyword\">while</span> odd:</span><br><span class=\"line\">        odd_h.next = ListNode(odd.val)</span><br><span class=\"line\">        odd, odd_h = odd.next.next <span class=\"keyword\">if</span> odd.next <span class=\"keyword\">else</span> <span class=\"literal\">None</span>, odd_h.next</span><br><span class=\"line\">    <span class=\"keyword\">while</span> even:</span><br><span class=\"line\">        even_h.next = ListNode(even.val)</span><br><span class=\"line\">        even, even_h = even.next.next <span class=\"keyword\">if</span> even.next <span class=\"keyword\">else</span> <span class=\"literal\">None</span>, even_h.next</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># reverse the one with descending order</span></span><br><span class=\"line\">    prev = <span class=\"literal\">None</span></span><br><span class=\"line\">    odd_head, even_head = odd_head.next, even_head.next</span><br><span class=\"line\">    <span class=\"keyword\">while</span> even_head:</span><br><span class=\"line\">        even_head.next, prev, even_head = prev, even_head, even_head.next</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># merge both lists</span></span><br><span class=\"line\">    ans = h = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> odd_head <span class=\"keyword\">and</span> prev:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> odd_head.val &lt;= prev.val:</span><br><span class=\"line\">            h.next, odd_head = odd_head, odd_head.next</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            h.next, prev = prev, prev.next</span><br><span class=\"line\">        h = h.next</span><br><span class=\"line\">    h.next = odd_head <span class=\"keyword\">or</span> prev</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans.next</span><br></pre></td></tr></table></figure>\n<h3 id=\"148-Sort-List\"><a href=\"#148-Sort-List\" class=\"headerlink\" title=\"148. Sort List\"></a>148. Sort List</h3><h4 id=\"给链表排序。原题\"><a href=\"#给链表排序。原题\" class=\"headerlink\" title=\"给链表排序。原题\"></a>给链表排序。<a href=\"https://leetcode.com/problems/sort-list/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: 4-&gt;2-&gt;1-&gt;3</span><br><span class=\"line\">Output: 1-&gt;2-&gt;3-&gt;4</span><br></pre></td></tr></table></figure>\n<p>方法一：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sortList</span><span class=\"params\">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge_both</span><span class=\"params\">(l1, l2)</span>:</span></span><br><span class=\"line\">        l = h = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">while</span> l1 <span class=\"keyword\">and</span> l2:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> l1.val &lt;= l2.val:</span><br><span class=\"line\">                l.next, l1 = l1, l1.next</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                l.next, l2 = l2, l2.next</span><br><span class=\"line\">            l = l.next</span><br><span class=\"line\">        l.next = l1 <span class=\"keyword\">or</span> l2</span><br><span class=\"line\">        <span class=\"keyword\">return</span> h.next</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge_sort</span><span class=\"params\">(h)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> h <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> h.next:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> h</span><br><span class=\"line\">        slow = fast = h</span><br><span class=\"line\">        prev = <span class=\"literal\">None</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> fast <span class=\"keyword\">and</span> fast.next:</span><br><span class=\"line\">            prev, slow, fast = slow, slow.next, fast.next.next</span><br><span class=\"line\">        prev.next = <span class=\"literal\">None</span></span><br><span class=\"line\">        left = merge_sort(h)</span><br><span class=\"line\">        right = merge_sort(slow)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> merge_both(left, right)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> merge_sort(head)</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"4\">方法二：要求是常数空间复杂度实现，看到有人说递归栈也要算在空间内，那就只能写成迭代。迭代确实比较复杂这是评论区中的一个方法。这里是官方题解给的方法，写得很好了。大体思路和我想的差不多，返回尾节点的操作一开始想放到cut_list中而不是merge中。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sortList</span><span class=\"params\">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge_two</span><span class=\"params\">(l1, l2, pre)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> l1 <span class=\"keyword\">and</span> l2:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> l1.val &lt;= l2.val:</span><br><span class=\"line\">                pre.next, l1 = l1, l1.next</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                pre.next, l2 = l2, l2.next</span><br><span class=\"line\">            pre = pre.next</span><br><span class=\"line\">        pre.next = l1 <span class=\"keyword\">or</span> l2</span><br><span class=\"line\">        <span class=\"keyword\">while</span> pre.next: pre = pre.next</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pre</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">cut_list</span><span class=\"params\">(head, size)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(size<span class=\"number\">-1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> head: <span class=\"keyword\">break</span></span><br><span class=\"line\">            head = head.next</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> head: <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">        next_head, head.next = head.next, <span class=\"literal\">None</span>  <span class=\"comment\"># cut</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> next_head</span><br><span class=\"line\"></span><br><span class=\"line\">    dummy = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">    dummy.next, h = head, head</span><br><span class=\"line\">    length, d = <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> h:</span><br><span class=\"line\">        h = h.next</span><br><span class=\"line\">        length += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> d &lt; length:</span><br><span class=\"line\">        pre, h = dummy, dummy.next</span><br><span class=\"line\">        <span class=\"keyword\">while</span> h:</span><br><span class=\"line\">            left = h</span><br><span class=\"line\">            right = cut_list(left, d)</span><br><span class=\"line\">            h = cut_list(right, d)</span><br><span class=\"line\">            pre = merge_two(left, right, pre)</span><br><span class=\"line\">        d *= <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dummy.next</span><br></pre></td></tr></table></figure>\n<h3 id=\"817-Linked-List-Components\"><a href=\"#817-Linked-List-Components\" class=\"headerlink\" title=\"817. Linked List Components\"></a>817. Linked List Components</h3><h4 id=\"链表的组件。给定一个集合G，然后根据是否在G中分成若干部分，求连起来在G中的部分的个数。原题\"><a href=\"#链表的组件。给定一个集合G，然后根据是否在G中分成若干部分，求连起来在G中的部分的个数。原题\" class=\"headerlink\" title=\"链表的组件。给定一个集合G，然后根据是否在G中分成若干部分，求连起来在G中的部分的个数。原题\"></a>链表的组件。给定一个集合G，然后根据是否在G中分成若干部分，求连起来在G中的部分的个数。<a href=\"https://leetcode.com/problems/linked-list-components/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: </span><br><span class=\"line\">head: 0-&gt;1-&gt;2-&gt;3-&gt;4</span><br><span class=\"line\">G &#x3D; [0, 3, 1, 4]</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numComponents</span><span class=\"params\">(self, head: ListNode, G: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    SET_G = set(G)</span><br><span class=\"line\">    h = head</span><br><span class=\"line\">    count = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> h:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> h.val <span class=\"keyword\">in</span> SET_G:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (h.next <span class=\"keyword\">and</span> h.next.val <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> SET_G <span class=\"keyword\">or</span> </span><br><span class=\"line\">                <span class=\"keyword\">not</span> h.next):</span><br><span class=\"line\">                count += <span class=\"number\">1</span></span><br><span class=\"line\">        h = h.next</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count</span><br></pre></td></tr></table></figure>\n<h3 id=\"86-Partition-List\"><a href=\"#86-Partition-List\" class=\"headerlink\" title=\"86. Partition List\"></a>86. Partition List</h3><h4 id=\"链表分区，将比x小的节点放到前面，其余节点放到后面，并保持原有顺序。原题\"><a href=\"#链表分区，将比x小的节点放到前面，其余节点放到后面，并保持原有顺序。原题\" class=\"headerlink\" title=\"链表分区，将比x小的节点放到前面，其余节点放到后面，并保持原有顺序。原题\"></a>链表分区，将比x小的节点放到前面，其余节点放到后面，并保持原有顺序。<a href=\"https://leetcode.com/problems/partition-list/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: head &#x3D; 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x &#x3D; 3</span><br><span class=\"line\">Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</span><br></pre></td></tr></table></figure>\n<p>方法一：首次AC的方法。注意最后gt后面可能有残留的节点比如最后一个2.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">partition</span><span class=\"params\">(self, head: ListNode, x: int)</span> -&gt; ListNode:</span></span><br><span class=\"line\">    lt = letter = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">    gt = greater = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">    h = head</span><br><span class=\"line\">    <span class=\"keyword\">while</span> h:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> h.val &lt; x:</span><br><span class=\"line\">            lt.next = h</span><br><span class=\"line\">            lt = h</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            gt.next = h</span><br><span class=\"line\">            gt = h</span><br><span class=\"line\">        h = h.next</span><br><span class=\"line\">    gt.next = <span class=\"literal\">None</span>   <span class=\"comment\"># important !!</span></span><br><span class=\"line\">    lt.next = greater.next</span><br><span class=\"line\">    <span class=\"keyword\">return</span> letter.next</span><br></pre></td></tr></table></figure>\n<h3 id=\"61-Rotate-List\"><a href=\"#61-Rotate-List\" class=\"headerlink\" title=\"61. Rotate List\"></a>61. Rotate List</h3><h4 id=\"向右旋转链表k次。原题\"><a href=\"#向右旋转链表k次。原题\" class=\"headerlink\" title=\"向右旋转链表k次。原题\"></a>向右旋转链表k次。<a href=\"https://leetcode.com/problems/rotate-list/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: 0-&gt;1-&gt;2-&gt;NULL, k &#x3D; 4</span><br><span class=\"line\">Output: 2-&gt;0-&gt;1-&gt;NULL</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULL</span><br><span class=\"line\">rotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULL</span><br><span class=\"line\">rotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULL</span><br><span class=\"line\">rotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rotateRight</span><span class=\"params\">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class=\"line\">    n, cur, prev = <span class=\"number\">0</span>, head, <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> cur:</span><br><span class=\"line\">        n += <span class=\"number\">1</span></span><br><span class=\"line\">        prev, cur = cur, cur.next</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> n==<span class=\"number\">0</span> <span class=\"keyword\">or</span> k%n==<span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head</span><br><span class=\"line\">    k = k % n</span><br><span class=\"line\">    tail = head</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n-k<span class=\"number\">-1</span>):</span><br><span class=\"line\">        tail = tail.next</span><br><span class=\"line\">    ans, tail.next, prev.next = tail.next, <span class=\"literal\">None</span>, head</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"725-Split-Linked-List-in-Parts\"><a href=\"#725-Split-Linked-List-in-Parts\" class=\"headerlink\" title=\"725. Split Linked List in Parts\"></a>725. Split Linked List in Parts</h3><h4 id=\"按部分拆分链表。如果不能整除，要保证前面部分的大。原题\"><a href=\"#按部分拆分链表。如果不能整除，要保证前面部分的大。原题\" class=\"headerlink\" title=\"按部分拆分链表。如果不能整除，要保证前面部分的大。原题\"></a>按部分拆分链表。如果不能整除，要保证前面部分的大。<a href=\"https://leetcode.com/problems/split-linked-list-in-parts/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: </span><br><span class=\"line\">root &#x3D; [1, 2, 3], k &#x3D; 5</span><br><span class=\"line\">Output: [[1],[2],[3],[],[]]</span><br><span class=\"line\">Input: </span><br><span class=\"line\">root &#x3D; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k &#x3D; 3</span><br><span class=\"line\">Output: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">splitListToParts</span><span class=\"params\">(self, root: ListNode, k: int)</span> -&gt; List[ListNode]:</span></span><br><span class=\"line\">    n, cur = <span class=\"number\">0</span>, root</span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> cur:</span><br><span class=\"line\">        n += <span class=\"number\">1</span></span><br><span class=\"line\">        cur = cur.next</span><br><span class=\"line\">    parts, remain = divmod(n, k)</span><br><span class=\"line\">    h = root</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(k):</span><br><span class=\"line\">        head = h</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(parts<span class=\"number\">-1</span>+(i&lt;remain)):</span><br><span class=\"line\">            h = h.next</span><br><span class=\"line\">        <span class=\"keyword\">if</span> h:</span><br><span class=\"line\">            h.next, h = <span class=\"literal\">None</span>, h.next</span><br><span class=\"line\">        ans.append(head)                            </span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"143-Reorder-List\"><a href=\"#143-Reorder-List\" class=\"headerlink\" title=\"143. Reorder List\"></a>143. Reorder List</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reorderList</span><span class=\"params\">(self, head: ListNode)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> head:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> </span><br><span class=\"line\">    slow = fast = head</span><br><span class=\"line\">    <span class=\"keyword\">while</span> fast <span class=\"keyword\">and</span> fast.next:</span><br><span class=\"line\">        slow, fast = slow.next, fast.next.next</span><br><span class=\"line\">    </span><br><span class=\"line\">    tail, slow.next = slow.next, <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverse</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        prev = <span class=\"literal\">None</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> node:</span><br><span class=\"line\">            node.next, prev, node = prev, node, node.next</span><br><span class=\"line\">        <span class=\"keyword\">return</span> prev</span><br><span class=\"line\">    tail = reverse(tail)</span><br><span class=\"line\">    h = head</span><br><span class=\"line\">    <span class=\"keyword\">while</span> h <span class=\"keyword\">and</span> tail:</span><br><span class=\"line\">        h.next, tail.next, tail, h = tail, h.next, tail.next, h.next</span><br></pre></td></tr></table></figure>\n<h3 id=\"1030-Next-Greater-Node-In-Linked-List\"><a href=\"#1030-Next-Greater-Node-In-Linked-List\" class=\"headerlink\" title=\"1030. Next Greater Node In Linked List\"></a>1030. Next Greater Node In Linked List</h3><h4 id=\"链表中下一个比当前节点大的值。和503题类似。原题\"><a href=\"#链表中下一个比当前节点大的值。和503题类似。原题\" class=\"headerlink\" title=\"链表中下一个比当前节点大的值。和503题类似。原题\"></a>链表中下一个比当前节点大的值。和503题类似。<a href=\"https://leetcode.com/problems/next-greater-node-in-linked-list/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [2,7,4,3,5]</span><br><span class=\"line\">Output: [7,0,5,5,0]</span><br></pre></td></tr></table></figure>\n<p>方法一：竞赛时没有做出来，虽然是一个链表题，但是跟链表没啥关系。思路<code>vals</code>保存了之前所有节点的值，<code>stack</code>按序存的索引，当遍历一个新的节点时，不断地去和之前的节点比较，如果大于，那么久更新<code>ans</code>中的值，之前设为了0。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">nextLargerNodes</span><span class=\"params\">(self, head: ListNode)</span> -&gt; List[int]:</span></span><br><span class=\"line\">    stack, vals = [], []</span><br><span class=\"line\">    i, ans = <span class=\"number\">0</span>, []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> head:</span><br><span class=\"line\">        num = head.val</span><br><span class=\"line\">        vals.append(num)</span><br><span class=\"line\">        <span class=\"keyword\">while</span> stack <span class=\"keyword\">and</span> num &gt; vals[stack[<span class=\"number\">-1</span>]]:</span><br><span class=\"line\">            ans[stack.pop()] = num</span><br><span class=\"line\">        stack.append(i)</span><br><span class=\"line\">        ans.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">        i += <span class=\"number\">1</span></span><br><span class=\"line\">        head = head.next</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：去除方法一中无用的变量。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">nextLargerNodes</span><span class=\"params\">(self, head: ListNode)</span> -&gt; List[int]:</span></span><br><span class=\"line\">    ans, stack = [], []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> head:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> stack <span class=\"keyword\">and</span> stack[<span class=\"number\">-1</span>][<span class=\"number\">1</span>] &lt; head.val:</span><br><span class=\"line\">            ans[stack.pop()[<span class=\"number\">0</span>]] = head.val</span><br><span class=\"line\">        stack.append((len(ans), head.val))</span><br><span class=\"line\">        ans.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">        head = head.next</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"1171-Remove-Zero-Sum-Consecutive-Nodes-from-Linked-List\"><a href=\"#1171-Remove-Zero-Sum-Consecutive-Nodes-from-Linked-List\" class=\"headerlink\" title=\"1171. Remove Zero Sum Consecutive Nodes from Linked List\"></a>1171. Remove Zero Sum Consecutive Nodes from Linked List</h3><h4 id=\"移除相连和为0的节点。像祖玛一样，连续地删除。答案不唯一。原题\"><a href=\"#移除相连和为0的节点。像祖玛一样，连续地删除。答案不唯一。原题\" class=\"headerlink\" title=\"移除相连和为0的节点。像祖玛一样，连续地删除。答案不唯一。原题\"></a>移除相连和为0的节点。像祖玛一样，连续地删除。答案不唯一。<a href=\"https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: head &#x3D; [1,2,-3,3,1]</span><br><span class=\"line\">Output: [3,1]</span><br><span class=\"line\">Note: The answer [1,2,1] would also be accepted.</span><br></pre></td></tr></table></figure>\n<font color=\"#FF0000\" size=\"3\"><strong>方法一：使用字典记录和，当和出现重复的时候，说明其中的一段和为0。看了评论发现此题OJ有错误，<code>[1,3,2,-3,-2,5,5,-5,1]</code>结果为<code>[1,5,5,-5,1]</code>居然对了。</strong></font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removeZeroSumSublists</span><span class=\"params\">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class=\"line\">    p = dummy = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">    dummy.next = head</span><br><span class=\"line\">    s = <span class=\"number\">0</span></span><br><span class=\"line\">    vals = &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> p:</span><br><span class=\"line\">        s += p.val</span><br><span class=\"line\">        <span class=\"keyword\">if</span> s <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> vals:</span><br><span class=\"line\">            vals[s] = p</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            vals[s].next = p.next</span><br><span class=\"line\">        p = p.next</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dummy.next</span><br></pre></td></tr></table></figure>\n<p>仔细分析一下上述代码，再结果变成<code>[1,5,5,-5,1]</code>时，没有将vals中删除的节点清空。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removeZeroSumSublists</span><span class=\"params\">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class=\"line\">    p = dummy = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">    dummy.next = head</span><br><span class=\"line\">    s = <span class=\"number\">0</span></span><br><span class=\"line\">    s_sum = [s]</span><br><span class=\"line\">    vals = &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> p:</span><br><span class=\"line\">        s += p.val</span><br><span class=\"line\">        s_sum.append(s)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> s <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> vals:</span><br><span class=\"line\">            vals[s] = p</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            vals[s].next = p.next</span><br><span class=\"line\">            s_sum.pop() <span class=\"comment\"># remove cur, keep the last</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> s_sum[<span class=\"number\">-1</span>] != s:</span><br><span class=\"line\">                vals.pop(s_sum.pop())</span><br><span class=\"line\">        p = p.next</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dummy.next</span><br></pre></td></tr></table></figure>\n<h3 id=\"25-Reverse-Nodes-in-k-Group\"><a href=\"#25-Reverse-Nodes-in-k-Group\" class=\"headerlink\" title=\"25. Reverse Nodes in k-Group\"></a><a href=\"https://leetcode.com/problems/reverse-nodes-in-k-group/\" target=\"_blank\" rel=\"noopener\">25. Reverse Nodes in k-Group</a></h3><h4 id=\"链表中每k个为一组，反转，要求常数空间复杂度。长度不够则不反转。\"><a href=\"#链表中每k个为一组，反转，要求常数空间复杂度。长度不够则不反转。\" class=\"headerlink\" title=\"链表中每k个为一组，反转，要求常数空间复杂度。长度不够则不反转。\"></a>链表中每k个为一组，反转，要求常数空间复杂度。长度不够则不反转。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: head &#x3D; [1,2,3,4,5], k &#x3D; 2</span><br><span class=\"line\">Output: [2,1,4,3,5]</span><br><span class=\"line\">Input: head &#x3D; [1,2,3,4,5], k &#x3D; 3</span><br><span class=\"line\">Output: [3,2,1,4,5]</span><br></pre></td></tr></table></figure>\n<p>方法一：有点笨，fast指针被修改到前面去了，然后做了补偿，感觉笨笨的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseKGroup</span><span class=\"params\">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverse_node</span><span class=\"params\">(head, prev)</span>:</span></span><br><span class=\"line\">        h = head</span><br><span class=\"line\">        tail = prev</span><br><span class=\"line\">        <span class=\"keyword\">while</span> h <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> prev:</span><br><span class=\"line\">            h.next, tail, h = tail, h, h.next</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tail</span><br><span class=\"line\"></span><br><span class=\"line\">    dummy = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">    dummy.next = head</span><br><span class=\"line\">    slow = fast = dummy</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(k):</span><br><span class=\"line\">        fast = fast.next</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> fast:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> dummy.next</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> fast:</span><br><span class=\"line\">        slow.next = reverse_node(slow.next, fast.next)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(k<span class=\"number\">-1</span>):</span><br><span class=\"line\">            fast = fast.next</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> fast: <span class=\"keyword\">return</span> dummy.next</span><br><span class=\"line\">        <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(k):</span><br><span class=\"line\">            slow, fast = slow.next, fast.next</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> fast:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> dummy.next</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：多用点指针。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseKGroup</span><span class=\"params\">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class=\"line\">    dummy = jump = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">    dummy.next = l = r = head</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#         def print_node(h):</span></span><br><span class=\"line\"><span class=\"comment\">#             hh = h</span></span><br><span class=\"line\"><span class=\"comment\">#             res = []</span></span><br><span class=\"line\"><span class=\"comment\">#             while hh:</span></span><br><span class=\"line\"><span class=\"comment\">#                 res.append(str(hh.val))</span></span><br><span class=\"line\"><span class=\"comment\">#                 hh = hh.next</span></span><br><span class=\"line\"><span class=\"comment\">#             print('-&gt;'.join(res))</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">        count = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> r <span class=\"keyword\">and</span> count&lt;k:</span><br><span class=\"line\">            r = r.next</span><br><span class=\"line\">            count += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> count == k:</span><br><span class=\"line\">            prev, cur = r, l</span><br><span class=\"line\">            <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(k):</span><br><span class=\"line\">                cur.next, prev, cur = prev, cur, cur.next</span><br><span class=\"line\">            jump.next, jump, l = prev, l, r</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> dummy.next</span><br></pre></td></tr></table></figure>\n<p>###1798. Maximum Number of Consecutive Values You Can Make</p>\n<h4 id=\"使用数组中的任意数组成0开始的连续序列，最多能组成到几。\"><a href=\"#使用数组中的任意数组成0开始的连续序列，最多能组成到几。\" class=\"headerlink\" title=\"使用数组中的任意数组成0开始的连续序列，最多能组成到几。\"></a>使用数组中的任意数组成0开始的连续序列，最多能组成到几。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: coins &#x3D; [1,1,1,4]</span><br><span class=\"line\">Output: 8</span><br><span class=\"line\">Explanation: You can make the following values:</span><br><span class=\"line\">- 0: take []</span><br><span class=\"line\">- 1: take [1]</span><br><span class=\"line\">- 2: take [1,1]</span><br><span class=\"line\">- 3: take [1,1,1]</span><br><span class=\"line\">- 4: take [4]</span><br><span class=\"line\">- 5: take [4,1]</span><br><span class=\"line\">- 6: take [4,1,1]</span><br><span class=\"line\">- 7: take [4,1,1,1]</span><br><span class=\"line\">You can make 8 consecutive integer values starting from 0.</span><br></pre></td></tr></table></figure>\n<p>方法一：竞赛时最后5分钟绝杀了，排序，按照最小的数开始组，如果连不上，则组不成这个最小的数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getMaximumConsecutive</span><span class=\"params\">(self, coins: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    r = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> sorted(coins):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> num &gt; r + <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> r + <span class=\"number\">1</span></span><br><span class=\"line\">        r += num</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n","categories":["算法"],"tags":["LeetCode","Python","Algorithm","Linked List"]},{"title":"LeetCode算法题整理（设计篇）Design","url":"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E8%AE%BE%E8%AE%A1%E7%AF%87%EF%BC%89Design/","content":"<h3 id=\"155-Min-Stack\"><a href=\"#155-Min-Stack\" class=\"headerlink\" title=\"155. Min Stack\"></a>155. Min Stack</h3><h4 id=\"设计一个栈，要求在常数时间复杂度取出最小值。原题\"><a href=\"#设计一个栈，要求在常数时间复杂度取出最小值。原题\" class=\"headerlink\" title=\"设计一个栈，要求在常数时间复杂度取出最小值。原题\"></a>设计一个栈，要求在常数时间复杂度取出最小值。<a href=\"https://leetcode.com/problems/min-stack/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">MinStack minStack &#x3D; new MinStack();</span><br><span class=\"line\">minStack.push(-2);</span><br><span class=\"line\">minStack.push(0);</span><br><span class=\"line\">minStack.push(-3);</span><br><span class=\"line\">minStack.getMin();   --&gt; Returns -3.</span><br><span class=\"line\">minStack.pop();</span><br><span class=\"line\">minStack.top();      --&gt; Returns 0.</span><br><span class=\"line\">minStack.getMin();   --&gt; Returns -2.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MinStack</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self._stack = []</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">push</span><span class=\"params\">(self, x: int)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        cur_min = self.getMin()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> x &lt; cur_min:</span><br><span class=\"line\">            cur_min = x</span><br><span class=\"line\">        self._stack.append((x, cur_min))</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pop</span><span class=\"params\">(self)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        self._stack.pop()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">top</span><span class=\"params\">(self)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self._stack:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self._stack[<span class=\"number\">-1</span>][<span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getMin</span><span class=\"params\">(self)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self._stack:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> float(<span class=\"string\">'inf'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self._stack[<span class=\"number\">-1</span>][<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"232-Implement-Queue-using-Stacks\"><a href=\"#232-Implement-Queue-using-Stacks\" class=\"headerlink\" title=\"232. Implement Queue using Stacks\"></a>232. Implement Queue using Stacks</h3><h4 id=\"使用两个栈实现一个队列。原题\"><a href=\"#使用两个栈实现一个队列。原题\" class=\"headerlink\" title=\"使用两个栈实现一个队列。原题\"></a>使用两个栈实现一个队列。<a href=\"https://leetcode.com/problems/implement-queue-using-stacks/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">MyQueue queue &#x3D; new MyQueue();</span><br><span class=\"line\"></span><br><span class=\"line\">queue.push(1);</span><br><span class=\"line\">queue.push(2);  </span><br><span class=\"line\">queue.peek();  &#x2F;&#x2F; returns 1</span><br><span class=\"line\">queue.pop();   &#x2F;&#x2F; returns 1</span><br><span class=\"line\">queue.empty(); &#x2F;&#x2F; returns false</span><br></pre></td></tr></table></figure>\n<p>方法一：push-O(1), pop-O(N). </p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyQueue</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.in_stack, self.out_stack = [], []</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">push</span><span class=\"params\">(self, x: int)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        self.in_stack.append(x)</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">move</span><span class=\"params\">(self)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.out_stack == []:</span><br><span class=\"line\">            <span class=\"keyword\">while</span> self.in_stack:</span><br><span class=\"line\">                self.out_stack.append(self.in_stack.pop())</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pop</span><span class=\"params\">(self)</span> -&gt; int:</span></span><br><span class=\"line\">        self.move()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.out_stack.pop()</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">peek</span><span class=\"params\">(self)</span> -&gt; int:</span></span><br><span class=\"line\">        self.move()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.out_stack[<span class=\"number\">-1</span>]</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">empty</span><span class=\"params\">(self)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.in_stack==self.out_stack==[]</span><br></pre></td></tr></table></figure>\n<p>方法二：push-O(N), pop-O(1).</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyQueue</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.s1 = []</span><br><span class=\"line\">        self.s2 = []</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">push</span><span class=\"params\">(self, x: int)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> self.s1:</span><br><span class=\"line\">            self.s2.append(self.s1.pop())</span><br><span class=\"line\">        self.s1.append(x)</span><br><span class=\"line\">        <span class=\"keyword\">while</span> self.s2:</span><br><span class=\"line\">            self.s1.append(self.s2.pop())</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pop</span><span class=\"params\">(self)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.s1.pop()</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">peek</span><span class=\"params\">(self)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.s1[<span class=\"number\">-1</span>]</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">empty</span><span class=\"params\">(self)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.s1 == []</span><br></pre></td></tr></table></figure>\n<h3 id=\"225-Implement-Stack-using-Queues\"><a href=\"#225-Implement-Stack-using-Queues\" class=\"headerlink\" title=\"225. Implement Stack using Queues\"></a>225. Implement Stack using Queues</h3><h4 id=\"使用队列实现栈。原题\"><a href=\"#使用队列实现栈。原题\" class=\"headerlink\" title=\"使用队列实现栈。原题\"></a>使用队列实现栈。<a href=\"https://leetcode.com/problems/implement-stack-using-queues/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：两个队列，push-O(1), pop/top O(n). 思想在于q2就是一个临时队列，无论是是top还是pop都是保持q1剩一个元素，然后再交换q1, q2.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyStack</span>:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> deque</span><br><span class=\"line\">        self.q1, self.q2 = deque(), deque()</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">push</span><span class=\"params\">(self, x: int)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        self.q1.append(x)</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pop</span><span class=\"params\">(self)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> len(self.q1) != <span class=\"number\">1</span>:</span><br><span class=\"line\">            self.q2.append(self.q1.popleft())</span><br><span class=\"line\">        pop_val = self.q1.popleft()</span><br><span class=\"line\">        self.q1, self.q2 = self.q2, self.q1</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pop_val</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">top</span><span class=\"params\">(self)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> len(self.q1) != <span class=\"number\">1</span>:</span><br><span class=\"line\">            self.q2.append(self.q1.popleft())</span><br><span class=\"line\">        val = self.q1[<span class=\"number\">0</span>]</span><br><span class=\"line\">        self.q2.append(self.q1.popleft())</span><br><span class=\"line\">        self.q1, self.q2 = self.q2, self.q1</span><br><span class=\"line\">        <span class=\"keyword\">return</span> val</span><br><span class=\"line\">       </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">empty</span><span class=\"params\">(self)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">not</span> self.q1</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：两个队列，push-O(n), pop/top-O(1). </font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyStack</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> deque</span><br><span class=\"line\">        self.q1, self.q2 = deque(), deque()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">push</span><span class=\"params\">(self, x: int)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        self.q2.append(x)</span><br><span class=\"line\">        <span class=\"keyword\">while</span> self.q1:</span><br><span class=\"line\">            self.q2.append(self.q1.popleft())</span><br><span class=\"line\">        self.q1, self.q2 = self.q2, self.q1</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pop</span><span class=\"params\">(self)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.q1.popleft()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">top</span><span class=\"params\">(self)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.q1[<span class=\"number\">0</span>]</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">empty</span><span class=\"params\">(self)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">not</span> self.q1</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：一个队列旋转。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyStack</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> deque</span><br><span class=\"line\">        self.q = deque()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">push</span><span class=\"params\">(self, x: int)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        self.q.append(x)</span><br><span class=\"line\">        <span class=\"comment\"># self.q.rotate(1)  这里是用了双端队列的特性</span></span><br><span class=\"line\">        <span class=\"comment\"># self.q.rotate(1-len(self.q))  这里和下面循环是一样的效果</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(len(self.q)<span class=\"number\">-1</span>):</span><br><span class=\"line\">            self.q.append(self.q.popleft())</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pop</span><span class=\"params\">(self)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.q.popleft()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">top</span><span class=\"params\">(self)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.q[<span class=\"number\">0</span>]</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">empty</span><span class=\"params\">(self)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">not</span> self.q</span><br></pre></td></tr></table></figure>\n<h3 id=\"295-Find-Median-from-Data-Stream\"><a href=\"#295-Find-Median-from-Data-Stream\" class=\"headerlink\" title=\"295. Find Median from Data Stream\"></a>295. Find Median from Data Stream</h3><h4 id=\"找出数据流中的中位数。原题\"><a href=\"#找出数据流中的中位数。原题\" class=\"headerlink\" title=\"找出数据流中的中位数。原题\"></a>找出数据流中的中位数。<a href=\"https://leetcode.com/problems/find-median-from-data-stream/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>思路：使用两个堆，最大堆存储较小的数据，最小堆存储较大的数据。添加数字时，先添加到最大堆，然后最大堆返回一个最大的数字给最小堆，最后为了平衡，可能需要最小堆还给最大堆一个最小值，以保证最大堆的长度&gt;=最小堆的长度。由于headpq是最小堆，所以使用取反实现最大堆。添加数字：Time-O(logn)，取出中位数：Time-O(1)。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"code\"><pre><span class=\"line\">Adding number <span class=\"number\">41</span></span><br><span class=\"line\">MaxHeap lo: [<span class=\"number\">41</span>]           // MaxHeap stores the largest value at the top (index <span class=\"number\">0</span>)</span><br><span class=\"line\">MinHeap hi: []             // MinHeap stores the smallest value at the top (index <span class=\"number\">0</span>)</span><br><span class=\"line\">Median is <span class=\"number\">41</span></span><br><span class=\"line\">=======================</span><br><span class=\"line\">Adding number <span class=\"number\">35</span></span><br><span class=\"line\">MaxHeap lo: [<span class=\"number\">35</span>]</span><br><span class=\"line\">MinHeap hi: [<span class=\"number\">41</span>]</span><br><span class=\"line\">Median is <span class=\"number\">38</span></span><br><span class=\"line\">=======================</span><br><span class=\"line\">Adding number <span class=\"number\">62</span></span><br><span class=\"line\">MaxHeap lo: [<span class=\"number\">41</span>, <span class=\"number\">35</span>]</span><br><span class=\"line\">MinHeap hi: [<span class=\"number\">62</span>]</span><br><span class=\"line\">Median is <span class=\"number\">41</span></span><br><span class=\"line\">=======================</span><br><span class=\"line\">Adding number <span class=\"number\">4</span></span><br><span class=\"line\">MaxHeap lo: [<span class=\"number\">35</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\">MinHeap hi: [<span class=\"number\">41</span>, <span class=\"number\">62</span>]</span><br><span class=\"line\">Median is <span class=\"number\">38</span></span><br><span class=\"line\">=======================</span><br><span class=\"line\">Adding number <span class=\"number\">97</span></span><br><span class=\"line\">MaxHeap lo: [<span class=\"number\">41</span>, <span class=\"number\">35</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\">MinHeap hi: [<span class=\"number\">62</span>, <span class=\"number\">97</span>]</span><br><span class=\"line\">Median is <span class=\"number\">41</span></span><br><span class=\"line\">=======================</span><br><span class=\"line\">Adding number <span class=\"number\">108</span></span><br><span class=\"line\">MaxHeap lo: [<span class=\"number\">41</span>, <span class=\"number\">35</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\">MinHeap hi: [<span class=\"number\">62</span>, <span class=\"number\">97</span>, <span class=\"number\">108</span>]</span><br><span class=\"line\">Median is <span class=\"number\">51.5</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> heapq <span class=\"keyword\">as</span> hq</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MedianFinder</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.lo, self.hi = [], []  <span class=\"comment\"># lo is max_heap, hi is min_heap</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addNum</span><span class=\"params\">(self, num)</span>:</span></span><br><span class=\"line\">        hq.heappush(self.lo, -num)</span><br><span class=\"line\">        hq.heappush(self.hi, -hq.heappop(self.lo))</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(self.lo) &lt; len(self.hi):</span><br><span class=\"line\">            hq.heappush(self.lo, -hq.heappop(self.hi))       </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findMedian</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(self.lo) == len(self.hi):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (-self.lo[<span class=\"number\">0</span>]+self.hi[<span class=\"number\">0</span>]) / <span class=\"number\">2.0</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> float(-self.lo[<span class=\"number\">0</span>])</span><br></pre></td></tr></table></figure>\n<h3 id=\"480-Sliding-Window-Median\"><a href=\"#480-Sliding-Window-Median\" class=\"headerlink\" title=\"480. Sliding Window Median\"></a><a href=\"https://leetcode.com/problems/sliding-window-median/\" target=\"_blank\" rel=\"noopener\">480. Sliding Window Median</a></h3><h4 id=\"滑动窗口中的中位数。这题基于295的思想，但是要比其难处理的多。\"><a href=\"#滑动窗口中的中位数。这题基于295的思想，但是要比其难处理的多。\" class=\"headerlink\" title=\"滑动窗口中的中位数。这题基于295的思想，但是要比其难处理的多。\"></a>滑动窗口中的中位数。这题基于295的思想，但是要比其难处理的多。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Window position                Median</span><br><span class=\"line\">---------------               -----</span><br><span class=\"line\">[1  3  -1] -3  5  3  6  7       1</span><br><span class=\"line\"> 1 [3  -1  -3] 5  3  6  7       -1</span><br><span class=\"line\"> 1  3 [-1  -3  5] 3  6  7       -1</span><br><span class=\"line\"> 1  3  -1 [-3  5  3] 6  7       3</span><br><span class=\"line\"> 1  3  -1  -3 [5  3  6] 7       5</span><br><span class=\"line\"> 1  3  -1  -3  5 [3  6  7]      6</span><br></pre></td></tr></table></figure>\n<p>方法一：我自己的思路是到了最大堆最小堆，不知道如何删除左侧窗口废弃的元素。看了讨论区知道了，要把索引加进去，但是当一个废弃的索引， 不在堆首无法将其剔除时，就是影响两个堆的长度，那么从而影响中位数的判断。这是这段代码的核心。首先，不能够像295那样，通过两个堆的长度来平衡，因为堆中可能含有废弃的元素，这里使用的是懒删除。然后尽量保证hi 即最小堆的长度较大，当要删除一个数时，判断这个数是在最大堆还是最小堆。如果是在lo中，则从hi补齐一个元素到lo中，因为平衡两个堆时不考虑将来要被删除的元素。20~27行是这段代码能正常运作的核心。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">medianSlidingWindow</span><span class=\"params\">(self, nums: List[int], k: int)</span> -&gt; List[float]:</span></span><br><span class=\"line\">    lo, hi  = [], [(n, i) <span class=\"keyword\">for</span> i, n <span class=\"keyword\">in</span> enumerate(nums[:k])]  <span class=\"comment\"># lo is maxheap, hi is minheap</span></span><br><span class=\"line\">    heapq.heapify(hi)</span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_med</span><span class=\"params\">(odd=True)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> odd:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> hi[<span class=\"number\">0</span>][<span class=\"number\">0</span>]</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (-lo[<span class=\"number\">0</span>][<span class=\"number\">0</span>] + hi[<span class=\"number\">0</span>][<span class=\"number\">0</span>]) / <span class=\"number\">2</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">move</span><span class=\"params\">(h1, h2)</span>:</span></span><br><span class=\"line\">        x, i = heapq.heappop(h1)</span><br><span class=\"line\">        heapq.heappush(h2, (-x, i))</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(k//<span class=\"number\">2</span>): </span><br><span class=\"line\">        move(hi, lo)</span><br><span class=\"line\">    <span class=\"comment\"># print(lo, hi)</span></span><br><span class=\"line\">    ans.append(get_med(k&amp;<span class=\"number\">1</span>))</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, n <span class=\"keyword\">in</span> enumerate(nums[k:], k):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &gt;= hi[<span class=\"number\">0</span>][<span class=\"number\">0</span>]:</span><br><span class=\"line\">            heapq.heappush(hi, (n, i))</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i-k] &lt;= hi[<span class=\"number\">0</span>][<span class=\"number\">0</span>]:</span><br><span class=\"line\">                move(hi, lo)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            heapq.heappush(lo, (-n, i))</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i-k] &gt;= hi[<span class=\"number\">0</span>][<span class=\"number\">0</span>]:</span><br><span class=\"line\">                move(lo, hi)</span><br><span class=\"line\">        <span class=\"keyword\">while</span> lo <span class=\"keyword\">and</span> lo[<span class=\"number\">0</span>][<span class=\"number\">1</span>] &lt;= i-k:</span><br><span class=\"line\">            heapq.heappop(lo)</span><br><span class=\"line\">        <span class=\"keyword\">while</span> hi <span class=\"keyword\">and</span> hi[<span class=\"number\">0</span>][<span class=\"number\">1</span>] &lt;= i-k:</span><br><span class=\"line\">            heapq.heappop(hi)</span><br><span class=\"line\">        <span class=\"comment\"># print(lo, hi)</span></span><br><span class=\"line\">        ans.append(get_med(k&amp;<span class=\"number\">1</span>))</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法二：还是stefan的方法好，比赛能做出来起码。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">medianSlidingWindow</span><span class=\"params\">(self, nums: List[int], k: int)</span> -&gt; List[float]:</span></span><br><span class=\"line\">    window = sorted(nums[:k])</span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> zip(nums, nums[k:] + [<span class=\"number\">0</span>]):</span><br><span class=\"line\">        ans.append((window[k//<span class=\"number\">2</span>]+window[~k//<span class=\"number\">2</span>]) / <span class=\"number\">2</span>)</span><br><span class=\"line\">        window.remove(a)</span><br><span class=\"line\">        bisect.insort(window, b)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：<code>bisect.insort</code>的时间复杂度为O(n)。这里使用SortedList可以优化到O(logn)。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">medianSlidingWindow</span><span class=\"params\">(self, nums: List[int], k: int)</span> -&gt; List[float]:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> sortedcontainers <span class=\"keyword\">import</span> SortedList</span><br><span class=\"line\">    window = SortedList(nums[:k])</span><br><span class=\"line\">    res = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> zip(nums, nums[k:]+[<span class=\"number\">0</span>]):</span><br><span class=\"line\">        res.append((window[k//<span class=\"number\">2</span>]+window[~k//<span class=\"number\">2</span>]) / <span class=\"number\">2</span>)</span><br><span class=\"line\">        window.remove(a)</span><br><span class=\"line\">        window.add(b)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"535-Encode-and-Decode-TinyURL\"><a href=\"#535-Encode-and-Decode-TinyURL\" class=\"headerlink\" title=\"535. Encode and Decode TinyURL\"></a>535. Encode and Decode TinyURL</h3><h4 id=\"设计一个短链接。原题\"><a href=\"#设计一个短链接。原题\" class=\"headerlink\" title=\"设计一个短链接。原题\"></a>设计一个短链接。<a href=\"https://leetcode.com/problems/encode-and-decode-tinyurl/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Codec</span>:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    BASE = <span class=\"number\">62</span></span><br><span class=\"line\">    UPPERCASE_OFFSET = <span class=\"number\">55</span></span><br><span class=\"line\">    LOWERCASE_OFFSET = <span class=\"number\">61</span></span><br><span class=\"line\">    DIGIT_OFFSET = <span class=\"number\">48</span></span><br><span class=\"line\">    num_sender = <span class=\"number\">0</span></span><br><span class=\"line\">    url = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">encode</span><span class=\"params\">(self, longUrl)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"Encodes a URL to a shortened URL.</span></span><br><span class=\"line\"><span class=\"string\">        </span></span><br><span class=\"line\"><span class=\"string\">        :type longUrl: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> Codec.num_sender == <span class=\"number\">0</span>:</span><br><span class=\"line\">            Codec.url[Codec.num_sender] = longUrl</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">'0'</span></span><br><span class=\"line\">        s_url = <span class=\"string\">''</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> Codec.num_sender &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            tail = Codec.num_sender % Codec.BASE</span><br><span class=\"line\">            s_url = self.parse_chr(tail) + s_url</span><br><span class=\"line\">            Codec.num_sender //= Codec.BASE</span><br><span class=\"line\">        </span><br><span class=\"line\">        Codec.url[Codec.num_sender] = longUrl</span><br><span class=\"line\">        Codec.num_sender += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> s_url</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decode</span><span class=\"params\">(self, shortUrl)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"Decodes a shortened URL to its original URL.</span></span><br><span class=\"line\"><span class=\"string\">        </span></span><br><span class=\"line\"><span class=\"string\">        :type shortUrl: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        num = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, char <span class=\"keyword\">in</span> enumerate(reversed(shortUrl)):</span><br><span class=\"line\">            num += self.parse_ord(char) * (Codec.BASE**i)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Codec.url[num]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse_ord</span><span class=\"params\">(self, char)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> char.isdigit():</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ord(char) - Codec.DIGIT_OFFSET</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> char.islower():</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ord(char) - Codec.LOWERCASE_OFFSET</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> char.isupper():</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ord(char) - Codec.UPPERCASE_OFFSET</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">'%s is not a valid character'</span> % char)</span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse_chr</span><span class=\"params\">(self, integer)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> integer &lt; <span class=\"number\">10</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> chr(integer + DIGIT_OFFSET)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> <span class=\"number\">10</span> &lt;= integer &lt;= <span class=\"number\">35</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> chr(integer + UPPERCASE_OFFSET)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> <span class=\"number\">36</span> &lt;= integer &lt; <span class=\"number\">62</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> chr(integer + LOWERCASE_OFFSET)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">'%d is not a valid integer in the range of base %d'</span> % (integer, Codec.BASE))</span><br></pre></td></tr></table></figure>\n<p>方法二：使用字典保存。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Codec</span>:</span></span><br><span class=\"line\">    BASE = <span class=\"number\">62</span></span><br><span class=\"line\">    num_sender = <span class=\"number\">0</span></span><br><span class=\"line\">    ALNUM = string.ascii_letters + <span class=\"string\">'0123456789'</span></span><br><span class=\"line\">    d_map = &#123;c: i <span class=\"keyword\">for</span> i, c <span class=\"keyword\">in</span> enumerate(ALNUM)&#125;</span><br><span class=\"line\">    url = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">encode</span><span class=\"params\">(self, longUrl)</span>:</span></span><br><span class=\"line\">        pk = Codec.num_sender</span><br><span class=\"line\">        s_url = <span class=\"string\">''</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> pk &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            pk, tail = divmod(pk, Codec.BASE)</span><br><span class=\"line\">            s_url = Codec.ALNUM[tail] + s_url</span><br><span class=\"line\"></span><br><span class=\"line\">        Codec.url[pk] = longUrl</span><br><span class=\"line\">        Codec.num_sender += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> pk == <span class=\"number\">0</span>:</span><br><span class=\"line\">            s_url = Codec.ALNUM[<span class=\"number\">0</span>]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s_url </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decode</span><span class=\"params\">(self, shortUrl)</span>:</span></span><br><span class=\"line\">        pk = sum(Codec.d_map[c]*Codec.BASE**i </span><br><span class=\"line\">                 <span class=\"keyword\">for</span> i, c <span class=\"keyword\">in</span> enumerate(reversed(shortUrl)))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Codec.url[pk]</span><br></pre></td></tr></table></figure>\n<h3 id=\"707-Design-Linked-List\"><a href=\"#707-Design-Linked-List\" class=\"headerlink\" title=\"707. Design Linked List\"></a>707. Design Linked List</h3><h4 id=\"设计一个链表。原题\"><a href=\"#设计一个链表。原题\" class=\"headerlink\" title=\"设计一个链表。原题\"></a>设计一个链表。<a href=\"https://leetcode.com/problems/design-linked-list/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">MyLinkedList linkedList &#x3D; new MyLinkedList();</span><br><span class=\"line\">linkedList.addAtHead(1);</span><br><span class=\"line\">linkedList.addAtTail(3);</span><br><span class=\"line\">linkedList.addAtIndex(1, 2);  &#x2F;&#x2F; linked list becomes 1-&gt;2-&gt;3</span><br><span class=\"line\">linkedList.get(1);            &#x2F;&#x2F; returns 2</span><br><span class=\"line\">linkedList.deleteAtIndex(1);  &#x2F;&#x2F; now the linked list is 1-&gt;3</span><br><span class=\"line\">linkedList.get(1);            &#x2F;&#x2F; returns 3</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ListNode</span>:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, val)</span>:</span></span><br><span class=\"line\">        self.val = val</span><br><span class=\"line\">        self.next = <span class=\"literal\">None</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyLinkedList</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.head = <span class=\"literal\">None</span></span><br><span class=\"line\">        self.size = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get</span><span class=\"params\">(self, index: <span class=\"string\">'int'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> index &lt; <span class=\"number\">0</span> <span class=\"keyword\">or</span> index &gt;= self.size <span class=\"keyword\">or</span> \\</span><br><span class=\"line\">            self.head <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.findIndex(index).val</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addAtHead</span><span class=\"params\">(self, val: <span class=\"string\">'int'</span>)</span> -&gt; '<span class=\"keyword\">None</span>':</span></span><br><span class=\"line\">        self.addAtIndex(<span class=\"number\">0</span>, val)</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addAtTail</span><span class=\"params\">(self, val: <span class=\"string\">'int'</span>)</span> -&gt; '<span class=\"keyword\">None</span>':</span></span><br><span class=\"line\">        self.addAtIndex(self.size, val)</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addAtIndex</span><span class=\"params\">(self, index: <span class=\"string\">'int'</span>, val: <span class=\"string\">'int'</span>)</span> -&gt; '<span class=\"keyword\">None</span>':</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> index &gt; self.size:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> index == <span class=\"number\">0</span>:</span><br><span class=\"line\">            head = ListNode(val)</span><br><span class=\"line\">            head.next, self.head = self.head, head</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            pre = self.findIndex(index<span class=\"number\">-1</span>)</span><br><span class=\"line\">            cur = ListNode(val)</span><br><span class=\"line\">            cur.next, pre.next = pre.next, cur</span><br><span class=\"line\">        self.size += <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">deleteAtIndex</span><span class=\"params\">(self, index: <span class=\"string\">'int'</span>)</span> -&gt; '<span class=\"keyword\">None</span>':</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> index &lt; <span class=\"number\">0</span> <span class=\"keyword\">or</span> index &gt;= self.size:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        cur = self.findIndex(index<span class=\"number\">-1</span>)</span><br><span class=\"line\">        cur.next = cur.next.next</span><br><span class=\"line\">        self.size -= <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findIndex</span><span class=\"params\">(self, index: <span class=\"string\">'int'</span>)</span> -&gt; '<span class=\"keyword\">None</span>':</span></span><br><span class=\"line\">        cur = self.head</span><br><span class=\"line\">        <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(index):</span><br><span class=\"line\">            cur = cur.next</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cur</span><br></pre></td></tr></table></figure>\n<h3 id=\"146-LRU-Cache\"><a href=\"#146-LRU-Cache\" class=\"headerlink\" title=\"146. LRU Cache\"></a>146. LRU Cache</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">LRUCache cache &#x3D; new LRUCache( 2 &#x2F;* capacity *&#x2F; );</span><br><span class=\"line\"></span><br><span class=\"line\">cache.put(1, 1);</span><br><span class=\"line\">cache.put(2, 2);</span><br><span class=\"line\">cache.get(1);       &#x2F;&#x2F; returns 1</span><br><span class=\"line\">cache.put(3, 3);    &#x2F;&#x2F; evicts key 2</span><br><span class=\"line\">cache.get(2);       &#x2F;&#x2F; returns -1 (not found)</span><br><span class=\"line\">cache.put(4, 4);    &#x2F;&#x2F; evicts key 1</span><br><span class=\"line\">cache.get(1);       &#x2F;&#x2F; returns -1 (not found)</span><br><span class=\"line\">cache.get(3);       &#x2F;&#x2F; returns 3</span><br><span class=\"line\">cache.get(4);       &#x2F;&#x2F; returns 4</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法一：使用<code>OrderedDict</code>. </font>\n\n<p>开始有两个<code>testcase</code>没过，一个是<code>{2: 3, 1: 1}</code>更新2时，和<code>{1: 1, 2: 3}</code>更新2时，二者都可以使用先pop再更新的方式。remain的方式是从discuss学来的，之前还用<code>len</code>或额外的<code>size</code>来保存。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LRUCache</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, capacity: <span class=\"string\">'int'</span>)</span>:</span></span><br><span class=\"line\">        self.cache = collections.OrderedDict()</span><br><span class=\"line\">        self.remain = capacity</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get</span><span class=\"params\">(self, key: <span class=\"string\">'int'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> key <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> self.cache:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        self.cache.move_to_end(key)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.cache.get(key)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">put</span><span class=\"params\">(self, key: <span class=\"string\">'int'</span>, value: <span class=\"string\">'int'</span>)</span> -&gt; '<span class=\"keyword\">None</span>':</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> key <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> self.cache:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.remain &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                self.remain -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                self.cache.popitem(last=<span class=\"literal\">False</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            self.cache.pop(key)</span><br><span class=\"line\">        self.cache[key] = value</span><br></pre></td></tr></table></figure>\n<p>方法二：不使用OrderedDict</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DLinkedNode</span>:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, key=<span class=\"number\">0</span>, value=<span class=\"number\">0</span>)</span>:</span></span><br><span class=\"line\">        self.key = key</span><br><span class=\"line\">        self.val = value</span><br><span class=\"line\">        self.next = <span class=\"literal\">None</span></span><br><span class=\"line\">        self.prev = <span class=\"literal\">None</span></span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"comment\">#     def __repr__(self):</span></span><br><span class=\"line\"><span class=\"comment\">#         return '&lt;DLinkedNode: (&#123;&#125;, &#123;&#125;)&gt;'.format(self.key, self.val)</span></span><br><span class=\"line\">        </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DLinkedList</span>:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.head = DLinkedNode()</span><br><span class=\"line\">        self.tail = DLinkedNode()</span><br><span class=\"line\">        self.head.next, self.tail.prev = self.tail, self.head</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_node</span><span class=\"params\">(self, node)</span>:</span></span><br><span class=\"line\">        node.prev, node.next = self.head, self.head.next</span><br><span class=\"line\">        node.next.prev, node.prev.next = node, node</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">remove_node</span><span class=\"params\">(self, node)</span>:</span></span><br><span class=\"line\">        node.prev.next, node.next.prev = node.next, node.prev</span><br><span class=\"line\">        <span class=\"keyword\">return</span> node.key</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">remove_tail</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        key = self.tail.prev.key</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.remove_node(self.tail.prev)</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">move_to_head</span><span class=\"params\">(self, node)</span>:</span></span><br><span class=\"line\">        self.remove_node(node)</span><br><span class=\"line\">        self.add_node(node)</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"comment\"># def __repr__(self):</span></span><br><span class=\"line\">    <span class=\"comment\">#     ans = []</span></span><br><span class=\"line\">    <span class=\"comment\">#     h = self.head</span></span><br><span class=\"line\">    <span class=\"comment\">#     while h:</span></span><br><span class=\"line\">    <span class=\"comment\">#         ans.append(str(h.val))</span></span><br><span class=\"line\">    <span class=\"comment\">#         h = h.next</span></span><br><span class=\"line\">    <span class=\"comment\">#     return '&lt;DLinkedList: &#123;&#125;&gt;'.format('-&gt;'.join(ans))</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LRUCache</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, capacity: int)</span>:</span></span><br><span class=\"line\">        self.capacity = capacity</span><br><span class=\"line\">        self.nodes = &#123;&#125;</span><br><span class=\"line\">        self.cache = DLinkedList()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get</span><span class=\"params\">(self, key: int)</span> -&gt; int:</span></span><br><span class=\"line\">        node = self.nodes.get(key, <span class=\"literal\">None</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            self.cache.move_to_head(node)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> node.val</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">put</span><span class=\"params\">(self, key: int, value: int)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        node = self.nodes.get(key, <span class=\"literal\">None</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.capacity &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                self.capacity -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                rm_key = self.cache.remove_tail()</span><br><span class=\"line\">                self.nodes.pop(rm_key)</span><br><span class=\"line\">            new_node = DLinkedNode(key, value)</span><br><span class=\"line\">            self.nodes[key] = new_node</span><br><span class=\"line\">            self.cache.add_node(new_node)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            self.cache.move_to_head(node)</span><br><span class=\"line\">            node.val = value</span><br></pre></td></tr></table></figure>\n<h3 id=\"460-LFU-Cache\"><a href=\"#460-LFU-Cache\" class=\"headerlink\" title=\"460. LFU Cache\"></a><a href=\"https://leetcode.com/problems/lfu-cache/\" target=\"_blank\" rel=\"noopener\">460. LFU Cache</a></h3><h4 id=\"设计一个LFU缓存。\"><a href=\"#设计一个LFU缓存。\" class=\"headerlink\" title=\"设计一个LFU缓存。\"></a>设计一个LFU缓存。</h4><p>方法一：简单地看了一下题解后，写了半个下午。需要考虑的地方确实很多。其它的地方都还好，关于<code>min_freq</code>的更新处踩了一个坑，就是必须得是当前最小的空了以后，再更新它。为了兼容capacity为0的情况，在DLinkedList中添加了count变量。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DLinkedNode</span>:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, key=<span class=\"number\">0</span>, value=<span class=\"number\">0</span>, freq=<span class=\"number\">1</span>)</span>:</span></span><br><span class=\"line\">        self.key = key</span><br><span class=\"line\">        self.val = value</span><br><span class=\"line\">        self.freq = freq</span><br><span class=\"line\">        self.next = <span class=\"literal\">None</span></span><br><span class=\"line\">        self.prev = <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DLinkedList</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.count = <span class=\"number\">0</span></span><br><span class=\"line\">        self.head = DLinkedNode()</span><br><span class=\"line\">        self.tail = DLinkedNode()</span><br><span class=\"line\">        self.head.next, self.tail.prev = self.tail, self.head</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_node</span><span class=\"params\">(self, node)</span>:</span></span><br><span class=\"line\">        self.count += <span class=\"number\">1</span></span><br><span class=\"line\">        node.prev, node.next = self.head, self.head.next</span><br><span class=\"line\">        node.next.prev, self.head.next = node, node</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">remove_node</span><span class=\"params\">(self, node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.count &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            self.count -= <span class=\"number\">1</span></span><br><span class=\"line\">            node.prev.next = node.next</span><br><span class=\"line\">            node.next.prev = node.prev</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">remove_tail</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        key = self.tail.prev.key</span><br><span class=\"line\">        self.remove_node(self.tail.prev)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> key</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_empty</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.count == <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LFUCache</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, capacity: int)</span>:</span></span><br><span class=\"line\">        self.capacity = capacity</span><br><span class=\"line\">        self.min_freq = <span class=\"number\">1</span></span><br><span class=\"line\">        self.freq_map = defaultdict(DLinkedList)</span><br><span class=\"line\">        self.key_map = &#123;&#125;</span><br><span class=\"line\">        self.is_empty = capacity==<span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get</span><span class=\"params\">(self, key: int)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.is_empty: <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        node = self.key_map.get(key, <span class=\"literal\">None</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            self.increase_freq(node)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> node.val</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">put</span><span class=\"params\">(self, key: int, value: int)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.is_empty: <span class=\"keyword\">return</span> </span><br><span class=\"line\">        node = self.key_map.get(key, <span class=\"literal\">None</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.capacity &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                self.capacity -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                r_key = self.freq_map[self.min_freq].remove_tail()</span><br><span class=\"line\">                self.key_map.pop(r_key, <span class=\"number\">-1</span>)</span><br><span class=\"line\">                </span><br><span class=\"line\">            new_node = DLinkedNode(key, value)</span><br><span class=\"line\">            self.freq_map[<span class=\"number\">1</span>].add_node(new_node)</span><br><span class=\"line\">            self.min_freq = <span class=\"number\">1</span></span><br><span class=\"line\">            self.key_map[key] = new_node</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            node.val = value</span><br><span class=\"line\">            self.increase_freq(node)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">increase_freq</span><span class=\"params\">(self, node)</span>:</span></span><br><span class=\"line\">        freq = node.freq</span><br><span class=\"line\">        self.freq_map[freq].remove_node(node)</span><br><span class=\"line\">        freq += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.freq_map[freq<span class=\"number\">-1</span>].is_empty():</span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.min_freq == freq - <span class=\"number\">1</span>:</span><br><span class=\"line\">                self.min_freq = freq</span><br><span class=\"line\">        node.freq = freq</span><br><span class=\"line\">        self.freq_map[freq].add_node(node)</span><br></pre></td></tr></table></figure>\n<h3 id=\"1381-Design-a-Stack-With-Increment-Operation\"><a href=\"#1381-Design-a-Stack-With-Increment-Operation\" class=\"headerlink\" title=\"1381. Design a Stack With Increment Operation\"></a>1381. Design a Stack With Increment Operation</h3><h4 id=\"设计一个栈，实现一个将k个栈底元素全部增加val的方法。原题\"><a href=\"#设计一个栈，实现一个将k个栈底元素全部增加val的方法。原题\" class=\"headerlink\" title=\"设计一个栈，实现一个将k个栈底元素全部增加val的方法。原题\"></a>设计一个栈，实现一个将k个栈底元素全部增加val的方法。<a href=\"https://leetcode.com/problems/design-a-stack-with-increment-operation/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input</span><br><span class=\"line\">[&quot;CustomStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;pop&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;increment&quot;,&quot;increment&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;]</span><br><span class=\"line\">[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]</span><br><span class=\"line\">Output</span><br><span class=\"line\">[null,null,null,2,null,null,null,null,null,103,202,201,-1]</span><br><span class=\"line\">Explanation</span><br><span class=\"line\">CustomStack customStack &#x3D; new CustomStack(3); &#x2F;&#x2F; Stack is Empty []</span><br><span class=\"line\">customStack.push(1);                          &#x2F;&#x2F; stack becomes [1]</span><br><span class=\"line\">customStack.push(2);                          &#x2F;&#x2F; stack becomes [1, 2]</span><br><span class=\"line\">customStack.pop();                            &#x2F;&#x2F; return 2 --&gt; Return top of the stack 2, stack becomes [1]</span><br><span class=\"line\">customStack.push(2);                          &#x2F;&#x2F; stack becomes [1, 2]</span><br><span class=\"line\">customStack.push(3);                          &#x2F;&#x2F; stack becomes [1, 2, 3]</span><br><span class=\"line\">customStack.push(4);                          &#x2F;&#x2F; stack still [1, 2, 3], Don&#39;t add another elements as size is 4</span><br><span class=\"line\">customStack.increment(5, 100);                &#x2F;&#x2F; stack becomes [101, 102, 103]</span><br><span class=\"line\">customStack.increment(2, 100);                &#x2F;&#x2F; stack becomes [201, 202, 103]</span><br><span class=\"line\">customStack.pop();                            &#x2F;&#x2F; return 103 --&gt; Return top of the stack 103, stack becomes [201, 202]</span><br><span class=\"line\">customStack.pop();                            &#x2F;&#x2F; return 202 --&gt; Return top of the stack 102, stack becomes [201]</span><br><span class=\"line\">customStack.pop();                            &#x2F;&#x2F; return 201 --&gt; Return top of the stack 101, stack becomes []</span><br><span class=\"line\">customStack.pop();                            &#x2F;&#x2F; return -1 --&gt; Stack is empty return -1.</span><br></pre></td></tr></table></figure>\n<p>方法一：普通的方法不记录了，这里学到一个延迟增加的方法。因为值的增加只有在<code>pop</code>的时候才会体现，所以维护了一个<code>inc</code>用来累加增加的值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomStack</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, maxSize: int)</span>:</span></span><br><span class=\"line\">        self.stack = []</span><br><span class=\"line\">        self.max_size = maxSize</span><br><span class=\"line\">        self.inc = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">push</span><span class=\"params\">(self, x: int)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(self.stack) &lt; self.max_size:</span><br><span class=\"line\">            self.stack.append(x)</span><br><span class=\"line\">            self.inc.append(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pop</span><span class=\"params\">(self)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self.stack: <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(self.inc) &gt; <span class=\"number\">1</span>:</span><br><span class=\"line\">            self.inc[<span class=\"number\">-2</span>] += self.inc[<span class=\"number\">-1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.inc.pop() + self.stack.pop()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">increment</span><span class=\"params\">(self, k: int, val: int)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.inc:</span><br><span class=\"line\">            self.inc[min(k, len(self.inc))<span class=\"number\">-1</span>] += val</span><br></pre></td></tr></table></figure>\n<h3 id=\"208-Implement-Trie-Prefix-Tree\"><a href=\"#208-Implement-Trie-Prefix-Tree\" class=\"headerlink\" title=\"208. Implement Trie (Prefix Tree)\"></a>208. Implement Trie (Prefix Tree)</h3><h4 id=\"实现一个单词查找树。原题\"><a href=\"#实现一个单词查找树。原题\" class=\"headerlink\" title=\"实现一个单词查找树。原题\"></a>实现一个单词查找树。<a href=\"https://leetcode.com/problems/implement-trie-prefix-tree/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Trie trie &#x3D; new Trie();</span><br><span class=\"line\"></span><br><span class=\"line\">trie.insert(&quot;apple&quot;);</span><br><span class=\"line\">trie.search(&quot;apple&quot;);   &#x2F;&#x2F; returns true</span><br><span class=\"line\">trie.search(&quot;app&quot;);     &#x2F;&#x2F; returns false</span><br><span class=\"line\">trie.startsWith(&quot;app&quot;); &#x2F;&#x2F; returns true</span><br><span class=\"line\">trie.insert(&quot;app&quot;);   </span><br><span class=\"line\">trie.search(&quot;app&quot;);     &#x2F;&#x2F; returns true</span><br></pre></td></tr></table></figure>\n<p>方法一：我的常规节点方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TrieNode</span>:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.child = collections.defaultdict(TrieNode)</span><br><span class=\"line\">        self.is_word = <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Trie</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.root = TrieNode()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">insert</span><span class=\"params\">(self, word: str)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        cur = self.root</span><br><span class=\"line\">        <span class=\"keyword\">for</span> letter <span class=\"keyword\">in</span> word:</span><br><span class=\"line\">            cur = cur.child[letter]</span><br><span class=\"line\">        cur.is_word = <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">search</span><span class=\"params\">(self, word: str)</span> -&gt; bool:</span></span><br><span class=\"line\">        cur = self.root</span><br><span class=\"line\">        <span class=\"keyword\">for</span> letter <span class=\"keyword\">in</span> word:</span><br><span class=\"line\">            cur = cur.child.get(letter)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> cur:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> cur.is_word</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">startsWith</span><span class=\"params\">(self, prefix: str)</span> -&gt; bool:</span></span><br><span class=\"line\">        cur = self.root</span><br><span class=\"line\">        <span class=\"keyword\">for</span> letter <span class=\"keyword\">in</span> prefix:</span><br><span class=\"line\">            cur = cur.child.get(letter)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> cur:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<p>方法二：<code>reduce</code>的妙用。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Trie</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        T = <span class=\"keyword\">lambda</span>: collections.defaultdict(T)</span><br><span class=\"line\">        self.root = T()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">insert</span><span class=\"params\">(self, word)</span>:</span></span><br><span class=\"line\">        reduce(dict.__getitem__, word, self.root)[<span class=\"string\">'#'</span>] = <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">search</span><span class=\"params\">(self, word)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'#'</span> <span class=\"keyword\">in</span> reduce(<span class=\"keyword\">lambda</span> cur, c: cur.get(c, &#123;&#125;), word, self.root)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">startsWith</span><span class=\"params\">(self, prefix)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> bool(reduce(<span class=\"keyword\">lambda</span> cur, c: cur.get(c, &#123;&#125;), prefix, self.root))</span><br></pre></td></tr></table></figure>\n<h3 id=\"380-Insert-Delete-GetRandom-O-1\"><a href=\"#380-Insert-Delete-GetRandom-O-1\" class=\"headerlink\" title=\"380. Insert Delete GetRandom O(1)\"></a>380. Insert Delete GetRandom O(1)</h3><h4 id=\"设计一个类，插入删除，随机都是O-1-。原题\"><a href=\"#设计一个类，插入删除，随机都是O-1-。原题\" class=\"headerlink\" title=\"设计一个类，插入删除，随机都是O(1)。原题\"></a>设计一个类，插入删除，随机都是O(1)。<a href=\"https://leetcode.com/problems/insert-delete-getrandom-o1/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Init an empty set.</span><br><span class=\"line\">RandomizedSet randomSet &#x3D; new RandomizedSet();</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Inserts 1 to the set. Returns true as 1 was inserted successfully.</span><br><span class=\"line\">randomSet.insert(1);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Returns false as 2 does not exist in the set.</span><br><span class=\"line\">randomSet.remove(2);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Inserts 2 to the set, returns true. Set now contains [1,2].</span><br><span class=\"line\">randomSet.insert(2);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; getRandom should return either 1 or 2 randomly.</span><br><span class=\"line\">randomSet.getRandom();</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Removes 1 from the set, returns true. Set now contains [2].</span><br><span class=\"line\">randomSet.remove(1);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 2 was already in the set, so return false.</span><br><span class=\"line\">randomSet.insert(2);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Since 2 is the only number in the set, getRandom always return 2.</span><br><span class=\"line\">randomSet.getRandom();</span><br></pre></td></tr></table></figure>\n<p>方法一：解法的思想有点像删除链表，是一种覆盖的思想。主要是删除时用最后的元素将其覆盖，然后再将末尾的元素删除。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RandomizedSet</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.nums, self.pos = [], &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">insert</span><span class=\"params\">(self, val: int)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> val <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> self.pos:</span><br><span class=\"line\">            self.nums.append(val)</span><br><span class=\"line\">            self.pos[val] = len(self.nums)<span class=\"number\">-1</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">remove</span><span class=\"params\">(self, val: int)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> val <span class=\"keyword\">in</span> self.pos:</span><br><span class=\"line\">            idx, last = self.pos[val], self.nums[<span class=\"number\">-1</span>]</span><br><span class=\"line\">            self.nums[idx], self.pos[last] = last, idx</span><br><span class=\"line\">            self.nums.pop()</span><br><span class=\"line\">            self.pos.pop(val)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getRandom</span><span class=\"params\">(self)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> random.choice(self.nums)</span><br></pre></td></tr></table></figure>\n<h3 id=\"341-Flatten-Nested-List-Iterator\"><a href=\"#341-Flatten-Nested-List-Iterator\" class=\"headerlink\" title=\"341. Flatten Nested List Iterator\"></a>341. Flatten Nested List Iterator</h3><h4 id=\"扁平化一个嵌套的List迭代器，NestedInteger是一个类。原题\"><a href=\"#扁平化一个嵌套的List迭代器，NestedInteger是一个类。原题\" class=\"headerlink\" title=\"扁平化一个嵌套的List迭代器，NestedInteger是一个类。原题\"></a>扁平化一个嵌套的List迭代器，NestedInteger是一个类。<a href=\"https://leetcode.com/problems/flatten-nested-list-iterator/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [[1,1],2,[1,1]]</span><br><span class=\"line\">Output: [1,1,2,1,1]</span><br><span class=\"line\">Explanation: By calling next repeatedly until hasNext returns false, </span><br><span class=\"line\">             the order of elements returned by next should be: [1,1,2,1,1].</span><br></pre></td></tr></table></figure>\n<p>方法一：这里设计时考虑了，next之前可能不会调用hasNext。因为正常来说一个生成器就是这样的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#class NestedInteger:</span></span><br><span class=\"line\"><span class=\"comment\">#    def isInteger(self) -&gt; bool:</span></span><br><span class=\"line\"><span class=\"comment\">#        \"\"\"</span></span><br><span class=\"line\"><span class=\"comment\">#        @return True if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class=\"line\"><span class=\"comment\">#        \"\"\"</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#    def getInteger(self) -&gt; int:</span></span><br><span class=\"line\"><span class=\"comment\">#        \"\"\"</span></span><br><span class=\"line\"><span class=\"comment\">#        @return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class=\"line\"><span class=\"comment\">#        Return None if this NestedInteger holds a nested list</span></span><br><span class=\"line\"><span class=\"comment\">#        \"\"\"</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#    def getList(self) -&gt; [NestedInteger]:</span></span><br><span class=\"line\"><span class=\"comment\">#        \"\"\"</span></span><br><span class=\"line\"><span class=\"comment\">#        @return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class=\"line\"><span class=\"comment\">#        Return None if this NestedInteger holds a single integer</span></span><br><span class=\"line\"><span class=\"comment\">#        \"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NestedIterator</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, nestedList: [NestedInteger])</span>:</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">flatten</span><span class=\"params\">(items)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> items:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> x.getInteger() <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">yield</span> x.getInteger()</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> flatten(x.getList())</span><br><span class=\"line\">                    </span><br><span class=\"line\">        self.g = flatten(nestedList)</span><br><span class=\"line\">        self.buff = <span class=\"literal\">None</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">next</span><span class=\"params\">(self)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.buff <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            ans = self.buff</span><br><span class=\"line\">            self.buff = <span class=\"literal\">None</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> next(self.g)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hasNext</span><span class=\"params\">(self)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.buff <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>: <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            self.buff = next(self.g)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">except</span> StopIteration:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Your NestedIterator object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"># i, v = NestedIterator(nestedList), []</span></span><br><span class=\"line\"><span class=\"comment\"># while i.hasNext(): v.append(i.next())</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"5525-皇位继承顺序\"><a href=\"#5525-皇位继承顺序\" class=\"headerlink\" title=\"5525. 皇位继承顺序\"></a><a href=\"https://leetcode-cn.com/problems/throne-inheritance/\" target=\"_blank\" rel=\"noopener\">5525. 皇位继承顺序</a></h4><h4 id=\"啰里啰嗦一大堆，实际上就是让见一个家族图谱，然后先序遍历。\"><a href=\"#啰里啰嗦一大堆，实际上就是让见一个家族图谱，然后先序遍历。\" class=\"headerlink\" title=\"啰里啰嗦一大堆，实际上就是让见一个家族图谱，然后先序遍历。\"></a>啰里啰嗦一大堆，实际上就是让见一个家族图谱，然后先序遍历。</h4><p>方法一：比赛的时候想到了N叉树，但是设计上没想好怎么通过family节点融合。所以直接用的defaultdict做的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThroneInheritance</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, kingName: str)</span>:</span></span><br><span class=\"line\">        self.g = defaultdict(list)</span><br><span class=\"line\">        self.king = kingName</span><br><span class=\"line\">        self.d = set()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">birth</span><span class=\"params\">(self, parentName: str, childName: str)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        self.g[parentName].append(childName)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">death</span><span class=\"params\">(self, name: str)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        self.d.add(name)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getInheritanceOrder</span><span class=\"params\">(self)</span> -&gt; List[str]:</span></span><br><span class=\"line\">        ans = []</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(p)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> p <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> self.d:</span><br><span class=\"line\">                ans.append(p)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> children <span class=\"keyword\">in</span> self.g[p]:</span><br><span class=\"line\">                dfs(children)</span><br><span class=\"line\">        dfs(self.king)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法二：使用多叉树模拟。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, name)</span>:</span></span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\">        self.children = []</span><br><span class=\"line\">        self.alive = <span class=\"literal\">True</span></span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThroneInheritance</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, kingName: str)</span>:</span></span><br><span class=\"line\">        self.root = Person(kingName)</span><br><span class=\"line\">        self.family = &#123;kingName: self.root&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">birth</span><span class=\"params\">(self, parentName: str, childName: str)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        child = Person(childName)</span><br><span class=\"line\">        self.family[parentName].children.append(child)</span><br><span class=\"line\">        self.family[childName] = child</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">death</span><span class=\"params\">(self, name: str)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        self.family[name].alive = <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getInheritanceOrder</span><span class=\"params\">(self)</span> -&gt; List[str]:</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> node.alive:</span><br><span class=\"line\">                    <span class=\"keyword\">yield</span> node.name</span><br><span class=\"line\">                <span class=\"keyword\">for</span> child <span class=\"keyword\">in</span> node.children:</span><br><span class=\"line\">                    <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> dfs(child)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> list(dfs(self.root))</span><br></pre></td></tr></table></figure>\n<h3 id=\"432-All-O-one-Data-Structure\"><a href=\"#432-All-O-one-Data-Structure\" class=\"headerlink\" title=\"432. All O`one Data Structure\"></a><a href=\"https://leetcode-cn.com/problems/all-oone-data-structure/\" target=\"_blank\" rel=\"noopener\">432. All O`one Data Structure</a></h3><h4 id=\"实现一个数据结构使所有的操作在O-1-时间复杂度。某个Key计数-1或者-1，返回最多、最少的key其中的一个。\"><a href=\"#实现一个数据结构使所有的操作在O-1-时间复杂度。某个Key计数-1或者-1，返回最多、最少的key其中的一个。\" class=\"headerlink\" title=\"实现一个数据结构使所有的操作在O(1)时间复杂度。某个Key计数+1或者-1，返回最多、最少的key其中的一个。\u0007\"></a>实现一个数据结构使所有的操作在O(1)时间复杂度。某个Key计数+1或者-1，返回最多、最少的key其中的一个。\u0007</h4><p>方法一：这道题有难度而且实现很复杂，我开始的时候想着以LFU的形式来解，写到最后发现一个问题就是，当一个key的计数变为0的时候，我没法维护一个min_freq来记录最小的计数。对我来说此题首先要打破常规，之前总是认为Node节点就装node，其实这里可以装上一整个key的集合。整体上实现一个双链表，每一个单节点里对应了某些key的集合。节点按照计数顺序增序排列，使用<code>node_freq</code>字典来定位每个频率的节点。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DLinkedNode</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.keys = set()</span><br><span class=\"line\">        self.next = <span class=\"literal\">None</span></span><br><span class=\"line\">        self.prev = <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_key</span><span class=\"params\">(self, key)</span>:</span></span><br><span class=\"line\">        self.keys.add(key)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">remove_key</span><span class=\"params\">(self, key)</span>:</span></span><br><span class=\"line\">        self.keys.remove(key)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_any_key</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.keys:</span><br><span class=\"line\">            key = self.keys.pop()</span><br><span class=\"line\">            self.keys.add(key)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> key</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__len__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> len(self.keys)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_empty</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> len(self) == <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DLinkedList</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.head = DLinkedNode()</span><br><span class=\"line\">        self.tail = DLinkedNode()</span><br><span class=\"line\">        self.head.next, self.tail.prev = self.tail, self.head</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">insert_after</span><span class=\"params\">(self, x)</span>:</span></span><br><span class=\"line\">        node = DLinkedNode()</span><br><span class=\"line\">        node.prev, node.next = x, x.next</span><br><span class=\"line\">        node.next.prev, node.prev.next = node, node</span><br><span class=\"line\">        <span class=\"keyword\">return</span> node</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">insert_before</span><span class=\"params\">(self, x)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.insert_after(x.prev)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">remove</span><span class=\"params\">(self, x)</span>:</span></span><br><span class=\"line\">        x.prev.next, x.next.prev = x.next, x.prev</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_head</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.head.next</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_tail</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.tail.prev</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_sentinel_head</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.head</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_sentinel_tail</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.tail</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AllOne</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.dll, self.key_counter = DLinkedList(), defaultdict(int)</span><br><span class=\"line\">        self.node_freq = &#123;<span class=\"number\">0</span>: self.dll.get_sentinel_head()&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_rmv_key_pf_node</span><span class=\"params\">(self, pf, key)</span>:</span></span><br><span class=\"line\">        node = self.node_freq[pf]</span><br><span class=\"line\">        node.remove_key(key)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.is_empty():</span><br><span class=\"line\">            self.dll.remove(node)</span><br><span class=\"line\">            self.node_freq.pop(pf)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inc</span><span class=\"params\">(self, key: str)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        self.key_counter[key] += <span class=\"number\">1</span></span><br><span class=\"line\">        cf, pf = self.key_counter[key], self.key_counter[key]<span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> cf <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> self.node_freq:</span><br><span class=\"line\">            <span class=\"comment\"># No need to test if pf = 0 since frequency zero points to sentinel node</span></span><br><span class=\"line\">            self.node_freq[cf] = self.dll.insert_after(self.node_freq[pf])</span><br><span class=\"line\">        self.node_freq[cf].add_key(key)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> pf &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            self._rmv_key_pf_node(pf, key)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dec</span><span class=\"params\">(self, key: str)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> key <span class=\"keyword\">in</span> self.key_counter:</span><br><span class=\"line\">            self.key_counter[key] -= <span class=\"number\">1</span></span><br><span class=\"line\">            cf, pf = self.key_counter[key], self.key_counter[key]+<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.key_counter[key] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                self.key_counter.pop(key)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> cf != <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> cf <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> self.node_freq:</span><br><span class=\"line\">                    self.node_freq[cf] = self.dll.insert_before(self.node_freq[pf])</span><br><span class=\"line\">                self.node_freq[cf].add_key(key)</span><br><span class=\"line\">            self._rmv_key_pf_node(pf, key)</span><br><span class=\"line\">       </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getMaxKey</span><span class=\"params\">(self)</span> -&gt; str:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.dll.get_tail().get_any_key() <span class=\"keyword\">if</span> len(self.dll.get_tail()) &gt; <span class=\"number\">0</span> <span class=\"keyword\">else</span> <span class=\"string\">\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getMinKey</span><span class=\"params\">(self)</span> -&gt; str:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.dll.get_head().get_any_key() <span class=\"keyword\">if</span> len(self.dll.get_tail()) &gt; <span class=\"number\">0</span> <span class=\"keyword\">else</span> <span class=\"string\">\"\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1670-Design-Front-Middle-Back-Queue\"><a href=\"#1670-Design-Front-Middle-Back-Queue\" class=\"headerlink\" title=\"1670. Design Front Middle Back Queue\"></a><a href=\"https://leetcode.com/problems/design-front-middle-back-queue/\" target=\"_blank\" rel=\"noopener\">1670. Design Front Middle Back Queue</a></h3><h4 id=\"设计一个可以从中间入队出队的队列。\"><a href=\"#设计一个可以从中间入队出队的队列。\" class=\"headerlink\" title=\"设计一个可以从中间入队出队的队列。\"></a>设计一个可以从中间入队出队的队列。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">[&quot;FrontMiddleBackQueue&quot;, &quot;pushFront&quot;, &quot;pushBack&quot;, &quot;pushMiddle&quot;, &quot;pushMiddle&quot;, &quot;popFront&quot;, &quot;popMiddle&quot;, &quot;popMiddle&quot;, &quot;popBack&quot;, &quot;popFront&quot;]</span><br><span class=\"line\">[[], [1], [2], [3], [4], [], [], [], [], []]</span><br><span class=\"line\">Output:</span><br><span class=\"line\">[null, null, null, null, null, 1, 3, 4, 2, -1]</span><br><span class=\"line\"></span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">FrontMiddleBackQueue q &#x3D; new FrontMiddleBackQueue();</span><br><span class=\"line\">q.pushFront(1);   &#x2F;&#x2F; [1]</span><br><span class=\"line\">q.pushBack(2);    &#x2F;&#x2F; [1, 2]</span><br><span class=\"line\">q.pushMiddle(3);  &#x2F;&#x2F; [1, 3, 2]</span><br><span class=\"line\">q.pushMiddle(4);  &#x2F;&#x2F; [1, 4, 3, 2]</span><br><span class=\"line\">q.popFront();     &#x2F;&#x2F; return 1 -&gt; [4, 3, 2]</span><br><span class=\"line\">q.popMiddle();    &#x2F;&#x2F; return 3 -&gt; [4, 2]</span><br><span class=\"line\">q.popMiddle();    &#x2F;&#x2F; return 4 -&gt; [2]</span><br><span class=\"line\">q.popBack();      &#x2F;&#x2F; return 2 -&gt; []</span><br><span class=\"line\">q.popFront();     &#x2F;&#x2F; return -1 -&gt; [] (The queue is empty)</span><br></pre></td></tr></table></figure>\n<p>方法一：比赛时用的双端队列，一开始想的3个，后来想2个就够了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FrontMiddleBackQueue</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.q1 = deque()</span><br><span class=\"line\">        self.q2 = deque()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pushFront</span><span class=\"params\">(self, val: int)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        self.q1.appendleft(val)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(self.q1) &gt; len(self.q2) + <span class=\"number\">1</span>:</span><br><span class=\"line\">            self.q2.appendleft(self.q1.pop())</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pushMiddle</span><span class=\"params\">(self, val: int)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(self.q1) &gt; len(self.q2):</span><br><span class=\"line\">            self.q2.appendleft(self.q1.pop())</span><br><span class=\"line\">        self.q1.append(val)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pushBack</span><span class=\"params\">(self, val: int)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        self.q2.append(val)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(self.q2) &gt; len(self.q1):</span><br><span class=\"line\">            self.q1.append(self.q2.popleft())</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">popFront</span><span class=\"params\">(self)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self.q1:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        ans = self.q1.popleft()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(self.q2) &gt; len(self.q1):</span><br><span class=\"line\">            self.q1.append(self.q2.popleft())</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">popMiddle</span><span class=\"params\">(self)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self.q1:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        ans = self.q1.pop()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(self.q2) &gt; len(self.q1):</span><br><span class=\"line\">            self.q1.append(self.q2.popleft())</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">popBack</span><span class=\"params\">(self)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self.q2:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self.q1:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">            self.q2.appendleft(self.q1.pop())</span><br><span class=\"line\">    </span><br><span class=\"line\">        ans = self.q2.pop()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(self.q1) &gt; len(self.q2) + <span class=\"number\">1</span>:</span><br><span class=\"line\">            self.q2.appendleft(self.q1.pop())</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法二：整理一下方法一。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FrontMiddleBackQueue</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.q1 = deque()</span><br><span class=\"line\">        self.q2 = deque()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pushFront</span><span class=\"params\">(self, val: int)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        self.q1.appendleft(val)</span><br><span class=\"line\">        self.balance()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pushMiddle</span><span class=\"params\">(self, val: int)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(self.q1) &gt; len(self.q2):</span><br><span class=\"line\">            self.q2.appendleft(self.q1.pop())</span><br><span class=\"line\">        self.q1.append(val)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pushBack</span><span class=\"params\">(self, val: int)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        self.q2.append(val)</span><br><span class=\"line\">        self.balance()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">popFront</span><span class=\"params\">(self)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self.q1:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        ans = self.q1.popleft()</span><br><span class=\"line\">        self.balance()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">popMiddle</span><span class=\"params\">(self)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self.q1:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        ans = self.q1.pop()</span><br><span class=\"line\">        self.balance()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">popBack</span><span class=\"params\">(self)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self.q2:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self.q1:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">            self.q2.appendleft(self.q1.pop())</span><br><span class=\"line\">    </span><br><span class=\"line\">        ans = self.q2.pop()</span><br><span class=\"line\">        self.balance()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">balance</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(self.q1) &gt; len(self.q2) + <span class=\"number\">1</span>:</span><br><span class=\"line\">            self.q2.appendleft(self.q1.pop())</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> len(self.q2) &gt; len(self.q1):</span><br><span class=\"line\">            self.q1.append(self.q2.popleft())</span><br></pre></td></tr></table></figure>\n<p>方法三：竞赛中直接使用复杂度较高的方法也能过。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FrontMiddleBackQueue</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.q = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pushFront</span><span class=\"params\">(self, val: int)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        self.q.insert(<span class=\"number\">0</span>, val)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pushMiddle</span><span class=\"params\">(self, val: int)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        self.q.insert(len(self.q)//<span class=\"number\">2</span>, val)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pushBack</span><span class=\"params\">(self, val: int)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        self.q.append(val)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">popFront</span><span class=\"params\">(self)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.q.pop(<span class=\"number\">0</span>) <span class=\"keyword\">if</span> self.q <span class=\"keyword\">else</span> <span class=\"number\">-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">popMiddle</span><span class=\"params\">(self)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.q.pop((len(self.q)<span class=\"number\">-1</span>)//<span class=\"number\">2</span>) <span class=\"keyword\">if</span> self.q <span class=\"keyword\">else</span> <span class=\"number\">-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">popBack</span><span class=\"params\">(self)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.q.pop() <span class=\"keyword\">if</span> self.q <span class=\"keyword\">else</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1825-Finding-MK-Average\"><a href=\"#1825-Finding-MK-Average\" class=\"headerlink\" title=\"1825. Finding MK Average\"></a>1825. Finding MK Average</h3><h4 id=\"找到M滑动窗口数据流中去除前后K个最大最小值的平均数。\"><a href=\"#找到M滑动窗口数据流中去除前后K个最大最小值的平均数。\" class=\"headerlink\" title=\"找到M滑动窗口数据流中去除前后K个最大最小值的平均数。\"></a>找到M滑动窗口数据流中去除前后K个最大最小值的平均数。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[&quot;MKAverage&quot;, &quot;addElement&quot;, &quot;addElement&quot;, &quot;calculateMKAverage&quot;, &quot;addElement&quot;, &quot;calculateMKAverage&quot;, &quot;addElement&quot;, &quot;addElement&quot;, &quot;addElement&quot;, &quot;calculateMKAverage&quot;]</span><br><span class=\"line\">[[3, 1], [3], [1], [], [10], [], [5], [5], [5], []]</span><br><span class=\"line\">Output</span><br><span class=\"line\">[null, null, null, -1, null, 3, null, null, null, 5]</span><br><span class=\"line\"></span><br><span class=\"line\">Explanation</span><br><span class=\"line\">MKAverage obj &#x3D; new MKAverage(3, 1); </span><br><span class=\"line\">obj.addElement(3);        &#x2F;&#x2F; current elements are [3]</span><br><span class=\"line\">obj.addElement(1);        &#x2F;&#x2F; current elements are [3,1]</span><br><span class=\"line\">obj.calculateMKAverage(); &#x2F;&#x2F; return -1, because m &#x3D; 3 and only 2 elements exist.</span><br><span class=\"line\">obj.addElement(10);       &#x2F;&#x2F; current elements are [3,1,10]</span><br><span class=\"line\">obj.calculateMKAverage(); &#x2F;&#x2F; The last 3 elements are [3,1,10].</span><br><span class=\"line\">                          &#x2F;&#x2F; After removing smallest and largest 1 element the container will be [3].</span><br><span class=\"line\">                          &#x2F;&#x2F; The average of [3] equals 3&#x2F;1 &#x3D; 3, return 3</span><br><span class=\"line\">obj.addElement(5);        &#x2F;&#x2F; current elements are [3,1,10,5]</span><br><span class=\"line\">obj.addElement(5);        &#x2F;&#x2F; current elements are [3,1,10,5,5]</span><br><span class=\"line\">obj.addElement(5);        &#x2F;&#x2F; current elements are [3,1,10,5,5,5]</span><br><span class=\"line\">obj.calculateMKAverage(); &#x2F;&#x2F; The last 3 elements are [5,5,5].</span><br><span class=\"line\">                          &#x2F;&#x2F; After removing smallest and largest 1 element the container will be [5].</span><br><span class=\"line\">                          &#x2F;&#x2F; The average of [5] equals 5&#x2F;1 &#x3D; 5, return 5</span><br></pre></td></tr></table></figure>\n<p>方法一：这题暴力居然过了。。10**5的数据集，暴力排序就过了。实际上比赛的时候想到了数据流中的中位数，想着用队列和堆来解决。但是堆不好解决删除的问题。此题应该用SortedList。这里不清楚python底层是用什么平衡树实现的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sortedcontainers <span class=\"keyword\">import</span> SortedList</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MKAverage</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, m: int, k: int)</span>:</span></span><br><span class=\"line\">        self.m, self.k = m, k</span><br><span class=\"line\">        self.q = collections.deque()</span><br><span class=\"line\">        self.sl = SortedList()</span><br><span class=\"line\">        self.total = self.first_k = self.last_k = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addElement</span><span class=\"params\">(self, num: int)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        self.total += num</span><br><span class=\"line\">        self.q.append(num)</span><br><span class=\"line\">        index = self.sl.bisect_left(num)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> index &lt; self.k:</span><br><span class=\"line\">            self.first_k += num</span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(self.sl) &gt;= self.k:</span><br><span class=\"line\">                self.first_k -= self.sl[self.k<span class=\"number\">-1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> index &gt;= len(self.sl) + <span class=\"number\">1</span> - self.k:</span><br><span class=\"line\">            self.last_k += num</span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(self.sl) &gt;= self.k:</span><br><span class=\"line\">                self.last_k -= self.sl[-self.k]</span><br><span class=\"line\">        self.sl.add(num)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(self.q) &gt; self.m:</span><br><span class=\"line\">            num = self.q.popleft()</span><br><span class=\"line\">            self.total -= num</span><br><span class=\"line\">            index = self.sl.index(num)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> index &lt; self.k:</span><br><span class=\"line\">                self.first_k -= num</span><br><span class=\"line\">                self.first_k += self.sl[self.k]</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> index &gt;= len(self.sl) - self.k:</span><br><span class=\"line\">                self.last_k -= num</span><br><span class=\"line\">                self.last_k += self.sl[-self.k<span class=\"number\">-1</span>]</span><br><span class=\"line\">            self.sl.remove(num)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">calculateMKAverage</span><span class=\"params\">(self)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(self.sl) &lt; self.m:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (self.total-self.first_k-self.last_k) // (self.m - <span class=\"number\">2</span> * self.k)</span><br></pre></td></tr></table></figure>\n","categories":["算法"],"tags":["LeetCode","Python","Algorithm","Design"]},{"title":"LeetCode算法题整理（回溯篇）BackTracking","url":"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%9B%9E%E6%BA%AF%E7%AF%87%EF%BC%89BackTracking/","content":"<h3 id=\"93-Restore-IP-Addresses\"><a href=\"#93-Restore-IP-Addresses\" class=\"headerlink\" title=\"93. Restore IP Addresses\"></a>93. Restore IP Addresses</h3><h4 id=\"恢复IP地址。原题\"><a href=\"#恢复IP地址。原题\" class=\"headerlink\" title=\"恢复IP地址。原题\"></a>恢复IP地址。<a href=\"https://leetcode.com/problems/restore-ip-addresses/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: &quot;25525511135&quot;</span><br><span class=\"line\">Output: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>方法一：需要注意0的情况。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">restoreIpAddresses</span><span class=\"params\">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtrack</span><span class=\"params\">(i, p)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == N <span class=\"keyword\">and</span> len(p)==<span class=\"number\">4</span>:</span><br><span class=\"line\">            ans.append(<span class=\"string\">'.'</span>.join(p))</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(p) &gt; <span class=\"number\">4</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">4</span>):</span><br><span class=\"line\">            cur = s[i:i+j]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> cur <span class=\"keyword\">and</span> (<span class=\"keyword\">not</span> cur.startswith(<span class=\"string\">'0'</span>) <span class=\"keyword\">or</span> cur==<span class=\"string\">'0'</span>) <span class=\"keyword\">and</span> int(cur) &lt; <span class=\"number\">256</span>:</span><br><span class=\"line\">                p.append(s[i:i+j])</span><br><span class=\"line\">                backtrack(i+j, p)</span><br><span class=\"line\">                p.pop()</span><br><span class=\"line\"></span><br><span class=\"line\">    ans, N = [], len(s)</span><br><span class=\"line\">    backtrack(<span class=\"number\">0</span>, [])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"131-Palindrome-Partitioning\"><a href=\"#131-Palindrome-Partitioning\" class=\"headerlink\" title=\"131. Palindrome Partitioning\"></a>131. Palindrome Partitioning</h3><h4 id=\"回文串切分。原题\"><a href=\"#回文串切分。原题\" class=\"headerlink\" title=\"回文串切分。原题\"></a>回文串切分。<a href=\"https://leetcode.com/problems/palindrome-partitioning/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: &quot;aab&quot;</span><br><span class=\"line\">Output:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [&quot;aa&quot;,&quot;b&quot;],</span><br><span class=\"line\">  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>方法一：原始回溯。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">partition</span><span class=\"params\">(self, s: str)</span> -&gt; List[List[str]]:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtrack</span><span class=\"params\">(s, remain)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> remain:</span><br><span class=\"line\">            ans.append(s)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(remain)+<span class=\"number\">1</span>):      <span class=\"comment\"># 这里是n+1，因为整个字符串也有可能。</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> remain[:i] == remain[:i][::<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                    backtrack(s+[remain[:i]], remain[i:])</span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    <span class=\"keyword\">if</span> s:</span><br><span class=\"line\">        backtrack([], s)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：使用列表生成式。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">partition</span><span class=\"params\">(self, s: str)</span> -&gt; List[List[str]]:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> s <span class=\"keyword\">and</span> [[s[:i]] + suffix </span><br><span class=\"line\">                  <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(s)+<span class=\"number\">1</span>) <span class=\"keyword\">if</span> s[:i]==s[i<span class=\"number\">-1</span>::<span class=\"number\">-1</span>]</span><br><span class=\"line\">                  <span class=\"keyword\">for</span> suffix <span class=\"keyword\">in</span> self.partition(s[i:])] <span class=\"keyword\">or</span> [[]]</span><br></pre></td></tr></table></figure>\n<h3 id=\"77-Combinations\"><a href=\"#77-Combinations\" class=\"headerlink\" title=\"77. Combinations\"></a>77. Combinations</h3><h4 id=\"实现组合。原题\"><a href=\"#实现组合。原题\" class=\"headerlink\" title=\"实现组合。原题\"></a>实现组合。<a href=\"https://leetcode.com/problems/combinations/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 4, k &#x3D; 2</span><br><span class=\"line\">Output:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [2,4],</span><br><span class=\"line\">  [3,4],</span><br><span class=\"line\">  [2,3],</span><br><span class=\"line\">  [1,2],</span><br><span class=\"line\">  [1,3],</span><br><span class=\"line\">  [1,4],</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>方法一：回溯。700ms, 比Solution中的慢了100ms.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">combine</span><span class=\"params\">(self, n: int, k: int)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtrack</span><span class=\"params\">(a, k, rest)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> k == <span class=\"number\">1</span>:</span><br><span class=\"line\">            ans.extend(a+[num] <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> rest)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i, h <span class=\"keyword\">in</span> enumerate(rest):</span><br><span class=\"line\">                backtrack(a+[h], k<span class=\"number\">-1</span>, rest[i+<span class=\"number\">1</span>:])</span><br><span class=\"line\">        </span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    backtrack([], k, list(range(<span class=\"number\">1</span>, n+<span class=\"number\">1</span>)))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法二：Solution中的递归。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">combine</span><span class=\"params\">(self, n: int, k: int)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtrack</span><span class=\"params\">(first=<span class=\"number\">1</span>, cur=[])</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(cur) == k:</span><br><span class=\"line\">            ans.append(cur[:])</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(first, n+<span class=\"number\">1</span>):</span><br><span class=\"line\">                cur.append(i)</span><br><span class=\"line\">                backtrack(i+<span class=\"number\">1</span>, cur)</span><br><span class=\"line\">                cur.pop()</span><br><span class=\"line\">        </span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    backtrack()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：列表生成式写法，递归。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">combine</span><span class=\"params\">(self, n: int, k: int)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> k == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [[]]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [pre+[i] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(k, n+<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> pre <span class=\"keyword\">in</span> self.combine(i<span class=\"number\">-1</span>, k<span class=\"number\">-1</span>)]</span><br></pre></td></tr></table></figure>\n<h3 id=\"39-Combination-Sum\"><a href=\"#39-Combination-Sum\" class=\"headerlink\" title=\"39. Combination Sum\"></a>39. Combination Sum</h3><h4 id=\"和77类似，找出和为指定数值的组合，候选数字可以重复使用。原题\"><a href=\"#和77类似，找出和为指定数值的组合，候选数字可以重复使用。原题\" class=\"headerlink\" title=\"和77类似，找出和为指定数值的组合，候选数字可以重复使用。原题\"></a>和77类似，找出和为指定数值的组合，候选数字可以重复使用。<a href=\"https://leetcode.com/problems/combination-sum/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: candidates &#x3D; [2,3,5], target &#x3D; 8,</span><br><span class=\"line\">A solution set is:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [2,2,2,2],</span><br><span class=\"line\">  [2,3,3],</span><br><span class=\"line\">  [3,5]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>方法一：将候选组排序，并记录当前的索引值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">combinationSum</span><span class=\"params\">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtrack</span><span class=\"params\">(g, i, target)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> target == <span class=\"number\">0</span>:</span><br><span class=\"line\">            ans.append(g)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> target &lt; candidates[i]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i, n):</span><br><span class=\"line\">            backtrack(g+[candidates[j]], j, target-candidates[j])</span><br><span class=\"line\">    </span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    n = len(candidates)</span><br><span class=\"line\">    candidates.sort()</span><br><span class=\"line\">    backtrack([], <span class=\"number\">0</span>, target)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法二：时隔一年又重做一遍，感觉方法更加精炼了。sort感觉没啥必要。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">combinationSum</span><span class=\"params\">(self, cn: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtrack</span><span class=\"params\">(i, t, p)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> t == <span class=\"number\">0</span>:</span><br><span class=\"line\">            ans.append(p[:])</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> t &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i, len(cn)):</span><br><span class=\"line\">            c = cn[j]</span><br><span class=\"line\">            p.append(c)</span><br><span class=\"line\">            backtrack(j, t-c, p)</span><br><span class=\"line\">            p.pop()</span><br><span class=\"line\"></span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    backtrack(<span class=\"number\">0</span>, target, [])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"40-Combination-Sum-II\"><a href=\"#40-Combination-Sum-II\" class=\"headerlink\" title=\"40. Combination Sum II\"></a>40. Combination Sum II</h3><h4 id=\"组合求和，和39类似，区别在于候选数字中可能有重复数字，但每个数字只能使用一次。原题\"><a href=\"#组合求和，和39类似，区别在于候选数字中可能有重复数字，但每个数字只能使用一次。原题\" class=\"headerlink\" title=\"组合求和，和39类似，区别在于候选数字中可能有重复数字，但每个数字只能使用一次。原题\"></a>组合求和，和39类似，区别在于候选数字中可能有重复数字，但每个数字只能使用一次。<a href=\"https://leetcode.com/problems/combination-sum-ii/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>麻烦的地方在于如何保证结果是非重复的。当<code>j==i</code>时，<code>cn[j]==cn[j-1]</code>说明前面刚刚用了和这个一样的数字。可以继续使用。比如<code>[1,1,6]</code>。当<code>j!=i</code>，<code>cn[j]==cn[j-1]</code>时，说明想以j开头同样找数组，这样肯定会找出一个重复的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">combinationSum2</span><span class=\"params\">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtrack</span><span class=\"params\">(g, i, target)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> target == <span class=\"number\">0</span>:</span><br><span class=\"line\">            ans.append(g)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> </span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i, n):</span><br><span class=\"line\">            <span class=\"comment\"># avoid duplicate result</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> j != i <span class=\"keyword\">and</span> candidates[j]==candidates[j<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> candidates[j] &gt; target:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            backtrack(g+[candidates[j]], j+<span class=\"number\">1</span>, target-candidates[j])</span><br><span class=\"line\">    </span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    n = len(candidates)</span><br><span class=\"line\">    candidates.sort()</span><br><span class=\"line\">    backtrack([], <span class=\"number\">0</span>, target)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"216-Combination-Sum-III\"><a href=\"#216-Combination-Sum-III\" class=\"headerlink\" title=\"216. Combination Sum III\"></a>216. Combination Sum III</h3><h4 id=\"组合求和，从1-9选出k个不重复的数，和为n。原题\"><a href=\"#组合求和，从1-9选出k个不重复的数，和为n。原题\" class=\"headerlink\" title=\"组合求和，从1~9选出k个不重复的数，和为n。原题\"></a>组合求和，从1~9选出k个不重复的数，和为n。<a href=\"https://leetcode.com/problems/combination-sum-iii/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: k &#x3D; 3, n &#x3D; 9</span><br><span class=\"line\">Output: [[1,2,6], [1,3,5], [2,3,4]]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">combinationSum3</span><span class=\"params\">(self, k: int, n: int)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtrack</span><span class=\"params\">(g, i, target, k)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> k==<span class=\"number\">0</span> <span class=\"keyword\">and</span> target==<span class=\"number\">0</span>:</span><br><span class=\"line\">            ans.append(g)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> k &lt; <span class=\"number\">0</span> <span class=\"keyword\">or</span> target &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i, <span class=\"number\">10</span>):</span><br><span class=\"line\">            backtrack(g+[j], j+<span class=\"number\">1</span>, target-j, k<span class=\"number\">-1</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    backtrack([], <span class=\"number\">1</span>, n, k)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法二：递归，使用<code>last</code>作为上限。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">combinationSum3</span><span class=\"params\">(self, k: int, n: int)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">combs</span><span class=\"params\">(k, n, cap)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> k:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [[]] * (<span class=\"keyword\">not</span> n)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [comb + [last]</span><br><span class=\"line\">                <span class=\"keyword\">for</span> last <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, cap)</span><br><span class=\"line\">                <span class=\"keyword\">for</span> comb <span class=\"keyword\">in</span> combs(k<span class=\"number\">-1</span>, n-last, last)]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> combs(k, n, <span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"78-Subsets\"><a href=\"#78-Subsets\" class=\"headerlink\" title=\"78. Subsets\"></a>78. Subsets</h3><h4 id=\"输出给定无重复集合的子集组合。原题\"><a href=\"#输出给定无重复集合的子集组合。原题\" class=\"headerlink\" title=\"输出给定无重复集合的子集组合。原题\"></a>输出给定无重复集合的子集组合。<a href=\"https://leetcode.com/problems/subsets/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [1,2,3]</span><br><span class=\"line\">Output:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [3],</span><br><span class=\"line\">  [1],</span><br><span class=\"line\">  [2],</span><br><span class=\"line\">  [1,2,3],</span><br><span class=\"line\">  [1,3],</span><br><span class=\"line\">  [2,3],</span><br><span class=\"line\">  [1,2],</span><br><span class=\"line\">  []</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>方法一：常规写法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">subsets</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtrack</span><span class=\"params\">(g, i, n)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> n:</span><br><span class=\"line\">            ans.append(g)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i, len(nums)):</span><br><span class=\"line\">            backtrack(g+[nums[j]], j+<span class=\"number\">1</span>, n<span class=\"number\">-1</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> range(len(nums)+<span class=\"number\">1</span>):</span><br><span class=\"line\">        backtrack([], <span class=\"number\">0</span>, n)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：做一个递增就好了。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">subsets</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">    ans = [[]]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        ans += [pre+[num] <span class=\"keyword\">for</span> pre <span class=\"keyword\">in</span> ans]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法三：使用索引来做。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">subsets</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">    self.ans = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(i, n, p)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> n:</span><br><span class=\"line\">            self.ans.append(p[:])</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i, len(nums)):</span><br><span class=\"line\">            d = nums[j]</span><br><span class=\"line\">            p.append(d)</span><br><span class=\"line\">            dfs(j+<span class=\"number\">1</span>, n<span class=\"number\">-1</span>, p)</span><br><span class=\"line\">            p.pop()</span><br><span class=\"line\"></span><br><span class=\"line\">    [dfs(<span class=\"number\">0</span>, i, []) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(nums)+<span class=\"number\">1</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"90-Subsets-II\"><a href=\"#90-Subsets-II\" class=\"headerlink\" title=\"90. Subsets II\"></a>90. Subsets II</h3><h4 id=\"和78类似，区别在于给定的数组有重复元素。原题\"><a href=\"#和78类似，区别在于给定的数组有重复元素。原题\" class=\"headerlink\" title=\"和78类似，区别在于给定的数组有重复元素。原题\"></a>和78类似，区别在于给定的数组有重复元素。<a href=\"https://leetcode.com/problems/subsets-ii/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：用到了40题中解法去重的代码。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">subsetsWithDup</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtrack</span><span class=\"params\">(g, i, n)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> n:</span><br><span class=\"line\">            ans.append(g)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i, len(nums)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> j!=i <span class=\"keyword\">and</span> nums[j]==nums[j<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            backtrack(g+[nums[j]], j+<span class=\"number\">1</span>, n<span class=\"number\">-1</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    nums.sort()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> range(len(nums)+<span class=\"number\">1</span>):</span><br><span class=\"line\">        backtrack([], <span class=\"number\">0</span>, n)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"79-Word-Search\"><a href=\"#79-Word-Search\" class=\"headerlink\" title=\"79. Word Search\"></a>79. Word Search</h3><h4 id=\"矩阵中的路径。原题\"><a href=\"#矩阵中的路径。原题\" class=\"headerlink\" title=\"矩阵中的路径。原题\"></a>矩阵中的路径。<a href=\"https://leetcode.com/problems/word-search/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">board &#x3D;</span><br><span class=\"line\">[</span><br><span class=\"line\">  [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;],</span><br><span class=\"line\">  [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;],</span><br><span class=\"line\">  [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;]</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">Given word &#x3D; &quot;ABCCED&quot;, return true.</span><br><span class=\"line\">Given word &#x3D; &quot;SEE&quot;, return true.</span><br><span class=\"line\">Given word &#x3D; &quot;ABCB&quot;, return false.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">exist</span><span class=\"params\">(self, g: List[List[str]], word: str)</span> -&gt; bool:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(i, j, word)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> word:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        original, g[i][j] = g[i][j], <span class=\"string\">'-'</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> ((i+<span class=\"number\">1</span>, j), (i, j+<span class=\"number\">1</span>), (i, j<span class=\"number\">-1</span>), (i<span class=\"number\">-1</span>, j)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=x&lt;R <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=y&lt;C <span class=\"keyword\">and</span> g[x][y] == word[<span class=\"number\">0</span>]: </span><br><span class=\"line\">                <span class=\"keyword\">if</span> dfs(x, y, word[<span class=\"number\">1</span>:]):</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        g[i][j] = original</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">    R, C = len(g), len(g[<span class=\"number\">0</span>])</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(R):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(C):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> g[i][j] == word[<span class=\"number\">0</span>] <span class=\"keyword\">and</span> dfs(i, j, word[<span class=\"number\">1</span>:]):</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"200-Number-of-Islands\"><a href=\"#200-Number-of-Islands\" class=\"headerlink\" title=\"200. Number of Islands\"></a>200. Number of Islands</h3><h4 id=\"小岛的个数。原题\"><a href=\"#小岛的个数。原题\" class=\"headerlink\" title=\"小岛的个数。原题\"></a>小岛的个数。<a href=\"https://leetcode.com/problems/number-of-islands/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">11110</span><br><span class=\"line\">11010</span><br><span class=\"line\">11000</span><br><span class=\"line\">00000</span><br><span class=\"line\"></span><br><span class=\"line\">Output: 1</span><br></pre></td></tr></table></figure>\n<p>方法一：常规写法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numIslands</span><span class=\"params\">(self, grid: List[List[str]])</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> grid:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    R, C = len(grid), len(grid[<span class=\"number\">0</span>])</span><br><span class=\"line\">    seen = set()</span><br><span class=\"line\">    count = <span class=\"number\">0</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">spread</span><span class=\"params\">(i, j)</span>:</span></span><br><span class=\"line\">        seen.add((i, j))</span><br><span class=\"line\">        <span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> ((i<span class=\"number\">-1</span>, j), (i+<span class=\"number\">1</span>, j), (i, j<span class=\"number\">-1</span>), (i, j+<span class=\"number\">1</span>)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"number\">0</span>&lt;=x&lt;R <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=y&lt;C <span class=\"keyword\">and</span> (x, y) <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> seen</span><br><span class=\"line\">                    <span class=\"keyword\">and</span> grid[x][y]==<span class=\"string\">'1'</span>):</span><br><span class=\"line\">                spread(x, y)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(R):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(C):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i, j) <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> seen <span class=\"keyword\">and</span> grid[i][j]==<span class=\"string\">'1'</span>:</span><br><span class=\"line\">                count += <span class=\"number\">1</span></span><br><span class=\"line\">                spread(i, j)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count</span><br></pre></td></tr></table></figure>\n<p>方法二：当登录一座岛屿时，使这座岛屿下沉，变为’0’。不明白为什么比上个方法慢了20ms。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numIslands</span><span class=\"params\">(self, grid: List[List[str]])</span> -&gt; int:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sink</span><span class=\"params\">(i, j)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=i&lt;len(grid) <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=j&lt;len(grid[i]) <span class=\"keyword\">and</span> grid[i][j]==<span class=\"string\">'1'</span>:</span><br><span class=\"line\">            grid[i][j] = <span class=\"string\">'0'</span></span><br><span class=\"line\">            list(map(sink, (i<span class=\"number\">-1</span>, i+<span class=\"number\">1</span>, i, i), (j, j, j<span class=\"number\">-1</span>, j+<span class=\"number\">1</span>)))   <span class=\"comment\"># important, return generator without list</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(sink(i, j) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(grid)) <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(grid[i])))</span><br></pre></td></tr></table></figure>\n<h3 id=\"1254-Number-of-Closed-Islands\"><a href=\"#1254-Number-of-Closed-Islands\" class=\"headerlink\" title=\"1254. Number of Closed Islands\"></a>1254. Number of Closed Islands</h3><h4 id=\"和200类似，但是与边界相连的岛不能算了。原题\"><a href=\"#和200类似，但是与边界相连的岛不能算了。原题\" class=\"headerlink\" title=\"和200类似，但是与边界相连的岛不能算了。原题\"></a>和200类似，但是与边界相连的岛不能算了。<a href=\"https://leetcode.com/problems/number-of-closed-islands/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: grid &#x3D; [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">Islands in gray are closed because they are completely surrounded by water (group of 1s).</span><br></pre></td></tr></table></figure>\n<p>方法一：下沉法。先把边界的岛屿处理，然后再累计。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">closedIsland</span><span class=\"params\">(self, g: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    m, n = len(g), len(g[<span class=\"number\">0</span>])</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sink</span><span class=\"params\">(i, j)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> m&gt;i&gt;=<span class=\"number\">0</span>&lt;=j&lt;n <span class=\"keyword\">and</span> g[i][j]==<span class=\"number\">0</span>:</span><br><span class=\"line\">            g[i][j] = <span class=\"number\">1</span></span><br><span class=\"line\">            list(map(sink, (i<span class=\"number\">-1</span>, i+<span class=\"number\">1</span>, i, i), (j, j, j<span class=\"number\">-1</span>, j+<span class=\"number\">1</span>)))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    list(map(sink, [<span class=\"number\">0</span>]*n, range(n)))</span><br><span class=\"line\">    list(map(sink, [m<span class=\"number\">-1</span>]*n, range(n)))</span><br><span class=\"line\">    list(map(sink, range(m), [<span class=\"number\">0</span>]*m))</span><br><span class=\"line\">    list(map(sink, range(m), [n<span class=\"number\">-1</span>]*m))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(sink(i, j) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, m<span class=\"number\">-1</span>) <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n<span class=\"number\">-1</span>))</span><br></pre></td></tr></table></figure>\n<h3 id=\"130-Surrounded-Regions\"><a href=\"#130-Surrounded-Regions\" class=\"headerlink\" title=\"130. Surrounded Regions\"></a>130. Surrounded Regions</h3><h4 id=\"将四周被包围的O翻转成X，边缘不算包围。原题\"><a href=\"#将四周被包围的O翻转成X，边缘不算包围。原题\" class=\"headerlink\" title=\"将四周被包围的O翻转成X，边缘不算包围。原题\"></a>将四周被包围的<code>O</code>翻转成<code>X</code>，边缘不算包围。<a href=\"https://leetcode.com/problems/surrounded-regions/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：传统的方法在延伸的时候判断不出是否到达边界。所以这里先得到边界的点，然后从边界往里延伸，将所有的<code>O</code>变为<code>S</code>，第二次遍历时，将<code>S</code>恢复成<code>O</code>，其他设为<code>X</code>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">solve</span><span class=\"params\">(self, board: List[List[str]])</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> board: <span class=\"keyword\">return</span></span><br><span class=\"line\">    R, C = len(board), len(board[<span class=\"number\">0</span>])</span><br><span class=\"line\">    bounds = [(i, j) <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(R+C) </span><br><span class=\"line\">              <span class=\"keyword\">for</span> i, j <span class=\"keyword\">in</span> ((<span class=\"number\">0</span>, k), (R<span class=\"number\">-1</span>, k), (k, <span class=\"number\">0</span>), (k, C<span class=\"number\">-1</span>))</span><br><span class=\"line\">              <span class=\"keyword\">if</span> i &lt; R <span class=\"keyword\">and</span> j &lt; C]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> bounds:</span><br><span class=\"line\">        x, y = bounds.pop()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=x&lt;R <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=y&lt;C <span class=\"keyword\">and</span> board[x][y]==<span class=\"string\">'O'</span>:</span><br><span class=\"line\">            board[x][y] = <span class=\"string\">'S'</span></span><br><span class=\"line\">            bounds += (x<span class=\"number\">-1</span>, y), (x+<span class=\"number\">1</span>, y), (x, y<span class=\"number\">-1</span>), (x, y+<span class=\"number\">1</span>)</span><br><span class=\"line\">    board[:] = [[<span class=\"string\">'XO'</span>[c==<span class=\"string\">'S'</span>] <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> row] <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> board]</span><br></pre></td></tr></table></figure>\n<h3 id=\"417-Pacific-Atlantic-Water-Flow\"><a href=\"#417-Pacific-Atlantic-Water-Flow\" class=\"headerlink\" title=\"417. Pacific Atlantic Water Flow\"></a>417. Pacific Atlantic Water Flow</h3><h4 id=\"太平洋大西洋水流向，假设陆地上可以沿着高度不高于的地方流淌，求能同时流入两个海洋的陆地坐标。原题\"><a href=\"#太平洋大西洋水流向，假设陆地上可以沿着高度不高于的地方流淌，求能同时流入两个海洋的陆地坐标。原题\" class=\"headerlink\" title=\"太平洋大西洋水流向，假设陆地上可以沿着高度不高于的地方流淌，求能同时流入两个海洋的陆地坐标。原题\"></a>太平洋大西洋水流向，假设陆地上可以沿着高度不高于的地方流淌，求能同时流入两个海洋的陆地坐标。<a href=\"https://leetcode.com/problems/pacific-atlantic-water-flow/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Given the following 5x5 matrix:</span><br><span class=\"line\"></span><br><span class=\"line\">  Pacific ~   ~   ~   ~   ~ </span><br><span class=\"line\">       ~  1   2   2   3  (5) *</span><br><span class=\"line\">       ~  3   2   3  (4) (4) *</span><br><span class=\"line\">       ~  2   4  (5)  3   1  *</span><br><span class=\"line\">       ~ (6) (7)  1   4   5  *</span><br><span class=\"line\">       ~ (5)  1   1   2   4  *</span><br><span class=\"line\">          *   *   *   *   * Atlantic</span><br><span class=\"line\">Return:</span><br><span class=\"line\">[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).</span><br><span class=\"line\"> </span><br><span class=\"line\"> Pacific  ~   ~   ~   </span><br><span class=\"line\">       ~  1   2  (3)  *</span><br><span class=\"line\">       ~ (8) (9) (4)  *</span><br><span class=\"line\">       ~ (7) (6) (5)  *</span><br><span class=\"line\">          *   *   *   * Atlantic</span><br></pre></td></tr></table></figure>\n<p>方法一：一开始我以为从左上的点只能往右或下方向找陆地，事实上还是要寻找四个方向。这应该是最暴力的解法了。但是看了几个高票答案都没我这个快。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pacificAtlantic</span><span class=\"params\">(self, matrix: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> matrix:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> []</span><br><span class=\"line\">    p_land = set()</span><br><span class=\"line\">    a_land = set()</span><br><span class=\"line\">    R, C = len(matrix), len(matrix[<span class=\"number\">0</span>])</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">spread</span><span class=\"params\">(i, j, land)</span>:</span></span><br><span class=\"line\">        land.add((i, j))</span><br><span class=\"line\">        <span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> ((i+<span class=\"number\">1</span>, j), (i, j+<span class=\"number\">1</span>), (i<span class=\"number\">-1</span>, j), (i, j<span class=\"number\">-1</span>)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"number\">0</span>&lt;=x&lt;R <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=y&lt;C <span class=\"keyword\">and</span> matrix[x][y] &gt;= matrix[i][j]</span><br><span class=\"line\">                    <span class=\"keyword\">and</span> (x, y) <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> land):</span><br><span class=\"line\">                spread(x, y, land)</span><br><span class=\"line\">                </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(R):</span><br><span class=\"line\">        spread(i, <span class=\"number\">0</span>, p_land)</span><br><span class=\"line\">        spread(i, C<span class=\"number\">-1</span>, a_land)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(C):</span><br><span class=\"line\">        spread(<span class=\"number\">0</span>, j, p_land)</span><br><span class=\"line\">        spread(R<span class=\"number\">-1</span>, j, a_land)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list(p_land &amp; a_land)</span><br></pre></td></tr></table></figure>\n<h3 id=\"526-Beautiful-Arrangement\"><a href=\"#526-Beautiful-Arrangement\" class=\"headerlink\" title=\"526. Beautiful Arrangement\"></a>526. Beautiful Arrangement</h3><h4 id=\"完美安排，给定1-N的数字，生成一种排列，是第i位的数字能被i整除，或者i能被第i位的数字整除，索引从1开始。原题\"><a href=\"#完美安排，给定1-N的数字，生成一种排列，是第i位的数字能被i整除，或者i能被第i位的数字整除，索引从1开始。原题\" class=\"headerlink\" title=\"完美安排，给定1~N的数字，生成一种排列，是第i位的数字能被i整除，或者i能被第i位的数字整除，索引从1开始。原题\"></a>完美安排，给定1~N的数字，生成一种排列，是第i位的数字能被i整除，或者i能被第i位的数字整除，索引从1开始。<a href=\"https://leetcode.com/problems/beautiful-arrangement/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: 2</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\"></span><br><span class=\"line\">The first beautiful arrangement is [1, 2]:</span><br><span class=\"line\"></span><br><span class=\"line\">Number at the 1st position (i&#x3D;1) is 1, and 1 is divisible by i (i&#x3D;1).</span><br><span class=\"line\"></span><br><span class=\"line\">Number at the 2nd position (i&#x3D;2) is 2, and 2 is divisible by i (i&#x3D;2).</span><br><span class=\"line\"></span><br><span class=\"line\">The second beautiful arrangement is [2, 1]:</span><br><span class=\"line\"></span><br><span class=\"line\">Number at the 1st position (i&#x3D;1) is 2, and 2 is divisible by i (i&#x3D;1).</span><br><span class=\"line\"></span><br><span class=\"line\">Number at the 2nd position (i&#x3D;2) is 1, and i (i&#x3D;2) is divisible by 1.</span><br></pre></td></tr></table></figure>\n<p>方法一：常规写法，1300ms，beats50%.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countArrangement</span><span class=\"params\">(self, N: int)</span> -&gt; int:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtrack</span><span class=\"params\">(g, rest)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">nonlocal</span> count</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> rest:</span><br><span class=\"line\">            count += <span class=\"number\">1</span></span><br><span class=\"line\">        index = len(g) + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, num <span class=\"keyword\">in</span> enumerate(rest):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> num % index == <span class=\"number\">0</span> <span class=\"keyword\">or</span> index % num == <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"comment\"># print(g, i, num, index, rest)</span></span><br><span class=\"line\">                g.append(num)</span><br><span class=\"line\">                backtrack(g, rest[:i]+rest[i+<span class=\"number\">1</span>:])</span><br><span class=\"line\">                g.pop()</span><br><span class=\"line\">    count = <span class=\"number\">0</span></span><br><span class=\"line\">    backtrack([], list(range(<span class=\"number\">1</span>, N+<span class=\"number\">1</span>)))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count</span><br></pre></td></tr></table></figure>\n<p>方法二：去掉了方法一中一些无用的空间和操作。1000ms, beats 67%.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countArrangement</span><span class=\"params\">(self, N: int)</span> -&gt; int:</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtrack</span><span class=\"params\">(g)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">nonlocal</span> count</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> rest:</span><br><span class=\"line\">            count += <span class=\"number\">1</span></span><br><span class=\"line\">        index = len(g) + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> rest:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> num % index == <span class=\"number\">0</span> <span class=\"keyword\">or</span> index % num == <span class=\"number\">0</span>:</span><br><span class=\"line\">                g.append(num)</span><br><span class=\"line\">                rest.remove(num)</span><br><span class=\"line\">                backtrack(g)</span><br><span class=\"line\">                g.pop()</span><br><span class=\"line\">                rest.add(num)</span><br><span class=\"line\">    count = <span class=\"number\">0</span></span><br><span class=\"line\">    rest = set(range(<span class=\"number\">1</span>, N+<span class=\"number\">1</span>))</span><br><span class=\"line\">    backtrack([])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：这里从后往前构建，最后构造1，因为1的位置放任何数字都可以。152ms</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countArrangement</span><span class=\"params\">(self, N: int)</span> -&gt; int:</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtrack</span><span class=\"params\">(i, rest)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum(backtrack(i<span class=\"number\">-1</span>, rest-&#123;x&#125;)</span><br><span class=\"line\">                   <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> rest</span><br><span class=\"line\">                   <span class=\"keyword\">if</span> x % i == <span class=\"number\">0</span> <span class=\"keyword\">or</span> i % x == <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> backtrack(N, set(range(<span class=\"number\">1</span>, N+<span class=\"number\">1</span>)))</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法四：在3的基础上优化，每次调用方法时可以利用之前的结果。52ms</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">cache = &#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countArrangement</span><span class=\"params\">(self, N: int)</span> -&gt; int:</span></span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtrack</span><span class=\"params\">(i, rest)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> i == <span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">            key = i, rest</span><br><span class=\"line\">            <span class=\"keyword\">if</span> key <span class=\"keyword\">in</span> cache:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> cache[key]</span><br><span class=\"line\">            ans =  sum(backtrack(i<span class=\"number\">-1</span>, rest[:j]+rest[j+<span class=\"number\">1</span>:])</span><br><span class=\"line\">                       <span class=\"keyword\">for</span> j, x <span class=\"keyword\">in</span> enumerate(rest)</span><br><span class=\"line\">                       <span class=\"keyword\">if</span> x % i == <span class=\"number\">0</span> <span class=\"keyword\">or</span> i % x == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"comment\"># print(ans, i, rest)</span></span><br><span class=\"line\">            cache[key] = ans</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">        <span class=\"keyword\">return</span> backtrack(N, tuple(range(<span class=\"number\">1</span>, N+<span class=\"number\">1</span>)))</span><br></pre></td></tr></table></figure>\n<h3 id=\"22-Generate-Parentheses\"><a href=\"#22-Generate-Parentheses\" class=\"headerlink\" title=\"22. Generate Parentheses\"></a>22. Generate Parentheses</h3><h4 id=\"生成n对合法的括号。原题\"><a href=\"#生成n对合法的括号。原题\" class=\"headerlink\" title=\"生成n对合法的括号。原题\"></a>生成n对合法的括号。<a href=\"https://leetcode.com/problems/generate-parentheses/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  &quot;((()))&quot;,</span><br><span class=\"line\">  &quot;(()())&quot;,</span><br><span class=\"line\">  &quot;(())()&quot;,</span><br><span class=\"line\">  &quot;()(())&quot;,</span><br><span class=\"line\">  &quot;()()()&quot;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>方法一：常规写法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">generateParenthesis</span><span class=\"params\">(self, n: int)</span> -&gt; List[str]:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtrack</span><span class=\"params\">(p, l, r)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(p) == n*<span class=\"number\">2</span>:</span><br><span class=\"line\">            ans.append(p)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> l &lt; n:</span><br><span class=\"line\">            backtrack(p+<span class=\"string\">'('</span>, l+<span class=\"number\">1</span>, r) </span><br><span class=\"line\">        <span class=\"keyword\">if</span> r &lt; l:</span><br><span class=\"line\">            backtrack(p+<span class=\"string\">')'</span>, l, r+<span class=\"number\">1</span>)</span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    backtrack(<span class=\"string\">''</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：生成器写法。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">generateParenthesis</span><span class=\"params\">(self, n: int)</span> -&gt; List[str]:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">gen_parens</span><span class=\"params\">(p, l, r)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> r &gt;= l &gt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> r:</span><br><span class=\"line\">                <span class=\"keyword\">yield</span> p</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> gen_parens(p+<span class=\"string\">'('</span>, l<span class=\"number\">-1</span>, r)</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> gen_parens(p+<span class=\"string\">')'</span>, l, r<span class=\"number\">-1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list(gen_parens(<span class=\"string\">''</span>, n, n))</span><br></pre></td></tr></table></figure>\n<h3 id=\"89-Gray-Code\"><a href=\"#89-Gray-Code\" class=\"headerlink\" title=\"89. Gray Code\"></a>89. Gray Code</h3><h4 id=\"灰码问题。给定一个n表示n位。从0开始每次改变一个位的数字，产生所有的组合。原题\"><a href=\"#灰码问题。给定一个n表示n位。从0开始每次改变一个位的数字，产生所有的组合。原题\" class=\"headerlink\" title=\"灰码问题。给定一个n表示n位。从0开始每次改变一个位的数字，产生所有的组合。原题\"></a>灰码问题。给定一个n表示n位。从0开始每次改变一个位的数字，产生所有的组合。<a href=\"https://leetcode.com/problems/gray-code/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: 2</span><br><span class=\"line\">Output: [0,1,3,2]</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">00 - 0</span><br><span class=\"line\">01 - 1</span><br><span class=\"line\">11 - 3</span><br><span class=\"line\">10 - 2</span><br><span class=\"line\"></span><br><span class=\"line\">For a given n, a gray code sequence may not be uniquely defined.</span><br><span class=\"line\">For example, [0,2,3,1] is also a valid gray code sequence.</span><br><span class=\"line\"></span><br><span class=\"line\">00 - 0</span><br><span class=\"line\">10 - 2</span><br><span class=\"line\">11 - 3</span><br><span class=\"line\">01 - 1</span><br></pre></td></tr></table></figure>\n<p>方法一：回溯法。一定要有顺序，一开始我误以为n位的进制0或1的组合。但是不行，因为不能从<code>01</code>跨越到<code>10</code>。这个问题我想了很久没有想出来如何解决，看到discuss中一个java版本的受到了启发。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">grayCode</span><span class=\"params\">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtrack</span><span class=\"params\">(p, n)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> n:</span><br><span class=\"line\">            ans.append(int(<span class=\"string\">''</span>.join(p), <span class=\"number\">2</span>))</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>):</span><br><span class=\"line\">            p += binary[i]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> p[<span class=\"number\">-1</span>] == <span class=\"string\">'0'</span>:</span><br><span class=\"line\">                backtrack(p, n<span class=\"number\">-1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                binary[<span class=\"number\">0</span>], binary[<span class=\"number\">1</span>] = binary[<span class=\"number\">1</span>], binary[<span class=\"number\">0</span>]</span><br><span class=\"line\">                backtrack(p, n<span class=\"number\">-1</span>)</span><br><span class=\"line\">                binary[<span class=\"number\">0</span>], binary[<span class=\"number\">1</span>] = binary[<span class=\"number\">1</span>], binary[<span class=\"number\">0</span>]</span><br><span class=\"line\">            p = p[:<span class=\"number\">-1</span>]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> n:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [<span class=\"number\">0</span>]</span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    binary = list(<span class=\"string\">'01'</span>)</span><br><span class=\"line\">    backtrack(<span class=\"string\">''</span>, n)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：此题有规律，这个规律讲不太好，有点像之字形那种感觉，倒序的时候在最高位补1。就能满足每个数只变化一位的要求。</font>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">0   1   11  110</span><br><span class=\"line\">        10  111</span><br><span class=\"line\">            101</span><br><span class=\"line\">            100</span><br><span class=\"line\"></span><br><span class=\"line\">start:      [0]  # [0]</span><br><span class=\"line\">i &#x3D; 0:      [0, 1]  # [0, 1]</span><br><span class=\"line\">i &#x3D; 1:      [0, 1, 3, 2]  # [00, 01, 11, 10]</span><br><span class=\"line\">i &#x3D; 2:      [0, 1, 3, 2, 6, 7, 5, 4]  # [000, 001, 011, 010, 110, 111, 101, 100]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">grayCode</span><span class=\"params\">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class=\"line\">    ans = [<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">        <span class=\"comment\"># ans += [x + pow(2, i) for x in reversed(ans)]</span></span><br><span class=\"line\">        ans += (x | <span class=\"number\">1</span>&lt;&lt;i <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> reversed(ans))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"842-Split-Array-into-Fibonacci-Sequence\"><a href=\"#842-Split-Array-into-Fibonacci-Sequence\" class=\"headerlink\" title=\"842. Split Array into Fibonacci Sequence\"></a>842. Split Array into Fibonacci Sequence</h3><h4 id=\"一串数组组成的字符串拆成斐波那契数列。原题\"><a href=\"#一串数组组成的字符串拆成斐波那契数列。原题\" class=\"headerlink\" title=\"一串数组组成的字符串拆成斐波那契数列。原题\"></a>一串数组组成的字符串拆成斐波那契数列。<a href=\"https://leetcode.com/problems/split-array-into-fibonacci-sequence/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: &quot;123456579&quot;</span><br><span class=\"line\">Output: [123,456,579]</span><br><span class=\"line\"></span><br><span class=\"line\">Input: &quot;112358130&quot;</span><br><span class=\"line\">Output: []</span><br><span class=\"line\">Explanation: The task is impossible.</span><br></pre></td></tr></table></figure>\n<p>ps: 此题第一天做的时候想了很久，提交了n个错误答案，后来第二天做的时候，20分钟就做出来了。</p>\n<p>方法一：第一次AC的答案。需要注意几个点。首先只有当元素结果大于2才算数列；主循环中<code>range(1, len(rest)+1)</code>否则会丢失最后元素；因为0的存在，所以要考虑0不能作为数字的开头；最后题中要求每个数字要在<code>int32</code>范围内。224ms.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">splitIntoFibonacci</span><span class=\"params\">(self, S: str)</span> -&gt; List[int]:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtrack</span><span class=\"params\">(p, rest)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> rest <span class=\"keyword\">and</span> len(p) &gt; <span class=\"number\">2</span>:</span><br><span class=\"line\">            ans.append(list(map(int, p)))</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(rest)+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(p) &lt; <span class=\"number\">2</span> <span class=\"keyword\">or</span> int(rest[:i])==int(p[<span class=\"number\">-1</span>])+int(p[<span class=\"number\">-2</span>]):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> len(rest[:i]) &gt; <span class=\"number\">1</span> <span class=\"keyword\">and</span> rest[<span class=\"number\">0</span>]==<span class=\"string\">'0'</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> int(rest[:i]) &gt; <span class=\"number\">2</span>**<span class=\"number\">31</span><span class=\"number\">-1</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\">                backtrack(p+[rest[:i]], rest[i:])</span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    backtrack([], S)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans[<span class=\"number\">0</span>] <span class=\"keyword\">if</span> ans <span class=\"keyword\">else</span> []</span><br></pre></td></tr></table></figure>\n<p>优化二：添加一个flag，在找到结果后返回。188ms, beats 26%.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">splitIntoFibonacci</span><span class=\"params\">(self, S: str)</span> -&gt; List[int]:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtrack</span><span class=\"params\">(p, rest)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># print(p, rest)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> rest <span class=\"keyword\">and</span> len(p) &gt; <span class=\"number\">2</span>:</span><br><span class=\"line\">            ans.append(list(map(int, p)))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(rest)+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(p) &lt; <span class=\"number\">2</span> <span class=\"keyword\">or</span> int(rest[:i])==int(p[<span class=\"number\">-1</span>])+int(p[<span class=\"number\">-2</span>]):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> len(rest[:i]) &gt; <span class=\"number\">1</span> <span class=\"keyword\">and</span> rest[<span class=\"number\">0</span>]==<span class=\"string\">'0'</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> int(rest[:i]) &gt; <span class=\"number\">2</span>**<span class=\"number\">31</span><span class=\"number\">-1</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> backtrack(p+[rest[:i]], rest[i:]):</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    backtrack([], S)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans[<span class=\"number\">0</span>] <span class=\"keyword\">if</span> ans <span class=\"keyword\">else</span> []</span><br></pre></td></tr></table></figure>\n<p>优化三：每个元素既然小于<code>2**31-1</code>那么，最长长度为10。在主循环中加入此条件可以提升到52ms。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">splitIntoFibonacci</span><span class=\"params\">(self, S: str)</span> -&gt; List[int]:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtrack</span><span class=\"params\">(p, rest)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> rest <span class=\"keyword\">and</span> len(p) &gt; <span class=\"number\">2</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> list(map(int, p))</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, min(<span class=\"number\">11</span>, len(rest)+<span class=\"number\">1</span>)):</span><br><span class=\"line\">            to_add = rest[:i]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(p) &lt; <span class=\"number\">2</span> <span class=\"keyword\">or</span> int(to_add)==int(p[<span class=\"number\">-1</span>])+int(p[<span class=\"number\">-2</span>]):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> len(to_add) &gt; <span class=\"number\">1</span> <span class=\"keyword\">and</span> rest.startswith(<span class=\"string\">'0'</span>):</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> int(to_add) &gt; <span class=\"number\">2</span>**<span class=\"number\">31</span><span class=\"number\">-1</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">                seq = backtrack(p+[to_add], rest[i:])</span><br><span class=\"line\">                <span class=\"keyword\">if</span> seq:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> seq</span><br><span class=\"line\">        <span class=\"keyword\">return</span> []</span><br><span class=\"line\"></span><br><span class=\"line\">    ans = backtrack([], S)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">优化4：当前两个数和已经为3位数时，下一个数没必要从1开始了。44ms。无论怎么提交都达不到迭代的40ms。猜测可能是递归栈的瓶颈了吧。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">splitIntoFibonacci</span><span class=\"params\">(self, S: str)</span> -&gt; List[int]:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtrack</span><span class=\"params\">(p, rest)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> rest <span class=\"keyword\">and</span> len(p) &gt; <span class=\"number\">2</span>:</span><br><span class=\"line\">            p[:] = list(map(int, p))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(p) &gt;= <span class=\"number\">2</span>:</span><br><span class=\"line\">            next_num = int(p[<span class=\"number\">-1</span>]) + int(p[<span class=\"number\">-2</span>])</span><br><span class=\"line\">            start = len(str(next_num))</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            start = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(start, min(<span class=\"number\">11</span>, len(rest)+<span class=\"number\">1</span>)):</span><br><span class=\"line\">            to_add = rest[:i]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(p) &lt; <span class=\"number\">2</span> <span class=\"keyword\">or</span> int(to_add)==next_num:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> len(to_add) &gt; <span class=\"number\">1</span> <span class=\"keyword\">and</span> rest.startswith(<span class=\"string\">'0'</span>):</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> int(to_add) &gt; <span class=\"number\">2</span>**<span class=\"number\">31</span><span class=\"number\">-1</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">                p.append(to_add)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> backtrack(p, rest[i:]):</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">                p.pop()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    backtrack(ans, S)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：迭代。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">splitIntoFibonacci</span><span class=\"params\">(self, S: str)</span> -&gt; List[int]:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(min(<span class=\"number\">10</span>, len(S))):</span><br><span class=\"line\">        a = S[:i+<span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> a != <span class=\"string\">'0'</span> <span class=\"keyword\">and</span> a.startswith(<span class=\"string\">'0'</span>): <span class=\"keyword\">break</span></span><br><span class=\"line\">        a = int(a)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i+<span class=\"number\">1</span>, min(i+<span class=\"number\">10</span>, len(S))):</span><br><span class=\"line\">            b = S[i+<span class=\"number\">1</span>:j+<span class=\"number\">1</span>]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> b != <span class=\"string\">'0'</span> <span class=\"keyword\">and</span> b.startswith(<span class=\"string\">'0'</span>): <span class=\"keyword\">break</span></span><br><span class=\"line\">            b = int(b)</span><br><span class=\"line\">            fib = [a, b]</span><br><span class=\"line\">            k = j + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> k &lt; len(S):</span><br><span class=\"line\">                nxt = fib[<span class=\"number\">-2</span>] + fib[<span class=\"number\">-1</span>]</span><br><span class=\"line\">                nxt_str = str(nxt)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> nxt &lt;= <span class=\"number\">2</span>**<span class=\"number\">31</span><span class=\"number\">-1</span> <span class=\"keyword\">and</span> S[k:].startswith(nxt_str):</span><br><span class=\"line\">                    fib.append(nxt)</span><br><span class=\"line\">                    k += len(nxt_str)</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> len(fib) &gt; <span class=\"number\">2</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> fib</span><br><span class=\"line\">    <span class=\"keyword\">return</span> []</span><br></pre></td></tr></table></figure>\n<h3 id=\"46-Permutations\"><a href=\"#46-Permutations\" class=\"headerlink\" title=\"46. Permutations\"></a>46. Permutations</h3><h4 id=\"数组全排列。原题\"><a href=\"#数组全排列。原题\" class=\"headerlink\" title=\"数组全排列。原题\"></a>数组全排列。<a href=\"https://leetcode.com/problems/permutations/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [1,2,3]</span><br><span class=\"line\">Output:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [1,2,3],</span><br><span class=\"line\">  [1,3,2],</span><br><span class=\"line\">  [2,1,3],</span><br><span class=\"line\">  [2,3,1],</span><br><span class=\"line\">  [3,1,2],</span><br><span class=\"line\">  [3,2,1]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法一：recursively. 锁定头部法。思想为拿出一个数字作为头部，剩下的递归。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">permute</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[n] + p</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i, n <span class=\"keyword\">in</span> enumerate(nums)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> self.permute(nums[:i]+nums[i+<span class=\"number\">1</span>:])] <span class=\"keyword\">or</span> [[]]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：到处插入法。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">permute</span><span class=\"params\">(self, nums: <span class=\"string\">'List[int]'</span>)</span> -&gt; 'List[List[int]]':</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums <span class=\"keyword\">and</span> [p[:i] + [nums[<span class=\"number\">0</span>]] + p[i:]</span><br><span class=\"line\">                     <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> self.permute(nums[<span class=\"number\">1</span>:])</span><br><span class=\"line\">                     <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(nums))] <span class=\"keyword\">or</span> [[]]</span><br></pre></td></tr></table></figure>\n<p>方法二：iteratively. 思想为拿出一个数字插入到现有排序中的各个位置。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">permute</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">    ans = [[]]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        ans = [l[:i] + [n] + l[i:]</span><br><span class=\"line\">               <span class=\"keyword\">for</span> l <span class=\"keyword\">in</span> ans</span><br><span class=\"line\">               <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(l)+<span class=\"number\">1</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"47-Permutations-II\"><a href=\"#47-Permutations-II\" class=\"headerlink\" title=\"47. Permutations II\"></a>47. Permutations II</h3><h4 id=\"全排列并去重。原题\"><a href=\"#全排列并去重。原题\" class=\"headerlink\" title=\"全排列并去重。原题\"></a>全排列并去重。<a href=\"https://leetcode.com/problems/permutations-ii/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [1,1,2]</span><br><span class=\"line\">Output:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [1,1,2],</span><br><span class=\"line\">  [1,2,1],</span><br><span class=\"line\">  [2,1,1]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>思路：当然可以使用<code>set</code>来去重，或者考虑一种迭代的方式。</p>\n<p>展开。拿着每个数字向上一个结果中插入到每一个位置。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">permuteUnique</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">    ans = [[]]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j, n <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">        new_ans = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> l <span class=\"keyword\">in</span> ans:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(l)+<span class=\"number\">1</span>):</span><br><span class=\"line\">                new_ans.append(l[:i]+[n]+l[i:])</span><br><span class=\"line\">                print(<span class=\"string\">'\\t j &#123;0&#125; - &#123;3&#125; + [&#123;2&#125;] + &#123;4&#125;'</span>.format(j, i, n, l[:i], l[i:]))</span><br><span class=\"line\">                <span class=\"comment\"># if i&lt;len(l) and l[i]==n: break              #handles duplication</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> i&lt;len(l) <span class=\"keyword\">and</span> l[i]==n: </span><br><span class=\"line\">                    print(<span class=\"string\">'\\t \\t l[&#123;&#125;] == &#123;&#125;'</span>.format(i, n))</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>              <span class=\"comment\">#handles duplication</span></span><br><span class=\"line\">        ans = new_ans</span><br><span class=\"line\">        print(<span class=\"string\">'j &#123;&#125; afer inner ans &#123;&#125;'</span>.format(j, ans))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>输入<code>nums=[1, 2, 3]</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">\t j 0 - [] + [1] + []</span><br><span class=\"line\">j 0 afer inner ans [[1]]</span><br><span class=\"line\">\t j 1 - [] + [2] + [1]</span><br><span class=\"line\">\t j 1 - [1] + [2] + []</span><br><span class=\"line\">j 1 afer inner ans [[2, 1], [1, 2]]</span><br><span class=\"line\">\t j 2 - [] + [3] + [2, 1]</span><br><span class=\"line\">\t j 2 - [2] + [3] + [1]</span><br><span class=\"line\">\t j 2 - [2, 1] + [3] + []</span><br><span class=\"line\">\t j 2 - [] + [3] + [1, 2]</span><br><span class=\"line\">\t j 2 - [1] + [3] + [2]</span><br><span class=\"line\">\t j 2 - [1, 2] + [3] + []</span><br><span class=\"line\">j 2 afer inner ans [[3, 2, 1], [2, 3, 1], [2, 1, 3], [3, 1, 2], [1, 3, 2], [1, 2, 3]]</span><br></pre></td></tr></table></figure>\n<p>理解一下是如何去重的，我们输入<code>nums=[1, 2, 1]</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">\t j 0 - [] + [1] + []</span><br><span class=\"line\">j 0 afer inner ans [[1]]</span><br><span class=\"line\">\t j 1 - [] + [2] + [1]</span><br><span class=\"line\">\t j 1 - [1] + [2] + []</span><br><span class=\"line\">j 1 afer inner ans [[2, 1], [1, 2]]</span><br><span class=\"line\">\t j 2 - [] + [1] + [2, 1]</span><br><span class=\"line\">\t j 2 - [2] + [1] + [1]</span><br><span class=\"line\">\t \t l[1] &#x3D;&#x3D; 1</span><br><span class=\"line\">\t j 2 - [] + [1] + [1, 2]</span><br><span class=\"line\">\t \t l[0] &#x3D;&#x3D; 1</span><br><span class=\"line\">j 2 afer inner ans [[1, 2, 1], [2, 1, 1], [1, 1, 2]]</span><br><span class=\"line\">[[1, 2, 1], [2, 1, 1], [1, 1, 2]]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">列表生成式整合。Stefan大神的写法。使用index来找非重复的临界值。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">permuteUnique</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">    ans = [[]]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        ans = [l[:i]+[n]+l[i:]</span><br><span class=\"line\">               <span class=\"keyword\">for</span> l <span class=\"keyword\">in</span> ans</span><br><span class=\"line\">               <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range((l+[n]).index(n)+<span class=\"number\">1</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">递归也可以</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">permuteUnique</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums <span class=\"keyword\">and</span> [p[:i] + [nums[<span class=\"number\">0</span>]] + p[i:]</span><br><span class=\"line\">                     <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> self.permuteUnique(nums[<span class=\"number\">1</span>:])</span><br><span class=\"line\">                     <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range((p+[nums[<span class=\"number\">0</span>]]).index(nums[<span class=\"number\">0</span>])+<span class=\"number\">1</span>)</span><br><span class=\"line\">                     ] <span class=\"keyword\">or</span> [[]]</span><br></pre></td></tr></table></figure>\n<h3 id=\"1079-Letter-Tile-Possibilities\"><a href=\"#1079-Letter-Tile-Possibilities\" class=\"headerlink\" title=\"1079. Letter Tile Possibilities\"></a>1079. Letter Tile Possibilities</h3><h4 id=\"本来是一道回溯的题，结果测试用例过于简单，所以暴力法就解出来了。原题\"><a href=\"#本来是一道回溯的题，结果测试用例过于简单，所以暴力法就解出来了。原题\" class=\"headerlink\" title=\"本来是一道回溯的题，结果测试用例过于简单，所以暴力法就解出来了。原题\"></a>本来是一道回溯的题，结果测试用例过于简单，所以暴力法就解出来了。<a href=\"https://leetcode.com/problems/letter-tile-possibilities/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: &quot;AAB&quot;</span><br><span class=\"line\">Output: 8</span><br><span class=\"line\">Explanation: The possible sequences are &quot;A&quot;, &quot;B&quot;, &quot;AA&quot;, &quot;AB&quot;, &quot;BA&quot;, &quot;AAB&quot;, &quot;ABA&quot;, &quot;BAA&quot;.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numTilePossibilities</span><span class=\"params\">(self, tiles: str)</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> itertools <span class=\"keyword\">import</span> permutations</span><br><span class=\"line\">    n = len(tiles)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(len(set(permutations(tiles, i))) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n+<span class=\"number\">1</span>))</span><br></pre></td></tr></table></figure>\n<h3 id=\"1415-The-k-th-Lexicographical-String-of-All-Happy-Strings-of-Length-n\"><a href=\"#1415-The-k-th-Lexicographical-String-of-All-Happy-Strings-of-Length-n\" class=\"headerlink\" title=\"1415. The k-th Lexicographical String of All Happy Strings of Length n\"></a>1415. The k-th Lexicographical String of All Happy Strings of Length n</h3><h4 id=\"列出第k个快乐字符串（a-b-c）组成并没有连续相同的字母。原题\"><a href=\"#列出第k个快乐字符串（a-b-c）组成并没有连续相同的字母。原题\" class=\"headerlink\" title=\"列出第k个快乐字符串（a,b,c）组成并没有连续相同的字母。原题\"></a>列出第k个快乐字符串（a,b,c）组成并没有连续相同的字母。<a href=\"https://leetcode.com/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：回溯法。列出所有的值，排序索引。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getHappyString</span><span class=\"params\">(self, n: int, k: int)</span> -&gt; str:</span></span><br><span class=\"line\">    combine = []</span><br><span class=\"line\">    s = <span class=\"string\">'abc'</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtrack</span><span class=\"params\">(cur, n)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            combine.append(cur)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> (cur <span class=\"keyword\">and</span> cur[<span class=\"number\">-1</span>]==c):</span><br><span class=\"line\">                backtrack(cur+c, n<span class=\"number\">-1</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    backtrack(<span class=\"string\">''</span>, n)</span><br><span class=\"line\">    combine.sort()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> combine[k<span class=\"number\">-1</span>] <span class=\"keyword\">if</span> k &lt;= len(combine) <span class=\"keyword\">else</span> <span class=\"string\">''</span></span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：开始想的就是这种方法，后来想偏了，想用数学的方式直接求目标字符串，最后没有写出来。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getHappyString</span><span class=\"params\">(self, n: int, k: int)</span> -&gt; str:</span></span><br><span class=\"line\">    nxt = &#123;<span class=\"string\">'a'</span>: <span class=\"string\">'bc'</span>, <span class=\"string\">'b'</span>: <span class=\"string\">'ac'</span>, <span class=\"string\">'c'</span>: <span class=\"string\">'ab'</span>&#125; </span><br><span class=\"line\">    q = collections.deque([<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>])</span><br><span class=\"line\">    <span class=\"keyword\">while</span> len(q[<span class=\"number\">0</span>]) != n:</span><br><span class=\"line\">        u = q.popleft()    </span><br><span class=\"line\">        <span class=\"keyword\">for</span> v <span class=\"keyword\">in</span> nxt[u[<span class=\"number\">-1</span>]]:</span><br><span class=\"line\">            q.append(u + v)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> q[k - <span class=\"number\">1</span>] <span class=\"keyword\">if</span> len(q) &gt;= k <span class=\"keyword\">else</span> <span class=\"string\">''</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1255-Maximum-Score-Words-Formed-by-Letters\"><a href=\"#1255-Maximum-Score-Words-Formed-by-Letters\" class=\"headerlink\" title=\"1255. Maximum Score Words Formed by Letters\"></a>1255. Maximum Score Words Formed by Letters</h3><h4 id=\"给定一些单词，每个字母有得分，不过每个字母用多少是有限制的。问最大得分是多少，一个典型的背包问题。原题\"><a href=\"#给定一些单词，每个字母有得分，不过每个字母用多少是有限制的。问最大得分是多少，一个典型的背包问题。原题\" class=\"headerlink\" title=\"给定一些单词，每个字母有得分，不过每个字母用多少是有限制的。问最大得分是多少，一个典型的背包问题。原题\"></a>给定一些单词，每个字母有得分，不过每个字母用多少是有限制的。问最大得分是多少，一个典型的背包问题。<a href=\"https://leetcode.com/problems/maximum-score-words-formed-by-letters/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: words &#x3D; [&quot;dog&quot;,&quot;cat&quot;,&quot;dad&quot;,&quot;good&quot;], letters &#x3D; [&quot;a&quot;,&quot;a&quot;,&quot;c&quot;,&quot;d&quot;,&quot;d&quot;,&quot;d&quot;,&quot;g&quot;,&quot;o&quot;,&quot;o&quot;], score &#x3D; [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0]</span><br><span class=\"line\">Output: 23</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">Score  a&#x3D;1, c&#x3D;9, d&#x3D;5, g&#x3D;3, o&#x3D;2</span><br><span class=\"line\">Given letters, we can form the words &quot;dad&quot; (5+1+5) and &quot;good&quot; (3+2+2+5) with a score of 23.</span><br><span class=\"line\">Words &quot;dad&quot; and &quot;dog&quot; only get a score of 21.</span><br></pre></td></tr></table></figure>\n<p>方法一：回溯。累加单词的分数可以提前退出递归。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxScoreWords</span><span class=\"params\">(self, words: List[str], letters: List[str], score: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    self.ans, n = <span class=\"number\">0</span>, len(words)</span><br><span class=\"line\">    wc = [Counter(w) <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> words]</span><br><span class=\"line\">    ws = [sum(v*score[ord(k)-ord(<span class=\"string\">'a'</span>)] <span class=\"keyword\">for</span> k, v <span class=\"keyword\">in</span> wc[i].items()) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(i, s, left)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> s + sum(ws[i:]) &lt;= self.ans:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        self.ans = max(self.ans, s)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j, wcnt <span class=\"keyword\">in</span> enumerate(wc[i:], i):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> all(n &lt;= left.get(c, <span class=\"number\">0</span>) <span class=\"keyword\">for</span> c, n <span class=\"keyword\">in</span> wcnt.items()):</span><br><span class=\"line\">                dfs(j+<span class=\"number\">1</span>, s+ws[j], left-wcnt)</span><br><span class=\"line\">                </span><br><span class=\"line\">    dfs(<span class=\"number\">0</span>, <span class=\"number\">0</span>, Counter(letters))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.ans</span><br></pre></td></tr></table></figure>\n<p>方法二：这个和我一开始想的方法很像。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxScoreWords</span><span class=\"params\">(self, words: List[str], letters: List[str], score: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtrack</span><span class=\"params\">(i, left)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == len(words):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        wc = Counter(words[i])</span><br><span class=\"line\">        <span class=\"keyword\">if</span> all(n&lt;=left[c] <span class=\"keyword\">for</span> c, n <span class=\"keyword\">in</span> wc.items()):</span><br><span class=\"line\">            cur_score = sum(v*score[ord(k)-ord(<span class=\"string\">'a'</span>)] <span class=\"keyword\">for</span> k, v <span class=\"keyword\">in</span> wc.items())</span><br><span class=\"line\">            ans = max(cur_score + backtrack(i+<span class=\"number\">1</span>, left-wc), backtrack(i+<span class=\"number\">1</span>, left))</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            ans = backtrack(i+<span class=\"number\">1</span>, left)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">    <span class=\"keyword\">return</span> backtrack(<span class=\"number\">0</span>, Counter(letters))</span><br></pre></td></tr></table></figure>\n<h3 id=\"1239-Maximum-Length-of-a-Concatenated-String-with-Unique-Characters\"><a href=\"#1239-Maximum-Length-of-a-Concatenated-String-with-Unique-Characters\" class=\"headerlink\" title=\"1239. Maximum Length of a Concatenated String with Unique Characters\"></a>1239. Maximum Length of a Concatenated String with Unique Characters</h3><h4 id=\"最长的不重复的字符串组合。原题\"><a href=\"#最长的不重复的字符串组合。原题\" class=\"headerlink\" title=\"最长的不重复的字符串组合。原题\"></a>最长的不重复的字符串组合。<a href=\"https://leetcode.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: arr &#x3D; [&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;]</span><br><span class=\"line\">Output: 4</span><br><span class=\"line\">Explanation: All possible concatenations are &quot;&quot;,&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;,&quot;uniq&quot; and &quot;ique&quot;.</span><br><span class=\"line\">Maximum length is 4.</span><br></pre></td></tr></table></figure>\n<p>方法一：回溯法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxLength</span><span class=\"params\">(self, arr: List[str])</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(i, seen)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == len(arr):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span> </span><br><span class=\"line\">        <span class=\"keyword\">if</span> set(arr[i]) &amp; seen <span class=\"keyword\">or</span> len(set(arr[i]))!=len(arr[i]):</span><br><span class=\"line\">            ans = dfs(i+<span class=\"number\">1</span>, seen)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            ans = max(len(arr[i]) + dfs(i+<span class=\"number\">1</span>, seen|set(arr[i])), dfs(i+<span class=\"number\">1</span>, seen))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> dfs(<span class=\"number\">0</span>, set())</span><br></pre></td></tr></table></figure>\n<p>方法二：Lee215的解法。append的方式，会将每步累加的追加的ans中。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxLength</span><span class=\"params\">(self, arr: List[str])</span> -&gt; int:</span></span><br><span class=\"line\">    ans = [set()]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> arr:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(set(a)) != len(a):<span class=\"keyword\">continue</span></span><br><span class=\"line\">        a = set(a)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> ans[:]:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> a &amp; c: <span class=\"keyword\">continue</span></span><br><span class=\"line\">            ans.append(a | c)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(len(a) <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> ans)</span><br></pre></td></tr></table></figure>\n<h3 id=\"51-N-Queens\"><a href=\"#51-N-Queens\" class=\"headerlink\" title=\"51. N-Queens\"></a>51. N-Queens</h3><h4 id=\"著名的N皇后问题，将N个皇后摆在N-N的棋盘中，直线，斜线不能同时存在2个皇后。问所有的摆放位置。原题\"><a href=\"#著名的N皇后问题，将N个皇后摆在N-N的棋盘中，直线，斜线不能同时存在2个皇后。问所有的摆放位置。原题\" class=\"headerlink\" title=\"著名的N皇后问题，将N个皇后摆在N*N的棋盘中，直线，斜线不能同时存在2个皇后。问所有的摆放位置。原题\"></a>著名的N皇后问题，将N个皇后摆在N*N的棋盘中，直线，斜线不能同时存在2个皇后。问所有的摆放位置。<a href=\"https://leetcode.com/problems/n-queens/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：调了一次就AC了。记录第一次AC的方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">solveNQueens</span><span class=\"params\">(self, n: int)</span> -&gt; List[List[str]]:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    l_dig = [<span class=\"literal\">False</span>] * (n*<span class=\"number\">2</span><span class=\"number\">-1</span>)</span><br><span class=\"line\">    r_dig = [<span class=\"literal\">False</span>] * (n*<span class=\"number\">2</span><span class=\"number\">-1</span>)</span><br><span class=\"line\">    row = [<span class=\"literal\">False</span>] * n</span><br><span class=\"line\">    col = [<span class=\"literal\">False</span>] * n</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtrack</span><span class=\"params\">(i, j, k, g)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># print(i, j, k, g)</span></span><br><span class=\"line\">        row[i] = <span class=\"literal\">True</span></span><br><span class=\"line\">        col[j] = <span class=\"literal\">True</span></span><br><span class=\"line\">        l_dig[i+j] = <span class=\"literal\">True</span></span><br><span class=\"line\">        r_dig[j-i+n<span class=\"number\">-1</span>] = <span class=\"literal\">True</span></span><br><span class=\"line\">        g[i][j] = <span class=\"string\">'Q'</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> k<span class=\"number\">-1</span>:</span><br><span class=\"line\">            ans.append([<span class=\"string\">''</span>.join(row) <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> g])</span><br><span class=\"line\">        <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(i+<span class=\"number\">1</span>, n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> row[x]:</span><br><span class=\"line\">                <span class=\"keyword\">for</span> y <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> col[y]:</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> l_dig[x+y] <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> r_dig[y-x+n<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                            backtrack(x, y, k<span class=\"number\">-1</span>, g)</span><br><span class=\"line\">        row[i] = <span class=\"literal\">False</span></span><br><span class=\"line\">        col[j] = <span class=\"literal\">False</span></span><br><span class=\"line\">        l_dig[i+j] = <span class=\"literal\">False</span></span><br><span class=\"line\">        r_dig[j-i+n<span class=\"number\">-1</span>] = <span class=\"literal\">False</span></span><br><span class=\"line\">        g[i][j] = <span class=\"string\">'.'</span></span><br><span class=\"line\">                        </span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">        g = [[<span class=\"string\">'.'</span>]*n <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">        backtrack(<span class=\"number\">0</span>, j, n, g)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法二：row是不必要的，因为遍历行是不会有重复的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">solveNQueens</span><span class=\"params\">(self, n: int)</span> -&gt; List[List[str]]:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    l_dig = [<span class=\"literal\">False</span>] * (n*<span class=\"number\">2</span><span class=\"number\">-1</span>)</span><br><span class=\"line\">    r_dig = [<span class=\"literal\">False</span>] * (n*<span class=\"number\">2</span><span class=\"number\">-1</span>)</span><br><span class=\"line\">    col = [<span class=\"literal\">False</span>] * n</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtrack</span><span class=\"params\">(i, j, k, g)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># print(i, j, k, g)</span></span><br><span class=\"line\">        col[j] = l_dig[i+j] = r_dig[j-i+n<span class=\"number\">-1</span>] = <span class=\"literal\">True</span></span><br><span class=\"line\">        g[i][j] = <span class=\"string\">'Q'</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> k<span class=\"number\">-1</span>:</span><br><span class=\"line\">            ans.append([<span class=\"string\">''</span>.join(row) <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> g])</span><br><span class=\"line\">        <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(i+<span class=\"number\">1</span>, n):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> y <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> col[y]:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> l_dig[x+y] <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> r_dig[y-x+n<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                        backtrack(x, y, k<span class=\"number\">-1</span>, g)</span><br><span class=\"line\">        col[j] = l_dig[i+j] = r_dig[j-i+n<span class=\"number\">-1</span>] = <span class=\"literal\">False</span></span><br><span class=\"line\">        g[i][j] = <span class=\"string\">'.'</span></span><br><span class=\"line\">                        </span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">        g = [[<span class=\"string\">'.'</span>]*n <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">        backtrack(<span class=\"number\">0</span>, j, n, g)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：上述两种方法，用时800ms，此方法52ms，直接以行为单位进行回溯。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">solveNQueens</span><span class=\"params\">(self, n: int)</span> -&gt; List[List[str]]:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    l_dig = [<span class=\"literal\">False</span>] * (n*<span class=\"number\">2</span><span class=\"number\">-1</span>)</span><br><span class=\"line\">    r_dig = [<span class=\"literal\">False</span>] * (n*<span class=\"number\">2</span><span class=\"number\">-1</span>)</span><br><span class=\"line\">    col = [<span class=\"literal\">False</span>] * n</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtrack</span><span class=\"params\">(i, g)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># print(i, j, k, g)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == n:</span><br><span class=\"line\">            ans.append(list(g))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> col[j] <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> l_dig[i+j] <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> r_dig[j-i+n<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                row = <span class=\"string\">'.'</span>*j + <span class=\"string\">'Q'</span> + <span class=\"string\">'.'</span>*(n-j<span class=\"number\">-1</span>)</span><br><span class=\"line\">                g.append(row)</span><br><span class=\"line\">                col[j] = l_dig[i+j] = r_dig[j-i+n<span class=\"number\">-1</span>] = <span class=\"literal\">True</span></span><br><span class=\"line\">                backtrack(i+<span class=\"number\">1</span>, g)</span><br><span class=\"line\">                col[j] = l_dig[i+j] = r_dig[j-i+n<span class=\"number\">-1</span>] = <span class=\"literal\">False</span></span><br><span class=\"line\">                g.pop()</span><br><span class=\"line\">                        </span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    backtrack(<span class=\"number\">0</span>, [])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"52-N-Queens-II\"><a href=\"#52-N-Queens-II\" class=\"headerlink\" title=\"52. N-Queens II\"></a>52. N-Queens II</h3><h4 id=\"和上边一样的N皇后问题，要求最后有多少种。原题\"><a href=\"#和上边一样的N皇后问题，要求最后有多少种。原题\" class=\"headerlink\" title=\"和上边一样的N皇后问题，要求最后有多少种。原题\"></a>和上边一样的N皇后问题，要求最后有多少种。<a href=\"https://leetcode.com/problems/n-queens-ii/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：不再需要一个数组来记录棋盘了，只需要计数就行。然后通过一个数组标记每行的棋子的纵坐标。而且无需重置，因为值会覆盖之前的。本质上还是回溯方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">totalNQueens</span><span class=\"params\">(self, n: int)</span> -&gt; int:</span></span><br><span class=\"line\">    rows = [<span class=\"number\">-1</span>] * n</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">valid</span><span class=\"params\">(k)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(k):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> rows[i]==rows[k] <span class=\"keyword\">or</span> abs(rows[k]-rows[i]) == k-i:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(i)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == n: </span><br><span class=\"line\">            <span class=\"keyword\">nonlocal</span> ans</span><br><span class=\"line\">            ans += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            rows[i] = j</span><br><span class=\"line\">            <span class=\"keyword\">if</span> valid(i):</span><br><span class=\"line\">                dfs(i+<span class=\"number\">1</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    dfs(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法二：位运算，空间上节省了一个一维数组，虽然数组长度不会很长。时间上快了一倍。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">totalNQueens</span><span class=\"params\">(self, n: int)</span> -&gt; int:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(n, row=<span class=\"number\">0</span>, col=<span class=\"number\">0</span>, ld=<span class=\"number\">0</span>, rd=<span class=\"number\">0</span>, bits=<span class=\"number\">0</span>)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> row &gt;= n: </span><br><span class=\"line\">            <span class=\"keyword\">nonlocal</span> count</span><br><span class=\"line\">            count += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"comment\"># col, ld, rd 中1表示不能放置，0表示可以放置</span></span><br><span class=\"line\">        bits = (~(col | ld | rd)) &amp; ((<span class=\"number\">1</span> &lt;&lt; n) - <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"comment\"># bits 表示剩余的皇后的列位置，也就是说某位为1，表示这一列的皇后还没有放</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> bits:   </span><br><span class=\"line\">            p = bits &amp; -bits   <span class=\"comment\"># 保留最后一位1，其余置为0</span></span><br><span class=\"line\">            bits = bits &amp; (bits - <span class=\"number\">1</span>)  <span class=\"comment\"># 去掉最后一位1</span></span><br><span class=\"line\">            dfs(n, row+<span class=\"number\">1</span>, col|p, (ld|p) &lt;&lt; <span class=\"number\">1</span>, (rd|p) &gt;&gt; <span class=\"number\">1</span>, bits)</span><br><span class=\"line\"></span><br><span class=\"line\">    count = <span class=\"number\">0</span></span><br><span class=\"line\">    dfs(n)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count</span><br></pre></td></tr></table></figure>\n<h3 id=\"37-Sudoku-Solver\"><a href=\"#37-Sudoku-Solver\" class=\"headerlink\" title=\"37. Sudoku Solver\"></a>37. Sudoku Solver</h3><h4 id=\"解9-9的数独。原题\"><a href=\"#解9-9的数独。原题\" class=\"headerlink\" title=\"解9*9的数独。原题\"></a>解9*9的数独。<a href=\"https://leetcode.com/problems/sudoku-solver/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：首次AC的方法，嗨呀，递归调用时忘记写return True了，调了半天。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">solveSudoku</span><span class=\"params\">(self, g: List[List[str]])</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    Do not return anything, modify board in-place instead.</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    row = [[<span class=\"literal\">True</span>]*<span class=\"number\">9</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">9</span>)]        </span><br><span class=\"line\">    col = [[<span class=\"literal\">True</span>]*<span class=\"number\">9</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">9</span>)]</span><br><span class=\"line\">    sub = [[<span class=\"literal\">True</span>]*<span class=\"number\">9</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">9</span>)]</span><br><span class=\"line\">    to_add = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">9</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">9</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> g[i][j] != <span class=\"string\">'.'</span>:</span><br><span class=\"line\">                d = int(g[i][j]) - <span class=\"number\">1</span></span><br><span class=\"line\">                row[i][d] = col[j][d] = sub[i//<span class=\"number\">3</span>*<span class=\"number\">3</span>+j//<span class=\"number\">3</span>][d] = <span class=\"literal\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                to_add.append((i, j))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtrack</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> to_add: </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        i, j = to_add.pop()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> range(<span class=\"number\">9</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> row[i][d] <span class=\"keyword\">and</span> col[j][d] <span class=\"keyword\">and</span> sub[i//<span class=\"number\">3</span>*<span class=\"number\">3</span>+j//<span class=\"number\">3</span>][d]:</span><br><span class=\"line\">                g[i][j] = str(d+<span class=\"number\">1</span>)</span><br><span class=\"line\">                row[i][d] = col[j][d] = sub[i//<span class=\"number\">3</span>*<span class=\"number\">3</span>+j//<span class=\"number\">3</span>][d] = <span class=\"literal\">False</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> backtrack():</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">                g[i][j] = <span class=\"string\">'.'</span></span><br><span class=\"line\">                row[i][d] = col[j][d] = sub[i//<span class=\"number\">3</span>*<span class=\"number\">3</span>+j//<span class=\"number\">3</span>][d] = <span class=\"literal\">True</span></span><br><span class=\"line\">        to_add.append((i, j))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">    backtrack()</span><br></pre></td></tr></table></figure>\n<h3 id=\"980-Unique-Paths-III\"><a href=\"#980-Unique-Paths-III\" class=\"headerlink\" title=\"980. Unique Paths III\"></a><a href=\"https://leetcode.com/problems/unique-paths-iii/\" target=\"_blank\" rel=\"noopener\">980. Unique Paths III</a></h3><h4 id=\"二维数组中有0，1，2，-1四种格子，要求从1开始走到2，经过所有的0，一共有多少种走法。\"><a href=\"#二维数组中有0，1，2，-1四种格子，要求从1开始走到2，经过所有的0，一共有多少种走法。\" class=\"headerlink\" title=\"二维数组中有0，1，2，-1四种格子，要求从1开始走到2，经过所有的0，一共有多少种走法。\"></a>二维数组中有0，1，2，-1四种格子，要求从1开始走到2，经过所有的0，一共有多少种走法。</h4><p>方法一：回溯法，思路很清晰，很快就写出来了，方向变量写错了调了半天。只需要关注0的个数就行。有优化的地方，因为1和2只有一个，所以可以先遍历一次找出0个个数和1的位置。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">uniquePathsIII</span><span class=\"params\">(self, g: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    M, N = len(g) , len(g[<span class=\"number\">0</span>])</span><br><span class=\"line\">    f = sum(g, [])</span><br><span class=\"line\">    zero = f.count(<span class=\"number\">0</span>)</span><br><span class=\"line\">    self.ans = <span class=\"number\">0</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bf</span><span class=\"params\">(i, j, n)</span>:</span></span><br><span class=\"line\">        ori = g[i][j]    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> ori == <span class=\"number\">2</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> n==zero+<span class=\"number\">2</span>:</span><br><span class=\"line\">                self.ans += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> </span><br><span class=\"line\">        g[i][j] = <span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> ((i+<span class=\"number\">1</span>, j), (i, j+<span class=\"number\">1</span>), (i<span class=\"number\">-1</span>, j), (i, j<span class=\"number\">-1</span>)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=x&lt;M <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=y&lt;N <span class=\"keyword\">and</span> g[x][y] <span class=\"keyword\">in</span> (<span class=\"number\">0</span>, <span class=\"number\">2</span>):</span><br><span class=\"line\">                bf(x, y, n+<span class=\"number\">1</span>)</span><br><span class=\"line\">        g[i][j] = ori</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(M):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(N):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> g[i][j] == <span class=\"number\">1</span>:</span><br><span class=\"line\">                bf(i, j, <span class=\"number\">1</span>)</span><br><span class=\"line\">                </span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"491-Increasing-Subsequences\"><a href=\"#491-Increasing-Subsequences\" class=\"headerlink\" title=\"491. Increasing Subsequences\"></a><a href=\"https://leetcode.com/problems/increasing-subsequences/\" target=\"_blank\" rel=\"noopener\">491. Increasing Subsequences</a></h3><h4 id=\"求一个数组的所有的长度2以上的递增子序列。\"><a href=\"#求一个数组的所有的长度2以上的递增子序列。\" class=\"headerlink\" title=\"求一个数组的所有的长度2以上的递增子序列。\"></a>求一个数组的所有的长度2以上的递增子序列。</h4><font color=\"#32CD32\" size=\"3\">方法一：联系了几道题，求最大长度的是用的dp，不适合这个。这里发现和subsets的组合有点像。于是用了78题中的方法二。因为数组本身最大也就15长度，所以方法并不很耗时。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findSubsequences</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">    ans = [[]]        </span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        ans += [pre+[num] <span class=\"keyword\">for</span> pre <span class=\"keyword\">in</span> ans <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> pre <span class=\"keyword\">or</span> pre[<span class=\"number\">-1</span>]&lt;=num]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list(&#123;tuple(a) <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> ans <span class=\"keyword\">if</span> len(a)&gt;=<span class=\"number\">2</span>&#125;)</span><br></pre></td></tr></table></figure>\n<p>方法二：我想用90的方法直接去重，试了一下，发现90题依赖数组有序才能去重，所以这里并不适用。只能最后通过转化tuple，set再去重。效率只有方法一的一半。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findSubsequences</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(i, m, p)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> m:</span><br><span class=\"line\">            ans.append(p[:])</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i, n):</span><br><span class=\"line\">            d = nums[j]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> p <span class=\"keyword\">or</span> d &gt;= p[<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                p.append(d)</span><br><span class=\"line\">                dfs(j+<span class=\"number\">1</span>, m<span class=\"number\">-1</span>, p)</span><br><span class=\"line\">                p.pop()</span><br><span class=\"line\">    </span><br><span class=\"line\">    n, ans = len(nums), []</span><br><span class=\"line\">    [dfs(<span class=\"number\">0</span>, i, []) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>, n+<span class=\"number\">1</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list(&#123;tuple(a) <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> ans&#125;)</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：Stefan的方法，我想的就差了一步，ans可以直接用set。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findSubsequences</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">    ans = &#123;()&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        ans |= &#123;pre+(num, ) <span class=\"keyword\">for</span> pre <span class=\"keyword\">in</span> ans <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> pre <span class=\"keyword\">or</span> pre[<span class=\"number\">-1</span>]&lt;=num&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [a <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> ans <span class=\"keyword\">if</span> len(a)&gt;=<span class=\"number\">2</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"面试题-08-09-括号\"><a href=\"#面试题-08-09-括号\" class=\"headerlink\" title=\"面试题 08.09. 括号\"></a><a href=\"https://leetcode-cn.com/problems/bracket-lcci/\" target=\"_blank\" rel=\"noopener\">面试题 08.09. 括号</a></h3><h4 id=\"求n对括号的合法组合。\"><a href=\"#求n对括号的合法组合。\" class=\"headerlink\" title=\"求n对括号的合法组合。\"></a>求n对括号的合法组合。</h4><p>方法一：回溯，我的方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">generateParenthesis</span><span class=\"params\">(self, n: int)</span> -&gt; List[str]:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtrack</span><span class=\"params\">(l, r, p)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> l <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> r: </span><br><span class=\"line\">            ans.append(<span class=\"string\">''</span>.join(p))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> </span><br><span class=\"line\">        <span class=\"keyword\">if</span> l:</span><br><span class=\"line\">            p.append(<span class=\"string\">'('</span>)</span><br><span class=\"line\">            backtrack(l<span class=\"number\">-1</span>, r, p)</span><br><span class=\"line\">            p.pop()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> r <span class=\"keyword\">and</span> r&gt;l:</span><br><span class=\"line\">            p.append(<span class=\"string\">')'</span>)</span><br><span class=\"line\">            backtrack(l, r<span class=\"number\">-1</span>, p)</span><br><span class=\"line\">            p.pop()</span><br><span class=\"line\"></span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    backtrack(n, n, [])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法二：大神的方法，学习了，使用and代替if。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">generateParenthesis</span><span class=\"params\">(self, n: int)</span> -&gt; List[str]:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(l, r, s)</span>:</span></span><br><span class=\"line\">        l == r == n <span class=\"keyword\">and</span> ans.append(s)</span><br><span class=\"line\">        l &lt; n <span class=\"keyword\">and</span> f(l + <span class=\"number\">1</span>, r, s + <span class=\"string\">'('</span>)</span><br><span class=\"line\">        r &lt; l <span class=\"keyword\">and</span> f(l, r + <span class=\"number\">1</span>, s + <span class=\"string\">')'</span>)</span><br><span class=\"line\">    f(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"string\">''</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"1655-Distribute-Repeating-Integers\"><a href=\"#1655-Distribute-Repeating-Integers\" class=\"headerlink\" title=\"1655. Distribute Repeating Integers\"></a><a href=\"https://leetcode.com/problems/distribute-repeating-integers/\" target=\"_blank\" rel=\"noopener\">1655. Distribute Repeating Integers</a></h3><h4 id=\"分配重复的数字，根据quantity中每个顾客的需求，给每个人分配quantity-i-个相同的元素。\"><a href=\"#分配重复的数字，根据quantity中每个顾客的需求，给每个人分配quantity-i-个相同的元素。\" class=\"headerlink\" title=\"分配重复的数字，根据quantity中每个顾客的需求，给每个人分配quantity[i]个相同的元素。\"></a>分配重复的数字，根据<code>quantity</code>中每个顾客的需求，给每个人分配<code>quantity[i]</code>个相同的元素。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [1,2,3,4], quantity &#x3D; [2]</span><br><span class=\"line\">Output: false</span><br><span class=\"line\">Explanation: The 0th customer cannot be given two different integers.</span><br><span class=\"line\">Input: nums &#x3D; [1,1,1,1,1], quantity &#x3D; [2,3]</span><br><span class=\"line\">Output: true</span><br><span class=\"line\">Explanation: The 0th customer is given [1,1], and the 1st customer is given [1,1,1].</span><br></pre></td></tr></table></figure>\n<p>方法一：暴力回溯法。作为竞赛的4题没有做上来。比赛的时候想用一种贪心的方式来做，这样做是不对的。这是Lee215竞赛时的方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">canDistribute</span><span class=\"params\">(self, nums: List[int], quantity: List[int])</span> -&gt; bool:</span></span><br><span class=\"line\">    cnts = sorted(Counter(nums).values())</span><br><span class=\"line\">    fail = &#123;&#125;</span><br><span class=\"line\">    N = len(quantity)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtrack</span><span class=\"params\">(state, i)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == N:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        t = tuple(state)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> t <span class=\"keyword\">in</span> fail:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        x = quantity[i]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j, v <span class=\"keyword\">in</span> enumerate(state):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> j&gt;<span class=\"number\">0</span> <span class=\"keyword\">and</span> state[j<span class=\"number\">-1</span>]==v:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> v &lt; x:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            state[j] -= x</span><br><span class=\"line\">            <span class=\"keyword\">if</span> backtrack(sorted(state), i+<span class=\"number\">1</span>):</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">            state[j] += x</span><br><span class=\"line\">        fail[t] = <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> backtrack(cnts, <span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"1718-Construct-the-Lexicographically-Largest-Valid-Sequence\"><a href=\"#1718-Construct-the-Lexicographically-Largest-Valid-Sequence\" class=\"headerlink\" title=\"1718. Construct the Lexicographically Largest Valid Sequence\"></a><a href=\"https://leetcode.com/problems/construct-the-lexicographically-largest-valid-sequence/\" target=\"_blank\" rel=\"noopener\">1718. Construct the Lexicographically Largest Valid Sequence</a></h3><blockquote>\n<p>给你一个整数 n ，请你找到满足下面条件的一个序列：</p>\n<p>整数 1 在序列中只出现一次。<br>2 到 n 之间每个整数都恰好出现两次。<br>对于每个 2 到 n 之间的整数 i ，两个 i 之间出现的距离恰好为 i 。<br>序列里面两个数 a[i] 和 a[j] 之间的 距离 ，我们定义为它们下标绝对值之差 |j - i| 。</p>\n<p>请你返回满足上述条件中 字典序最大 的序列。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：n &#x3D; 3</span><br><span class=\"line\">输出：[3,1,2,3,2]</span><br><span class=\"line\">解释：[2,3,2,1,3] 也是一个可行的序列，但是 [3,1,2,3,2] 是字典序最大的序列。</span><br></pre></td></tr></table></figure>\n<p>方法一：比赛时没时间做，思路是正确的，有一个判断很关键，没有这个判断代码将会超时。里面有贪心的思想，优先拿最大的数。<br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">constructDistancedSequence</span><span class=\"params\">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    can = list(range(<span class=\"number\">1</span>, n+<span class=\"number\">1</span>))</span><br><span class=\"line\">    res = [<span class=\"number\">-1</span>] * (n*<span class=\"number\">2</span> - <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtrack</span><span class=\"params\">(i, left)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> left:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> res[i] != <span class=\"number\">-1</span>:\t\t\t\t\t<span class=\"comment\"># 没有这个优化，代码将会超时。</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> backtrack(i+<span class=\"number\">1</span>, left)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(left)<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">            d = left[j]</span><br><span class=\"line\">            r = i <span class=\"keyword\">if</span> d==<span class=\"number\">1</span> <span class=\"keyword\">else</span> i+d</span><br><span class=\"line\">            <span class=\"keyword\">if</span> r&lt;len(res) <span class=\"keyword\">and</span> res[r]==<span class=\"number\">-1</span>:</span><br><span class=\"line\">                res[i] = res[r] = d</span><br><span class=\"line\">                <span class=\"keyword\">if</span> backtrack(i+<span class=\"number\">1</span>, left[:j]+left[j+<span class=\"number\">1</span>:]):</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">                res[i] = res[r] = <span class=\"number\">-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    backtrack(<span class=\"number\">0</span>, can)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"1723-Find-Minimum-Time-to-Finish-All-Jobs\"><a href=\"#1723-Find-Minimum-Time-to-Finish-All-Jobs\" class=\"headerlink\" title=\"1723. Find Minimum Time to Finish All Jobs\"></a><a href=\"https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/\" target=\"_blank\" rel=\"noopener\">1723. Find Minimum Time to Finish All Jobs</a></h3><h4 id=\"给你一个整数数组-jobs-，其中-jobs-i-是完成第-i-项工作要花费的时间。请你将这些工作分配给-k-位工人。所有工作都应该分配给工人，且每项工作只能分配给一位工人。工人的-工作时间-是完成分配给他们的所有工作花费时间的总和。请你设计一套最佳的工作分配方案，使工人的-最大工作时间-得以-最小化-。\"><a href=\"#给你一个整数数组-jobs-，其中-jobs-i-是完成第-i-项工作要花费的时间。请你将这些工作分配给-k-位工人。所有工作都应该分配给工人，且每项工作只能分配给一位工人。工人的-工作时间-是完成分配给他们的所有工作花费时间的总和。请你设计一套最佳的工作分配方案，使工人的-最大工作时间-得以-最小化-。\" class=\"headerlink\" title=\"给你一个整数数组 jobs ，其中 jobs[i] 是完成第 i 项工作要花费的时间。请你将这些工作分配给 k 位工人。所有工作都应该分配给工人，且每项工作只能分配给一位工人。工人的 工作时间 是完成分配给他们的所有工作花费时间的总和。请你设计一套最佳的工作分配方案，使工人的 最大工作时间 得以 最小化 。\"></a>给你一个整数数组 jobs ，其中 jobs[i] 是完成第 i 项工作要花费的时间。请你将这些工作分配给 k 位工人。所有工作都应该分配给工人，且每项工作只能分配给一位工人。工人的 工作时间 是完成分配给他们的所有工作花费时间的总和。请你设计一套最佳的工作分配方案，使工人的 最大工作时间 得以 最小化 。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：jobs &#x3D; [3,2,3], k &#x3D; 3</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：给每位工人分配一项工作，最大工作时间是 3 。</span><br></pre></td></tr></table></figure>\n<p>方法一：竞赛时搜了一下，以为是NP背包问题被吓住了， 其实给定的范围可以用回溯剪枝的方式来做。总共有三个优化点。其中第二点比较难想。1. 可以按照时长最多的倒序分配给每个工人；2.让某个工人不干活的次数只有一次，比如以<code>[3,2,3],k=3</code>为例，<code>[32,3,0]</code>与<code>[32,0,3]</code>是重复的，后者可以提前终止；如果当前结果过大了，就不用再继续了。2852ms.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minimumTimeRequired</span><span class=\"params\">(self, A: List[int], k: int)</span> -&gt; int:</span></span><br><span class=\"line\">    n = len(A)</span><br><span class=\"line\">    A.sort(reverse=<span class=\"literal\">True</span>) <span class=\"comment\"># opt 1</span></span><br><span class=\"line\">    self.res = sum(A)</span><br><span class=\"line\">    count = [<span class=\"number\">0</span>] * k</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(i)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == n:</span><br><span class=\"line\">            self.res = min(self.res, max(count))</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(k):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> count[j] + A[i] &lt; self.res: <span class=\"comment\"># opt 3</span></span><br><span class=\"line\">                count[j] += A[i]</span><br><span class=\"line\">                dfs(i + <span class=\"number\">1</span>)</span><br><span class=\"line\">                count[j] -= A[i]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> count[j] == <span class=\"number\">0</span>: </span><br><span class=\"line\">                <span class=\"keyword\">break</span> <span class=\"comment\"># opt 2</span></span><br><span class=\"line\">    dfs(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.res</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：二分法，这个方法简直超神，用二分法来确定这个容量的值。耗时44ms。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minimumTimeRequired</span><span class=\"params\">(self, A: List[int], k: int)</span> -&gt; int:</span></span><br><span class=\"line\">    n = len(A)</span><br><span class=\"line\">    A.sort(reverse=<span class=\"literal\">True</span>) <span class=\"comment\"># opt 1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(i)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == n:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(k):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> cap[j] &gt;= A[i]:</span><br><span class=\"line\">                cap[j] -= A[i]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> dfs(i + <span class=\"number\">1</span>): <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">                cap[j] += A[i]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> cap[j] == mid: <span class=\"keyword\">break</span> <span class=\"comment\"># opt 2</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    left, right = max(A), sum(A)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> left &lt; right:</span><br><span class=\"line\">        mid = (left+right) &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">        cap = [mid] * k</span><br><span class=\"line\">        <span class=\"keyword\">if</span> dfs(<span class=\"number\">0</span>):</span><br><span class=\"line\">            right = mid</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            left = mid + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> left</span><br></pre></td></tr></table></figure>\n","categories":["算法"],"tags":["LeetCode","Python","Algorithm","BackTracking"]},{"title":"《Web API 的设计与开发》读后总结","url":"/%E3%80%8AWeb-API-%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BB%E5%90%8E%E6%80%BB%E7%BB%93/","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>此书为[日]水野贵明著，之前已经通读了一遍，收获不少，为了复习与总结，这里便整理一份笔记，以便忘记的时候查找。</p>\n<a id=\"more\"></a>\n<h3 id=\"第一章：什么是Web-API\"><a href=\"#第一章：什么是Web-API\" class=\"headerlink\" title=\"第一章：什么是Web API\"></a>第一章：什么是Web API</h3><h4 id=\"REST与Web-API\"><a href=\"#REST与Web-API\" class=\"headerlink\" title=\"REST与Web API\"></a>REST与Web API</h4><p>REST一词经常以”REST API”的形式出现。一般而言，人们认为它是指”能够通过HTTP协议进行访问，得到XML或JSON格式的返回数据的API”。而REST一词一般是有两种意思：</p>\n<ul>\n<li>符合REST架构风格的Web服务系统。</li>\n<li>符合RPC风格的XML(or JSON)+HTTP接口的系统（不适用SOAP）。</li>\n</ul>\n<p>书中的API设计思想侧重于第2条，旨在API更加亲切易懂，比如搜索操作时，没有在URI中强制使用名词，而是使用search；在URI中添加版本号，而不是Header中。</p>\n<h4 id=\"LSUD-vs-SSKD\"><a href=\"#LSUD-vs-SSKD\" class=\"headerlink\" title=\"LSUD vs SSKD\"></a>LSUD vs SSKD</h4><ul>\n<li>LSUD(Large Set of Unknown Developers)</li>\n<li>SSKD(Small Set of Known Developers)，有时使用REST这种基于资源的思维方式不能完全满足需求，还需要引入<strong>策略编排层</strong>这样的思维方式。</li>\n</ul>\n<h3 id=\"第二章：端点的设计与请求的形式\"><a href=\"#第二章：端点的设计与请求的形式\" class=\"headerlink\" title=\"第二章：端点的设计与请求的形式\"></a>第二章：端点的设计与请求的形式</h3><h4 id=\"端点的概念：\"><a href=\"#端点的概念：\" class=\"headerlink\" title=\"端点的概念：\"></a>端点的概念：</h4><p>在Web API的语境里，端点是指用于访问的API的URI。</p>\n<h4 id=\"端点的设计规范：\"><a href=\"#端点的设计规范：\" class=\"headerlink\" title=\"端点的设计规范：\"></a>端点的设计规范：</h4><ul>\n<li><p>短小便于输入</p>\n<p><code>http://api.example.com/service/api/search</code>不如<code>http://api.example.com/search</code>，不应该出现重复的词，也不应该使用<code>service</code>这种含义过于广泛的词。</p>\n</li>\n<li><p>人可以读懂</p>\n<p>不要使用缩写，甚至将products缩写为prod，即使是SSKD，也应尽量减少缩写。</p>\n<p>合适的语义，使用合适的单词，拼写错误是不应该出现的。</p>\n</li>\n<li><p>不能大小写混用</p>\n</li>\n<li><p>修改方便</p>\n<p>如/items/12346，明显修改12346就可以查看其它商品信息。</p>\n</li>\n<li><p>不会暴露服务端的架构</p>\n<p>比如，php或jsp结尾。</p>\n</li>\n<li><p>规则统一</p>\n<p>URI采用一致的风格</p>\n</li>\n</ul>\n<h4 id=\"HTTP方法和端点\"><a href=\"#HTTP方法和端点\" class=\"headerlink\" title=\"HTTP方法和端点\"></a>HTTP方法和端点</h4><p>URI和HTTP的关系可以认为是操作对象和操作方法的关系。如果把URI当做API(HTTP)的“操作对象=资源”，HTTP方法则表示“进行怎样的操作”。</p>\n<ul>\n<li><p>GET</p>\n<p>表示获取信息，最为常用。一般不会修改已有资源（已读/未读，最后访问日期等属性属于例外）。</p>\n</li>\n<li><p>POST</p>\n<p>一般认为POST方法用于更新信息，其实这样的理解存在一些偏差。POST方法的初衷是用于向服务器注册新建的资源。信息的更新和删除等操作应使用其他HTTP方法。由于HTML4.0的表单中method属性只支持GET和POST两种方法，因此使用表单从浏览器提交信息时，以及更新删除，都使用POST方法了。虽然在HTML5的草案中加入了表单允许使用PUT以及DELETE方法的规范，但最终还是讲该内容删除了。由于Web API基本不涉及表单通过浏览器进行访问，所以一般使用PUT和DELETE更容易理解。</p>\n</li>\n<li><p>PUT</p>\n<p>和POST方法相同，都可用与对服务端的信息进行更新，但二者URI的指定方式有所不同。POST方法发送的数据“附属”于指定的URI，附属表示从属URI之下。以文件系统为例，把文件放入目录后，文件就成了目录的附属部分。虽然HTTP协议定义了当所指定的资源不存在时，可以通过PUT操作发送数据，生成心得资源，但Web API一般只用PUT方法来更新数据，而一般会使用POST来生成新的资源。<strong>PUT会用发送的数据完全替换原有的资源信息，如果只是更新资源的某部分数据，可以使用PATCH方法来实现。</strong></p>\n</li>\n<li><p>DELETE</p>\n<p>删除资源。</p>\n</li>\n<li><p>PATCH</p>\n<p>PATCH和PUT相同，用于更新指定的资源。在数据量较高的情况下，会有显著的效果。</p>\n</li>\n</ul>\n<h4 id=\"X-HTTP-Method-Override\"><a href=\"#X-HTTP-Method-Override\" class=\"headerlink\" title=\"X-HTTP-Method-Override\"></a>X-HTTP-Method-Override</h4><p>由于HTML的表单规范只支持GET和POST，或是其它开发客户端中只能有GET和POST。所以要利用POST方法将真正想要使用的HTTP方法以元数据信息的形式发送给服务器。有两种方式：</p>\n<ul>\n<li><p>通过名为<code>X-HTTP-Method-Override</code>的Header来实现，推荐使用。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">POST /v1/users/123 HTTP/1.1</span><br><span class=\"line\">Host: api.example.com</span><br><span class=\"line\">X-HTTP-Method-Override: DELETE</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通过传递表单参数<code>_method</code>来实现。</p>\n<p><code>user=testuser&amp;_method=PUT</code>使用<code>application/x-www-form-urlencoded</code>Media Type。</p>\n</li>\n</ul>\n<p>这里看了一下，Django没有支持这种功能，需要自己写中间件或者三方库来实现。<a href=\"https://pypi.org/project/django-method-override/\" target=\"_blank\" rel=\"noopener\">django-method-override</a>。而DRF这里的文档说，在3.3.0版本之前是支持的，后来将其从核心功能中移除。<a href=\"https://www.django-rest-framework.org/topics/browser-enhancements/#http-header-based-method-overriding\" target=\"_blank\" rel=\"noopener\">DRF文档</a>。</p>\n<h4 id=\"动态相关的端点举例\"><a href=\"#动态相关的端点举例\" class=\"headerlink\" title=\"动态相关的端点举例\"></a>动态相关的端点举例</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">目的</th>\n<th>端点</th>\n<th style=\"text-align:center\">方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">编辑动态信息</td>\n<td><a href=\"http://api.example.com/v1/updates/:id\" target=\"_blank\" rel=\"noopener\">http://api.example.com/v1/updates/:id</a></td>\n<td style=\"text-align:center\">PUT</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">删除动态信息</td>\n<td><a href=\"http://api.example.com/v1/updates/:id\" target=\"_blank\" rel=\"noopener\">http://api.example.com/v1/updates/:id</a></td>\n<td style=\"text-align:center\">DELETE</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">发表动态信息</td>\n<td><a href=\"http://api.example.com/v1/updates\" target=\"_blank\" rel=\"noopener\">http://api.example.com/v1/updates</a></td>\n<td style=\"text-align:center\">POST</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">获取特定用户的动态信息</td>\n<td><a href=\"http://api.example.com/v1/users/:id/updates\" target=\"_blank\" rel=\"noopener\">http://api.example.com/v1/users/:id/updates</a></td>\n<td style=\"text-align:center\">GET</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">获取好友的动态列表</td>\n<td><a href=\"http://api.example.com/v1/users/:id/friends/updates\" target=\"_blank\" rel=\"noopener\">http://api.example.com/v1/users/:id/friends/updates</a></td>\n<td style=\"text-align:center\">GET</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"访问资源的端点设计注意事项\"><a href=\"#访问资源的端点设计注意事项\" class=\"headerlink\" title=\"访问资源的端点设计注意事项\"></a>访问资源的端点设计注意事项</h4><ul>\n<li><p><strong>使用名词的复数形式</strong></p>\n<p>极力避免使用动词，因为HTTP协议原本就是用URI来表示资源，用HTTP方法来表示对资源所进行的操作。</p>\n</li>\n<li><p>注意所用的单词</p>\n<p>多看大公司的开放API范例，查阅<a href=\"https://www.programmableweb.com/\" target=\"_blank\" rel=\"noopener\">ProgrammableWeb</a>，明白那些具有相近意义的单词哪个更加合适。</p>\n</li>\n<li><p>不适用空格及需要编码的字符</p>\n</li>\n<li><p>使用连接符<code>-</code>来连接多个单词</p>\n<p>相对于驼峰发和蛇形法，这种脊柱法对于SEO更加友好。不过应尽量避免使用多个单词，而是使用路径划分，如<code>popular_users</code>不如<code>users/popular</code>，或者将一部分内容作为查询参数，让URI变得更短。</p>\n</li>\n</ul>\n<h4 id=\"相对位置获取数据大分页时效率低下\"><a href=\"#相对位置获取数据大分页时效率低下\" class=\"headerlink\" title=\"相对位置获取数据大分页时效率低下\"></a>相对位置获取数据大分页时效率低下</h4><p>使用绝对位置，事先记录下当前已获得的数据里最后一条数据的ID、时间等信息，然后再指定“该ID之前的所有数据”或“该时刻之前的所有数据”。</p>\n<h4 id=\"查询参数还是使用路径？\"><a href=\"#查询参数还是使用路径？\" class=\"headerlink\" title=\"查询参数还是使用路径？\"></a>查询参数还是使用路径？</h4><ul>\n<li>是否是表示唯一资源所需的信息，比如用户ID。</li>\n<li>是否可以省略，如page等分页参数，一般都会设置默认值。</li>\n</ul>\n<h4 id=\"登录与OAuth2-0\"><a href=\"#登录与OAuth2-0\" class=\"headerlink\" title=\"登录与OAuth2.0\"></a>登录与OAuth2.0</h4><h5 id=\"什么是OAuth\"><a href=\"#什么是OAuth\" class=\"headerlink\" title=\"什么是OAuth?\"></a>什么是OAuth?</h5><p>假设带有用户注册功能的在线服务A（Facebook）对外公开了API，在线服务B便可以使用这些在线服务A的API提供的各种功能。在这种情况下，当某个已在Facebook里注册的用户需要使用你的在线服务时，你的在线服务就回希望访问Facebook来使用该用户在Facebook中注册的信息。这时，判断是否允许你的在线服务使用该用户在Facebook里注册的信息的机制就是OAuth。</p>\n<img src=\"/%E3%80%8AWeb-API-%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BB%E5%90%8E%E6%80%BB%E7%BB%93/OAuth_base.jpeg\" class>\n<h5 id=\"OAuth2-0里的4中类型的交互模式用于访问资源的许可，称为Grant-Type。\"><a href=\"#OAuth2-0里的4中类型的交互模式用于访问资源的许可，称为Grant-Type。\" class=\"headerlink\" title=\"OAuth2.0里的4中类型的交互模式用于访问资源的许可，称为Grant Type。\"></a>OAuth2.0里的4中类型的交互模式用于访问资源的许可，称为Grant Type。</h5><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Grant Type</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Authorization Code</td>\n<td>适用于在服务端进行大量处理的Web应用</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Implicit</td>\n<td>适用于只能手机应用及使用JavaScript客户端进行大量处理的应用</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Resource Owner Password Credentials</td>\n<td>适用于不适用服务端（网站B）的应用</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Client Credentials</td>\n<td>适用于不以用户为单位来进行认证的应用</td>\n</tr>\n</tbody>\n</table>\n<p>Resource 的模式能够应用于公司内部所开发的客户端应用中。</p>\n<h5 id=\"SSKD应用尽量减少API调用次数\"><a href=\"#SSKD应用尽量减少API调用次数\" class=\"headerlink\" title=\"SSKD应用尽量减少API调用次数\"></a>SSKD应用尽量减少API调用次数</h5><p>如首页包含“人气商品”，“推荐商品”，“用户信息”等信息，这样需要访问不同的API，效率很低，因此可以把应用主页所需要的显示信息归集到一个API中，提高了客户端的便捷性。为了完成一次任务需要多次访问API，这样的API设计叫“Chatty API”，不但会加大网络流量的消耗，还会增加客户端的处理工序。</p>\n<h5 id=\"HETEOAS和REST-LEVEL3-API\"><a href=\"#HETEOAS和REST-LEVEL3-API\" class=\"headerlink\" title=\"HETEOAS和REST LEVEL3 API\"></a>HETEOAS和REST LEVEL3 API</h5><p>等级制度</p>\n<ul>\n<li>LEVEL0：使用HTTP</li>\n<li>LEVEL1：引入资源概念</li>\n<li>LEVEL2：引入HTTP动词</li>\n<li>LEVEL3：引入HATEOAS概念</li>\n</ul>\n<p>HETEOAS: (Hypermedia As The Engine Of Application State)，超媒体即应用状态引擎。意思就是在API返回的数据中包含下一步要执行的行为、要获取的数据等URI的链接信息，客户端只要看到这些信息，就能知道接下来需要访问什么端点，比如DRF中的下一页链接。</p>\n<p>优点：使URI得更改变得容易。</p>\n<p>面向SSKDs的API，需要根据实际需求采用。面向LSUDs的API，这个概念还没有得到广泛的普及。</p>\n<h3 id=\"第三章：响应数据的设计\"><a href=\"#第三章：响应数据的设计\" class=\"headerlink\" title=\"第三章：响应数据的设计\"></a>第三章：响应数据的设计</h3><h4 id=\"JSONP\"><a href=\"#JSONP\" class=\"headerlink\" title=\"JSONP\"></a>JSONP</h4><h5 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h5><p>JSONP是一种将JSON传递给浏览器的方式，是JSON with Padding的缩写。一般形式如下：</p>\n<p><code>callback({&quot;id&quot;: 123, &quot;name&quot;: &quot;Saeed&quot;})</code></p>\n<p>留坑…</p>\n<h4 id=\"封装是否必要\"><a href=\"#封装是否必要\" class=\"headerlink\" title=\"封装是否必要\"></a>封装是否必要</h4><p>比如返回的格式为：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"meta\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"code\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"attr\">\"message\"</span>: 'OK',</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"data\"</span>: &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果结构形式统一，在客户端就更容易抽象化处理。实际上由于封装的做法会显得冗长，并不值得实现。因为Web API基本上都是用HTTP协议，HTTP已经帮你完成了封装的工作。HTTP协议里引入首部的概念，在首部中可以放入各种数据信息，也可以通过状态码来确认无误地判断是否发生了某种错误等，并将更详细的错误信息放入HTTP首部返回。而如果对API数据进行封装，发生错误时，用户所获得的状态依然是200，<del>这就无法通过状态码来判断处理是成功还是失败。这样的做法没有正确地运用好HTTP协议的机制。</del>这可能会导致客户端的处理发生混乱，这种情况是无论如何都要明令禁止的。而且通用的HTTP客户端程序往往会首先根据状态码来判断请求的处理是否成功，如果出错时返回200，客户端就无法利用通用的错误分类，增加处理负担。</p>\n<h4 id=\"扁平化还是层级？\"><a href=\"#扁平化还是层级？\" class=\"headerlink\" title=\"扁平化还是层级？\"></a>扁平化还是层级？</h4><p>Google的JSON Style Guide使用了模棱两可的陈述：“虽然要尽可能使用扁平化方式，但在某些情况下使用层级形式反而更容易理解。”</p>\n<ul>\n<li><p>情景一：</p>\n<ul>\n<li><p>层级</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"id\"</span>: <span class=\"number\">3342124</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"message\"</span>: <span class=\"string\">\"Hi!\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"sender\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"id\"</span>: <span class=\"number\">3456</span>,</span><br><span class=\"line\">        <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"Tom\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"receiver\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"id\"</span>: <span class=\"number\">12877</span>,</span><br><span class=\"line\">        <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"Bob\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>扁平化</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"id\"</span>: <span class=\"number\">3342124</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"message\"</span>: <span class=\"string\">\"Hi!\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"sender_id\"</span>: <span class=\"number\">3456</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"sender_name\"</span>: <span class=\"string\">\"Tom\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"receiver_id\"</span>: <span class=\"number\">12877</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"receiver_name\"</span>: <span class=\"string\">\"Bob\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>其中”sender”和”receiver”描述了相同的用户这一数据结构，因此层级形式较好，因为客户端可以将各个数据作为用户这一相同的数据来处理。</p>\n</li>\n<li><p>情景二：</p>\n<ul>\n<li><p>层级</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"id\"</span>: <span class=\"number\">2345</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"Tom\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"profile\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"birthday\"</span>: <span class=\"number\">3322</span>,</span><br><span class=\"line\">        <span class=\"attr\">\"gender\"</span>: <span class=\"string\">\"male\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>扁平化</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"id\"</span>: <span class=\"number\">2345</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"Tom\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"birthday\"</span>: <span class=\"number\">3322</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"gender\"</span>: <span class=\"string\">\"male\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这种情况，层级导致JSON数据尺寸变大，而且两者看起来没有什么区别，所以应该扁平化。</p>\n</li>\n</ul>\n<h4 id=\"序列与格式\"><a href=\"#序列与格式\" class=\"headerlink\" title=\"序列与格式\"></a>序列与格式</h4><p>比如一个好友列表的URI <code>/friends</code></p>\n<ul>\n<li><p>序列原封不动返回</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"id\"</span>: <span class=\"number\">234</span>,</span><br><span class=\"line\">        <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"Tom\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"id\"</span>: <span class=\"number\">235</span>,</span><br><span class=\"line\">        <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"Bob\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>用对象进行封装</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"friends\"</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"id\"</span>: <span class=\"number\">234</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"Tom\"</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"id\"</span>: <span class=\"number\">235</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"Bob\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>看上去第二种方式显得有些冗余，因为URI中已经使用了”friends”来表示好友。而且又显得冗长。但是这样写有三个优点：</p>\n<ul>\n<li><p>更容易理解响应数据表示什么</p>\n</li>\n<li><p><strong>响应数据通过对象封装实现了结构统一</strong></p>\n<p>顶层数据不会根据API的不同而不同，客户端无需适配序列或是对象，免除麻烦。</p>\n</li>\n<li><p>可以避免安全方面的风险</p>\n<p>顶层数据中使用JSON序列，可能会导致名为JSON注入的安全隐患，风险很大。</p>\n</li>\n</ul>\n<h4 id=\"返回数据的个数\"><a href=\"#返回数据的个数\" class=\"headerlink\" title=\"返回数据的个数\"></a>返回数据的个数</h4><h5 id=\"返回数据的名称\"><a href=\"#返回数据的名称\" class=\"headerlink\" title=\"返回数据的名称\"></a>返回数据的名称</h5><ul>\n<li><p>使用多数API中使用的表示相同含义的单词</p>\n</li>\n<li><p>通过尽可能少的单词来表示</p>\n<p>比如注册时间<code>registrationDateTime</code>不如<code>registeredAt</code></p>\n</li>\n<li><p>使用多个单词时，整个API中连接单词的方法要统一</p>\n<p>一般使用驼峰法</p>\n</li>\n<li><p>尽可能不用奇怪的缩略语</p>\n</li>\n<li><p>注意单复数形式</p>\n</li>\n</ul>\n<h5 id=\"日期的格式\"><a href=\"#日期的格式\" class=\"headerlink\" title=\"日期的格式\"></a>日期的格式</h5><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">格式名</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">RFC 822</td>\n<td>Sun, 06 Nov 1994 08:49:37 GMT</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">RFC 850</td>\n<td>Sunday, 06-Nov-94 08:49:37 GMT</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ANSI C的asctime()格式</td>\n<td>Sun Nov 6 08:49:37 1994</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>RFC 3339</strong></td>\n<td><strong>2015-10-12T11:30:22+09:00</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Unix 时间戳（epoch）秒</td>\n<td>1396821803</td>\n</tr>\n</tbody>\n</table>\n<p>一般采用RFC 3339格式。如果考虑国际化产品，则推荐使用”+00:00”。在RFC 3339中使用UTC时，可以通过”Z”来标记。<code>2015-11-02T13:00:12+00:00</code> == <code>2015-11-02T13:00:12Z</code>。如果是”-00:00”，则表示时区不明。</p>\n<p>如果面向SSKD，也可使用Unix时间戳，因为其易于保存和比较，不过会调试稍微麻烦。</p>\n<p>有时需要在HTTP首部添加时间，这个格式不支持RFC 3339，只支持上表中的前三项。</p>\n<h5 id=\"详细的出错信息\"><a href=\"#详细的出错信息\" class=\"headerlink\" title=\"详细的出错信息\"></a>详细的出错信息</h5><p>状态码属于通用的错误描述，在表示同各个API的内容相关的错误时显得力不从心。所以要返回额外的错误信息。</p>\n<ul>\n<li><p>一种是通过首部返回</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">X-MYNAME-ERROR-CODE: 2013</span><br><span class=\"line\">X-MYNAME-ERROR-MESSAGE: Bad authentication token</span><br><span class=\"line\">X-MYNAME-ERROR-INFO: http:&#x2F;&#x2F;docs.example.com&#x2F;api&#x2F;vi&#x2F;authentication</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将出错信息放入消息体</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"error\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"code\"</span>: <span class=\"number\">2013</span>,</span><br><span class=\"line\">        <span class=\"attr\">\"message\"</span>: <span class=\"string\">\"Bad authentication token\"</span>,</span><br><span class=\"line\">        <span class=\"attr\">\"info\"</span>: <span class=\"string\">\"http://docs.example.com/api/vi/authentication\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>对于客户端来说第二种消息体的方案比较容易处理，所以优先选择后者。错误码一般4位与HTTP状态码区分，1字头表示通用错误，2字头表示用户错误等。有时提示信息里同时包含面向非开发人员和开发人员的信息。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"error\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"developerMessage\"</span>: <span class=\"string\">\"面向开发人员信息\"</span>,</span><br><span class=\"line\">        <span class=\"attr\">\"userMessage\"</span>: <span class=\"string\">\"面向用户的信息\"</span>,</span><br><span class=\"line\">        <span class=\"attr\">\"code\"</span>: <span class=\"number\">2013</span>,</span><br><span class=\"line\">        <span class=\"attr\">\"info\"</span>: <span class=\"string\">\"http://docs.example.com/api/vi/authentication\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有时程序返回500、503或404等错误时，默认会返回HTML或者是<code>ContentType: text/plain</code>格式的信息，会导致客户端崩溃等问题。所以即使这种情况下，服务端应该努力保证发生错误、负载过高、访问的端点不存在等情况下也能以合适的格式返回数据。</p>\n<p>如果服务端不得已进行维护返回503状态码的同时，还应该返回<code>Retry-After</code>来告知客户端重试的时间。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">503 Service Temporarily Unavailable</span><br><span class=\"line\">Retry-After Mon, 2 Dec 2013 03:00:00 GMT</span><br></pre></td></tr></table></figure>\n<h5 id=\"需要返回意义不明确的信息时\"><a href=\"#需要返回意义不明确的信息时\" class=\"headerlink\" title=\"需要返回意义不明确的信息时\"></a>需要返回意义不明确的信息时</h5><p>比如用户在登录时需要输入邮箱和密码，如果登录失败，返回邮箱不存在还是返回邮箱存在但密码错误，还是返回用户已冻结？虽然详细信息对于用户而言显得非常友好，但从另一方面来说，也为非法登录和爬虫提供了友好的信息。所以服务端在这种情况下一般只提供非常少量的信息，让无法正常登陆的用户通过重置密码等手段重新登录。不过这样不太方便调试，所以也可将逻辑分开，在开发时返回详尽信息，生产环境返回不明确的信息。</p>\n<h3 id=\"第四章：最大程度地利用HTTP协议\"><a href=\"#第四章：最大程度地利用HTTP协议\" class=\"headerlink\" title=\"第四章：最大程度地利用HTTP协议\"></a>第四章：最大程度地利用HTTP协议</h3><h4 id=\"使用HTTP协议规范的意义\"><a href=\"#使用HTTP协议规范的意义\" class=\"headerlink\" title=\"使用HTTP协议规范的意义\"></a>使用HTTP协议规范的意义</h4><p>HTTP协议等很多互联网协议都是由名为RFC的规范文档来定义的。</p>\n<h4 id=\"正确使用状态码\"><a href=\"#正确使用状态码\" class=\"headerlink\" title=\"正确使用状态码\"></a>正确使用状态码</h4><h5 id=\"首位数字大概含义\"><a href=\"#首位数字大概含义\" class=\"headerlink\" title=\"首位数字大概含义\"></a>首位数字大概含义</h5><table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1字头</td>\n<td>消息</td>\n</tr>\n<tr>\n<td>2字头</td>\n<td>成功</td>\n</tr>\n<tr>\n<td>3字头</td>\n<td>重定向</td>\n</tr>\n<tr>\n<td>4字头</td>\n<td>客户端原因引起的错误</td>\n</tr>\n<tr>\n<td>5字头</td>\n<td>服务端原因引起的错误</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"主要的HTTP状态码\"><a href=\"#主要的HTTP状态码\" class=\"headerlink\" title=\"主要的HTTP状态码\"></a>主要的HTTP状态码</h5><table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>200</td>\n<td>OK</td>\n<td>请求成功</td>\n</tr>\n<tr>\n<td>201</td>\n<td>Created</td>\n<td>请求成功，新的资源已创建</td>\n</tr>\n<tr>\n<td>202</td>\n<td>Accepted</td>\n<td>请求成功</td>\n</tr>\n<tr>\n<td>204</td>\n<td>No Content</td>\n<td>没有内容</td>\n</tr>\n<tr>\n<td>300</td>\n<td>Multiple Choices</td>\n<td>存在多个资源</td>\n</tr>\n<tr>\n<td>301</td>\n<td>Moved Permanently</td>\n<td>资源被永久转移</td>\n</tr>\n<tr>\n<td>302</td>\n<td>Found</td>\n<td>请求的资源被暂时转移</td>\n</tr>\n<tr>\n<td>303</td>\n<td>See Other</td>\n<td>引用他出</td>\n</tr>\n<tr>\n<td>304</td>\n<td>Not Modified</td>\n<td>自上一次访问后没有发生更新</td>\n</tr>\n<tr>\n<td>307</td>\n<td>Temporary Redirect</td>\n<td>请求的资源被暂时转移</td>\n</tr>\n<tr>\n<td>400</td>\n<td>Bad Request</td>\n<td>请求不正确</td>\n</tr>\n<tr>\n<td>401</td>\n<td>Unauthorized</td>\n<td>需要认证</td>\n</tr>\n<tr>\n<td>403</td>\n<td>Forbidden</td>\n<td>禁止访问</td>\n</tr>\n<tr>\n<td>404</td>\n<td>Not Found</td>\n<td>没有找到指定的资源</td>\n</tr>\n<tr>\n<td>405</td>\n<td>Method Not Allowed</td>\n<td>无法使用指定的方法</td>\n</tr>\n<tr>\n<td>406</td>\n<td>Not Acceptable</td>\n<td>同Accept相关的首部里含有无法处理的内容</td>\n</tr>\n<tr>\n<td>408</td>\n<td>Request Timeout</td>\n<td>请求在规定时间内没有处理结束</td>\n</tr>\n<tr>\n<td>409</td>\n<td>Conflict</td>\n<td>资源存在冲突</td>\n</tr>\n<tr>\n<td>410</td>\n<td>Gone</td>\n<td>指定的资源已不存在</td>\n</tr>\n<tr>\n<td>413</td>\n<td>Request Entity Too Large</td>\n<td>请求消息体太大</td>\n</tr>\n<tr>\n<td>414</td>\n<td>Request-URI Too Long</td>\n<td>请求的URI太长</td>\n</tr>\n<tr>\n<td>415</td>\n<td>Unsupported Media Type</td>\n<td>不支持所指定的媒体类型</td>\n</tr>\n<tr>\n<td>429</td>\n<td>Too Many Requests</td>\n<td>请求次数过多</td>\n</tr>\n<tr>\n<td>500</td>\n<td>Internal Server Error</td>\n<td>服务器端发生错误</td>\n</tr>\n<tr>\n<td>503</td>\n<td>Service Unavailable</td>\n<td>服务器暂时停止运行</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"状态码详解及使用场景：\"><a href=\"#状态码详解及使用场景：\" class=\"headerlink\" title=\"状态码详解及使用场景：\"></a>状态码详解及使用场景：</h5><ul>\n<li><p>2字头  成功</p>\n<ul>\n<li><p>201 “Created”</p>\n<p>POST请求的场景，表示创建了一个资源，上传了图片，或是添加了用户。</p>\n</li>\n<li><p>202 “Accepted”</p>\n<p>表示“Accepted”，在异步处理客户端请求时，它用来表示服务器端已接收了来自客户端的请求，但处理尚未结束。</p>\n<ul>\n<li>通常的使用场景是文件格式转换、处理远程通知耗时的场景中。</li>\n<li>以LinkedIn的参与群组讨论的API为例，我们知道如果成功参与讨论并发表意见，服务器通常会返回201；但如果需要得到 群主确认，所发表的意见就无法立即在页面上显示出来，这时服务器就需要返回202状态码。从广义上来看，也属于异步处理，但是与程序里所说的异步不是一个概念。</li>\n</ul>\n<p>另外，使用Box的API来下载文件时，如果文件尚未准备好，服务器会返回202，还会在首部中添加<code>Retry-After</code>写入处理完成所需时间。</p>\n</li>\n<li><p>204 “No Content”</p>\n<p>响应消息为空时会返回该状态码。</p>\n<ul>\n<li>使用DELETE方法删除数据时。</li>\n</ul>\n<p>关于204有一些争论，这里笔者给出的建议是PUT或PATCH请求时，服务端返回200并将数据同时返回，使用DELETE请求时，返回204。这样，无论在何种情况下，都可以从服务器端返回的数据得知修改操作正确执行。病情也能在PUT/PATCH操作后同时获得ETag信息。</p>\n<p>这里有个疑问，实际业务中有时需要“假删除”，此时应该返回204还是200？</p>\n</li>\n</ul>\n</li>\n<li><p>3字头  添加必要的处理</p>\n<p>常用来描述重定向操作。在定义了HTTP1.1的RFC 2068中，用于重定向的状态码只有301和302。301表示请求内容已从当前位置移动到了其他地方，而302则表示请求内容只是临时移动到了别处，而且使用的HTTP方法不会在访问重定向的URI时发生变化（如使用POST方法的话，在重定向后依然会使用POST方法来访问重定向的地址）。不过大部分浏览器却采用了与协议相反的设计，用GET方法来访问重定向后的地址。由于这个原因，在RFC 2616里，人们又新定义了303和307状态码。303定义了无论在重定向之前使用什么HTTP方法访问，都允许在请求完成后用GET方法继续访问。即便如此，现在依然有很多重定向操作会返回302状态码。另外RFC 7238里还定义了308状态码。307和308输入302和301的修正版，定义更加严密。302和301允许访问方法从POST变更为GET，307和308则不允许任何HTTP方法在访问过程中发生变更。</p>\n<p>API中应极力避免返回重定向类状态码。</p>\n<ul>\n<li><p>300 “Multiple Choices”</p>\n<p>当有多个分支可供客户端选择时，服务端会返回该状态码。API使用场景可能性很低，在文件存储类服务里，对于客户端请求的某个键值，如果存在多个数据库，有时会返回该状态码。</p>\n</li>\n<li><p>304 “Not Modified”</p>\n<p>表示客户端上次获取的数据至今为止没有发生更新。当服务端返回304时，整个响应消息体为空。</p>\n</li>\n</ul>\n</li>\n<li><p>4字头  客户端请求发生问题</p>\n<p>服务端无法理解客户端发送的请求，或虽然服务端能理解但请求没有被执行。</p>\n<ul>\n<li><p>400 “Bad Request”</p>\n<p>它表示“其他错误”，无法找到其它满足要求的状态码时返回，比如参数错误。</p>\n</li>\n<li><p>401 “Unauthorized” </p>\n<p>表示认证（Authentication）类型的错误，“识别前来访问的是谁”。</p>\n</li>\n<li><p>403 “Forbidden”</p>\n<p>表示授权（Authorization）类型的错误 ，“赋予特定用户执行特定操作的权限”。</p>\n</li>\n<li><p>404 “Not Found”</p>\n<p>有时不明确是URI不存在还是资源不存在，所以一般会额外返回其它详细的说明。</p>\n</li>\n<li><p>405 “Method Not Allowed”</p>\n<p>客户端使用的HTTP方法不被服务器端允许。</p>\n</li>\n<li><p>406 “Not Acceptable”</p>\n<p>API不支持客户端指定的数据格式时服务器端所返回的状态码。</p>\n</li>\n<li><p>408 “Request Timeout”</p>\n<p>客户端发送请求至服务端所需的时间过长时，触发服务端的超时处理。</p>\n</li>\n<li><p><strong>409 “Conflict”</strong></p>\n<p>状态码用于表示资源发生冲突时的错误。比如通过指定ID等唯一键值信息来调用注册功能的API，当这样的API创建数据时，倘若已有相同ID的数据存在，就回导致服务端返回409状态码告知客户端该邮箱地址或ID已被使用。</p>\n</li>\n<li><p>410 “Gone”</p>\n<p>和404相同，表示资源不存在。只是410状态码表示资源曾经存在但目前已经消失了，因此服务端常在访问数据被删除时返回该状态码。但是为了该状态码，服务器必须保存数据已被删除的信息，有些邮箱地址搜索用户信息的API中，从保护个人信息的角度来说，返回410状态的做法会受到质疑。</p>\n</li>\n<li><p>413  “Request Entity Too Large” 和 414 “Request-URI Too Long”</p>\n<p>413表示请求消息体过长，如上传文件过大。</p>\n<p>414表示请求首部过长而引发的错误，如查询参数过长。</p>\n</li>\n<li><p>415  “Unsupported Media Type”</p>\n<p>和406类似，表示服务器端不支持客户端请求首部<code>Content-Type</code>里指定的数据格式。区别在于，406一般和GET操作一起使用，415和POST、PUT以及PATCH等方法请求的消息体数据格式不被服务器端支持。例如在只接受JSON格式的请求的API里放入XML格式的数据并向服务器发送，或在Content-Type首部里指定application/xml，都会导致该类型的错误。</p>\n</li>\n<li><p>429 “Too Many Requests”</p>\n<p>访问次数超过了所允许的范围。</p>\n</li>\n</ul>\n</li>\n<li><p>5字头  服务器端发生问题</p>\n<ul>\n<li><p>500  “Internal Server Error”</p>\n<p>服务端代码存在bug，会返回该类型的错误。应该监控错误日志，防止再次发生。</p>\n</li>\n<li><p>503  “Service Unavailable”</p>\n<p>服务端暂时不可用，服务器维护，或者自身负载过高。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"缓存与HTTP协议规范\"><a href=\"#缓存与HTTP协议规范\" class=\"headerlink\" title=\"缓存与HTTP协议规范\"></a>缓存与HTTP协议规范</h4><p>HTTP协议中，缓存处于可用的状态时称为fresh（新鲜）状态，而处于不可用的状态时则称为stale（不新鲜）状态。</p>\n<h5 id=\"过期模型\"><a href=\"#过期模型\" class=\"headerlink\" title=\"过期模型\"></a>过期模型</h5><p>预先决定响应数据的保存期限，当到达期限后机会再次访问服务端来重新获得所需的数据。</p>\n<p>一个方法是用<code>Cache-Control</code>响应首部，另一个使用<code>Expires</code>响应首部。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Expires: Fri, 01 Jan 2016 00:00:00 GMT</span><br><span class=\"line\">Cache-Control: max-age&#x3D;3600</span><br></pre></td></tr></table></figure>\n<p>Expires使用RFC 1123中定义的时间格式。HTTP1.0就存在，<code>Cache-Control</code>是HTTP1.1中定义的。有时需要制定一个遥远的日期，使得缓存始终生效，但HTTP1.1规定，不允许设置超过1年以上的时间。两者同时定义时，<code>Cache-Control</code>优先。<code>max-age</code>是根据首部中的<code>Date</code>算的。根据HTTP协议的规定，除了5字头错误等几个特殊情况以外，所有的HTTP消息都必须添加<code>Date</code>首部。<strong>描述日期的HTTP首部信息里，只能使用GMT（格林尼治标准时区）作为时区。</strong></p>\n<h5 id=\"验证模型\"><a href=\"#验证模型\" class=\"headerlink\" title=\"验证模型\"></a>验证模型</h5><p>轮询当前保存的缓存数据是否为最新数据，并只在服务器端进行数据更新时，才重新获取新的数据。</p>\n<p>虽然这么做没有减少网络通信的开销，但假设客户端缓存的数据过大，那么此时缓存的作用就体现出来了。这种方式，服务器需要知道“客户端当前保存的信息的状态”，为此需要用到更新日期或实体标签（Entity Tag）作为指标。两者分别填充在<code>Last-Modified</code>和<code>ETag</code>响应消息首部返回给客户端。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Last-Modified: Tue, 01 Jul 2014 00:00:00 GMT</span><br><span class=\"line\">Etag: &quot;jfkeiwjpii189u98jljdfioj822adf&quot;</span><br></pre></td></tr></table></figure>\n<p>ETag如何生成取决于服务器端的实现。</p>\n<p>客户端使用最后更新日期执行附带条件的请求时，会用到<code>Modified-Since</code>首部。使用实体标签时，会用到<code>If-None-Match</code>首部。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">GET &#x2F;v1&#x2F;users&#x2F;12345</span><br><span class=\"line\">If-Modified-Since: Tue, 01 Jul 2014 00:00:00  GMT</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">GET &#x2F;v1&#x2F;users&#x2F;12345</span><br><span class=\"line\">If-None-Match: &quot;jfkeiwjpii189u98jljdfioj822adf&quot;</span><br></pre></td></tr></table></figure>\n<p>服务端检查是否有更新，如果有更新，则返回200和更新后的资源，同时添加最后更新日期或实体标签。未更新，则返回304，响应消息体为空。</p>\n<p>如果使用验证模型，并且更新的资源是某个特定的资源，则返回资源自身的最后更新日期；如果是列表信息的多个资源的话，则要使用其中最后更新的资源的最后更新日期。<a href=\"https://docs.djangoproject.com/en/1.11/topics/conditional-view-processing/\" target=\"_blank\" rel=\"noopener\">Django中的Etag相关。</a></p>\n<p>ETag有强验证和弱验证两个概念。</p>\n<ul>\n<li>强验证ETag： <code>Etag: &quot;jfkeiwjpii189u98jljdfioj822adf&quot;</code>，服务端同客户端数据不能有一个字节的差别，必须完全一样。</li>\n<li>弱验证ETag：<code>Etag: W/&quot;jfkeiwjpii189u98jljdfioj822adf&quot;</code>，只要从资源意义的角度来看没有发生变化，就可以视为相同的数据。例如Web页面的广告信息，虽然每次看到广告的内容会有所改变，但它们依然是相同的资源。</li>\n</ul>\n<h5 id=\"启发式过期\"><a href=\"#启发式过期\" class=\"headerlink\" title=\"启发式过期\"></a>启发式过期</h5><p>客户端自己寻找服务端资源的规律，<strong>所以服务器如果不能返回“将缓存数据保存多久”的信息，那么应该返回<code>Last-Modified</code>等首部信息来告知客户端</strong>，努力减少客户端不必要的访问，这一点非常重要。</p>\n<h5 id=\"不希望实施缓存\"><a href=\"#不希望实施缓存\" class=\"headerlink\" title=\"不希望实施缓存\"></a>不希望实施缓存</h5><p>在实时性要求比较高的场景中，不希望客户端进行缓存。使用<code>Cache-Control</code>首部。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Cache-Control: no-cache</span><br></pre></td></tr></table></figure>\n<p>除此之外，如果<code>Expires</code>首部里写入的过去的日期或不正确的日期格式，客户端也不会进行缓存操作。但不同浏览器可能发生不同的行为，所以此方法并不建议。</p>\n<p>no-cache严格意义来讲，不是“不缓存”的意思，而是表示至少“需要使用验证模型来验证”。如果不希望含有机密信息的数据在代理服务器上保存，就可以在Cache-Control首部里使用<code>no-store</code>并返回。</p>\n<h5 id=\"使用Vary来指定缓存单位\"><a href=\"#使用Vary来指定缓存单位\" class=\"headerlink\" title=\"使用Vary来指定缓存单位\"></a>使用Vary来指定缓存单位</h5><p>在实施缓存时可能还需要同时指定Vary首部。在实施缓存时，Vary用于指定除URI外使用哪个请求首部项目来确定唯一的数据。因为即使URI相同，获取的数据有时也会因请求首部内容的不同而发生变化。</p>\n<p>HTTP里有这样一种机制：根据由Accept开始的一系列请求首部值的不同，响应消息的内容也会发生变化。该机制称为<strong>服务器驱动的内容协商</strong>。比如API可以通过支持<code>Accept-Language</code>首部指定客户端能接受的自然语言，并据此切换响应数据里包含的语言信息。这时可以使用<code>Vary</code>首部来判断哪个请求首部需要实施缓存操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Vary: Accept-Language</span><br></pre></td></tr></table></figure>\n<p>一般而言，Vary首部用于HTTP经由代理服务器进行交互的场景，特别是在代理服务器拥有缓存功能时。但是有时服务器端无法知晓客户端的访问是否经由代理服务器，这种情况下就需要用到服务器驱动的内容协商机制，Vary首部就成了必选项。比如如果希望在查看用户代理（User Agent）信息后对返回的数据内容进行更新，就需要指定User-Agent首部。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Vary: Accept-Language,User-Agent</span><br></pre></td></tr></table></figure>\n<p>在API中，返回的数据信息根据用户代理的不同而变化的情况非常少见，但我们仍需要考虑这样的情况：当使用智能手机对普通的Web页面进行访问时，即使URI相同，网站也需要返回和访问终端相匹配的内容。因此当Google的网络爬虫访问服务器端时，如果服务器端会根据URI以外的信息改变返回的内容，则推荐添加Vary首部。</p>\n<h5 id=\"Cache-Control-首部\"><a href=\"#Cache-Control-首部\" class=\"headerlink\" title=\"Cache-Control 首部\"></a>Cache-Control 首部</h5><p>缓存操作指令及含义</p>\n<table>\n<thead>\n<tr>\n<th>指令名称</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>public</td>\n<td>代理服务器处保存的缓存可以在不同用户之间共享</td>\n</tr>\n<tr>\n<td>private</td>\n<td>每个用户的缓存数据必须各不相同</td>\n</tr>\n<tr>\n<td>no-cache</td>\n<td>缓存数据需要通过验证模型来确认</td>\n</tr>\n<tr>\n<td>no-store</td>\n<td>不需要进行缓存</td>\n</tr>\n<tr>\n<td>no-transform</td>\n<td>代理服务器不可变更响应数据的媒体类型或其他相关内容</td>\n</tr>\n<tr>\n<td>must-revalidate</td>\n<td>不管何时都需要向原始服务器进行再次验证</td>\n</tr>\n<tr>\n<td>proxy-revalidate</td>\n<td>代理服务器需要向原始服务器进行再次验证</td>\n</tr>\n<tr>\n<td>max-age</td>\n<td>表示缓存数据处于新鲜状态的时间</td>\n</tr>\n<tr>\n<td>s-maxage</td>\n<td>和max-age一样，但只用于中继服务器</td>\n</tr>\n</tbody>\n</table>\n<p>通过<code>stale-while-revalidate=600</code>这样指定秒数，那么即使代理服务器超过了<code>max-age</code>指定的时间，其内部也能异步进行缓存验证，并指定在一定的时间内允许将缓存数据经由响应消息返回。换言之，在指定了<code>max-age=600,stale-while-revalidate=600</code>的情况下，虽然数据维持新鲜状态的时间只有10分钟，但在随后的10分钟内，缓存服务器也能处理来自客户端的请求，并将所保存的缓存数据直接返回给客户端。与此同时，代理服务器还会异步地向原始服务器发起缓存验证的询问。也就是说，客户端最长可以在20分钟内接收到缓存的数据，使得缓存的数据不会因为突然变得到期而不可用。另外，在缓存到期时，这样做还能异步地完成缓存的交互更新，从而更有效率地对客户端的访问做出响应。</p>\n<img src=\"/%E3%80%8AWeb-API-%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BB%E5%90%8E%E6%80%BB%E7%BB%93/stale-while-revalidate.jpeg\" class>\n<p>由于某种原为无法访问原始服务器时，可以将<code>stale-if-error</code>指令指定为一定的秒数，允许在该段时间内代理服务器直接将所保存的不新鲜缓存返回给客户端。使用该指令的话，万一突发时间导致宕机，直接通过代理服务器和客户端交互，至少还能够在某段时间内不中断客户端的访问。</p>\n<h4 id=\"媒体类型的指定\"><a href=\"#媒体类型的指定\" class=\"headerlink\" title=\"媒体类型的指定\"></a>媒体类型的指定</h4><h5 id=\"具有代表性的媒体类型，也就是Content-Type\"><a href=\"#具有代表性的媒体类型，也就是Content-Type\" class=\"headerlink\" title=\"具有代表性的媒体类型，也就是Content-Type\"></a>具有代表性的媒体类型，也就是<code>Content-Type</code></h5><table>\n<thead>\n<tr>\n<th>媒体类型</th>\n<th>数据格式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>text/plain</td>\n<td>纯文本</td>\n</tr>\n<tr>\n<td>text/html</td>\n<td>HTML文件</td>\n</tr>\n<tr>\n<td>application/xml</td>\n<td>XML文件</td>\n</tr>\n<tr>\n<td>text/css</td>\n<td>CSS 文件</td>\n</tr>\n<tr>\n<td>application/javascript</td>\n<td>JavaScript</td>\n</tr>\n<tr>\n<td>application/json</td>\n<td>JSON文件</td>\n</tr>\n<tr>\n<td>application/rss+xml</td>\n<td>RSS域</td>\n</tr>\n<tr>\n<td>application/atom+xml</td>\n<td>Atom域</td>\n</tr>\n<tr>\n<td>application/octet-stream</td>\n<td>二进制数据</td>\n</tr>\n<tr>\n<td>application/zip</td>\n<td>zip文件</td>\n</tr>\n<tr>\n<td>image/jpeg</td>\n<td>JPEG图像</td>\n</tr>\n<tr>\n<td>image/png</td>\n<td>PNG图像</td>\n</tr>\n<tr>\n<td>image/svg+xml</td>\n<td>SVG图像</td>\n</tr>\n<tr>\n<td>multipart/form-data</td>\n<td>多个数据组成的Web表单数据</td>\n</tr>\n<tr>\n<td>video/mp4</td>\n<td>MP4动画文件</td>\n</tr>\n<tr>\n<td>application/vnd.ms-excel</td>\n<td>Excel文件</td>\n</tr>\n</tbody>\n</table>\n<p>顶层类型名称中application和text非常容易混淆。比如XML文件的媒体类型由RFC 3023定义，根据该协议，text/xml媒体类型用于表示（没有XML背景知识的用户）能够理解的XML，而API返回的数据中应该不会存在这样的XML文件，因此使用application/xml更加合理。</p>\n<p>除了由于历史原因而一直使用text作为顶层类型的text/css和text/html之外，某数据格式即使能够作为文本数据打开，但如果只有知道该数据格式的人才能理解，那么其媒体类型也依然需要用application作为顶层类型名称，这一方式已成为主流。</p>\n<h5 id=\"以x-开头的媒体类型\"><a href=\"#以x-开头的媒体类型\" class=\"headerlink\" title=\"以x-开头的媒体类型\"></a>以x-开头的媒体类型</h5><p>如<code>application/x-msgpack</code>。表示该媒体类型尚未在IANA里注册。IANA(Internet Assigned Numbers Authority)是管理Internet相关编号的组织，还负责域名的管理、IP地址的分配等，在Internet领域承担了非常重要的职责。</p>\n<p>没有在IANA里注册的并且以x-开头的媒体类型</p>\n<table>\n<thead>\n<tr>\n<th>媒体类型</th>\n<th>数据格式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>application/x-msgpack</td>\n<td>MessagePack</td>\n</tr>\n<tr>\n<td>application/x-yaml</td>\n<td>YAML</td>\n</tr>\n<tr>\n<td>application/x-plist</td>\n<td>属性列表</td>\n</tr>\n</tbody>\n</table>\n<p>但是有些媒体类型已在IANA注册，但在过去刚出现时，使用了x-开头。需要去查一下是否存在不以x-开头的替代类型。</p>\n<p>这里有一个例外就是发送HTML表单数据时使用的<code>application/x-www-form-urlencoded</code>类型。该类型在RFC 1866中定义，虽然由于历史原因在命名时加上了x-，但确实IANA中正式注册的媒体类型，虽然有了不加x-的替代，但尚未被IANA采用。</p>\n<h5 id=\"自定义媒体类型\"><a href=\"#自定义媒体类型\" class=\"headerlink\" title=\"自定义媒体类型\"></a>自定义媒体类型</h5><p>根据不同的前缀区分</p>\n<table>\n<thead>\n<tr>\n<th>树名</th>\n<th>前缀</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Standards tree（标准树）</td>\n<td>无</td>\n</tr>\n<tr>\n<td>Vendor tree（供应商树）</td>\n<td>vnd</td>\n</tr>\n<tr>\n<td>Personal(Vanity) tree（个人树）</td>\n<td>prs.</td>\n</tr>\n<tr>\n<td>Unregistered tree（未注册树）</td>\n<td>x.</td>\n</tr>\n</tbody>\n</table>\n<p>标准树指RFC进行了规范化后的媒体类型，如<code>text/html</code>那样，没有前缀。</p>\n<p>供应商树下的数据格式虽然旨在大范围使用，但却由特定的企业、团体来管理。例如Excel文件由微软公司管理，媒体类型为<code>application/vnd.ms-excel</code>。可以这样定义<code>application/vnd.companyname.awesomeformat</code>，Excel由于名气大，所以省略了公司名。</p>\n<p>个人树下的数据格式只在实验性质或未公开的产品等中使用。</p>\n<p>未注册树下的数据格式一般用于本地环境和私有环境，一般供应商树和个人树基本涵盖未注册树所涉及的用例，因此不推荐这种类型。</p>\n<h5 id=\"请求数据与媒体类型\"><a href=\"#请求数据与媒体类型\" class=\"headerlink\" title=\"请求数据与媒体类型\"></a>请求数据与媒体类型</h5><ul>\n<li><p>Content-Type</p>\n<p>首部和相应消息首部一样，表示请求消息体是以怎样的数据格式发送给服务端的。如客户端发送POST请求时，如果以JSON的形式发送数据，就应该在首部里指定<code>application/json</code>；如果是从Web页面发送表单数据，就会使用<code>application/x-www-form-urlencoded</code>。进行表单操作时，如果有添加文件的情况，就要指定<code>multipart/form-data</code>。</p>\n</li>\n<li><p>Accept</p>\n<p>此首部用于客户端向服务端表明能接受怎样的媒体类型。</p>\n<p><code>Accept: text/html,application/xml;q=0.9,*/*;q=0.8</code></p>\n<p>q表示品质因数（Quality Value），指定该媒体类型的优先级。默认为1，表示优先级最高。可以使用<code>*/*</code>表示所有的媒体类型。</p>\n<p>在使用服务器驱动的内容协商确定返回的数据格式时，服务器端会在响应消息的Vary首部里指定Accept，根据Accept的值的不同，响应的详细也可能不同。</p>\n</li>\n</ul>\n<h4 id=\"同源策略和跨域资源共享\"><a href=\"#同源策略和跨域资源共享\" class=\"headerlink\" title=\"同源策略和跨域资源共享\"></a>同源策略和跨域资源共享</h4><h5 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h5><p>通过XHTTPRequest对不同的域进行访问将无法获取响应数据，这一原则称为<strong>同源策略</strong>。同源策略主要是出于安全方面的考虑，它只允许从相同的源来获取数据，并通过URI里的schema（http, https等）、主机（api.example.com）、端口号的组合来判断是否同源。由于JSONP有很多安全问题，所以制定了<strong>跨域资源共享</strong>（Cross-Origin Resource Sharing，CORS）的方式解决跨域访问的问题。</p>\n<h5 id=\"CORS基本的交互\"><a href=\"#CORS基本的交互\" class=\"headerlink\" title=\"CORS基本的交互\"></a>CORS基本的交互</h5><p>当实施CORS时，客户端要先发送一个名为Origin的请求消息首部。如从<code>http://www.example.com/</code>访问<code>http://api/example.com/</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Origin: http:&#x2F;&#x2F;www.example.com</span><br></pre></td></tr></table></figure>\n<p>服务器保存着允许访问的白名单，请求发送过来，会判断是否在白名单中。如果不在，则返回403；如果在，服务端会在<code>Access-Control-Allow-Origin</code>响应消息首部里放入和请求消息的Origin首部相同的源并返回，表示允许访问。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Access-Control-Allow-Origin: http:&#x2F;&#x2F;www.example.com</span><br></pre></td></tr></table></figure>\n<h5 id=\"CORS与用户认证信息\"><a href=\"#CORS与用户认证信息\" class=\"headerlink\" title=\"CORS与用户认证信息\"></a>CORS与用户认证信息</h5><p>CORS中发送用户认证信息时，必须发布追加的HTTP响应消息首部。例如当客户端使用Cookie首部、Authentication首部发送用户认证信息时，服务器端需要像下面这样将<code>Access-Control-Allow-Credentials</code>首部设为true，来告知客户端“已识别所发送的认证信息”。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure>\n<p>如果不这么做，浏览器会直接拒绝来自服务器的响应消息。</p>\n<p>在各个浏览器的XHTTPRequest中，发送cookie等认证信息时，必须把withCredentials属性设为true，否则客户端将无法向服务器发送用户的认证信息。</p>\n<h4 id=\"私有的HTTP首部\"><a href=\"#私有的HTTP首部\" class=\"headerlink\" title=\"私有的HTTP首部\"></a>私有的HTTP首部</h4><p>定义新的HTTP首部时，一般需要在最前面加<code>X-</code>，接着添加服务、应用、团体等名称。例如GitHub会通过<code>X-GitHub-Request-Id</code>的自定义首部来针对每个请求返回唯一的ID。</p>\n<p>RFC 6648中建议不适用<code>X-</code>前缀，即目前的最佳方案，其定义的规则并不具备强制实施的效力。所以，用或不用，统一就好。</p>\n<h3 id=\"第五章：开发方便更改设计的Web-API\"><a href=\"#第五章：开发方便更改设计的Web-API\" class=\"headerlink\" title=\"第五章：开发方便更改设计的Web API\"></a>第五章：开发方便更改设计的Web API</h3><p>版本迭代：</p>\n<ul>\n<li>在URI路径的开头添加形如v1的版本号，如果新API没有向下兼容，则新增版本号；如果是bug，增加build编号，如果向下兼容的变更或废除某些特定的功能，增加次版本号。</li>\n</ul>\n<h3 id=\"第六章：开发牢固的Web-API\"><a href=\"#第六章：开发牢固的Web-API\" class=\"headerlink\" title=\"第六章：开发牢固的Web API\"></a>第六章：开发牢固的Web API</h3><h4 id=\"中间人攻击（Man-In-The-Middle-Attack-MITM攻击）\"><a href=\"#中间人攻击（Man-In-The-Middle-Attack-MITM攻击）\" class=\"headerlink\" title=\"中间人攻击（Man-In-The-Middle Attack, MITM攻击）\"></a>中间人攻击（Man-In-The-Middle Attack, MITM攻击）</h4><p>使用HTTPS加密机制进行通信时，客户端会从服务端获得SSL证书，此时就要求客户端验证该证书的真伪。如果客户端未能执行验证工作，整个通信过程就有可能遭到中间人攻击，导致通信内容被窃取。</p>\n<p>有时一些不含机密信息的API，可以直接使用HTTP而不使用HTTPS加密机制。虽然根据不同类别的API采用不同的方式略微有些复杂，但从降低访问延迟、提高响应速度的角度来说，无疑是行之有效的方法。</p>\n<h4 id=\"XSS\"><a href=\"#XSS\" class=\"headerlink\" title=\"XSS\"></a>XSS</h4><p>XSS接收用户的输入内容并将其嵌入页面的HTML代码，当页面在浏览器里显示时，会自动执行用户输入的JavaScript脚本。一旦页面执行了用户输入的JavaScript脚本，攻击者就能够访问会话、cookie等浏览器里保存的信息，或者篡改页面，还能不受同源策略的限制进行跨域访问，从而完成任意操作。</p>\n<p>如服务器返回</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"attr\">\"data\"</span>: <span class=\"string\">\"&lt;script&gt;alert('xss');&lt;/script&gt;\"</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>在<code>Content-Type</code>首部的值为text/html的情况下，如果浏览器直接访问该JSON数据的URI，该JSON数据会被解释为HTML，导致通过SCRIPT元素加载的JavaScript代码被浏览器执行。所以为了防范，需要让浏览器将JSON格式的数据只识别成JSON，响应首部添加</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Content-Type: application&#x2F;json</span><br></pre></td></tr></table></figure>\n<p>但是IE会有一个<code>Content Sniffering</code>功能，根据实际的数据内容来推测数据格式。所以在返回JSON类型的数据时还应该添加</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">X-Content-Type-Options: nosniff</span><br></pre></td></tr></table></figure>\n<p>这会使IE8以后的浏览器不再使用<code>Content sniffering</code>功能。</p>\n<img src=\"/%E3%80%8AWeb-API-%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BB%E5%90%8E%E6%80%BB%E7%BB%93/XSS.jpeg\" class>\n<h4 id=\"XSRF-CSRF-Cross-Site-Request-Forgery\"><a href=\"#XSRF-CSRF-Cross-Site-Request-Forgery\" class=\"headerlink\" title=\"XSRF/CSRF(Cross Site Request Forgery)\"></a>XSRF/CSRF(Cross Site Request Forgery)</h4><p>跨站点请求伪造。通过跨站点发送伪造的请求，让服务器执行用户意愿意外的处理。</p>\n<img src=\"/%E3%80%8AWeb-API-%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BB%E5%90%8E%E6%80%BB%E7%BB%93/CSRF.jpeg\" class>\n<p>常见例子：向公告板任意发帖，攻击站点以造成损失；恶意刷好评或差评。</p>\n<p>防范：</p>\n<ul>\n<li><p>禁止通过GET方法来修改服务端的数据，如添加收藏、公告板发帖等。这样一来，就无法用IMG元素等嵌入用于攻击的脚本了。</p>\n</li>\n<li><p>CSRF 令牌。</p>\n<img src=\"/%E3%80%8AWeb-API-%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BB%E5%90%8E%E6%80%BB%E7%BB%93/CSRF_TOKEN.jpeg\" class>\n</li>\n<li><p>如果Web API只存在由XMLHTTPRequest或非浏览器客户端发起的访问，就要求客户端使用某种机制在请求附加一个特殊的首部，如果请求消息中不存在这一特殊的首部，就拒绝访问。如<code>X-Request-With</code>首部</p>\n</li>\n</ul>\n<h4 id=\"JSON劫持\"><a href=\"#JSON劫持\" class=\"headerlink\" title=\"JSON劫持\"></a>JSON劫持</h4><p>未完待续。</p>\n","categories":["Web"],"tags":["API","RESTful"]},{"title":"LeetCode算法题整理（贪心篇）Greedy","url":"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E8%B4%AA%E5%BF%83%E7%AF%87%EF%BC%89greedy/","content":"<h3 id=\"984-String-Without-AAA-or-BBB\"><a href=\"#984-String-Without-AAA-or-BBB\" class=\"headerlink\" title=\"984. String Without AAA or BBB\"></a>984. String Without AAA or BBB</h3><h4 id=\"生成字符串没有‘aaa’和’bbb’。原题\"><a href=\"#生成字符串没有‘aaa’和’bbb’。原题\" class=\"headerlink\" title=\"生成字符串没有‘aaa’和’bbb’。原题\"></a>生成字符串没有‘aaa’和’bbb’。<a href=\"https://leetcode.com/problems/string-without-aaa-or-bbb/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: A &#x3D; 1, B &#x3D; 2</span><br><span class=\"line\">Output: &quot;abb&quot;</span><br><span class=\"line\">Explanation: &quot;abb&quot;, &quot;bab&quot; and &quot;bba&quot; are all correct answers.</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">strWithout3a3b</span><span class=\"params\">(self, A, B)</span>:</span></span><br><span class=\"line\">    ans = <span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> A <span class=\"keyword\">or</span> B:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(ans) &gt;= <span class=\"number\">2</span> <span class=\"keyword\">and</span> ans[<span class=\"number\">-1</span>]==ans[<span class=\"number\">-2</span>]:</span><br><span class=\"line\">            writeA = ans[<span class=\"number\">-1</span>]==<span class=\"string\">'b'</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            writeA = A&gt;=B</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> writeA:</span><br><span class=\"line\">            A -= <span class=\"number\">1</span></span><br><span class=\"line\">            ans += <span class=\"string\">'a'</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            B -= <span class=\"number\">1</span></span><br><span class=\"line\">            ans += <span class=\"string\">'b'</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"455-Assign-Cookies\"><a href=\"#455-Assign-Cookies\" class=\"headerlink\" title=\"455. Assign Cookies\"></a>455. Assign Cookies</h3><h4 id=\"发小饼干，s为若干个饼干的大小，g为每个人需要的大小，没人发的饼干不能比要求的size小，问最多可以满足几个人。原题\"><a href=\"#发小饼干，s为若干个饼干的大小，g为每个人需要的大小，没人发的饼干不能比要求的size小，问最多可以满足几个人。原题\" class=\"headerlink\" title=\"发小饼干，s为若干个饼干的大小，g为每个人需要的大小，没人发的饼干不能比要求的size小，问最多可以满足几个人。原题\"></a>发小饼干，s为若干个饼干的大小，g为每个人需要的大小，没人发的饼干不能比要求的size小，问最多可以满足几个人。<a href=\"https://leetcode.com/problems/assign-cookies/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [1,2], [1,2,3]</span><br><span class=\"line\"></span><br><span class=\"line\">Output: 2</span><br><span class=\"line\"></span><br><span class=\"line\">Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. </span><br><span class=\"line\">You have 3 cookies and their sizes are big enough to gratify all of the children, </span><br><span class=\"line\">You need to output 2.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findContentChildren</span><span class=\"params\">(self, g: List[int], s: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    g.sort()</span><br><span class=\"line\">    s.sort()</span><br><span class=\"line\">    i = j = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> i &lt; len(g) <span class=\"keyword\">and</span> j &lt; len(s):</span><br><span class=\"line\">        i += s[j] &gt;= g[i]</span><br><span class=\"line\">        j += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> i</span><br></pre></td></tr></table></figure>\n<h3 id=\"860-Lemonade-Change\"><a href=\"#860-Lemonade-Change\" class=\"headerlink\" title=\"860. Lemonade Change\"></a>860. Lemonade Change</h3><h4 id=\"柠檬找零，每人买一个柠檬，（价值5）可能付5-10-20面值的钞票，问零钱是否能找开。原题\"><a href=\"#柠檬找零，每人买一个柠檬，（价值5）可能付5-10-20面值的钞票，问零钱是否能找开。原题\" class=\"headerlink\" title=\"柠檬找零，每人买一个柠檬，（价值5）可能付5, 10, 20面值的钞票，问零钱是否能找开。原题\"></a>柠檬找零，每人买一个柠檬，（价值5）可能付5, 10, 20面值的钞票，问零钱是否能找开。<a href=\"https://leetcode.com/problems/lemonade-change/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [5,5,5,10,20]</span><br><span class=\"line\">Output: true</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">From the first 3 customers, we collect three $5 bills in order.</span><br><span class=\"line\">From the fourth customer, we collect a $10 bill and give back a $5.</span><br><span class=\"line\">From the fifth customer, we give a $10 bill and a $5 bill.</span><br><span class=\"line\">Since all customers got correct change, we output true.</span><br></pre></td></tr></table></figure>\n<p>方法一：<code>defaultdict</code>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lemonadeChange</span><span class=\"params\">(self, bills: <span class=\"string\">'List[int]'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\">    c = collections.defaultdict(int)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> bill <span class=\"keyword\">in</span> bills:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> bill == <span class=\"number\">10</span>:</span><br><span class=\"line\">            c[<span class=\"number\">5</span>] -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> bill == <span class=\"number\">20</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> c[<span class=\"number\">10</span>] &gt;= <span class=\"number\">1</span>:</span><br><span class=\"line\">                c[<span class=\"number\">10</span>] -= <span class=\"number\">1</span></span><br><span class=\"line\">                c[<span class=\"number\">5</span>] -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                c[<span class=\"number\">5</span>] -= <span class=\"number\">3</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> c[<span class=\"number\">5</span>] &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        c[bill] += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"944-Delete-Columns-to-Make-Sorted\"><a href=\"#944-Delete-Columns-to-Make-Sorted\" class=\"headerlink\" title=\"944. Delete Columns to Make Sorted\"></a>944. Delete Columns to Make Sorted</h3><h4 id=\"找出并行项中未排序的个数。原题\"><a href=\"#找出并行项中未排序的个数。原题\" class=\"headerlink\" title=\"找出并行项中未排序的个数。原题\"></a>找出并行项中未排序的个数。<a href=\"https://leetcode.com/problems/delete-columns-to-make-sorted/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：<code>sorted</code>要比<code>any</code>快，感觉是Cpython的优化导致，理论上来说应该是any快。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minDeletionSize</span><span class=\"params\">(self, A: <span class=\"string\">'List[str]'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> col <span class=\"keyword\">in</span> zip(*A):</span><br><span class=\"line\">        <span class=\"comment\"># if any(col[i]&gt;col[i+1] for i in range(len(col)-1)):</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> sorted(col) != list(col):</span><br><span class=\"line\">            ans += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"55-Jump-Game\"><a href=\"#55-Jump-Game\" class=\"headerlink\" title=\"55. Jump Game\"></a>55. Jump Game</h3><h4 id=\"跳跃游戏，数组中每个元素表示下一步的距离，问是否能跳到最后索引位置。原题\"><a href=\"#跳跃游戏，数组中每个元素表示下一步的距离，问是否能跳到最后索引位置。原题\" class=\"headerlink\" title=\"跳跃游戏，数组中每个元素表示下一步的距离，问是否能跳到最后索引位置。原题\"></a>跳跃游戏，数组中每个元素表示下一步的距离，问是否能跳到最后索引位置。<a href=\"https://leetcode.com/problems/jump-game/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [2,3,1,1,4]</span><br><span class=\"line\">Output: true</span><br><span class=\"line\">Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法一：贪心。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">canJump</span><span class=\"params\">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class=\"line\">    last_pos = len(nums) - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(nums)<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i + nums[i] &gt;= last_pos:</span><br><span class=\"line\">            last_pos = i</span><br><span class=\"line\">    <span class=\"keyword\">return</span> last_pos == <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1005-Maximize-Sum-Of-Array-After-K-Negations\"><a href=\"#1005-Maximize-Sum-Of-Array-After-K-Negations\" class=\"headerlink\" title=\"1005. Maximize Sum Of Array After K Negations\"></a>1005. Maximize Sum Of Array After K Negations</h3><h4 id=\"K次取负后的数组最大和。原题\"><a href=\"#K次取负后的数组最大和。原题\" class=\"headerlink\" title=\"K次取负后的数组最大和。原题\"></a>K次取负后的数组最大和。<a href=\"https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: A &#x3D; [3,-1,0,2], K &#x3D; 3</span><br><span class=\"line\">Output: 6</span><br><span class=\"line\">Explanation: Choose indices (1, 2, 2) and A becomes [3,1,0,2].</span><br></pre></td></tr></table></figure>\n<p>方法一：竞赛的时候，写得比较麻烦，分了两个数组，还考虑了0，后来看lee神的整理一下。注意最后一步要用一下<code>min</code>，否则获取不了最小值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">largestSumAfterKNegations</span><span class=\"params\">(self, A: List[int], K: int)</span> -&gt; int:</span></span><br><span class=\"line\">    A.sort()</span><br><span class=\"line\">    i = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> i&lt;len(A) <span class=\"keyword\">and</span> i&lt;K <span class=\"keyword\">and</span> A[i]&lt;<span class=\"number\">0</span>:</span><br><span class=\"line\">        A[i] = -A[i]</span><br><span class=\"line\">        i += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(A) - (K-i)%<span class=\"number\">2</span>*min(A)*<span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1029-Two-City-Scheduling\"><a href=\"#1029-Two-City-Scheduling\" class=\"headerlink\" title=\"1029. Two City Scheduling\"></a>1029. Two City Scheduling</h3><h4 id=\"两个城市调度。每个坐标表示，去A和B的花费，使花费最小。原题\"><a href=\"#两个城市调度。每个坐标表示，去A和B的花费，使花费最小。原题\" class=\"headerlink\" title=\"两个城市调度。每个坐标表示，去A和B的花费，使花费最小。原题\"></a>两个城市调度。每个坐标表示，去A和B的花费，使花费最小。<a href=\"https://leetcode.com/problems/two-city-scheduling/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [[10,20],[30,200],[400,50],[30,20]]</span><br><span class=\"line\">Output: 110</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">The first person goes to city A for a cost of 10.</span><br><span class=\"line\">The second person goes to city A for a cost of 30.</span><br><span class=\"line\">The third person goes to city B for a cost of 50.</span><br><span class=\"line\">The fourth person goes to city B for a cost of 20.</span><br><span class=\"line\"></span><br><span class=\"line\">The total minimum cost is 10 + 30 + 50 + 20 &#x3D; 110 to have half the people interviewing in each city.</span><br></pre></td></tr></table></figure>\n<p>方法一：假设左边的人留在A，右边的人留在B，如果不是最优解，那么右边的人r需要移到左边，左边的人l需要移到右边，相当于从<code>l[0]+r[1]</code>变为了<code>l[1]+r[0]</code>，即<code>l[1]-l[0]+r[0]-r[1]&lt;0</code>时需要交换两个城市，推导可得出，<code>l[0]-l[1] &gt; r[0]-r[1]</code>，则得出排序规则。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">twoCitySchedCost</span><span class=\"params\">(self, costs: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    costs.sort(key=<span class=\"keyword\">lambda</span> x: x[<span class=\"number\">0</span>]-x[<span class=\"number\">1</span>]) </span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(i[<span class=\"number\">0</span>] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> costs[:len(costs)//<span class=\"number\">2</span>]) + sum(j[<span class=\"number\">1</span>] <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> costs[len(costs)//<span class=\"number\">2</span>:])</span><br></pre></td></tr></table></figure>\n<h3 id=\"1042-Flower-Planting-With-No-Adjacent\"><a href=\"#1042-Flower-Planting-With-No-Adjacent\" class=\"headerlink\" title=\"1042. Flower Planting With No Adjacent\"></a>1042. Flower Planting With No Adjacent</h3><h4 id=\"联通图染色问题，paths表示相邻的花园，相邻的花园中不能种同一种花，一种有四种花。原题\"><a href=\"#联通图染色问题，paths表示相邻的花园，相邻的花园中不能种同一种花，一种有四种花。原题\" class=\"headerlink\" title=\"联通图染色问题，paths表示相邻的花园，相邻的花园中不能种同一种花，一种有四种花。原题\"></a>联通图染色问题，paths表示相邻的花园，相邻的花园中不能种同一种花，一种有四种花。<a href=\"https://leetcode.com/problems/flower-planting-with-no-adjacent/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">gardenNoAdj</span><span class=\"params\">(self, N: int, paths: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    res = [<span class=\"number\">0</span>] * N</span><br><span class=\"line\">    g = [[] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(N)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> paths:</span><br><span class=\"line\">        g[x<span class=\"number\">-1</span>].append(y<span class=\"number\">-1</span>)</span><br><span class=\"line\">        g[y<span class=\"number\">-1</span>].append(x<span class=\"number\">-1</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(N):</span><br><span class=\"line\">        res[i] = (&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;-&#123;res[j] <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> g[i]&#125;).pop()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"1046-Last-Stone-Weight\"><a href=\"#1046-Last-Stone-Weight\" class=\"headerlink\" title=\"1046. Last Stone Weight\"></a>1046. Last Stone Weight</h3><h4 id=\"最后一块石头的质量。每次从石头堆中拿出两块最重的pk，剩下为二者之差。原题\"><a href=\"#最后一块石头的质量。每次从石头堆中拿出两块最重的pk，剩下为二者之差。原题\" class=\"headerlink\" title=\"最后一块石头的质量。每次从石头堆中拿出两块最重的pk，剩下为二者之差。原题\"></a>最后一块石头的质量。每次从石头堆中拿出两块最重的pk，剩下为二者之差。<a href=\"https://leetcode.com/problems/last-stone-weight/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：暴力排序。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lastStoneWeight</span><span class=\"params\">(self, stones: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    stones = sorted(stones)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> len(stones) &gt; <span class=\"number\">1</span>:</span><br><span class=\"line\">        a, b = stones.pop(), stones.pop()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> a != b:</span><br><span class=\"line\">            stones.append(a - b)</span><br><span class=\"line\">            stones.sort()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stones[<span class=\"number\">0</span>] <span class=\"keyword\">if</span> stones <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<p>方法二：使用堆。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lastStoneWeight</span><span class=\"params\">(self, stones: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">import</span> heapq <span class=\"keyword\">as</span> hq</span><br><span class=\"line\">    <span class=\"keyword\">from</span> operator <span class=\"keyword\">import</span> neg</span><br><span class=\"line\">    stones = list(map(neg, stones))</span><br><span class=\"line\">    hq.heapify(stones)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> len(stones) &gt; <span class=\"number\">1</span>:</span><br><span class=\"line\">        a = -hq.heappop(stones)</span><br><span class=\"line\">        b = -hq.heappop(stones)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> a != b:</span><br><span class=\"line\">            hq.heappush(stones, b - a)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -hq.heappop(stones) <span class=\"keyword\">if</span> stones <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1090-Largest-Values-From-Labels\"><a href=\"#1090-Largest-Values-From-Labels\" class=\"headerlink\" title=\"1090. Largest Values From Labels\"></a>1090. Largest Values From Labels</h3><h4 id=\"给一个集合，每个元素有一个值values-i-与标签labels-i-。这里要选择一个子集，使得子集的元素个数不超过num-wanted，而且相同标签的元素个数不超过use-limit。求子集的最大和。原题\"><a href=\"#给一个集合，每个元素有一个值values-i-与标签labels-i-。这里要选择一个子集，使得子集的元素个数不超过num-wanted，而且相同标签的元素个数不超过use-limit。求子集的最大和。原题\" class=\"headerlink\" title=\"给一个集合，每个元素有一个值values[i]与标签labels[i]。这里要选择一个子集，使得子集的元素个数不超过num_wanted，而且相同标签的元素个数不超过use_limit。求子集的最大和。原题\"></a>给一个集合，每个元素有一个值<code>values[i]</code>与标签<code>labels[i]</code>。这里要选择一个子集，使得子集的元素个数不超过<code>num_wanted</code>，而且相同标签的元素个数不超过<code>use_limit</code>。求子集的最大和。<a href=\"https://leetcode.com/problems/largest-values-from-labels/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: values &#x3D; [5,4,3,2,1], labels &#x3D; [1,1,2,2,3], num_wanted &#x3D; 3, use_limit &#x3D; 1</span><br><span class=\"line\">Output: 9</span><br><span class=\"line\">Explanation: The subset chosen is the first, third, and fifth item.</span><br></pre></td></tr></table></figure>\n<p>方法一：此题大部分时间花在理解题意，英文原文非常容易误解。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">largestValsFromLabels</span><span class=\"params\">(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int)</span> -&gt; int:</span></span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    c = collections.defaultdict(int)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> v, b <span class=\"keyword\">in</span> sorted(zip(values, labels), reverse=<span class=\"literal\">True</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> num_wanted == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> c[b] &lt; use_limit:</span><br><span class=\"line\">            c[b] += <span class=\"number\">1</span></span><br><span class=\"line\">            ans += v</span><br><span class=\"line\">            num_wanted -= <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"1094-Car-Pooling\"><a href=\"#1094-Car-Pooling\" class=\"headerlink\" title=\"1094. Car Pooling\"></a>1094. Car Pooling</h3><h4 id=\"一辆车接旅客，根据旅客的人数，上下车位置，判断是否可以载完所有的旅客。原题\"><a href=\"#一辆车接旅客，根据旅客的人数，上下车位置，判断是否可以载完所有的旅客。原题\" class=\"headerlink\" title=\"一辆车接旅客，根据旅客的人数，上下车位置，判断是否可以载完所有的旅客。原题\"></a>一辆车接旅客，根据旅客的人数，上下车位置，判断是否可以载完所有的旅客。<a href=\"https://leetcode.com/problems/car-pooling/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: trips &#x3D; [[2,1,5],[3,3,7]], capacity &#x3D; 4</span><br><span class=\"line\">Output: false</span><br></pre></td></tr></table></figure>\n<p>方法一：将旅客上下车地点排序。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">carPooling</span><span class=\"params\">(self, trips: List[List[int]], capacity: int)</span> -&gt; bool:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, v <span class=\"keyword\">in</span> sorted(x <span class=\"keyword\">for</span> n, s, e <span class=\"keyword\">in</span> trips <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> ((s, n), (e, -n))):</span><br><span class=\"line\">        capacity -= v</span><br><span class=\"line\">        <span class=\"keyword\">if</span> capacity &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1403-Minimum-Subsequence-in-Non-Increasing-Order\"><a href=\"#1403-Minimum-Subsequence-in-Non-Increasing-Order\" class=\"headerlink\" title=\"1403. Minimum Subsequence in Non-Increasing Order\"></a>1403. Minimum Subsequence in Non-Increasing Order</h3><h4 id=\"最小的宽度的和大于剩余数的子序列。原题\"><a href=\"#最小的宽度的和大于剩余数的子序列。原题\" class=\"headerlink\" title=\"最小的宽度的和大于剩余数的子序列。原题\"></a>最小的宽度的和大于剩余数的子序列。<a href=\"https://leetcode.com/problems/minimum-subsequence-in-non-increasing-order/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [4,3,10,9,8]</span><br><span class=\"line\">Output: [10,9] </span><br><span class=\"line\">Explanation: The subsequences [10,9] and [10,8] are minimal such that the sum of their elements is strictly greater than the sum of elements not included, however, the subsequence [10,9] has the maximum total sum of its elements.</span><br></pre></td></tr></table></figure>\n<p>方法一：排序。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minSubsequence</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    nums.sort(reverse=<span class=\"literal\">True</span>)</span><br><span class=\"line\">    total = sum(nums)</span><br><span class=\"line\">    cur = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, d <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">        cur += d</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cur * <span class=\"number\">2</span> &gt; total:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums[:i+<span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums</span><br></pre></td></tr></table></figure>\n<h3 id=\"1400-Construct-K-Palindrome-Strings\"><a href=\"#1400-Construct-K-Palindrome-Strings\" class=\"headerlink\" title=\"1400. Construct K Palindrome Strings\"></a>1400. Construct K Palindrome Strings</h3><h4 id=\"是否能用给定的字符串够成k个回文串。原题\"><a href=\"#是否能用给定的字符串够成k个回文串。原题\" class=\"headerlink\" title=\"是否能用给定的字符串够成k个回文串。原题\"></a>是否能用给定的字符串够成k个回文串。<a href=\"https://leetcode.com/problems/construct-k-palindrome-strings/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;annabelle&quot;, k &#x3D; 2</span><br><span class=\"line\">Output: true</span><br><span class=\"line\">Explanation: You can construct two palindromes using all characters in s.</span><br><span class=\"line\">Some possible constructions &quot;anna&quot; + &quot;elble&quot;, &quot;anbna&quot; + &quot;elle&quot;, &quot;anellena&quot; + &quot;b&quot;</span><br></pre></td></tr></table></figure>\n<p>方法一：能否构成回文串，要看奇数个字符是否小于等于k。<br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">canConstruct</span><span class=\"params\">(self, s: str, k: int)</span> -&gt; bool:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Counter</span><br><span class=\"line\">    odd_c = sum(cnt&amp;<span class=\"number\">1</span>==<span class=\"number\">1</span> <span class=\"keyword\">for</span> cnt <span class=\"keyword\">in</span> Counter(s).values())</span><br><span class=\"line\">    <span class=\"keyword\">return</span> odd_c &lt;= k &lt;= len(s)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"45-Jump-Game-II\"><a href=\"#45-Jump-Game-II\" class=\"headerlink\" title=\"45. Jump Game II\"></a>45. Jump Game II</h3><h4 id=\"跳跃游戏。每个位置写了最远距离。原题\"><a href=\"#跳跃游戏。每个位置写了最远距离。原题\" class=\"headerlink\" title=\"跳跃游戏。每个位置写了最远距离。原题\"></a>跳跃游戏。每个位置写了最远距离。<a href=\"https://leetcode.com/problems/jump-game-ii/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [2,3,1,1,4]</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: The minimum number of jumps to reach the last index is 2.</span><br><span class=\"line\">    Jump 1 step from index 0 to 1, then 3 steps to the last index.</span><br></pre></td></tr></table></figure>\n<p>方法一：使用了与1024题一样的方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">jump</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    n = len(nums)</span><br><span class=\"line\">    end, end2, cnt = <span class=\"number\">-1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, s <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> end2 &gt;= n<span class=\"number\">-1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> end &lt; i &lt;= end2:</span><br><span class=\"line\">            cnt += <span class=\"number\">1</span></span><br><span class=\"line\">            end = end2</span><br><span class=\"line\">        end2 = max(end2, i+s)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cnt</span><br></pre></td></tr></table></figure>\n<p>方法二：使用两个指针，表示了一个范围，每次增加一步时，在这个范围中找到下一次最右的距离，为了不让范围重叠, 让<code>left=right+1</code>，直到最右点到达末尾。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">jump</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(nums) &lt;= <span class=\"number\">1</span>: <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    l, r = <span class=\"number\">0</span>, nums[<span class=\"number\">0</span>]</span><br><span class=\"line\">    step = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> r &lt; len(nums)<span class=\"number\">-1</span>:</span><br><span class=\"line\">        step += <span class=\"number\">1</span></span><br><span class=\"line\">        nxt = max(i+nums[i] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(l, r+<span class=\"number\">1</span>))</span><br><span class=\"line\">        l, r = r+<span class=\"number\">1</span>, nxt</span><br><span class=\"line\">    <span class=\"keyword\">return</span> step</span><br></pre></td></tr></table></figure>\n<h3 id=\"1296-Divide-Array-in-Sets-of-K-Consecutive-Numbers\"><a href=\"#1296-Divide-Array-in-Sets-of-K-Consecutive-Numbers\" class=\"headerlink\" title=\"1296. Divide Array in Sets of K Consecutive Numbers\"></a>1296. Divide Array in Sets of K Consecutive Numbers</h3><h4 id=\"数组能否分成连续的k个元素的子数组。原题\"><a href=\"#数组能否分成连续的k个元素的子数组。原题\" class=\"headerlink\" title=\"数组能否分成连续的k个元素的子数组。原题\"></a>数组能否分成连续的k个元素的子数组。<a href=\"https://leetcode.com/problems/divide-array-in-sets-of-k-consecutive-numbers/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [1,2,3,3,4,4,5,6], k &#x3D; 4</span><br><span class=\"line\">Output: true</span><br><span class=\"line\">Explanation: Array can be divided into [1,2,3,4] and [3,4,5,6].</span><br></pre></td></tr></table></figure>\n<p>方法一：首次ac的方法。每次取最小的key比较耗时。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isPossibleDivide</span><span class=\"params\">(self, nums: List[int], k: int)</span> -&gt; bool:</span></span><br><span class=\"line\">    n = len(nums)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n % k != <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    c = collections.Counter(nums)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n//k):</span><br><span class=\"line\">        s = min(c.keys())</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(k):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> s+j <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> c:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">            c[s+j] -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> c[s+j] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">del</span> c[s+j]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：排序，每次从中取最小，如果其数量不为1，那么作为它的等差数列一组，另外的k-1个数也得大于等于这个数量。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isPossibleDivide</span><span class=\"params\">(self, nums: List[int], k: int)</span> -&gt; bool:</span></span><br><span class=\"line\">    c = collections.Counter(nums)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> sorted(c):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> c[i] &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, k):</span><br><span class=\"line\">                c[i+j] -= c[i]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> c[i+j] &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1282-Group-the-People-Given-the-Group-Size-They-Belong-To\"><a href=\"#1282-Group-the-People-Given-the-Group-Size-They-Belong-To\" class=\"headerlink\" title=\"1282. Group the People Given the Group Size They Belong To\"></a>1282. Group the People Given the Group Size They Belong To</h3><h4 id=\"将元素分组到指定的size中。原题\"><a href=\"#将元素分组到指定的size中。原题\" class=\"headerlink\" title=\"将元素分组到指定的size中。原题\"></a>将元素分组到指定的size中。<a href=\"https://leetcode.com/problems/group-the-people-given-the-group-size-they-belong-to/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: groupSizes &#x3D; [3,3,3,3,3,1,3]</span><br><span class=\"line\">Output: [[5],[0,1,2],[3,4,6]]</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">Other possible solutions are [[2,1,6],[5],[0,4,3]] and [[5],[0,6,2],[4,3,1]].</span><br></pre></td></tr></table></figure>\n<p>方法一：比赛时用的sort，其实有O(n)的方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">groupThePeople</span><span class=\"params\">(self, groupSizes: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">    gs = [(i, s) <span class=\"keyword\">for</span> i, s <span class=\"keyword\">in</span> enumerate(groupSizes)]</span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    last = <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, s <span class=\"keyword\">in</span> sorted(gs, key=<span class=\"keyword\">lambda</span> x: x[<span class=\"number\">1</span>]):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> last <span class=\"keyword\">or</span> len(ans[<span class=\"number\">-1</span>]) == last:</span><br><span class=\"line\">            ans.append([i])</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            ans[<span class=\"number\">-1</span>].append(i)</span><br><span class=\"line\">        last = s</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：hash.</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">groupThePeople</span><span class=\"params\">(self, groupSizes: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">    count = collections.defaultdict(list)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, g <span class=\"keyword\">in</span> enumerate(groupSizes):</span><br><span class=\"line\">        count[g].append(i)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [l[i:i+s] <span class=\"keyword\">for</span> s, l <span class=\"keyword\">in</span> count.items() <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(l), s)]</span><br></pre></td></tr></table></figure>\n<h3 id=\"1253-Reconstruct-a-2-Row-Binary-Matrix\"><a href=\"#1253-Reconstruct-a-2-Row-Binary-Matrix\" class=\"headerlink\" title=\"1253. Reconstruct a 2-Row Binary Matrix\"></a>1253. Reconstruct a 2-Row Binary Matrix</h3><h4 id=\"两个二进制数组，给出每个累加1的和，和列的和，重建这个二进制数组，答案不唯一。原题\"><a href=\"#两个二进制数组，给出每个累加1的和，和列的和，重建这个二进制数组，答案不唯一。原题\" class=\"headerlink\" title=\"两个二进制数组，给出每个累加1的和，和列的和，重建这个二进制数组，答案不唯一。原题\"></a>两个二进制数组，给出每个累加1的和，和列的和，重建这个二进制数组，答案不唯一。<a href=\"https://leetcode.com/problems/reconstruct-a-2-row-binary-matrix/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: upper &#x3D; 2, lower &#x3D; 1, colsum &#x3D; [1,1,1]</span><br><span class=\"line\">Output: [[1,1,0],[0,0,1]]</span><br><span class=\"line\">Explanation: [[1,0,1],[0,1,0]], and [[0,1,1],[1,0,0]] are also correct answers.</span><br></pre></td></tr></table></figure>\n<p>方法一：竞赛时的方法写的太java。因为在于贪心的条件选择先塞满第一个数。这样会徒增一些没用的判断。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reconstructMatrix</span><span class=\"params\">(self, upper: int, lower: int, colsum: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">    n = len(colsum)</span><br><span class=\"line\">    c1, c2 = colsum.count(<span class=\"number\">1</span>), colsum.count(<span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> upper+lower-c2*<span class=\"number\">2</span> != c1 <span class=\"keyword\">or</span> min(upper, lower)&lt;c2:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> []</span><br><span class=\"line\">    a, b, r = [], [], <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> colsum:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> c == <span class=\"number\">2</span>:</span><br><span class=\"line\">            i = j = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> c == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> upper-c2-r &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                i = <span class=\"number\">1</span></span><br><span class=\"line\">                j = <span class=\"number\">0</span></span><br><span class=\"line\">                r += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                i = <span class=\"number\">0</span></span><br><span class=\"line\">                j = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            i = j = <span class=\"number\">0</span></span><br><span class=\"line\">        a.append(i)</span><br><span class=\"line\">        b.append(j)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [a, b]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：可以用大小判断选择放哪个数中。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reconstructMatrix</span><span class=\"params\">(self, upper: int, lower: int, colsum: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">    n = len(colsum)</span><br><span class=\"line\">    a1, a2 = [<span class=\"number\">0</span>] * n, [<span class=\"number\">0</span>] * n</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, s <span class=\"keyword\">in</span> enumerate(colsum):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> s == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> upper &gt; lower:</span><br><span class=\"line\">                a1[i] = <span class=\"number\">1</span></span><br><span class=\"line\">                upper -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                a2[i] = <span class=\"number\">1</span></span><br><span class=\"line\">                lower -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> s == <span class=\"number\">2</span>:</span><br><span class=\"line\">            a1[i] = a2[i] = <span class=\"number\">1</span></span><br><span class=\"line\">            upper -= <span class=\"number\">1</span></span><br><span class=\"line\">            lower -= <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a1, a2) <span class=\"keyword\">if</span> lower==upper==<span class=\"number\">0</span> <span class=\"keyword\">else</span> []</span><br></pre></td></tr></table></figure>\n<h3 id=\"1247-Minimum-Swaps-to-Make-Strings-Equal\"><a href=\"#1247-Minimum-Swaps-to-Make-Strings-Equal\" class=\"headerlink\" title=\"1247. Minimum Swaps to Make Strings Equal\"></a>1247. Minimum Swaps to Make Strings Equal</h3><h4 id=\"两个包含x和y的字符串，互换任意两个字符，最小需要多少次才能相等。原题\"><a href=\"#两个包含x和y的字符串，互换任意两个字符，最小需要多少次才能相等。原题\" class=\"headerlink\" title=\"两个包含x和y的字符串，互换任意两个字符，最小需要多少次才能相等。原题\"></a>两个包含x和y的字符串，互换任意两个字符，最小需要多少次才能相等。<a href=\"https://leetcode.com/problems/minimum-swaps-to-make-strings-equal/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: s1 &#x3D; &quot;xx&quot;, s2 &#x3D; &quot;yy&quot;</span><br><span class=\"line\">Output: 1</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">Swap s1[0] and s2[1], s1 &#x3D; &quot;yx&quot;, s2 &#x3D; &quot;yx&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">Input: s1 &#x3D; &quot;xy&quot;, s2 &#x3D; &quot;yx&quot;</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">Swap s1[0] and s2[0], s1 &#x3D; &quot;yy&quot;, s2 &#x3D; &quot;xx&quot;.</span><br><span class=\"line\">Swap s1[0] and s2[1], s1 &#x3D; &quot;xy&quot;, s2 &#x3D; &quot;xy&quot;.</span><br><span class=\"line\">Note that you can&#39;t swap s1[0] and s1[1] to make s1 equal to &quot;yx&quot;, cause we can only swap chars in different strings.</span><br></pre></td></tr></table></figure>\n<p>方法一：尽量多的匹配,’xx’和’yy’这样只需要一步。ac倒是ac了，写法上看着有点烂。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minimumSwap</span><span class=\"params\">(self, s1: str, s2: str)</span> -&gt; int:</span></span><br><span class=\"line\">    c_x, c_y = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> zip(s1, s2):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> a != b:</span><br><span class=\"line\">            c_x += (a==<span class=\"string\">'x'</span>)</span><br><span class=\"line\">            c_y += (a==<span class=\"string\">'y'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> max(c_x, c_y)==<span class=\"number\">2</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> c_x &gt; c_y:</span><br><span class=\"line\">                c_x -= <span class=\"number\">2</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                c_y -= <span class=\"number\">2</span></span><br><span class=\"line\">            ans += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> c_x + c_y == <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    ans += (c_x==<span class=\"number\">1</span> <span class=\"keyword\">and</span> c_y==<span class=\"number\">1</span>) * <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法二：优化一下。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minimumSwap</span><span class=\"params\">(self, s1: str, s2: str)</span> -&gt; int:</span></span><br><span class=\"line\">    x1 = y1 = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> zip(s1, s2):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> a != b:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> a == <span class=\"string\">'x'</span>:</span><br><span class=\"line\">                x1 += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                y1 += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x1+y1) &amp; <span class=\"number\">1</span> == <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x1//<span class=\"number\">2</span> + y1//<span class=\"number\">2</span> + <span class=\"number\">2</span>*(x1&amp;<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"406-Queue-Reconstruction-by-Height\"><a href=\"#406-Queue-Reconstruction-by-Height\" class=\"headerlink\" title=\"406. Queue Reconstruction by Height\"></a>406. Queue Reconstruction by Height</h3><h4 id=\"根据没跟人的高度和前面比他高的k个人，重建队列。原题\"><a href=\"#根据没跟人的高度和前面比他高的k个人，重建队列。原题\" class=\"headerlink\" title=\"根据没跟人的高度和前面比他高的k个人，重建队列。原题\"></a>根据没跟人的高度和前面比他高的k个人，重建队列。<a href=\"https://leetcode.com/problems/queue-reconstruction-by-height/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]</span><br><span class=\"line\"></span><br><span class=\"line\">Output:</span><br><span class=\"line\">[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]</span><br></pre></td></tr></table></figure>\n<p>方法一：看了答案，理解起来也不是很难，根据高度来排序，每次选出一个人插入到队列中，因为队列里的人都是比他高的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reconstructQueue</span><span class=\"params\">(self, people: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">    people.sort(key=<span class=\"keyword\">lambda</span> x: (-x[<span class=\"number\">0</span>], x[<span class=\"number\">1</span>]))</span><br><span class=\"line\">    queue = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> people:</span><br><span class=\"line\">        queue.insert(p[<span class=\"number\">1</span>], p)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> queue</span><br></pre></td></tr></table></figure>\n<h3 id=\"1488-Avoid-Flood-in-The-City\"><a href=\"#1488-Avoid-Flood-in-The-City\" class=\"headerlink\" title=\"1488. Avoid Flood in The City\"></a>1488. Avoid Flood in The City</h3><h4 id=\"rains表示哪个湖会下雨，0的时候表示可以选择一个湖抽干水，如果有湖水在抽干前又下雨了，那么就会发洪水，返回-1，然后需要返回一个数组，表示每天应该抽干哪个湖的水，答案不唯一。原题\"><a href=\"#rains表示哪个湖会下雨，0的时候表示可以选择一个湖抽干水，如果有湖水在抽干前又下雨了，那么就会发洪水，返回-1，然后需要返回一个数组，表示每天应该抽干哪个湖的水，答案不唯一。原题\" class=\"headerlink\" title=\"rains表示哪个湖会下雨，0的时候表示可以选择一个湖抽干水，如果有湖水在抽干前又下雨了，那么就会发洪水，返回-1，然后需要返回一个数组，表示每天应该抽干哪个湖的水，答案不唯一。原题 \"></a>rains表示哪个湖会下雨，0的时候表示可以选择一个湖抽干水，如果有湖水在抽干前又下雨了，那么就会发洪水，返回-1，然后需要返回一个数组，表示每天应该抽干哪个湖的水，答案不唯一。<a href=\"https://leetcode.com/problems/avoid-flood-in-the-city/\" target=\"_blank\" rel=\"noopener\">原题 </a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: rains &#x3D; [1,2,0,0,2,1]</span><br><span class=\"line\">Output: [-1,-1,2,1,-1,-1]</span><br><span class=\"line\">Explanation: After the first day full lakes are [1]</span><br><span class=\"line\">After the second day full lakes are [1,2]</span><br><span class=\"line\">After the third day, we dry lake 2. Full lakes are [1]</span><br><span class=\"line\">After the fourth day, we dry lake 1. There is no full lakes.</span><br><span class=\"line\">After the fifth day, full lakes are [2].</span><br><span class=\"line\">After the sixth day, full lakes are [1,2].</span><br><span class=\"line\">It is easy that this scenario is flood-free. [-1,-1,1,2,-1,-1] is another acceptable scenario.</span><br></pre></td></tr></table></figure>\n<p>方法一：竞赛的时候没有做出来，在多次wa后TLE了，使用的方式是二分查找修改要抽哪天的水。没有想到用堆。而且整体的思路有一种滞后性，就是当遇见第二次下雨的时候再去找0的那天抽干哪个湖的水。这个方法遍历了两次数组，第一次将每个湖下雨的天数记录下来。然后可以抽水的时候用一个堆去计算最近的哪个湖会再次下雨，这样优先抽干这个湖的水。to_empty中记录索引。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">avoidFlood</span><span class=\"params\">(self, rains: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    n = len(rains)</span><br><span class=\"line\">    dic = collections.defaultdict(list)</span><br><span class=\"line\">    ans = [<span class=\"number\">-1</span>] * n</span><br><span class=\"line\">    full = set()</span><br><span class=\"line\">    to_empty = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, rain <span class=\"keyword\">in</span> enumerate(rains):</span><br><span class=\"line\">        dic[rain].append(i)</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, rain <span class=\"keyword\">in</span> enumerate(rains):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> rain:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> rain <span class=\"keyword\">in</span> full:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> []</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                full.add(rain)</span><br><span class=\"line\">                dic[rain].pop(<span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> dic[rain]:</span><br><span class=\"line\">                    heapq.heappush(to_empty, dic[rain][<span class=\"number\">0</span>])</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> to_empty:</span><br><span class=\"line\">                j = heapq.heappop(to_empty)</span><br><span class=\"line\">                ans[i] = rains[j]</span><br><span class=\"line\">                full.remove(rains[j])</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                ans[i] = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"1505-Minimum-Possible-Integer-After-at-Most-K-Adjacent-Swaps-On-Digits\"><a href=\"#1505-Minimum-Possible-Integer-After-at-Most-K-Adjacent-Swaps-On-Digits\" class=\"headerlink\" title=\"1505. Minimum Possible Integer After at Most K Adjacent Swaps On Digits\"></a>1505. Minimum Possible Integer After at Most K Adjacent Swaps On Digits</h3><h4 id=\"一个数字最多交换K次相邻的字符，使其表示的数字最小，可以0开头。原题\"><a href=\"#一个数字最多交换K次相邻的字符，使其表示的数字最小，可以0开头。原题\" class=\"headerlink\" title=\"一个数字最多交换K次相邻的字符，使其表示的数字最小，可以0开头。原题\"></a>一个数字最多交换K次相邻的字符，使其表示的数字最小，可以0开头。<a href=\"https://leetcode.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: num &#x3D; &quot;4321&quot;, k &#x3D; 4</span><br><span class=\"line\">Output: &quot;1342&quot;</span><br><span class=\"line\">Explanation: The steps to obtain the minimum integer from 4321 with 4 adjacent swaps are shown.</span><br></pre></td></tr></table></figure>\n<p>方法一：据说是字节的面试题。contest时卡在了第三题，此题没有时间看。这个方法是超时的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minInteger</span><span class=\"params\">(self, num: str, k: int)</span> -&gt; str:</span></span><br><span class=\"line\">    num = [*map(int, num)]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> k &gt;= (len(num) ** <span class=\"number\">2</span>) // <span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(map(str, sorted(num)))</span><br><span class=\"line\">    </span><br><span class=\"line\">    res = []</span><br><span class=\"line\">    q = [(v, i) <span class=\"keyword\">for</span> i, v <span class=\"keyword\">in</span> enumerate(num)]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> k <span class=\"keyword\">and</span> q:</span><br><span class=\"line\">        idx, (v, i) = min(enumerate(q[:k + <span class=\"number\">1</span>]), key=<span class=\"keyword\">lambda</span> p:p[<span class=\"number\">1</span>])</span><br><span class=\"line\">        k -= idx</span><br><span class=\"line\">        <span class=\"keyword\">del</span> q[idx]</span><br><span class=\"line\">        res += v,</span><br><span class=\"line\">        </span><br><span class=\"line\">    res += [v <span class=\"keyword\">for</span> v, _ <span class=\"keyword\">in</span> q]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(map(str, res))</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：使用一个FenWick数即二叉索引数记录位移。总体的思路是一样的，每次在可以k的范围内找到一个最小的数移到最左边，这样数字会变为最小，开始的时候记录每个数的原始索引，使用FenWick记录位移索引，如在一个i的位置找到一个最小数移到最左边，那么其原始序列右侧的数下次需要位移为原始做阴-1，因为最左位已经被占用了。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FenWick</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">        self.nums = [<span class=\"number\">0</span>] * (<span class=\"number\">1</span>+ n)</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">update</span><span class=\"params\">(self, i, delta)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; len(self.nums):</span><br><span class=\"line\">            self.nums[i] += delta</span><br><span class=\"line\">            i += i &amp; -i</span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">query</span><span class=\"params\">(self, i)</span>:</span></span><br><span class=\"line\">        ans = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            ans += self.nums[i]</span><br><span class=\"line\">            i -= i &amp; -i</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minInteger</span><span class=\"params\">(self, num: str, k: int)</span> -&gt; str:</span></span><br><span class=\"line\">        n = len(num)</span><br><span class=\"line\">        pos = [[] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(<span class=\"number\">10</span>)]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">            pos[ord(num[i])-ord(<span class=\"string\">'0'</span>)].append(i)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">find_min</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> range(<span class=\"number\">10</span>):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> pos[d]: <span class=\"keyword\">continue</span></span><br><span class=\"line\">                i = pos[d][<span class=\"number\">-1</span>]</span><br><span class=\"line\">                cost = i - tree.query(i)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> cost &lt;= k: <span class=\"keyword\">return</span> d, cost</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">None</span>, <span class=\"literal\">None</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        tree = FenWick(n)</span><br><span class=\"line\">        res = []</span><br><span class=\"line\">        removed = [<span class=\"literal\">False</span>] * n</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> k:</span><br><span class=\"line\">            d, cost = find_min()</span><br><span class=\"line\">            <span class=\"keyword\">if</span> d <span class=\"keyword\">is</span> <span class=\"literal\">None</span>: <span class=\"keyword\">break</span>  </span><br><span class=\"line\">            k -= cost</span><br><span class=\"line\">            res.append(d)</span><br><span class=\"line\">            i = pos[d].pop()</span><br><span class=\"line\">            tree.update(i+<span class=\"number\">1</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">            removed[i] = <span class=\"literal\">True</span></span><br><span class=\"line\">            </span><br><span class=\"line\">        lhs = <span class=\"string\">''</span>.join(map(str, res))</span><br><span class=\"line\">        rhs = <span class=\"string\">''</span>.join(num[i] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n) <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> removed[i])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> lhs + rhs</span><br></pre></td></tr></table></figure>\n<h3 id=\"763-Partition-Labels\"><a href=\"#763-Partition-Labels\" class=\"headerlink\" title=\"763. Partition Labels\"></a>763. Partition Labels</h3><h4 id=\"将字符串S尽可能分成多的部分，不同部分不能有相同的字符。原题\"><a href=\"#将字符串S尽可能分成多的部分，不同部分不能有相同的字符。原题\" class=\"headerlink\" title=\"将字符串S尽可能分成多的部分，不同部分不能有相同的字符。原题\"></a>将字符串S尽可能分成多的部分，不同部分不能有相同的字符。<a href=\"https://leetcode.com/problems/partition-labels/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: S &#x3D; &quot;ababcbacadefegdehijhklij&quot;</span><br><span class=\"line\">Output: [9,7,8]</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">The partition is &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;.</span><br><span class=\"line\">This is a partition so that each letter appears in at most one part.</span><br><span class=\"line\">A partition like &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; is incorrect, because it splits S into less parts.</span><br></pre></td></tr></table></figure>\n<p>方法一：一开始想的方法。每次遇到之前的元素就用栈的方式来合并。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">partitionLabels</span><span class=\"params\">(self, S: str)</span> -&gt; List[int]:</span></span><br><span class=\"line\">    n = len(S)</span><br><span class=\"line\">    last = &#123;&#125;</span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, c <span class=\"keyword\">in</span> enumerate(S):</span><br><span class=\"line\">        last[c] = i</span><br><span class=\"line\">        </span><br><span class=\"line\">    hi = <span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> hi != n<span class=\"number\">-1</span>:</span><br><span class=\"line\">        lo = start = hi + <span class=\"number\">1</span></span><br><span class=\"line\">        hi = last[S[lo]]</span><br><span class=\"line\">        <span class=\"keyword\">while</span> lo &lt; hi:</span><br><span class=\"line\">            lo += <span class=\"number\">1</span></span><br><span class=\"line\">            hi = max(hi, last[S[lo]])</span><br><span class=\"line\">        ans.append(hi-start+<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：这个判断条件没有想到，其实只要和最后索引相同，就可以添加一段了。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">partitionLabels</span><span class=\"params\">(self, S: str)</span> -&gt; List[int]:</span></span><br><span class=\"line\">    last = &#123;c: i <span class=\"keyword\">for</span> i, c <span class=\"keyword\">in</span> enumerate(S)&#125;</span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    lo = hi = <span class=\"number\">0</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, c <span class=\"keyword\">in</span> enumerate(S):</span><br><span class=\"line\">        hi = max(hi, last[c])</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == hi:</span><br><span class=\"line\">            ans.append(hi-lo+<span class=\"number\">1</span>)</span><br><span class=\"line\">            lo = i + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：stefan有比较直观的方法。时间复杂度略高</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">partitionLabels</span><span class=\"params\">(self, S: str)</span> -&gt; List[int]:</span></span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> S:</span><br><span class=\"line\">        i = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> set(S[:i]) &amp; set(S[i:]):</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">        ans.append(i)</span><br><span class=\"line\">        S = S[i:]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"621-Task-Scheduler\"><a href=\"#621-Task-Scheduler\" class=\"headerlink\" title=\"621. Task Scheduler\"></a>621. Task Scheduler</h3><h4 id=\"每两个相同任务之间需要有n个时间，不足则需要闲置，问最少的任务调度完成时间是多少。原题\"><a href=\"#每两个相同任务之间需要有n个时间，不足则需要闲置，问最少的任务调度完成时间是多少。原题\" class=\"headerlink\" title=\"每两个相同任务之间需要有n个时间，不足则需要闲置，问最少的任务调度完成时间是多少。原题\"></a>每两个相同任务之间需要有n个时间，不足则需要闲置，问最少的任务调度完成时间是多少。<a href=\"https://leetcode.com/problems/task-scheduler/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: tasks &#x3D; [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n &#x3D; 2</span><br><span class=\"line\">Output: 8</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">A -&gt; B -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; A -&gt; B</span><br><span class=\"line\">There is at least 2 units of time between any two same tasks.</span><br></pre></td></tr></table></figure>\n<p>方法一：使用堆。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">leastInterval</span><span class=\"params\">(self, tasks: List[str], n: int)</span> -&gt; int:</span></span><br><span class=\"line\">    c = Counter(tasks).most_common()</span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    c = [(-b, a) <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> c]</span><br><span class=\"line\">    heapq.heapify(c)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> c:</span><br><span class=\"line\">        tmp = [heapq.heappop(c)]</span><br><span class=\"line\">        k = n</span><br><span class=\"line\">        <span class=\"keyword\">while</span> k <span class=\"keyword\">and</span> c:</span><br><span class=\"line\">            tmp.append(heapq.heappop(c))</span><br><span class=\"line\">            k -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> t, l <span class=\"keyword\">in</span> tmp:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> -t &gt; <span class=\"number\">1</span>:</span><br><span class=\"line\">                heapq.heappush(c, (t+<span class=\"number\">1</span>, l))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> c:</span><br><span class=\"line\">            ans += k</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans + len(tasks)</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：构造一个<code>M*(n+1)</code>的矩阵（最后一行可能不满），将最多的任务排在每一列中。Mct表示最多的任务有多少个。那么总时间为<br><br><code>(M-1)(n+1)+Mct</code>。</font>\n\n<img src=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E8%B4%AA%E5%BF%83%E7%AF%87%EF%BC%89greedy/162_1.png\" class>\n<img src=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E8%B4%AA%E5%BF%83%E7%AF%87%EF%BC%89greedy/162_2.png\" class>\n<p>如果还有任务没有放置，该怎么办？这时只要增加宽度，对于CPU来说，相当于没有空闲时间，一直在满负载运行。</p>\n<img src=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E8%B4%AA%E5%BF%83%E7%AF%87%EF%BC%89greedy/162_3.png\" class>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">leastInterval</span><span class=\"params\">(self, tasks: List[str], N: int)</span> -&gt; int:</span></span><br><span class=\"line\">    task_counts = list(collections.Counter(tasks).values())</span><br><span class=\"line\">    M = max(task_counts)</span><br><span class=\"line\">    Mct = task_counts.count(M)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(len(tasks), (M - <span class=\"number\">1</span>) * (N + <span class=\"number\">1</span>) + Mct)</span><br></pre></td></tr></table></figure>\n<h3 id=\"1536-Minimum-Swaps-to-Arrange-a-Binary-Grid\"><a href=\"#1536-Minimum-Swaps-to-Arrange-a-Binary-Grid\" class=\"headerlink\" title=\"1536. Minimum Swaps to Arrange a Binary Grid\"></a>1536. Minimum Swaps to Arrange a Binary Grid</h3><h4 id=\"二维矩阵，每次换相邻的2行，最小步数使左上右下的对象线上方全是0-原题\"><a href=\"#二维矩阵，每次换相邻的2行，最小步数使左上右下的对象线上方全是0-原题\" class=\"headerlink\" title=\"二维矩阵，每次换相邻的2行，最小步数使左上右下的对象线上方全是0.原题\"></a>二维矩阵，每次换相邻的2行，最小步数使左上右下的对象线上方全是0.<a href=\"https://leetcode.com/problems/minimum-swaps-to-arrange-a-binary-grid/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：贪心。曾经做过一道类似的题，是每次变换十字形，然后最后变成全是0，那道题用了转换的方式，将数组转换成了一个二维数字。受到了那题的影响，比赛时想的是BFS的方法，所以最后超时了。为什么贪心的方法可行，因为每行所需的结尾0的个数是越来越少的，所以每次将所满足的行移到最上，下面的行需要的个数不会超过此行。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minSwaps</span><span class=\"params\">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    n = len(grid)</span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    tail_zero = [len(list(itertools.takewhile(<span class=\"keyword\">lambda</span> x: x==<span class=\"number\">0</span>, row[::<span class=\"number\">-1</span>]))) </span><br><span class=\"line\">                 <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> grid]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i, n):</span><br><span class=\"line\">            tail_zero[i], tail_zero[j] = tail_zero[j], tail_zero[i]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> tail_zero[i] &gt;= n-i<span class=\"number\">-1</span>:</span><br><span class=\"line\">                ans += j - i</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"435-Non-overlapping-Intervals\"><a href=\"#435-Non-overlapping-Intervals\" class=\"headerlink\" title=\"435. Non-overlapping Intervals\"></a>435. Non-overlapping Intervals</h3><h4 id=\"删除最少的段，使剩余的不重复。原题\"><a href=\"#删除最少的段，使剩余的不重复。原题\" class=\"headerlink\" title=\"删除最少的段，使剩余的不重复。原题\"></a>删除最少的段，使剩余的不重复。<a href=\"https://leetcode.com/problems/non-overlapping-intervals/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [[1,2],[2,3],[3,4],[1,3]]</span><br><span class=\"line\">Output: 1</span><br><span class=\"line\">Explanation: [1,3] can be removed and the rest of intervals are non-overlapping.</span><br></pre></td></tr></table></figure>\n<p>方法一：排序。一开始没有加key，为什么是这样的条件呢，因为需要每次选取最小的end，才能保证容纳更多的段。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">eraseOverlapIntervals</span><span class=\"params\">(self, intervals: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    intervals.sort(key=<span class=\"keyword\">lambda</span> x: x[<span class=\"number\">1</span>])</span><br><span class=\"line\">    end, ans = float(<span class=\"string\">'-inf'</span>), <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> s, e <span class=\"keyword\">in</span> intervals:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> s &lt; end:</span><br><span class=\"line\">            ans += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            end = e</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"134-Gas-Station\"><a href=\"#134-Gas-Station\" class=\"headerlink\" title=\"134. Gas Station\"></a>134. Gas Station</h3><h4 id=\"说有这么一个加油站，每个加油站能加gas-i-的油量，走到下一个站需要花费cost-i-的油量，这些加油站围绕成一个圈，只有从一个站走才能顺时针走完一圈，问这个站的索引是多少，如果没有，返回-1。原题\"><a href=\"#说有这么一个加油站，每个加油站能加gas-i-的油量，走到下一个站需要花费cost-i-的油量，这些加油站围绕成一个圈，只有从一个站走才能顺时针走完一圈，问这个站的索引是多少，如果没有，返回-1。原题\" class=\"headerlink\" title=\"说有这么一个加油站，每个加油站能加gas[i]的油量，走到下一个站需要花费cost[i]的油量，这些加油站围绕成一个圈，只有从一个站走才能顺时针走完一圈，问这个站的索引是多少，如果没有，返回-1。原题\"></a>说有这么一个加油站，每个加油站能加gas[i]的油量，走到下一个站需要花费cost[i]的油量，这些加油站围绕成一个圈，只有从一个站走才能顺时针走完一圈，问这个站的索引是多少，如果没有，返回-1。<a href=\"https://leetcode.com/problems/gas-station/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: </span><br><span class=\"line\">gas  &#x3D; [1,2,3,4,5]</span><br><span class=\"line\">cost &#x3D; [3,4,5,1,2]</span><br><span class=\"line\"></span><br><span class=\"line\">Output: 3</span><br><span class=\"line\"></span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank &#x3D; 0 + 4 &#x3D; 4</span><br><span class=\"line\">Travel to station 4. Your tank &#x3D; 4 - 1 + 5 &#x3D; 8</span><br><span class=\"line\">Travel to station 0. Your tank &#x3D; 8 - 2 + 1 &#x3D; 7</span><br><span class=\"line\">Travel to station 1. Your tank &#x3D; 7 - 3 + 2 &#x3D; 6</span><br><span class=\"line\">Travel to station 2. Your tank &#x3D; 6 - 4 + 3 &#x3D; 5</span><br><span class=\"line\">Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.</span><br><span class=\"line\">Therefore, return 3 as the starting index.</span><br></pre></td></tr></table></figure>\n<p>方法一：首次ac的方法。找到油量消耗最多的点，然后让其最后经过那里。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">canCompleteCircuit</span><span class=\"params\">(self, gas: List[int], cost: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    diff = [a-b <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> zip(gas, cost)]</span><br><span class=\"line\">    acc = list(itertools.accumulate(diff))</span><br><span class=\"line\">    <span class=\"keyword\">if</span> sum(diff) &lt; <span class=\"number\">0</span>: <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    ans = acc.index(min(acc)) + <span class=\"number\">1</span> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans <span class=\"keyword\">if</span> ans &lt; len(gas) <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：这个方法遍历一次，one-pass，想想原理其实一样。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">canCompleteCircuit</span><span class=\"params\">(self, gas: List[int], cost: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    gas_left = gas_needed = start = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, (g, c) <span class=\"keyword\">in</span> enumerate(zip(gas, cost)):</span><br><span class=\"line\">        gas_left += g - c</span><br><span class=\"line\">        <span class=\"keyword\">if</span> gas_left &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            gas_needed -= gas_left</span><br><span class=\"line\">            start = i + <span class=\"number\">1</span></span><br><span class=\"line\">            gas_left = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> start <span class=\"keyword\">if</span> gas_left &gt;= gas_needed <span class=\"keyword\">else</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1558-Minimum-Numbers-of-Function-Calls-to-Make-Target-Array\"><a href=\"#1558-Minimum-Numbers-of-Function-Calls-to-Make-Target-Array\" class=\"headerlink\" title=\"1558. Minimum Numbers of Function Calls to Make Target Array\"></a>1558. Minimum Numbers of Function Calls to Make Target Array</h3><h4 id=\"最小步骤能将全是0的数组变为目标数组。每步可以选择一个元素-1，或者所有元素-2。原题\"><a href=\"#最小步骤能将全是0的数组变为目标数组。每步可以选择一个元素-1，或者所有元素-2。原题\" class=\"headerlink\" title=\"最小步骤能将全是0的数组变为目标数组。每步可以选择一个元素+1，或者所有元素*2。原题\"></a>最小步骤能将全是0的数组变为目标数组。每步可以选择一个元素+1，或者所有元素*2。<a href=\"https://leetcode.com/problems/minimum-numbers-of-function-calls-to-make-target-array/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [1,5]</span><br><span class=\"line\">Output: 5</span><br><span class=\"line\">Explanation: Increment by 1 (second element): [0, 0] to get [0, 1] (1 operation).</span><br><span class=\"line\">Double all the elements: [0, 1] -&gt; [0, 2] -&gt; [0, 4] (2 operations).</span><br><span class=\"line\">Increment by 1 (both elements)  [0, 4] -&gt; [1, 4] -&gt; [1, 5] (2 operations).</span><br><span class=\"line\">Total of operations: 1 + 2 + 2 &#x3D; 5.</span><br></pre></td></tr></table></figure>\n<p>方法一：比赛时想到了这个方法，从后往前算，然后尽量/2，但是感觉会超时，所以没有提交。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minOperations</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    d = nums.index(max(nums))</span><br><span class=\"line\">    </span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(nums)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i]&amp; <span class=\"number\">1</span> == <span class=\"number\">1</span>:</span><br><span class=\"line\">                nums[i] -= <span class=\"number\">1</span></span><br><span class=\"line\">                ans += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[d] == <span class=\"number\">0</span>: <span class=\"keyword\">break</span></span><br><span class=\"line\">        nums = [n//<span class=\"number\">2</span> <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> nums]</span><br><span class=\"line\">        ans += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"comment\"># print(nums, ans)</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：这个方法差一点想出来，没想到用二进制时可以看到规律，/2的操作可以被共享，这点我也想到了，其实是最大数的二进制长度-1，而-1的操作就是每个数字有多少个1，这点没有想到。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minOperations</span><span class=\"params\">(self, A: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(bin(a).count(<span class=\"string\">'1'</span>) <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> A) + len(format(max(A), <span class=\"string\">'b'</span>)) - <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1568-Minimum-Number-of-Days-to-Disconnect-Island\"><a href=\"#1568-Minimum-Number-of-Days-to-Disconnect-Island\" class=\"headerlink\" title=\"1568. Minimum Number of Days to Disconnect Island\"></a>1568. Minimum Number of Days to Disconnect Island</h3><h4 id=\"把刚好存在一个岛屿变成2个或没有，最少需要几步。每步可以沉没一个格子。原题\"><a href=\"#把刚好存在一个岛屿变成2个或没有，最少需要几步。每步可以沉没一个格子。原题\" class=\"headerlink\" title=\"把刚好存在一个岛屿变成2个或没有，最少需要几步。每步可以沉没一个格子。原题\"></a>把刚好存在一个岛屿变成2个或没有，最少需要几步。每步可以沉没一个格子。<a href=\"https://leetcode.com/problems/minimum-number-of-days-to-disconnect-island/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: grid &#x3D; [[0,1,1,0],[0,1,1,0],[0,0,0,0]]</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: We need at least 2 days to get a disconnected grid.</span><br><span class=\"line\">Change land grid[1][1] and grid[0][2] to water and get 2 disconnected island.</span><br></pre></td></tr></table></figure>\n<p>方法一：这题需要想明白一件事，对于任意的岛屿，我找一个角沉没它旁边两个，就能将其变成一个单独的岛屿。那么也就是说 最多需要2步就行。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minDays</span><span class=\"params\">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    m, n = len(grid), len(grid[<span class=\"number\">0</span>])</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">count</span><span class=\"params\">(g)</span>:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sink</span><span class=\"params\">(i, j)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=i&lt;m <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=j&lt;n <span class=\"keyword\">and</span> g[i][j]:</span><br><span class=\"line\">                g[i][j] = <span class=\"number\">0</span></span><br><span class=\"line\">                list(map(sink, (i, i, i+<span class=\"number\">1</span>, i<span class=\"number\">-1</span>), (j+<span class=\"number\">1</span>, j<span class=\"number\">-1</span>, j, j)))        </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum(sink(i, j) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m) <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n))</span><br><span class=\"line\">    </span><br><span class=\"line\">    cnt_g = count(copy.deepcopy(grid))</span><br><span class=\"line\">    <span class=\"keyword\">if</span> cnt_g == <span class=\"number\">0</span> <span class=\"keyword\">or</span> cnt_g &gt; <span class=\"number\">1</span>: <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            tmp_g = copy.deepcopy(grid)</span><br><span class=\"line\">            tmp_g[i][j] = <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> count(tmp_g)!=<span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<p>方法二：不用深拷贝，用集合判断点是否重复。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minDays</span><span class=\"params\">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    m, n = len(grid), len(grid[<span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    seen = set()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">count</span><span class=\"params\">(g)</span>:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sink</span><span class=\"params\">(i, j)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=i&lt;m <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=j&lt;n <span class=\"keyword\">and</span> (i, j) <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> seen <span class=\"keyword\">and</span> g[i][j]:</span><br><span class=\"line\">                seen.add((i, j))</span><br><span class=\"line\">                list(map(sink, (i, i, i+<span class=\"number\">1</span>, i<span class=\"number\">-1</span>), (j+<span class=\"number\">1</span>, j<span class=\"number\">-1</span>, j, j)))        </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum(sink(i, j) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m) <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n))</span><br><span class=\"line\">    </span><br><span class=\"line\">    cnt_g = count(grid)</span><br><span class=\"line\">    seen.clear()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> cnt_g == <span class=\"number\">0</span> <span class=\"keyword\">or</span> cnt_g &gt; <span class=\"number\">1</span>: <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> grid[i][j]:</span><br><span class=\"line\">                grid[i][j] = <span class=\"number\">0</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> count(grid)!=<span class=\"number\">1</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">                grid[i][j] = <span class=\"number\">1</span></span><br><span class=\"line\">                seen.clear()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1567-Maximum-Length-of-Subarray-With-Positive-Product\"><a href=\"#1567-Maximum-Length-of-Subarray-With-Positive-Product\" class=\"headerlink\" title=\"1567. Maximum Length of Subarray With Positive Product\"></a>1567. Maximum Length of Subarray With Positive Product</h3><h4 id=\"最长的子数组累乘为正数。原题\"><a href=\"#最长的子数组累乘为正数。原题\" class=\"headerlink\" title=\"最长的子数组累乘为正数。原题\"></a>最长的子数组累乘为正数。<a href=\"https://leetcode.com/problems/maximum-length-of-subarray-with-positive-product/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [1,-2,-3,4]</span><br><span class=\"line\">Output: 4</span><br><span class=\"line\">Explanation: The array nums already has a positive product of 24.</span><br><span class=\"line\">Input: nums &#x3D; [0,1,-2,-3,-4]</span><br><span class=\"line\">Output: 3</span><br></pre></td></tr></table></figure>\n<p>方法一：比赛时的方法。这题作为竞赛第二题有点稍难，但还是完成了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getMaxLen</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"comment\"># [1, 0, -2, 4, 3, 1]</span></span><br><span class=\"line\">    start = ans = <span class=\"number\">0</span></span><br><span class=\"line\">    flag = <span class=\"number\">1</span></span><br><span class=\"line\">    q = collections.deque()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> end <span class=\"keyword\">in</span> range(len(nums)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[end] == <span class=\"number\">0</span>:</span><br><span class=\"line\">            start = end+<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> flag:</span><br><span class=\"line\">                ans = max(ans, end-start)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                ans = max(ans, end-q[<span class=\"number\">0</span>]<span class=\"number\">-1</span>)</span><br><span class=\"line\">            q.clear()</span><br><span class=\"line\">            flag = <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> nums[end] &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">pass</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            q.append(end)</span><br><span class=\"line\">            flag ^= <span class=\"number\">1</span></span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">if</span> flag:</span><br><span class=\"line\">            ans = max(ans, end-start+<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            ans = max(ans, end-q[<span class=\"number\">0</span>])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法二：0这个元素不是很好判断，所以先将数组以0分割。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getMaxLen</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    trip_zeros = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> num:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> trip_zeros: trip_zeros[<span class=\"number\">-1</span>].append(num)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>: trip_zeros.append([num])</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            trip_zeros.append([])</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">count</span><span class=\"params\">(arr)</span>:</span></span><br><span class=\"line\">        start = ans = <span class=\"number\">0</span></span><br><span class=\"line\">        left_neg = <span class=\"literal\">None</span></span><br><span class=\"line\">        pos = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> end <span class=\"keyword\">in</span> range(len(arr)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> arr[end] &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> left_neg <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">                    left_neg = end</span><br><span class=\"line\">                pos ^= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> pos:</span><br><span class=\"line\">                ans = max(ans, end-start+<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                ans = max(ans, end-left_neg)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(map(count, trip_zeros))</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：dp方法。这个方法有用，有一道dp的类似题，152号题。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getMaxLen</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    n = len(nums)</span><br><span class=\"line\">    pos, neg = [<span class=\"number\">0</span>] * n, [<span class=\"number\">0</span>] * n</span><br><span class=\"line\">    <span class=\"keyword\">if</span> nums[<span class=\"number\">0</span>] &gt; <span class=\"number\">0</span>: pos[<span class=\"number\">0</span>] = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> nums[<span class=\"number\">0</span>] &lt; <span class=\"number\">0</span>: neg[<span class=\"number\">0</span>] = <span class=\"number\">1</span></span><br><span class=\"line\">    ans = pos[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[i] &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            pos[i] = <span class=\"number\">1</span> + pos[i - <span class=\"number\">1</span>]</span><br><span class=\"line\">            neg[i] = (<span class=\"number\">1</span> + neg[i - <span class=\"number\">1</span>]) * (neg[i - <span class=\"number\">1</span>] != <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> nums[i] &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            pos[i] = (<span class=\"number\">1</span> + neg[i - <span class=\"number\">1</span>]) * (neg[i - <span class=\"number\">1</span>] != <span class=\"number\">0</span>)</span><br><span class=\"line\">            neg[i] = <span class=\"number\">1</span> + pos[i - <span class=\"number\">1</span>]</span><br><span class=\"line\">        ans = max(ans, pos[i])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"881-Boats-to-Save-People\"><a href=\"#881-Boats-to-Save-People\" class=\"headerlink\" title=\"881. Boats to Save People\"></a>881. Boats to Save People</h3><h4 id=\"最少需要多少小船救人。小船限重为limit，最多能装俩人。根据人的重量，最少需要多少小船。原题\"><a href=\"#最少需要多少小船救人。小船限重为limit，最多能装俩人。根据人的重量，最少需要多少小船。原题\" class=\"headerlink\" title=\"最少需要多少小船救人。小船限重为limit，最多能装俩人。根据人的重量，最少需要多少小船。原题\"></a>最少需要多少小船救人。小船限重为limit，最多能装俩人。根据人的重量，最少需要多少小船。<a href=\"https://leetcode.com/problems/boats-to-save-people/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: people &#x3D; [3,2,2,1], limit &#x3D; 3</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: 3 boats (1, 2), (2) and (3)</span><br></pre></td></tr></table></figure>\n<p>方法一：抱着超时的心态提交，居然ac了。但是太慢了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numRescueBoats</span><span class=\"params\">(self, people: List[int], limit: int)</span> -&gt; int:</span></span><br><span class=\"line\">    c = Counter(people)</span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, limit+<span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">while</span> c[i]&gt;<span class=\"number\">0</span>:</span><br><span class=\"line\">            c[i] -= <span class=\"number\">1</span></span><br><span class=\"line\">            ans += <span class=\"number\">1</span></span><br><span class=\"line\">            p = limit - i</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(p, i<span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> c[j]:</span><br><span class=\"line\">                    c[j] -= <span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：要从肥的人考虑，这样简单一些。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numRescueBoats</span><span class=\"params\">(self, people: List[int], limit: int)</span> -&gt; int:</span></span><br><span class=\"line\">    q = collections.deque(sorted(people, reverse=<span class=\"literal\">True</span>))</span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> q:</span><br><span class=\"line\">        fat = q.popleft()</span><br><span class=\"line\">        ans += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> q <span class=\"keyword\">and</span> q[<span class=\"number\">-1</span>] + fat &lt;= limit:</span><br><span class=\"line\">            q.pop()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法三：用指针。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numRescueBoats</span><span class=\"params\">(self, p: List[int], limit: int)</span> -&gt; int:</span></span><br><span class=\"line\">    p.sort()</span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    i, j = <span class=\"number\">0</span>, len(p)<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> i &lt;= j:</span><br><span class=\"line\">        fat = p[j]</span><br><span class=\"line\">        j -= <span class=\"number\">1</span></span><br><span class=\"line\">        ans += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> fat+p[i] &lt;= limit:</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法四：Lee的方法，用i表示Ans。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numRescueBoats</span><span class=\"params\">(self, p: List[int], limit: int)</span> -&gt; int:</span></span><br><span class=\"line\">    p.sort(reverse=<span class=\"literal\">True</span>)</span><br><span class=\"line\">    i, j = <span class=\"number\">0</span>, len(p)<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> i &lt;= j:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> p[j]+p[i] &lt;= limit:</span><br><span class=\"line\">            j -= <span class=\"number\">1</span></span><br><span class=\"line\">        i += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> i</span><br></pre></td></tr></table></figure>\n<h3 id=\"1405-Longest-Happy-String\"><a href=\"#1405-Longest-Happy-String\" class=\"headerlink\" title=\"1405. Longest Happy String\"></a>1405. Longest Happy String</h3><h4 id=\"最长的欢乐字符串，有’abc’3个字符组成，并且不存在’aaa’这种三连的情况。给定每个字符的个数，问最长可以生成多长的这样的字符串。原题\"><a href=\"#最长的欢乐字符串，有’abc’3个字符组成，并且不存在’aaa’这种三连的情况。给定每个字符的个数，问最长可以生成多长的这样的字符串。原题\" class=\"headerlink\" title=\"最长的欢乐字符串，有’abc’3个字符组成，并且不存在’aaa’这种三连的情况。给定每个字符的个数，问最长可以生成多长的这样的字符串。原题\"></a>最长的欢乐字符串，有’abc’3个字符组成，并且不存在’aaa’这种三连的情况。给定每个字符的个数，问最长可以生成多长的这样的字符串。<a href=\"https://leetcode.com/problems/longest-happy-string/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: a &#x3D; 1, b &#x3D; 1, c &#x3D; 7</span><br><span class=\"line\">Output: &quot;ccaccbcc&quot;</span><br><span class=\"line\">Explanation: &quot;ccbccacc&quot; would also be a correct answer.</span><br></pre></td></tr></table></figure>\n<p>方法一：用最大堆实现，注意这里选择第二多元素时要添加一个字符，因为有时候第二个字符可能不够分割。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestDiverseString</span><span class=\"params\">(self, a: int, b: int, c: int)</span> -&gt; str:</span></span><br><span class=\"line\">    ans = <span class=\"string\">''</span></span><br><span class=\"line\">    lt = [(-a, <span class=\"string\">'a'</span>), (-b, <span class=\"string\">'b'</span>), (-c, <span class=\"string\">'c'</span>)]</span><br><span class=\"line\">    heapq.heapify(lt)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> lt:</span><br><span class=\"line\">        max_d, char = heapq.heappop(lt)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ans[<span class=\"number\">-2</span>:]==char*<span class=\"number\">2</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> lt:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            snd_d, char2 = heapq.heappop(lt)</span><br><span class=\"line\">            ans += char2*min(-snd_d, <span class=\"number\">1</span>)</span><br><span class=\"line\">            snd_d += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> snd_d &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                heapq.heappush(lt, (snd_d, char2))</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            ans += char*min(-max_d, <span class=\"number\">2</span>)</span><br><span class=\"line\">            max_d += <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> max_d &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            heapq.heappush(lt, (max_d, char))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"870-Advantage-Shuffle\"><a href=\"#870-Advantage-Shuffle\" class=\"headerlink\" title=\"870. Advantage Shuffle\"></a>870. Advantage Shuffle</h3><h4 id=\"将A重新排序，使得对应位置-gt-B的数尽可能地多。原题\"><a href=\"#将A重新排序，使得对应位置-gt-B的数尽可能地多。原题\" class=\"headerlink\" title=\"将A重新排序，使得对应位置&gt;B的数尽可能地多。原题\"></a>将A重新排序，使得对应位置&gt;B的数尽可能地多。<a href=\"https://leetcode.com/problems/advantage-shuffle/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: A &#x3D; [2,7,11,15], B &#x3D; [1,10,4,11]</span><br><span class=\"line\">Output: [2,11,7,15]</span><br></pre></td></tr></table></figure>\n<p>方法一：很直观的贪心算法。将AB排序。每次拿出最大的和B最大的比，如果比不过，就拿最小的顶上。类似于田忌赛马。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">advantageCount</span><span class=\"params\">(self, A: List[int], B: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    q = collections.deque(sorted(A))</span><br><span class=\"line\">    ans = [<span class=\"number\">0</span>] * len(A)</span><br><span class=\"line\">    B = reversed(sorted((b, i) <span class=\"keyword\">for</span> i, b <span class=\"keyword\">in</span> enumerate(B)))</span><br><span class=\"line\">    <span class=\"keyword\">for</span> b, i <span class=\"keyword\">in</span> B:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> q[<span class=\"number\">-1</span>] &lt;= b:</span><br><span class=\"line\">            ans[i] = q.popleft()</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            ans[i] = q.pop()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法二：这个方法很新颖，把能赢的位置放到take中。然后A会剩下一部分，这部分顺序已经无所谓了，所以当take不到时，就从A随便返回一个就行了</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">advantageCount</span><span class=\"params\">(self, A: List[int], B: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    A.sort()</span><br><span class=\"line\">    take = collections.defaultdict(list)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> sorted(B, reverse=<span class=\"literal\">True</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> b &lt; A[<span class=\"number\">-1</span>]: take[b].append(A.pop())</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [(take[b] <span class=\"keyword\">or</span> A).pop() <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> B]</span><br></pre></td></tr></table></figure>\n<h3 id=\"861-Score-After-Flipping-Matrix\"><a href=\"#861-Score-After-Flipping-Matrix\" class=\"headerlink\" title=\"861. Score After Flipping Matrix\"></a>861. Score After Flipping Matrix</h3><h4 id=\"一个二维矩阵，可以按行，列翻转，问最大每行和是多少。原题\"><a href=\"#一个二维矩阵，可以按行，列翻转，问最大每行和是多少。原题\" class=\"headerlink\" title=\"一个二维矩阵，可以按行，列翻转，问最大每行和是多少。原题\"></a>一个二维矩阵，可以按行，列翻转，问最大每行和是多少。<a href=\"https://leetcode.com/problems/score-after-flipping-matrix/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [[0,0,1,1],[1,0,1,0],[1,1,0,0]]</span><br><span class=\"line\">Output: 39</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">Toggled to [[1,1,1,1],[1,0,0,1],[1,1,1,1]].</span><br><span class=\"line\">0b1111 + 0b1001 + 0b1111 &#x3D; 15 + 9 + 15 &#x3D; 39</span><br></pre></td></tr></table></figure>\n<p>方法一：贪心，首先保证行首位是1，然后列翻转时保证多余一半1.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">matrixScore</span><span class=\"params\">(self, A: <span class=\"string\">'List[List[int]]'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    m, n = len(A), len(A[<span class=\"number\">0</span>])</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> A[i][<span class=\"number\">0</span>] == <span class=\"number\">0</span>:</span><br><span class=\"line\">            A[i] = [A[i][j]^<span class=\"number\">1</span> <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, cols <span class=\"keyword\">in</span> enumerate(list(zip(*A))[::<span class=\"number\">-1</span>]):</span><br><span class=\"line\">        ans += <span class=\"number\">2</span>**i * max(sum(cols), m-sum(cols))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：Lee215的方法。首先保证行首是1，但是并没有实际翻过来，后序通过跟行首比较，判断翻过后的值。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">matrixScore</span><span class=\"params\">(self, A: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    M, N = len(A), len(A[<span class=\"number\">0</span>])</span><br><span class=\"line\">    ans = (<span class=\"number\">1</span> &lt;&lt; N<span class=\"number\">-1</span>) * M</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, N):</span><br><span class=\"line\">        cur = sum(A[i][j]==A[i][<span class=\"number\">0</span>] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(M))</span><br><span class=\"line\">        ans += max(cur, M-cur) * (<span class=\"number\">1</span> &lt;&lt; N<span class=\"number\">-1</span>-j)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"452-Minimum-Number-of-Arrows-to-Burst-Balloons\"><a href=\"#452-Minimum-Number-of-Arrows-to-Burst-Balloons\" class=\"headerlink\" title=\"452. Minimum Number of Arrows to Burst Balloons\"></a><a href=\"https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\" target=\"_blank\" rel=\"noopener\">452. Minimum Number of Arrows to Burst Balloons</a></h3><h4 id=\"有很多个气球绑在了水平线上，给了这些气球的start-end表示和水平线相交的点。问最少需要多少个飞镖才能将所有气球扎坏。\"><a href=\"#有很多个气球绑在了水平线上，给了这些气球的start-end表示和水平线相交的点。问最少需要多少个飞镖才能将所有气球扎坏。\" class=\"headerlink\" title=\"有很多个气球绑在了水平线上，给了这些气球的start, end表示和水平线相交的点。问最少需要多少个飞镖才能将所有气球扎坏。\"></a>有很多个气球绑在了水平线上，给了这些气球的start, end表示和水平线相交的点。问最少需要多少个飞镖才能将所有气球扎坏。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">[[10,16], [2,8], [1,6], [7,12]]</span><br><span class=\"line\"></span><br><span class=\"line\">Output:</span><br><span class=\"line\">2</span><br><span class=\"line\"></span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">One way is to shoot one arrow for example at x &#x3D; 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x &#x3D; 11 (bursting the other two balloons).</span><br></pre></td></tr></table></figure>\n<p>方法一：贪心法，尽量扎多点。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findMinArrowShots</span><span class=\"params\">(self, points: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    points.sort(key=<span class=\"keyword\">lambda</span> x: x[<span class=\"number\">1</span>], reverse=<span class=\"literal\">True</span>)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> points:</span><br><span class=\"line\">        ans += <span class=\"number\">1</span></span><br><span class=\"line\">        s, e = points.pop()</span><br><span class=\"line\">        <span class=\"keyword\">while</span> points <span class=\"keyword\">and</span> points[<span class=\"number\">-1</span>][<span class=\"number\">0</span>]&lt;=e:</span><br><span class=\"line\">            points.pop()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：for循环也可以。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findMinArrowShots</span><span class=\"params\">(self, points: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    ans, e = <span class=\"number\">0</span>, float(<span class=\"string\">'-inf'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> start, end <span class=\"keyword\">in</span> sorted(points, key=itemgetter(<span class=\"number\">1</span>)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> start &gt; e:</span><br><span class=\"line\">            ans += <span class=\"number\">1</span></span><br><span class=\"line\">            e = end</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"1589-Maximum-Sum-Obtained-of-Any-Permutation\"><a href=\"#1589-Maximum-Sum-Obtained-of-Any-Permutation\" class=\"headerlink\" title=\"1589. Maximum Sum Obtained of Any Permutation\"></a><a href=\"https://leetcode.com/problems/maximum-sum-obtained-of-any-permutation/\" target=\"_blank\" rel=\"noopener\">1589. Maximum Sum Obtained of Any Permutation</a></h3><h4 id=\"说要查询某一段，进行n次查询，问将数组如何排列能使线段的总和最大。\"><a href=\"#说要查询某一段，进行n次查询，问将数组如何排列能使线段的总和最大。\" class=\"headerlink\" title=\"说要查询某一段，进行n次查询，问将数组如何排列能使线段的总和最大。\"></a>说要查询某一段，进行n次查询，问将数组如何排列能使线段的总和最大。</h4><p>方法一：这题竞赛时没做出来，心态崩了。不知道怎么构造一个对线段的计数，用Counter超时了。剩下的一小时就是拼命地构造一个不重复的线段tuple，最后也没完成。正确的思路是这样的，在线段的起点+1，结束点后一位-1，这样在累加的时候就会把这段1都算出来。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxSumRangeQuery</span><span class=\"params\">(self, nums: List[int], requests: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    n = len(nums)</span><br><span class=\"line\">    imos = [<span class=\"number\">0</span>] * (n + <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> l, r <span class=\"keyword\">in</span> requests:</span><br><span class=\"line\">        imos[l] += <span class=\"number\">1</span></span><br><span class=\"line\">        imos[r + <span class=\"number\">1</span>] -= <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">        imos[i+<span class=\"number\">1</span>] += imos[i]</span><br><span class=\"line\">    <span class=\"keyword\">del</span> imos[<span class=\"number\">-1</span>]</span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, v <span class=\"keyword\">in</span> zip(sorted(nums), sorted(imos)):</span><br><span class=\"line\">        ans += i * v</span><br><span class=\"line\">        ans %= <span class=\"number\">10</span> ** <span class=\"number\">9</span> + <span class=\"number\">7</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"1599-Maximum-Profit-of-Operating-a-Centennial-Wheel\"><a href=\"#1599-Maximum-Profit-of-Operating-a-Centennial-Wheel\" class=\"headerlink\" title=\"1599. Maximum Profit of Operating a Centennial Wheel\"></a><a href=\"https://leetcode.com/problems/maximum-profit-of-operating-a-centennial-wheel/\" target=\"_blank\" rel=\"noopener\">1599. Maximum Profit of Operating a Centennial Wheel</a></h3><h4 id=\"这题看起来很复杂，作为竞赛第二题还算可以。有这样一个摩天轮，一次只能上4个人，转一次要花费runningCost，门票boardingCost。给定一个游客时间人数队列，问最大利润时在第几轮（摩天轮转了多少圈）。\"><a href=\"#这题看起来很复杂，作为竞赛第二题还算可以。有这样一个摩天轮，一次只能上4个人，转一次要花费runningCost，门票boardingCost。给定一个游客时间人数队列，问最大利润时在第几轮（摩天轮转了多少圈）。\" class=\"headerlink\" title=\"这题看起来很复杂，作为竞赛第二题还算可以。有这样一个摩天轮，一次只能上4个人，转一次要花费runningCost，门票boardingCost。给定一个游客时间人数队列，问最大利润时在第几轮（摩天轮转了多少圈）。\"></a>这题看起来很复杂，作为竞赛第二题还算可以。有这样一个摩天轮，一次只能上4个人，转一次要花费runningCost，门票boardingCost。给定一个游客时间人数队列，问最大利润时在第几轮（摩天轮转了多少圈）。</h4><p>方法一：竞赛时的答案擦边过的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minOperationsMaxProfit</span><span class=\"params\">(self, cust: List[int], bc: int, rc: int)</span> -&gt; int:</span></span><br><span class=\"line\">    cust.reverse()</span><br><span class=\"line\">    wait, profit, t, max_p, ans = <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, float(<span class=\"string\">'-inf'</span>), <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> cust <span class=\"keyword\">or</span> wait:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cust:</span><br><span class=\"line\">            wait += cust.pop()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> wait &gt;= <span class=\"number\">4</span>:</span><br><span class=\"line\">            profit += <span class=\"number\">4</span> * bc</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            profit += wait * bc</span><br><span class=\"line\">        wait = max(<span class=\"number\">0</span>, wait<span class=\"number\">-4</span>)</span><br><span class=\"line\">        profit -= rc</span><br><span class=\"line\">        t += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> profit &gt; max_p:</span><br><span class=\"line\">            ans = t</span><br><span class=\"line\">            max_p = profit</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans <span class=\"keyword\">if</span> max_p&gt;<span class=\"number\">0</span> <span class=\"keyword\">else</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<p>方法二：实际上最后需要一个取余操作就行，不用再模拟了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minOperationsMaxProfit</span><span class=\"params\">(self, cust: List[int], bc: int, rc: int)</span> -&gt; int:</span></span><br><span class=\"line\">    ans = <span class=\"number\">-1</span></span><br><span class=\"line\">    most = profit = wait = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, c <span class=\"keyword\">in</span> enumerate(cust, <span class=\"number\">1</span>):</span><br><span class=\"line\">        wait += c</span><br><span class=\"line\">        wait -= (cur := min(<span class=\"number\">4</span>, wait))</span><br><span class=\"line\">        profit += bc*cur - rc</span><br><span class=\"line\">        <span class=\"keyword\">if</span> profit &gt; most:</span><br><span class=\"line\">            ans, most = i, profit</span><br><span class=\"line\">    q, r = divmod(wait, <span class=\"number\">4</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"number\">4</span>*bc - rc &gt; <span class=\"number\">0</span>: ans += q</span><br><span class=\"line\">    <span class=\"keyword\">if</span> r*bc - rc &gt; <span class=\"number\">0</span>: ans += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"1605-Find-Valid-Matrix-Given-Row-and-Column-Sums\"><a href=\"#1605-Find-Valid-Matrix-Given-Row-and-Column-Sums\" class=\"headerlink\" title=\"1605. Find Valid Matrix Given Row and Column Sums\"></a><a href=\"https://leetcode.com/problems/find-valid-matrix-given-row-and-column-sums/\" target=\"_blank\" rel=\"noopener\">1605. Find Valid Matrix Given Row and Column Sums</a></h3><h4 id=\"给定一个二维数组行的和与列的和，求这个二维数组，答案不唯一。\"><a href=\"#给定一个二维数组行的和与列的和，求这个二维数组，答案不唯一。\" class=\"headerlink\" title=\"给定一个二维数组行的和与列的和，求这个二维数组，答案不唯一。\"></a>给定一个二维数组行的和与列的和，求这个二维数组，答案不唯一。</h4><p>方法一：这道题比赛用回溯法写的，超时了一次，然后改为倒序勉强过了。其实可以用贪心，每次都尽量将最大的数填进去，但是并不知道怎么证明。Lee也没有给出很好的证明方式。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">restoreMatrix</span><span class=\"params\">(self, rowSum: List[int], colSum: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">    M, N = len(rowSum), len(colSum)</span><br><span class=\"line\">    g = [[<span class=\"number\">0</span>]*N <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(M)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(M):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(N):</span><br><span class=\"line\">            g[i][j] = min(rowSum[i], colSum[j])</span><br><span class=\"line\">            rowSum[i] -= g[i][j]</span><br><span class=\"line\">            colSum[j] -= g[i][j]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> g</span><br></pre></td></tr></table></figure>\n<h3 id=\"1616-Split-Two-Strings-to-Make-Palindrome\"><a href=\"#1616-Split-Two-Strings-to-Make-Palindrome\" class=\"headerlink\" title=\"1616. Split Two Strings to Make Palindrome\"></a><a href=\"https://leetcode.com/problems/split-two-strings-to-make-palindrome/\" target=\"_blank\" rel=\"noopener\">1616. Split Two Strings to Make Palindrome</a></h3><h4 id=\"从某个索引出切断两个字符串，相互拼接是否能组成回文串。\"><a href=\"#从某个索引出切断两个字符串，相互拼接是否能组成回文串。\" class=\"headerlink\" title=\"从某个索引出切断两个字符串，相互拼接是否能组成回文串。\"></a>从某个索引出切断两个字符串，相互拼接是否能组成回文串。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: a &#x3D; &quot;ulacfd&quot;, b &#x3D; &quot;jizalu&quot;</span><br><span class=\"line\">Output: true</span><br><span class=\"line\">Explaination: Split them at index 3:</span><br><span class=\"line\">aprefix &#x3D; &quot;ula&quot;, asuffix &#x3D; &quot;cfd&quot;</span><br><span class=\"line\">bprefix &#x3D; &quot;jiz&quot;, bsuffix &#x3D; &quot;alu&quot;</span><br><span class=\"line\">Then, aprefix + bsuffix &#x3D; &quot;ula&quot; + &quot;alu&quot; &#x3D; &quot;ulaalu&quot;, which is a palindrome.</span><br></pre></td></tr></table></figure>\n<p>方法一：竞赛时最后一分钟做了出来，顶着压力AC了。不过之前超时了两次，妄想用暴力法过，没有得逞。整理一下代码。以每个字符串中心找最大的回文串，然后比较相互的头尾相交。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">checkPalindromeFormation</span><span class=\"params\">(self, a: str, b: str)</span> -&gt; bool:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">max_palindrome_by_center</span><span class=\"params\">(s)</span>:</span></span><br><span class=\"line\">        n = len(s)</span><br><span class=\"line\">        l, r = (n<span class=\"number\">-1</span>)//<span class=\"number\">2</span>, n//<span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> l &gt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> s[l]==s[r]:</span><br><span class=\"line\">            l -= <span class=\"number\">1</span></span><br><span class=\"line\">            r += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> l, r</span><br><span class=\"line\">    </span><br><span class=\"line\">    i, j = max_palindrome_by_center(a)</span><br><span class=\"line\">    ans = [b[:i+<span class=\"number\">1</span>] + a[j:], a[:i+<span class=\"number\">1</span>] + b[j:]]</span><br><span class=\"line\">    i, j = max_palindrome_by_center(b)</span><br><span class=\"line\">    ans.extend([a[:i+<span class=\"number\">1</span>] + b[j:], b[:i+<span class=\"number\">1</span>] + a[j:]])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> any(s==s[::<span class=\"number\">-1</span>] <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> ans)</span><br></pre></td></tr></table></figure>\n<p>方法二：Lee的方法。从头尾找相同，判断中间是否回文。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">checkPalindromeFormation</span><span class=\"params\">(self, a: str, b: str)</span> -&gt; bool:</span></span><br><span class=\"line\">    i, j = <span class=\"number\">0</span>, len(a)<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> i&lt;j <span class=\"keyword\">and</span> a[i]==b[j]:</span><br><span class=\"line\">        i += <span class=\"number\">1</span></span><br><span class=\"line\">        j -= <span class=\"number\">1</span></span><br><span class=\"line\">    s1, s2 = a[i:j+<span class=\"number\">1</span>], b[i:j+<span class=\"number\">1</span>]</span><br><span class=\"line\">    </span><br><span class=\"line\">    i, j = <span class=\"number\">0</span>, len(a)<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> i&lt;j <span class=\"keyword\">and</span> b[i]==a[j]:</span><br><span class=\"line\">        i += <span class=\"number\">1</span></span><br><span class=\"line\">        j -= <span class=\"number\">1</span></span><br><span class=\"line\">    s3, s4 = a[i:j+<span class=\"number\">1</span>], b[i:j+<span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> any(s==s[::<span class=\"number\">-1</span>] <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> (s1, s2, s3, s4))</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">可以封装一下。这个方法确实比我的简单一点。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">checkPalindromeFormation</span><span class=\"params\">(self, a: str, b: str)</span> -&gt; bool:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_middle</span><span class=\"params\">(a, b)</span>:</span></span><br><span class=\"line\">        i, j = <span class=\"number\">0</span>, len(a)<span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i&lt;j <span class=\"keyword\">and</span> a[i]==b[j]:</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">            j -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> a[i:j+<span class=\"number\">1</span>], b[i:j+<span class=\"number\">1</span>]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> any(s==s[::<span class=\"number\">-1</span>] <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> get_middle(a, b)+get_middle(b, a))</span><br></pre></td></tr></table></figure>\n<h3 id=\"948-Bag-of-Tokens\"><a href=\"#948-Bag-of-Tokens\" class=\"headerlink\" title=\"948. Bag of Tokens\"></a><a href=\"https://leetcode.com/problems/bag-of-tokens/\" target=\"_blank\" rel=\"noopener\">948. Bag of Tokens</a></h3><h4 id=\"你的初始能量为-P，初始分数为-0，只有一包令牌。令牌的值为-token-i-，每个令牌最多只能使用一次，可能的两种使用方法如下：如果你至少有-token-i-点能量，可以将令牌置为正面朝上，失去-token-i-点能量，并得到-1-分。如果我们至少有-1-分，可以将令牌置为反面朝上，获得-token-i-点能量，并失去-1-分。在使用任意数量的令牌后，返回我们可以得到的最大分数。\"><a href=\"#你的初始能量为-P，初始分数为-0，只有一包令牌。令牌的值为-token-i-，每个令牌最多只能使用一次，可能的两种使用方法如下：如果你至少有-token-i-点能量，可以将令牌置为正面朝上，失去-token-i-点能量，并得到-1-分。如果我们至少有-1-分，可以将令牌置为反面朝上，获得-token-i-点能量，并失去-1-分。在使用任意数量的令牌后，返回我们可以得到的最大分数。\" class=\"headerlink\" title=\"你的初始能量为 P，初始分数为 0，只有一包令牌。令牌的值为 token[i]，每个令牌最多只能使用一次，可能的两种使用方法如下：如果你至少有 token[i] 点能量，可以将令牌置为正面朝上，失去 token[i] 点能量，并得到 1 分。如果我们至少有 1 分，可以将令牌置为反面朝上，获得 token[i] 点能量，并失去 1 分。在使用任意数量的令牌后，返回我们可以得到的最大分数。\"></a>你的初始能量为 P，初始分数为 0，只有一包令牌。令牌的值为 token[i]，每个令牌最多只能使用一次，可能的两种使用方法如下：如果你至少有 token[i] 点能量，可以将令牌置为正面朝上，失去 token[i] 点能量，并得到 1 分。如果我们至少有 1 分，可以将令牌置为反面朝上，获得 token[i] 点能量，并失去 1 分。在使用任意数量的令牌后，返回我们可以得到的最大分数。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: tokens &#x3D; [100,200,300,400], P &#x3D; 200</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: Play the tokens in this order to get a score of 2:</span><br><span class=\"line\">1. Play the 0th token (100) face up, your power becomes 100 and score becomes 1.</span><br><span class=\"line\">2. Play the 3rd token (400) face down, your power becomes 500 and score becomes 0.</span><br><span class=\"line\">3. Play the 1st token (200) face up, your power becomes 300 and score becomes 1.</span><br><span class=\"line\">4. Play the 2nd token (300) face up, your power becomes 0 and score becomes 2.</span><br></pre></td></tr></table></figure>\n<p>方法一：双指针。很容易想到是贪心，因为分数都是一样的，以最少的能量换最多的分。10分钟AC。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bagOfTokensScore</span><span class=\"params\">(self, tokens: List[int], P: int)</span> -&gt; int:</span></span><br><span class=\"line\">    ans, cur_score, p = <span class=\"number\">0</span>, <span class=\"number\">0</span>, P</span><br><span class=\"line\">    tokens.sort()</span><br><span class=\"line\">    lo, hi = <span class=\"number\">0</span>, len(tokens)<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> lo &lt;= hi:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> tokens[lo] &lt;= p:</span><br><span class=\"line\">            p -= tokens[lo]</span><br><span class=\"line\">            lo += <span class=\"number\">1</span></span><br><span class=\"line\">            cur_score += <span class=\"number\">1</span></span><br><span class=\"line\">            ans = max(ans, cur_score)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> cur_score &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            p += tokens[hi]</span><br><span class=\"line\">            hi -= <span class=\"number\">1</span></span><br><span class=\"line\">            cur_score -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法二：Lee的写法，deque，将判断放到while 中了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bagOfTokensScore</span><span class=\"params\">(self, tokens: List[int], P: int)</span> -&gt; int:</span></span><br><span class=\"line\">    ans, cur_score = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    q = deque(sorted(tokens))</span><br><span class=\"line\">    <span class=\"keyword\">while</span> q <span class=\"keyword\">and</span> (q[<span class=\"number\">0</span>]&lt;=P <span class=\"keyword\">or</span> cur_score):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> q[<span class=\"number\">0</span>] &lt;= P:</span><br><span class=\"line\">            cur_score += <span class=\"number\">1</span></span><br><span class=\"line\">            P -= q.popleft()</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            cur_score -= <span class=\"number\">1</span></span><br><span class=\"line\">            P += q.pop()</span><br><span class=\"line\">        ans = max(ans, cur_score)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"135-Candy\"><a href=\"#135-Candy\" class=\"headerlink\" title=\"135. Candy\"></a><a href=\"https://leetcode.com/problems/candy/\" target=\"_blank\" rel=\"noopener\">135. Candy</a></h3><h4 id=\"N个学生站成一排，每个人有个比率，要求每人至少发一块糖，比率如果比挨着的两位同学大，那么糖要比他们多。问最少需要多少个糖。\"><a href=\"#N个学生站成一排，每个人有个比率，要求每人至少发一块糖，比率如果比挨着的两位同学大，那么糖要比他们多。问最少需要多少个糖。\" class=\"headerlink\" title=\"N个学生站成一排，每个人有个比率，要求每人至少发一块糖，比率如果比挨着的两位同学大，那么糖要比他们多。问最少需要多少个糖。\"></a>N个学生站成一排，每个人有个比率，要求每人至少发一块糖，比率如果比挨着的两位同学大，那么糖要比他们多。问最少需要多少个糖。</h4><p>方法一：左右遍历两次。从左向右遍历之后，保证每人比左侧大的条件，再从右向左遍历，保证每人比左侧大的条件。注意<code>13452</code>的情况，反向遍历时要去最大值。因为左侧遍历完事<code>12341</code>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">candy</span><span class=\"params\">(self, ratings: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    N = len(ratings)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> N &lt;= <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> N</span><br><span class=\"line\">    candies = [<span class=\"number\">1</span>] * N</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, N):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ratings[i] &gt; ratings[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">            candies[i] = candies[i<span class=\"number\">-1</span>] + <span class=\"number\">1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(N<span class=\"number\">-1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ratings[i] &lt; ratings[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">            candies[i<span class=\"number\">-1</span>] = max(candies[i<span class=\"number\">-1</span>], candies[i]+<span class=\"number\">1</span>)</span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(candies)</span><br></pre></td></tr></table></figure>\n<h3 id=\"646-Maximum-Length-of-Pair-Chain\"><a href=\"#646-Maximum-Length-of-Pair-Chain\" class=\"headerlink\" title=\"646. Maximum Length of Pair Chain\"></a><a href=\"https://leetcode.com/problems/maximum-length-of-pair-chain/\" target=\"_blank\" rel=\"noopener\">646. Maximum Length of Pair Chain</a></h3><h4 id=\"能组成的最长的链。和300题一样。\"><a href=\"#能组成的最长的链。和300题一样。\" class=\"headerlink\" title=\"能组成的最长的链。和300题一样。\"></a>能组成的最长的链。和300题一样。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [[1,2], [2,3], [3,4]]</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: The longest chain is [1,2] -&gt; [3,4]</span><br></pre></td></tr></table></figure>\n<p>方法一：dp, O(n^2)的暴力方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findLongestChain</span><span class=\"params\">(self, pairs: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    n = len(pairs)</span><br><span class=\"line\">    dp = [<span class=\"number\">1</span>] * (n+<span class=\"number\">1</span>)</span><br><span class=\"line\">    pairs.sort()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> pairs[i][<span class=\"number\">0</span>] &gt; pairs[j][<span class=\"number\">1</span>]:</span><br><span class=\"line\">                dp[i] = max(dp[i], dp[j]+<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pairs <span class=\"keyword\">and</span> max(dp) <span class=\"keyword\">or</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：此题优化的解法不能像300一样用二分，因为有两个维度的信息需要考虑，最优的解法是贪心。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findLongestChain</span><span class=\"params\">(self, pairs: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    ans, last = <span class=\"number\">0</span>, float(<span class=\"string\">'-inf'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> start, end <span class=\"keyword\">in</span> sorted(pairs, key=itemgetter(<span class=\"number\">1</span>)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> last &lt; start:</span><br><span class=\"line\">            ans += <span class=\"number\">1</span></span><br><span class=\"line\">            last = end</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"1647-Minimum-Deletions-to-Make-Character-Frequencies-Unique\"><a href=\"#1647-Minimum-Deletions-to-Make-Character-Frequencies-Unique\" class=\"headerlink\" title=\"1647. Minimum Deletions to Make Character Frequencies Unique\"></a><a href=\"https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/\" target=\"_blank\" rel=\"noopener\">1647. Minimum Deletions to Make Character Frequencies Unique</a></h3><h4 id=\"最少需要删除多少次字母使得每个字母的频率都不一样。\"><a href=\"#最少需要删除多少次字母使得每个字母的频率都不一样。\" class=\"headerlink\" title=\"最少需要删除多少次字母使得每个字母的频率都不一样。\"></a>最少需要删除多少次字母使得每个字母的频率都不一样。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;aaabbbcc&quot;</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: You can delete two &#39;b&#39;s resulting in the good string &quot;aaabcc&quot;.</span><br><span class=\"line\">Another way it to delete one &#39;b&#39; and one &#39;c&#39; resulting in the good string &quot;aaabbc&quot;.</span><br></pre></td></tr></table></figure>\n<p>方法一：比赛时写得比较直观的方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minDeletions</span><span class=\"params\">(self, s: str)</span> -&gt; int:</span></span><br><span class=\"line\">    c = Counter(s)</span><br><span class=\"line\">    cnt = Counter(c.values())</span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> sorted(cnt.keys()):</span><br><span class=\"line\">        <span class=\"keyword\">while</span> cnt[k] &gt; <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(k)[::<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> j == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    cnt[k] -= <span class=\"number\">1</span></span><br><span class=\"line\">                    ans += k</span><br><span class=\"line\">                <span class=\"keyword\">elif</span> cnt[j] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    cnt[k] -= <span class=\"number\">1</span></span><br><span class=\"line\">                    cnt[j] = <span class=\"number\">1</span></span><br><span class=\"line\">                    ans += k-j</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：可以用一个集合来做去重的工作。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minDeletions</span><span class=\"params\">(self, s: str)</span> -&gt; int:</span></span><br><span class=\"line\">    ans, seen = <span class=\"number\">0</span>, set()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> cnt <span class=\"keyword\">in</span> sorted(Counter(s).values(), reverse=<span class=\"literal\">True</span>):</span><br><span class=\"line\">        <span class=\"keyword\">while</span> cnt <span class=\"keyword\">in</span> seen:</span><br><span class=\"line\">            cnt -= <span class=\"number\">1</span></span><br><span class=\"line\">            ans += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> cnt: </span><br><span class=\"line\">            seen.add(cnt)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"1648-Sell-Diminishing-Valued-Colored-Balls\"><a href=\"#1648-Sell-Diminishing-Valued-Colored-Balls\" class=\"headerlink\" title=\"1648. Sell Diminishing-Valued Colored Balls\"></a><a href=\"https://leetcode.com/problems/sell-diminishing-valued-colored-balls/\" target=\"_blank\" rel=\"noopener\">1648. Sell Diminishing-Valued Colored Balls</a></h3><h4 id=\"有这么几种颜色的球，每种球有一些个数。当取出一个球的时候，分数为剩下同种颜色的球，问一共需要取orders个球，问最大的分是多少？\"><a href=\"#有这么几种颜色的球，每种球有一些个数。当取出一个球的时候，分数为剩下同种颜色的球，问一共需要取orders个球，问最大的分是多少？\" class=\"headerlink\" title=\"有这么几种颜色的球，每种球有一些个数。当取出一个球的时候，分数为剩下同种颜色的球，问一共需要取orders个球，问最大的分是多少？\"></a>有这么几种颜色的球，每种球有一些个数。当取出一个球的时候，分数为剩下同种颜色的球，问一共需要取orders个球，问最大的分是多少？</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: inventory &#x3D; [2,5], orders &#x3D; 4</span><br><span class=\"line\">Output: 14</span><br><span class=\"line\">Explanation: Sell the 1st color 1 time (2) and the 2nd color 3 times (5 + 4 + 3).</span><br><span class=\"line\">The maximum total value is 2 + 5 + 4 + 3 &#x3D; 14.</span><br></pre></td></tr></table></figure>\n<p>方法一：很容易看出是一道贪心的题，比赛时超时了一次，因为想用堆来模拟。后来想到了用数学的方式。就是尽量将所有的剩下球平均，因为越少拿球分就越少。这里用了一个动态的求平均的方式。不是最优解，700+ms，beats 30%，还有很大的优化空间。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxProfit</span><span class=\"params\">(self, inventory: List[int], orders: int)</span> -&gt; int:</span></span><br><span class=\"line\">    ans, mod = <span class=\"number\">0</span>, <span class=\"number\">10</span>**<span class=\"number\">9</span>+<span class=\"number\">7</span></span><br><span class=\"line\">    total = sum(inventory) </span><br><span class=\"line\">    inventory.sort()</span><br><span class=\"line\">    remain = total - orders</span><br><span class=\"line\">    N = len(inventory)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, d <span class=\"keyword\">in</span> enumerate(inventory):</span><br><span class=\"line\">        each = remain // (N-i)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> d &gt; each:</span><br><span class=\"line\">            ans += (each+<span class=\"number\">1</span>+d) * (d-each) // <span class=\"number\">2</span></span><br><span class=\"line\">        remain -= min(each, d)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans % mod</span><br></pre></td></tr></table></figure>\n<h3 id=\"1653-Minimum-Deletions-to-Make-String-Balanced\"><a href=\"#1653-Minimum-Deletions-to-Make-String-Balanced\" class=\"headerlink\" title=\"1653. Minimum Deletions to Make String Balanced\"></a><a href=\"https://leetcode.com/problems/minimum-deletions-to-make-string-balanced/\" target=\"_blank\" rel=\"noopener\">1653. Minimum Deletions to Make String Balanced</a></h3><h4 id=\"最少的步数可以让字符串中没有b在a前的情况。\"><a href=\"#最少的步数可以让字符串中没有b在a前的情况。\" class=\"headerlink\" title=\"最少的步数可以让字符串中没有b在a前的情况。\"></a>最少的步数可以让字符串中没有b在a前的情况。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;aababbab&quot;</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: You can either:</span><br><span class=\"line\">Delete the characters at 0-indexed positions 2 and 6 (&quot;aababbab&quot; -&gt; &quot;aaabbb&quot;), or</span><br><span class=\"line\">Delete the characters at 0-indexed positions 3 and 6 (&quot;aababbab&quot; -&gt; &quot;aabbbb&quot;).</span><br></pre></td></tr></table></figure>\n<p>方法一：比赛时想着和<code>秋叶收藏集</code>一题很像，就用了dp，也能过，不过不是最优。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minimumDeletions</span><span class=\"params\">(self, s: str)</span> -&gt; int:</span></span><br><span class=\"line\">    a, b, ab = int(s[<span class=\"number\">0</span>]!=<span class=\"string\">'a'</span>), int(s[<span class=\"number\">0</span>]!=<span class=\"string\">'b'</span>), float(<span class=\"string\">'inf'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(s)):</span><br><span class=\"line\">        cur = int(s[i]!=<span class=\"string\">'a'</span>)</span><br><span class=\"line\">        a, b, ab = a+cur, b+(cur^<span class=\"number\">1</span>), min(a, ab)+(cur^<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min(a, b, ab)</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：贪心。分为两种情况，一种将后面的a全部删掉；一种将前面的b全部删掉。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minimumDeletions</span><span class=\"params\">(self, s: str)</span> -&gt; int:</span></span><br><span class=\"line\">    cur = res = s.count(<span class=\"string\">'a'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> c == <span class=\"string\">'a'</span>:</span><br><span class=\"line\">            cur -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            cur += <span class=\"number\">1</span></span><br><span class=\"line\">        res = min(res, cur)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"1663-Smallest-String-With-A-Given-Numeric-Value\"><a href=\"#1663-Smallest-String-With-A-Given-Numeric-Value\" class=\"headerlink\" title=\"1663. Smallest String With A Given Numeric Value\"></a><a href=\"https://leetcode.com/problems/smallest-string-with-a-given-numeric-value/\" target=\"_blank\" rel=\"noopener\">1663. Smallest String With A Given Numeric Value</a></h3><h4 id=\"每个字母对应一个值，给定一个长度为n的条件，求这个条件字符总和为k的最小字典序的字符串。\"><a href=\"#每个字母对应一个值，给定一个长度为n的条件，求这个条件字符总和为k的最小字典序的字符串。\" class=\"headerlink\" title=\"每个字母对应一个值，给定一个长度为n的条件，求这个条件字符总和为k的最小字典序的字符串。\"></a>每个字母对应一个值，给定一个长度为n的条件，求这个条件字符总和为k的最小字典序的字符串。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 3, k &#x3D; 27</span><br><span class=\"line\">Output: &quot;aay&quot;</span><br><span class=\"line\">Explanation: The numeric value of the string is 1 + 1 + 25 &#x3D; 27, and it is the smallest string with such a value and length equal to 3.</span><br></pre></td></tr></table></figure>\n<p>方法一：这题我想错了一个点，z对应的是26而不是25。导致用了1个小时才提交上。周赛第一题用了44秒的好成绩都浪费掉了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getSmallestString</span><span class=\"params\">(self, n: int, k: int)</span> -&gt; str:</span></span><br><span class=\"line\">    ans = <span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n*<span class=\"number\">26</span> == k:</span><br><span class=\"line\">            ans += n * <span class=\"string\">'z'</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> k<span class=\"number\">-1</span> &lt;= (n<span class=\"number\">-1</span>)*<span class=\"number\">26</span>:</span><br><span class=\"line\">            ans += <span class=\"string\">'a'</span></span><br><span class=\"line\">            n -= <span class=\"number\">1</span></span><br><span class=\"line\">            k -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            m = k - (n<span class=\"number\">-1</span>)*<span class=\"number\">26</span></span><br><span class=\"line\">            ans += chr(ord(<span class=\"string\">'a'</span>) + m <span class=\"number\">-1</span>)</span><br><span class=\"line\">            n -= <span class=\"number\">1</span></span><br><span class=\"line\">            k -= m</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：这个思路我想到了，但是没想好代码，本质上这个字符串就是<code>aaxzzz</code>。所以用数学的思路可以直接求出。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getSmallestString</span><span class=\"params\">(self, n: int, k: int)</span> -&gt; str:</span></span><br><span class=\"line\">    num2 = (k-n) // <span class=\"number\">25</span>     </span><br><span class=\"line\">    num1 = n - num2 - <span class=\"number\">1</span></span><br><span class=\"line\">    num = k - (num1 + num2 * <span class=\"number\">26</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'a'</span> * num1 + chr(num+ord(<span class=\"string\">'a'</span>)<span class=\"number\">-1</span>) + <span class=\"string\">'z'</span> * num2</span><br></pre></td></tr></table></figure>\n<h3 id=\"1664-Ways-to-Make-a-Fair-Array\"><a href=\"#1664-Ways-to-Make-a-Fair-Array\" class=\"headerlink\" title=\"1664. Ways to Make a Fair Array\"></a><a href=\"https://leetcode.com/problems/ways-to-make-a-fair-array/\" target=\"_blank\" rel=\"noopener\">1664. Ways to Make a Fair Array</a></h3><h4 id=\"删除一个数使得数组奇数位偶数位和相等，一共有多少种删除的方法。\"><a href=\"#删除一个数使得数组奇数位偶数位和相等，一共有多少种删除的方法。\" class=\"headerlink\" title=\"删除一个数使得数组奇数位偶数位和相等，一共有多少种删除的方法。\"></a>删除<em>一个</em>数使得数组奇数位偶数位和相等，一共有多少种删除的方法。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [2,1,6,4]</span><br><span class=\"line\">Output: 1</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">Remove index 0: [1,6,4] -&gt; Even sum: 1 + 4 &#x3D; 5. Odd sum: 6. Not fair.</span><br><span class=\"line\">Remove index 1: [2,6,4] -&gt; Even sum: 2 + 4 &#x3D; 6. Odd sum: 6. Fair.</span><br><span class=\"line\">Remove index 2: [2,1,4] -&gt; Even sum: 2 + 4 &#x3D; 6. Odd sum: 1. Not fair.</span><br><span class=\"line\">Remove index 3: [2,1,6] -&gt; Even sum: 2 + 6 &#x3D; 8. Odd sum: 1. Not fair.</span><br><span class=\"line\">There is 1 index that you can remove to make nums fair.</span><br></pre></td></tr></table></figure>\n<p>方法一：前缀和，竞赛时想到了，但是没做出来，因为看错了题，忽略了删除一次这个条件。这里是Lee的写法，维持一个当前的奇偶和与右侧的奇偶和，当删除某个数后，后面的奇偶位互换。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">waysToMakeFair</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    res = <span class=\"number\">0</span></span><br><span class=\"line\">    acc, total = [<span class=\"number\">0</span>, <span class=\"number\">0</span>], [sum(nums[::<span class=\"number\">2</span>]), sum(nums[<span class=\"number\">1</span>::<span class=\"number\">2</span>])]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, num <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">        total[i%<span class=\"number\">2</span>] -= num</span><br><span class=\"line\">        res += acc[<span class=\"number\">0</span>]+total[<span class=\"number\">1</span>]==acc[<span class=\"number\">1</span>]+total[<span class=\"number\">0</span>]</span><br><span class=\"line\">        acc[i%<span class=\"number\">2</span>] += num</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"767-Reorganize-String\"><a href=\"#767-Reorganize-String\" class=\"headerlink\" title=\"767. Reorganize String\"></a><a href=\"https://leetcode.com/problems/reorganize-string/\" target=\"_blank\" rel=\"noopener\">767. Reorganize String</a></h3><h4 id=\"重排字符串使其没有相邻的两个字符使相同的。\"><a href=\"#重排字符串使其没有相邻的两个字符使相同的。\" class=\"headerlink\" title=\"重排字符串使其没有相邻的两个字符使相同的。\"></a>重排字符串使其没有相邻的两个字符使相同的。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: S &#x3D; &quot;aab&quot;</span><br><span class=\"line\">Output: &quot;aba&quot;</span><br></pre></td></tr></table></figure>\n<p>方法一：使用堆实现的。每次从堆中取一个或两个。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reorganizeString</span><span class=\"params\">(self, S: str)</span> -&gt; str:</span></span><br><span class=\"line\">    heap = [(-cnt, c) <span class=\"keyword\">for</span> c, cnt <span class=\"keyword\">in</span> Counter(S).items()]</span><br><span class=\"line\">    heapq.heapify(heap)</span><br><span class=\"line\">    res = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> heap:</span><br><span class=\"line\">        cnt_1, c1 = heapq.heappop(heap)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> res <span class=\"keyword\">and</span> res[<span class=\"number\">-1</span>]==c1:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> heap:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">''</span></span><br><span class=\"line\">            cnt_2, c2 = heapq.heappop(heap)</span><br><span class=\"line\">            res.append(c2)</span><br><span class=\"line\">            cnt_2 += <span class=\"number\">1</span></span><br><span class=\"line\">            heapq.heappush(heap, (cnt_1, c1))</span><br><span class=\"line\">            <span class=\"keyword\">if</span> cnt_2:</span><br><span class=\"line\">                heapq.heappush(heap, (cnt_2, c2))</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            res.append(c1)</span><br><span class=\"line\">            cnt_1 += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> cnt_1:</span><br><span class=\"line\">                heapq.heappush(heap, (cnt_1, c1))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(res)</span><br></pre></td></tr></table></figure>\n<p>方法二：by @Stefan。为何内层也要sorted一下，是因为<code>[a, b, b, a]</code>会保留原来的相对顺序。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reorganizeString</span><span class=\"params\">(self, S: str)</span> -&gt; str:</span></span><br><span class=\"line\">    a = sorted(sorted(S), key=S.count)</span><br><span class=\"line\">    h = len(a) // <span class=\"number\">2</span></span><br><span class=\"line\">    a[<span class=\"number\">1</span>::<span class=\"number\">2</span>], a[::<span class=\"number\">2</span>] = a[:h], a[h:]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(a) * (a[<span class=\"number\">-1</span>:] != a[<span class=\"number\">-2</span>:<span class=\"number\">-1</span>])</span><br></pre></td></tr></table></figure>\n<h3 id=\"659-Split-Array-into-Consecutive-Subsequences\"><a href=\"#659-Split-Array-into-Consecutive-Subsequences\" class=\"headerlink\" title=\"659. Split Array into Consecutive Subsequences\"></a><a href=\"https://leetcode.com/problems/split-array-into-consecutive-subsequences/\" target=\"_blank\" rel=\"noopener\">659. Split Array into Consecutive Subsequences</a></h3><h4 id=\"将一个升序的数组，拆分重连续的子数组段，长度不能小于3\"><a href=\"#将一个升序的数组，拆分重连续的子数组段，长度不能小于3\" class=\"headerlink\" title=\"将一个升序的数组，拆分重连续的子数组段，长度不能小于3.\"></a>将一个升序的数组，拆分重连续的子数组段，长度不能小于3.</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [1,2,3,3,4,4,5,5]</span><br><span class=\"line\">Output: True</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">You can split them into two consecutive subsequences : </span><br><span class=\"line\">1, 2, 3, 4, 5</span><br><span class=\"line\">3, 4, 5</span><br></pre></td></tr></table></figure>\n<p>方法一：By@lee215。挺难想的方法，left表示每个数剩了多少个。end表示以这个数结尾的有几个。当我没法将当前的数追加到前一段的结尾时，也没法找到后两个连续的数时，就不能拆分成功。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isPossible</span><span class=\"params\">(self, A: List[int])</span> -&gt; bool:</span></span><br><span class=\"line\">    left = collections.Counter(A)</span><br><span class=\"line\">    end = collections.Counter()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> A:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> left[i]: <span class=\"keyword\">continue</span></span><br><span class=\"line\">        left[i] -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> end[i - <span class=\"number\">1</span>] &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            end[i - <span class=\"number\">1</span>] -= <span class=\"number\">1</span></span><br><span class=\"line\">            end[i] += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> left[i + <span class=\"number\">1</span>] <span class=\"keyword\">and</span> left[i + <span class=\"number\">2</span>]:</span><br><span class=\"line\">            left[i + <span class=\"number\">1</span>] -= <span class=\"number\">1</span></span><br><span class=\"line\">            left[i + <span class=\"number\">2</span>] -= <span class=\"number\">1</span></span><br><span class=\"line\">            end[i + <span class=\"number\">2</span>] += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        print(left, end)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1702-Maximum-Binary-String-After-Change\"><a href=\"#1702-Maximum-Binary-String-After-Change\" class=\"headerlink\" title=\"1702. Maximum Binary String After Change\"></a><a href=\"https://leetcode.com/problems/maximum-binary-string-after-change/\" target=\"_blank\" rel=\"noopener\">1702. Maximum Binary String After Change</a></h3><h4 id=\"对于一个二进制的字符串，你可以将00变成10-也可以将10变成01，问可以变成的表示最大的十进制的数对应的字符串是多少。\"><a href=\"#对于一个二进制的字符串，你可以将00变成10-也可以将10变成01，问可以变成的表示最大的十进制的数对应的字符串是多少。\" class=\"headerlink\" title=\"对于一个二进制的字符串，你可以将00变成10, 也可以将10变成01，问可以变成的表示最大的十进制的数对应的字符串是多少。\"></a>对于一个二进制的字符串，你可以将<code>00</code>变成<code>10</code>, 也可以将<code>10</code>变成<code>01</code>，问可以变成的表示最大的十进制的数对应的字符串是多少。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: binary &#x3D; &quot;000110&quot;</span><br><span class=\"line\">Output: &quot;111011&quot;</span><br><span class=\"line\">Explanation: A valid transformation sequence can be:</span><br><span class=\"line\">&quot;000110&quot; -&gt; &quot;000101&quot; </span><br><span class=\"line\">&quot;000101&quot; -&gt; &quot;100101&quot; </span><br><span class=\"line\">&quot;100101&quot; -&gt; &quot;110101&quot; </span><br><span class=\"line\">&quot;110101&quot; -&gt; &quot;110011&quot; </span><br><span class=\"line\">&quot;110011&quot; -&gt; &quot;111011&quot;</span><br></pre></td></tr></table></figure>\n<p>方法一：竞赛时想出来了，无非是找到规律就行，代码写的过于冗长。思路是开头的1不用管，将后面所有的0冒泡到最高位，<code>0000</code>可以变成<code>1110</code>，最后以一些1结尾。这里是Lee的优雅写法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maximumBinaryString</span><span class=\"params\">(self, binary: str)</span> -&gt; str:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"string\">'0'</span> <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> s: <span class=\"keyword\">return</span> s</span><br><span class=\"line\">    k, n = s.count(<span class=\"string\">'1'</span>, s.find(<span class=\"string\">'0'</span>)), len(s)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'1'</span> * (n - k - <span class=\"number\">1</span>) + <span class=\"string\">'0'</span> + <span class=\"string\">'1'</span> * k</span><br></pre></td></tr></table></figure>\n<h3 id=\"1727-Largest-Submatrix-With-Rearrangements\"><a href=\"#1727-Largest-Submatrix-With-Rearrangements\" class=\"headerlink\" title=\"1727. Largest Submatrix With Rearrangements\"></a><a href=\"https://leetcode.com/problems/largest-submatrix-with-rearrangements/\" target=\"_blank\" rel=\"noopener\">1727. Largest Submatrix With Rearrangements</a></h3><h4 id=\"重新排列二维矩阵，可以得到的最大的都是1的矩阵面积是多少。\"><a href=\"#重新排列二维矩阵，可以得到的最大的都是1的矩阵面积是多少。\" class=\"headerlink\" title=\"重新排列二维矩阵，可以得到的最大的都是1的矩阵面积是多少。\"></a>重新排列二维矩阵，可以得到的最大的都是1的矩阵面积是多少。</h4><img src=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E8%B4%AA%E5%BF%83%E7%AF%87%EF%BC%89greedy/1727.png\" class>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: matrix &#x3D; [[0,0,1],[1,1,1],[1,0,1]]</span><br><span class=\"line\">Output: 4</span><br><span class=\"line\">Explanation: You can rearrange the columns as shown above.</span><br><span class=\"line\">The largest submatrix of 1s, in bold, has an area of 4.</span><br></pre></td></tr></table></figure>\n<p>方法一：比赛时没有做出来，想到了贪心和排序，但是没想到列的怎么保持一致的顺序。此题和84，85很像，印象不深，所以没有关联上。从列上从上至下做一个累加，所以累加的数都到了一行，这样再排序每行都是独立的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">largestSubmatrix</span><span class=\"params\">(self, matrix: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    M, N = len(matrix), len(matrix[<span class=\"number\">0</span>])</span><br><span class=\"line\">    res = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(M):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(N):</span><br><span class=\"line\">            matrix[i][j] += matrix[i<span class=\"number\">-1</span>][j] * matrix[i][j] * (i&gt;=<span class=\"number\">1</span>)</span><br><span class=\"line\">        arr = sorted(matrix[i], reverse = <span class=\"literal\">True</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(N):</span><br><span class=\"line\">            res = max(res, (j+<span class=\"number\">1</span>) * arr[j])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"1737-Change-Minimum-Characters-to-Satisfy-One-of-Three-Conditions\"><a href=\"#1737-Change-Minimum-Characters-to-Satisfy-One-of-Three-Conditions\" class=\"headerlink\" title=\"1737. Change Minimum Characters to Satisfy One of Three Conditions\"></a><a href=\"https://leetcode.com/problems/change-minimum-characters-to-satisfy-one-of-three-conditions/\" target=\"_blank\" rel=\"noopener\">1737. Change Minimum Characters to Satisfy One of Three Conditions</a></h3><h4 id=\"给定两个字符串a和b，都是由小写字母组成。然后每次允许将任意字符串的一个字符改成任意一个字符最后满足下列三种条件之一：问最小操作步数是多少。1-a的所有字符严格小于b；2：b的所有字符严格小于a；3：a，b都是一种相同的字符。\"><a href=\"#给定两个字符串a和b，都是由小写字母组成。然后每次允许将任意字符串的一个字符改成任意一个字符最后满足下列三种条件之一：问最小操作步数是多少。1-a的所有字符严格小于b；2：b的所有字符严格小于a；3：a，b都是一种相同的字符。\" class=\"headerlink\" title=\"给定两个字符串a和b，都是由小写字母组成。然后每次允许将任意字符串的一个字符改成任意一个字符最后满足下列三种条件之一：问最小操作步数是多少。1. a的所有字符严格小于b；2：b的所有字符严格小于a；3：a，b都是一种相同的字符。\"></a>给定两个字符串a和b，都是由小写字母组成。然后每次允许将任意字符串的一个字符改成任意一个字符最后满足下列三种条件之一：问最小操作步数是多少。1. a的所有字符严格小于b；2：b的所有字符严格小于a；3：a，b都是一种相同的字符。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: a &#x3D; &quot;aba&quot;, b &#x3D; &quot;caa&quot;</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: Consider the best way to make each condition true:</span><br><span class=\"line\">1) Change b to &quot;ccc&quot; in 2 operations, then every letter in a is less than every letter in b.</span><br><span class=\"line\">2) Change a to &quot;bbb&quot; and b to &quot;aaa&quot; in 3 operations, then every letter in b is less than every letter in a.</span><br><span class=\"line\">3) Change a to &quot;aaa&quot; and b to &quot;aaa&quot; in 2 operations, then a and b consist of one distinct letter.</span><br><span class=\"line\">The best way was done in 2 operations (either condition 1 or condition 3).</span><br><span class=\"line\">Input: a &#x3D; &quot;dabadd&quot;, b &#x3D; &quot;cda&quot;</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: The best way is to make condition 1 true by changing b to &quot;eee&quot;.</span><br></pre></td></tr></table></figure>\n<p>方法一：竞赛时没有做出来，就差一点。第三种条件很容易想到。前两种不好想，需要用到前缀和+错位。这点我想到了，没想到是以分割字符来暴力枚举。将a,b字符串转成字母计数的数组，以a~y中的字母d来分割，a串全部小于等于d，b串全部大于d。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minCharacters</span><span class=\"params\">(self, a: str, b: str)</span> -&gt; int:</span></span><br><span class=\"line\">    c_a, c_b = Counter(a), Counter(b)</span><br><span class=\"line\">    res = len(a) + len(b) - max((c_a + c_b).values())</span><br><span class=\"line\">    lst_a = []</span><br><span class=\"line\">    lst_b = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> string.ascii_lowercase:</span><br><span class=\"line\">        lst_a.append(c_a[d])</span><br><span class=\"line\">        lst_b.append(c_b[d])</span><br><span class=\"line\"></span><br><span class=\"line\">    r_pre_sum_a = list(accumulate(lst_a[::<span class=\"number\">-1</span>]))[::<span class=\"number\">-1</span>]</span><br><span class=\"line\">    pre_sum_b = list(accumulate(lst_b))</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">26</span>):</span><br><span class=\"line\">        res = min(res, r_pre_sum_a[i]+pre_sum_b[i<span class=\"number\">-1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    r_pre_sum_b = list(accumulate(lst_b[::<span class=\"number\">-1</span>]))[::<span class=\"number\">-1</span>]</span><br><span class=\"line\">    pre_sum_a = list(accumulate(lst_a))</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">26</span>):</span><br><span class=\"line\">        res = min(res, r_pre_sum_b[i]+pre_sum_a[i<span class=\"number\">-1</span>])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<p>方法二：可以用总和减去前缀和来求得后缀和。Lee的方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minCharacters</span><span class=\"params\">(self, a: str, b: str)</span> -&gt; int:</span></span><br><span class=\"line\">    m, n = len(a), len(b)</span><br><span class=\"line\">    c1 = Counter(ord(c) - <span class=\"number\">97</span> <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> a)</span><br><span class=\"line\">    c2 = Counter(ord(c) - <span class=\"number\">97</span> <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> b)</span><br><span class=\"line\">    res = m + n - max((c1+c2).values())</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">25</span>):</span><br><span class=\"line\">        c1[i+<span class=\"number\">1</span>] += c1[i]</span><br><span class=\"line\">        c2[i+<span class=\"number\">1</span>] += c2[i]</span><br><span class=\"line\">        res = min(res, m - c1[i] + c2[i]) <span class=\"comment\"># condition 1</span></span><br><span class=\"line\">        res = min(res, n - c2[i] + c1[i]) <span class=\"comment\"># condition 2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"1665-Minimum-Initial-Energy-to-Finish-Tasks\"><a href=\"#1665-Minimum-Initial-Energy-to-Finish-Tasks\" class=\"headerlink\" title=\"1665. Minimum Initial Energy to Finish Tasks\"></a><a href=\"https://leetcode.com/problems/minimum-initial-energy-to-finish-tasks/\" target=\"_blank\" rel=\"noopener\">1665. Minimum Initial Energy to Finish Tasks</a></h3><h4 id=\"最少需要多少能量完成所有的任务。每个任务有一个最低能量和消耗的能量。\"><a href=\"#最少需要多少能量完成所有的任务。每个任务有一个最低能量和消耗的能量。\" class=\"headerlink\" title=\"最少需要多少能量完成所有的任务。每个任务有一个最低能量和消耗的能量。\"></a>最少需要多少能量完成所有的任务。每个任务有一个最低能量和消耗的能量。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: tasks &#x3D; [[1,2],[2,4],[4,8]]</span><br><span class=\"line\">Output: 8</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">Starting with 8 energy, we finish the tasks in the following order:</span><br><span class=\"line\">    - 3rd task. Now energy &#x3D; 8 - 4 &#x3D; 4.</span><br><span class=\"line\">    - 2nd task. Now energy &#x3D; 4 - 2 &#x3D; 2.</span><br><span class=\"line\">    - 1st task. Now energy &#x3D; 2 - 1 &#x3D; 1.</span><br><span class=\"line\">Notice that even though we have leftover energy, starting with 7 energy does not work because we cannot do the 3rd task.</span><br></pre></td></tr></table></figure>\n<p>方法一：很容易想到贪心，要排序，但是根据什么排序很重要。因为 minimum 表示的是”开始做这个任务的时候，拥有的最小能量值是多少“；actual 则是”做这个任务所消耗的能量值“。所以，minimum - actual 的结果，就是”完成这个任务以后，剩余的能量值的最小值“。为了完成所有的任务，我们显然希望剩余的能量值越多越好。所以，我们应该先完成“使得剩余的能量值多的任务”，即 minimum - actual 大的任务；这样有更多的能量，去完成别的任务。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minimumEffort</span><span class=\"params\">(self, tasks: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    res = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> a, m <span class=\"keyword\">in</span> sorted(tasks, key=<span class=\"keyword\">lambda</span> x: x[<span class=\"number\">1</span>]-x[<span class=\"number\">0</span>]):</span><br><span class=\"line\">        res += a</span><br><span class=\"line\">        res = max(res, m)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"1754-Largest-Merge-Of-Two-Strings\"><a href=\"#1754-Largest-Merge-Of-Two-Strings\" class=\"headerlink\" title=\"1754. Largest Merge Of Two Strings\"></a><a href=\"https://leetcode.com/problems/largest-merge-of-two-strings/\" target=\"_blank\" rel=\"noopener\">1754. Largest Merge Of Two Strings</a></h3><h4 id=\"合并两个字符串，字典序最大。每次从两个单词开头拿字符。\"><a href=\"#合并两个字符串，字典序最大。每次从两个单词开头拿字符。\" class=\"headerlink\" title=\"合并两个字符串，字典序最大。每次从两个单词开头拿字符。\"></a>合并两个字符串，字典序最大。每次从两个单词开头拿字符。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: word1 &#x3D; &quot;cabaa&quot;, word2 &#x3D; &quot;bcaaa&quot;</span><br><span class=\"line\">Output: &quot;cbcabaaaaa&quot;</span><br><span class=\"line\">Explanation: One way to get the lexicographically largest merge is:</span><br><span class=\"line\">- Take from word1: merge &#x3D; &quot;c&quot;, word1 &#x3D; &quot;abaa&quot;, word2 &#x3D; &quot;bcaaa&quot;</span><br><span class=\"line\">- Take from word2: merge &#x3D; &quot;cb&quot;, word1 &#x3D; &quot;abaa&quot;, word2 &#x3D; &quot;caaa&quot;</span><br><span class=\"line\">- Take from word2: merge &#x3D; &quot;cbc&quot;, word1 &#x3D; &quot;abaa&quot;, word2 &#x3D; &quot;aaa&quot;</span><br><span class=\"line\">- Take from word1: merge &#x3D; &quot;cbca&quot;, word1 &#x3D; &quot;baa&quot;, word2 &#x3D; &quot;aaa&quot;</span><br><span class=\"line\">- Take from word1: merge &#x3D; &quot;cbcab&quot;, word1 &#x3D; &quot;aa&quot;, word2 &#x3D; &quot;aaa&quot;</span><br><span class=\"line\">- Append the remaining 5 a&#39;s from word1 and word2 at the end of merge.</span><br></pre></td></tr></table></figure>\n<p>方法一：模拟。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">largestMerge</span><span class=\"params\">(self, word1: str, word2: str)</span> -&gt; str:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_larger</span><span class=\"params\">(a, b)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> c1, c2 <span class=\"keyword\">in</span> zip_longest(reversed(a), reversed(b), fillvalue=<span class=\"string\">'-'</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> c1 &gt; c2:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> c1 &lt; c2:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">    s1, s2 = list(word1)[::<span class=\"number\">-1</span>], list(word2)[::<span class=\"number\">-1</span>]</span><br><span class=\"line\">    res = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> s1 <span class=\"keyword\">or</span> s2:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> is_larger(s1, s2):</span><br><span class=\"line\">            res.append(s1.pop())</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            res.append(s2.pop())</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(res)</span><br></pre></td></tr></table></figure>\n<p>方法二：递归。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">largestMerge</span><span class=\"params\">(self, s1: str, s2: str)</span> -&gt; str:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> s1 &gt;= s2 &gt; <span class=\"string\">''</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s1[<span class=\"number\">0</span>] + self.largestMerge(s1[<span class=\"number\">1</span>:], s2)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> s2 &gt;= s1 &gt; <span class=\"string\">''</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s2[<span class=\"number\">0</span>] + self.largestMerge(s1, s2[<span class=\"number\">1</span>:])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s1 + s2</span><br></pre></td></tr></table></figure>\n<h3 id=\"1591-Strange-Printer-II\"><a href=\"#1591-Strange-Printer-II\" class=\"headerlink\" title=\"1591. Strange Printer II\"></a><a href=\"https://leetcode.com/problems/strange-printer-ii/\" target=\"_blank\" rel=\"noopener\">1591. Strange Printer II</a></h3><h4 id=\"二维矩阵中，每次能打一个递增的数字，但是必须打出矩形，后打的字可以覆盖之前的，问一个结果是否能被打印出来。\"><a href=\"#二维矩阵中，每次能打一个递增的数字，但是必须打出矩形，后打的字可以覆盖之前的，问一个结果是否能被打印出来。\" class=\"headerlink\" title=\"二维矩阵中，每次能打一个递增的数字，但是必须打出矩形，后打的字可以覆盖之前的，问一个结果是否能被打印出来。\"></a>二维矩阵中，每次能打一个递增的数字，但是必须打出矩形，后打的字可以覆盖之前的，问一个结果是否能被打印出来。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: targetGrid &#x3D; [[1,1,1,1],[1,2,2,1],[1,2,2,1],[1,1,1,1]]</span><br><span class=\"line\">Output: true</span><br></pre></td></tr></table></figure>\n<p>方法一：此题需要逆向思维，将数字还原为0。需要注意一点，不能排序从大到小因为，可能有<code>[4,3,3,4]</code>的情况。所以判断条件是，当所有的颜色都不能透过矩形变小时，返回False。遍历过程中可以置为0，因为当大数可打印时，其可以替换为任何比它小的数字，相当于万能，所以在检测到矩形时，就将其置为0.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isPrintable</span><span class=\"params\">(self, g: List[List[int]])</span> -&gt; bool:</span></span><br><span class=\"line\">    colors = set()</span><br><span class=\"line\">    M, N = len(g), len(g[<span class=\"number\">0</span>])</span><br><span class=\"line\">    pos = [[M, N, <span class=\"number\">0</span>, <span class=\"number\">0</span>] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(<span class=\"number\">61</span>)] </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, row <span class=\"keyword\">in</span> enumerate(g):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j, d <span class=\"keyword\">in</span> enumerate(row):</span><br><span class=\"line\">            colors.add(d)</span><br><span class=\"line\">            pos[d][<span class=\"number\">0</span>] = min(pos[d][<span class=\"number\">0</span>], i)</span><br><span class=\"line\">            pos[d][<span class=\"number\">1</span>] = min(pos[d][<span class=\"number\">1</span>], j)</span><br><span class=\"line\">            pos[d][<span class=\"number\">2</span>] = max(pos[d][<span class=\"number\">2</span>], i)</span><br><span class=\"line\">            pos[d][<span class=\"number\">3</span>] = max(pos[d][<span class=\"number\">3</span>], j)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check</span><span class=\"params\">(d)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(pos[d][<span class=\"number\">0</span>], pos[d][<span class=\"number\">2</span>]+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(pos[d][<span class=\"number\">1</span>], pos[d][<span class=\"number\">3</span>]+<span class=\"number\">1</span>):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> g[i][j]&gt;<span class=\"number\">0</span> <span class=\"keyword\">and</span> g[i][j]!=d:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(pos[d][<span class=\"number\">0</span>], pos[d][<span class=\"number\">2</span>]+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(pos[d][<span class=\"number\">1</span>], pos[d][<span class=\"number\">3</span>]+<span class=\"number\">1</span>):</span><br><span class=\"line\">                g[i][j] = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> colors:</span><br><span class=\"line\">        colors2 = set()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> colors:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> check(d):</span><br><span class=\"line\">                colors2.add(d)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(colors) == len(colors2):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        colors = colors2</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1793-Maximum-Score-of-a-Good-Subarray\"><a href=\"#1793-Maximum-Score-of-a-Good-Subarray\" class=\"headerlink\" title=\"1793. Maximum Score of a Good Subarray\"></a><a href=\"https://leetcode.com/problems/maximum-score-of-a-good-subarray/\" target=\"_blank\" rel=\"noopener\">1793. Maximum Score of a Good Subarray</a></h3><h4 id=\"从数组k的位置向两侧延伸，子数组分数（最小值-长度）最大为多少\"><a href=\"#从数组k的位置向两侧延伸，子数组分数（最小值-长度）最大为多少\" class=\"headerlink\" title=\"从数组k的位置向两侧延伸，子数组分数（最小值*长度）最大为多少\"></a>从数组k的位置向两侧延伸，子数组分数（最小值*长度）最大为多少</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [1,4,3,7,4,5], k &#x3D; 3</span><br><span class=\"line\">Output: 15</span><br><span class=\"line\">Explanation: The optimal subarray is (1, 5) with a score of min(4,3,7,4,5) * (5-1+1) &#x3D; 3 * 5 &#x3D; 15.</span><br></pre></td></tr></table></figure>\n<p>方法一：这周周赛简单，作为第四题过于简单。我这里想了最后才用了二分法做出来。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maximumScore</span><span class=\"params\">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class=\"line\">    right = list(accumulate(nums[k:], min))</span><br><span class=\"line\">    left = list(accumulate(nums[:k][::<span class=\"number\">-1</span>], min))[::<span class=\"number\">-1</span>]</span><br><span class=\"line\">    min_nums = left + right</span><br><span class=\"line\">    res = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> sorted(set(min_nums)):</span><br><span class=\"line\">        i = bisect_left(left, num)</span><br><span class=\"line\">        j = bisect_left(right[::<span class=\"number\">-1</span>], num)</span><br><span class=\"line\">        j = len(right)-j+k</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i &lt;= k <span class=\"keyword\">and</span> j&gt;k:</span><br><span class=\"line\">            res = max(res, num*(j-i))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<p>方法二：贪心，双指针。就尽量让最小值减少得慢。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maximumScore</span><span class=\"params\">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class=\"line\">    res = mini = nums[k]</span><br><span class=\"line\">    i, j, n = k, k, len(nums)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> i&gt;<span class=\"number\">0</span> <span class=\"keyword\">or</span> j&lt;n<span class=\"number\">-1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i<span class=\"number\">-1</span>] <span class=\"keyword\">if</span> i <span class=\"keyword\">else</span> <span class=\"number\">0</span>) &gt;= (nums[j+<span class=\"number\">1</span>] <span class=\"keyword\">if</span> j&lt;n<span class=\"number\">-1</span> <span class=\"keyword\">else</span> <span class=\"number\">0</span>):</span><br><span class=\"line\">            i -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            j += <span class=\"number\">1</span></span><br><span class=\"line\">        mini = min(mini, nums[i], nums[j])</span><br><span class=\"line\">        res = max(res, mini*(j-i+<span class=\"number\">1</span>))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"1806-Minimum-Number-of-Operations-to-Reinitialize-a-Permutation\"><a href=\"#1806-Minimum-Number-of-Operations-to-Reinitialize-a-Permutation\" class=\"headerlink\" title=\"1806. Minimum Number of Operations to Reinitialize a Permutation\"></a>1806. Minimum Number of Operations to Reinitialize a Permutation</h3><h4 id=\"操作多少次，数组能变回原样\"><a href=\"#操作多少次，数组能变回原样\" class=\"headerlink\" title=\"操作多少次，数组能变回原样\"></a>操作多少次，数组能变回原样</h4><ul>\n<li>If <code>i % 2 == 0</code>, then <code>arr[i] = perm[i / 2]</code>.</li>\n<li>If <code>i % 2 == 1</code>, then <code>arr[i] = perm[n / 2 + (i - 1) / 2]</code>.</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 4</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: prem &#x3D; [0,1,2,3] initially.</span><br><span class=\"line\">After the 1st operation, prem &#x3D; [0,2,1,3]</span><br><span class=\"line\">After the 2nd operation, prem &#x3D; [0,1,2,3]</span><br><span class=\"line\">So it takes only 2 operations.</span><br></pre></td></tr></table></figure>\n<p>方法一：比较简单，写法上有点 丑陋。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reinitializePermutation</span><span class=\"params\">(self, n: int)</span> -&gt; int:</span></span><br><span class=\"line\">    first = <span class=\"literal\">False</span></span><br><span class=\"line\">    i = <span class=\"number\">1</span></span><br><span class=\"line\">    i *= <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> i &gt; n<span class=\"number\">-1</span>:</span><br><span class=\"line\">        i -= n<span class=\"number\">-1</span></span><br><span class=\"line\">    res = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> i != <span class=\"number\">1</span>:</span><br><span class=\"line\">        i *= <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i &gt; n<span class=\"number\">-1</span>:</span><br><span class=\"line\">            i -= n<span class=\"number\">-1</span></span><br><span class=\"line\">        res += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：Lee215的方法。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reinitializePermutation</span><span class=\"params\">(self, n: int)</span> -&gt; int:</span></span><br><span class=\"line\">    res, i = <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> res==<span class=\"number\">0</span> <span class=\"keyword\">or</span> i &gt; <span class=\"number\">1</span>:</span><br><span class=\"line\">        i = i * <span class=\"number\">2</span> % (n<span class=\"number\">-1</span>)</span><br><span class=\"line\">        res += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n","categories":["算法"],"tags":["LeetCode","Python","Algorithm","Greedy"]},{"title":"LeetCode算法题整理（数学篇）Math","url":"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%95%B0%E5%AD%A6%E7%AF%87%EF%BC%89Math/","content":"<h3 id=\"7-Reverse-Integer\"><a href=\"#7-Reverse-Integer\" class=\"headerlink\" title=\"7. Reverse Integer\"></a>7. Reverse Integer</h3><h4 id=\"倒置一个整数，-此答案忽略了原题中的范围判断。原题\"><a href=\"#倒置一个整数，-此答案忽略了原题中的范围判断。原题\" class=\"headerlink\" title=\"倒置一个整数， 此答案忽略了原题中的范围判断。原题\"></a>倒置一个整数， 此答案忽略了原题中的范围判断。<a href=\"https://leetcode.com/problems/reverse-integer/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: -123</span><br><span class=\"line\">Output: -321</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>方法一：str</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverse_int</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> x &gt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> int(str(x)[::<span class=\"number\">-1</span>])</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -int(str(x)[:<span class=\"number\">0</span>:<span class=\"number\">-1</span>])</span><br></pre></td></tr></table></figure>\n<p>方法二：math</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverse</span><span class=\"params\">(self, x: int)</span> -&gt; int:</span></span><br><span class=\"line\">    sign = <span class=\"number\">1</span> <span class=\"keyword\">if</span> x &gt;= <span class=\"number\">0</span> <span class=\"keyword\">else</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    ans, tail = <span class=\"number\">0</span>, abs(x)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> tail:</span><br><span class=\"line\">        ans = ans*<span class=\"number\">10</span> + tail%<span class=\"number\">10</span></span><br><span class=\"line\">        tail //= <span class=\"number\">10</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans * sign <span class=\"keyword\">if</span> ans &lt; <span class=\"number\">2</span>**<span class=\"number\">31</span> <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"9-Palindrome-Number\"><a href=\"#9-Palindrome-Number\" class=\"headerlink\" title=\"9. Palindrome Number\"></a>9. Palindrome Number</h3><h4 id=\"判断一个数是否是回文数，这里把负数认为是不符合条件的。原题\"><a href=\"#判断一个数是否是回文数，这里把负数认为是不符合条件的。原题\" class=\"headerlink\" title=\"判断一个数是否是回文数，这里把负数认为是不符合条件的。原题\"></a>判断一个数是否是回文数，这里把负数认为是不符合条件的。<a href=\"https://leetcode.com/problems/palindrome-number/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：str</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_palindrome</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> str(x) == str(x)[::<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<p>方法二：math</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_palindrome</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">    l, r = x, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> l &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">        r = r*<span class=\"number\">10</span> + l%<span class=\"number\">10</span></span><br><span class=\"line\">        l //= <span class=\"number\">10</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> r == x</span><br></pre></td></tr></table></figure>\n<h3 id=\"13-Roman-to-Integer\"><a href=\"#13-Roman-to-Integer\" class=\"headerlink\" title=\"13. Roman to Integer\"></a>13. Roman to Integer</h3><h4 id=\"罗马数字转换整型。原题\"><a href=\"#罗马数字转换整型。原题\" class=\"headerlink\" title=\"罗马数字转换整型。原题\"></a>罗马数字转换整型。<a href=\"https://leetcode.com/problems/roman-to-integer/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">roman_to_int</span><span class=\"params\">(s)</span>:</span></span><br><span class=\"line\">    roman = &#123;<span class=\"string\">'I'</span>: <span class=\"number\">1</span>, <span class=\"string\">'V'</span>: <span class=\"number\">5</span>, <span class=\"string\">'X'</span>: <span class=\"number\">10</span>, <span class=\"string\">'L'</span>: <span class=\"number\">50</span>, </span><br><span class=\"line\">             <span class=\"string\">'C'</span>: <span class=\"number\">100</span>, <span class=\"string\">'D'</span>: <span class=\"number\">500</span>, <span class=\"string\">'M'</span>: <span class=\"number\">1000</span>&#125;</span><br><span class=\"line\">    total = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(s)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == len(s)<span class=\"number\">-1</span> <span class=\"keyword\">or</span> roman[s[i]] &gt;= roman[s[i+<span class=\"number\">1</span>]]</span><br><span class=\"line\">            total += roman[s[i]]</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            total -= roman[s[i]]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> total</span><br></pre></td></tr></table></figure>\n<h3 id=\"69-Sqrt-x\"><a href=\"#69-Sqrt-x\" class=\"headerlink\" title=\"69. Sqrt(x)\"></a>69. Sqrt(x)</h3><h4 id=\"实现开方，返回整数部分。原题\"><a href=\"#实现开方，返回整数部分。原题\" class=\"headerlink\" title=\"实现开方，返回整数部分。原题\"></a>实现开方，返回整数部分。<a href=\"https://leetcode.com/problems/sqrtx/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: 8</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: The square root of 8 is 2.82842..., and since </span><br><span class=\"line\">             the decimal part is truncated, 2 is returned.</span><br></pre></td></tr></table></figure>\n<p>方法一：二分法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mySqrt</span><span class=\"params\">(self, x: int)</span> -&gt; int:</span></span><br><span class=\"line\">    lo, hi = <span class=\"number\">1</span>, x</span><br><span class=\"line\">    <span class=\"keyword\">while</span> lo &lt;= hi:</span><br><span class=\"line\">        mid = (lo + hi) // <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> mid**<span class=\"number\">2</span> &lt; x:</span><br><span class=\"line\">            lo = mid + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> mid**<span class=\"number\">2</span> &gt; x:</span><br><span class=\"line\">            hi = mid - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hi</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\" target=\"_blank\" rel=\"noopener\">牛顿迭代法</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_sqrt</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">    r = x</span><br><span class=\"line\">    <span class=\"keyword\">while</span> r**<span class=\"number\">2</span> &gt; x:</span><br><span class=\"line\">        r = (r+x//r) // <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> r</span><br></pre></td></tr></table></figure>\n<h3 id=\"367-Valid-Perfect-Square\"><a href=\"#367-Valid-Perfect-Square\" class=\"headerlink\" title=\"367. Valid Perfect Square\"></a>367. Valid Perfect Square</h3><h4 id=\"判断一个数是不是某个数的平方。原题\"><a href=\"#判断一个数是不是某个数的平方。原题\" class=\"headerlink\" title=\"判断一个数是不是某个数的平方。原题\"></a>判断一个数是不是某个数的平方。<a href=\"https://leetcode.com/problems/valid-perfect-square/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: 16</span><br><span class=\"line\">Output: true</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\"><strong>方法一：牛顿迭代法。同69。</strong></font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isPerfectSquare</span><span class=\"params\">(self, num)</span>:</span></span><br><span class=\"line\">    r = num</span><br><span class=\"line\">    <span class=\"keyword\">while</span> r**<span class=\"number\">2</span> &gt; num:</span><br><span class=\"line\">        r = (r + num // r) // <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> r**<span class=\"number\">2</span> == num</span><br></pre></td></tr></table></figure>\n<h3 id=\"171-Excel-Sheet-Column-Number\"><a href=\"#171-Excel-Sheet-Column-Number\" class=\"headerlink\" title=\"171. Excel Sheet Column Number\"></a>171. Excel Sheet Column Number</h3><h4 id=\"excel表格列表数字转换，二十六进制。原题\"><a href=\"#excel表格列表数字转换，二十六进制。原题\" class=\"headerlink\" title=\"excel表格列表数字转换，二十六进制。原题\"></a>excel表格列表数字转换，二十六进制。<a href=\"https://leetcode.com/problems/excel-sheet-column-number/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">A -&gt; 1</span><br><span class=\"line\">B -&gt; 2</span><br><span class=\"line\">C -&gt; 3</span><br><span class=\"line\">...</span><br><span class=\"line\">Z -&gt; 26</span><br><span class=\"line\">AA -&gt; 27</span><br><span class=\"line\">AB -&gt; 28     A -&gt; 1</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">titleToNumber</span><span class=\"params\">(self, s: str)</span> -&gt; int:</span></span><br><span class=\"line\">    OFFSET = ord(<span class=\"string\">'A'</span>)<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum((ord(x)-OFFSET)*<span class=\"number\">26</span>**i <span class=\"keyword\">for</span> i, x <span class=\"keyword\">in</span> enumerate(s[::<span class=\"number\">-1</span>]))</span><br></pre></td></tr></table></figure>\n<h3 id=\"168-Excel-Sheet-Column-Title\"><a href=\"#168-Excel-Sheet-Column-Title\" class=\"headerlink\" title=\"168. Excel Sheet Column Title\"></a>168. Excel Sheet Column Title</h3><h4 id=\"excel转换，数字转字母。十进制-gt-26进制。原题\"><a href=\"#excel转换，数字转字母。十进制-gt-26进制。原题\" class=\"headerlink\" title=\"excel转换，数字转字母。十进制-&gt;26进制。原题\"></a>excel转换，数字转字母。十进制-&gt;26进制。<a href=\"https://leetcode.com/problems/excel-sheet-column-title\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">convertToTitle</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">    res = <span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> n:</span><br><span class=\"line\">        res = chr((n<span class=\"number\">-1</span>)%<span class=\"number\">26</span>+<span class=\"number\">65</span>) + res</span><br><span class=\"line\">        <span class=\"comment\"># n //= 26</span></span><br><span class=\"line\">        n = (n<span class=\"number\">-1</span>) // <span class=\"number\">26</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"172-Factorial-Trailing-Zeroes\"><a href=\"#172-Factorial-Trailing-Zeroes\" class=\"headerlink\" title=\"172. Factorial Trailing Zeroes\"></a>172. Factorial Trailing Zeroes</h3><h4 id=\"求n的阶乘末尾有几个0。原题\"><a href=\"#求n的阶乘末尾有几个0。原题\" class=\"headerlink\" title=\"求n的阶乘末尾有几个0。原题\"></a>求n的阶乘末尾有几个0。<a href=\"https://leetcode.com/problems/factorial-trailing-zeroes/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: 5</span><br><span class=\"line\">Output: 1</span><br><span class=\"line\">Explanation: 5! &#x3D; 120, one trailing zero.</span><br></pre></td></tr></table></figure>\n<p>思路：每一对2和5可以产生一个0，在n的阶乘中，5比2多，所以问题变成求5的个数，而25这种数有两个5，所以递归求解</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">trailing_zeroes</span><span class=\"params\">(n)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span> <span class=\"keyword\">if</span> n == <span class=\"number\">0</span> <span class=\"keyword\">else</span> n//<span class=\"number\">5</span> + trailing_zeroes(n//<span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"204-Count-Primes\"><a href=\"#204-Count-Primes\" class=\"headerlink\" title=\"204. Count Primes\"></a>204. Count Primes</h3><h4 id=\"求小于n的整数中，有多少个质数。原题\"><a href=\"#求小于n的整数中，有多少个质数。原题\" class=\"headerlink\" title=\"求小于n的整数中，有多少个质数。原题\"></a>求小于n的整数中，有多少个质数。<a href=\"https://leetcode.com/problems/count-primes/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countPrimes</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">    is_prime = [<span class=\"literal\">False</span>]*<span class=\"number\">2</span> + [<span class=\"literal\">True</span>]*(n<span class=\"number\">-2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>, int(n ** <span class=\"number\">0.5</span>)+<span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> is_prime[i]:</span><br><span class=\"line\">            is_prime[i*i:n:i] = [<span class=\"literal\">False</span>] * len(is_prime[i*i:n:i])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(is_prime)</span><br></pre></td></tr></table></figure>\n<h3 id=\"50-Pow-x-n\"><a href=\"#50-Pow-x-n\" class=\"headerlink\" title=\"50. Pow(x, n)\"></a>50. Pow(x, n)</h3><h4 id=\"实现pow函数。原题\"><a href=\"#实现pow函数。原题\" class=\"headerlink\" title=\"实现pow函数。原题\"></a>实现pow函数。<a href=\"https://leetcode.com/problems/powx-n/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: 2.00000, 10</span><br><span class=\"line\">Output: 1024.00000</span><br><span class=\"line\"></span><br><span class=\"line\">Input: 2.00000, -2</span><br><span class=\"line\">Output: 0.25000 .</span><br></pre></td></tr></table></figure>\n<p>说明：常规方法在Leetcode 上内存会爆掉。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">myPow</span><span class=\"params\">(self, x, n)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span> / self.pow_with_unsigned(x, -n)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.pow_with_unsigned(x, n)</span><br><span class=\"line\">              </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pow_with_unsigned</span><span class=\"params\">(self, x, n)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> x</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        res = self.pow_with_unsigned(x, n &gt;&gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">        res *= res</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &amp; <span class=\"number\">1</span> == <span class=\"number\">1</span>:</span><br><span class=\"line\">            res *= x</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"233-Number-of-Digit-One\"><a href=\"#233-Number-of-Digit-One\" class=\"headerlink\" title=\"233. Number of Digit One\"></a>233. Number of Digit One</h3><h4 id=\"1-n数字中1的个数。原题\"><a href=\"#1-n数字中1的个数。原题\" class=\"headerlink\" title=\"1~n数字中1的个数。原题\"></a>1~n数字中1的个数。<a href=\"https://leetcode.com/problems/number-of-digit-one/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countDigitOne</span><span class=\"params\">(self, n)</span>:</span>    </span><br><span class=\"line\">    countr, i = <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> i &lt;= n:</span><br><span class=\"line\">        divider = i * <span class=\"number\">10</span></span><br><span class=\"line\">        countr += (n // divider) * i + min(max(n % divider - i + <span class=\"number\">1</span>, <span class=\"number\">0</span>), i)</span><br><span class=\"line\">        i *= <span class=\"number\">10</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> countr</span><br></pre></td></tr></table></figure>\n<h3 id=\"263-Ugly-Number\"><a href=\"#263-Ugly-Number\" class=\"headerlink\" title=\"263. Ugly Number\"></a>263. Ugly Number</h3><h4 id=\"判断一个数是否是丑数。原题\"><a href=\"#判断一个数是否是丑数。原题\" class=\"headerlink\" title=\"判断一个数是否是丑数。原题\"></a>判断一个数是否是丑数。<a href=\"https://leetcode.com/problems/ugly-number-ii/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：根据定义实现。<code>&lt; num</code>是为了判断<code>num=0</code>的情况。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isUgly</span><span class=\"params\">(self, num)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> f <span class=\"keyword\">in</span> <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> num % f == <span class=\"number\">0</span> &lt; num:</span><br><span class=\"line\">            num //= f</span><br><span class=\"line\">    <span class=\"keyword\">return</span> num == <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"264-Ugly-Number-II\"><a href=\"#264-Ugly-Number-II\" class=\"headerlink\" title=\"264. Ugly Number II\"></a>264. Ugly Number II</h3><h4 id=\"输出第n个丑数。原题\"><a href=\"#输出第n个丑数。原题\" class=\"headerlink\" title=\"输出第n个丑数。原题\"></a>输出第n个丑数。<a href=\"https://leetcode.com/problems/ugly-number-ii/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>书中的方法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">nthUglyNumber</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">    q = [<span class=\"number\">1</span>]</span><br><span class=\"line\">    t2, t3, t5 = <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n<span class=\"number\">-1</span>):</span><br><span class=\"line\">        a2, a3, a5 = q[t2]*<span class=\"number\">2</span>, q[t3]*<span class=\"number\">3</span>, q[t5]*<span class=\"number\">5</span></span><br><span class=\"line\">        to_add = min(a2, a3, a5)</span><br><span class=\"line\">        q.append(to_add)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> a2 == to_add:</span><br><span class=\"line\">            t2 += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> a3 == to_add:</span><br><span class=\"line\">            t3 += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> a5 == to_add:</span><br><span class=\"line\">            t5 += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> q[<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"67-Add-Binary\"><a href=\"#67-Add-Binary\" class=\"headerlink\" title=\"67.Add Binary\"></a>67.Add Binary</h3><h4 id=\"实现二进制加法。原题\"><a href=\"#实现二进制加法。原题\" class=\"headerlink\" title=\"实现二进制加法。原题\"></a>实现二进制加法。<a href=\"https://leetcode.com/problems/add-binary/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: a &#x3D; &quot;11&quot;, b &#x3D; &quot;1&quot;</span><br><span class=\"line\">Output: &quot;100&quot;</span><br></pre></td></tr></table></figure>\n<p>方法一：按照加法的二进制思想来计算，不过Runtime大约100ms。后来试着将<code>list comprehension</code>拆成一个<code>for</code>循环，也并没有提高速度。居然<code>beats</code>只有4%，难道大部分人都用的<code>bin</code>。讨论区简单翻了了一下，没有找到一个高效的pythonic的方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addBinary</span><span class=\"params\">(self, a, b)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(a) &gt; len(b):</span><br><span class=\"line\">        b = b.zfill(len(a))</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        a = a.zfill(len(b))</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span> int(b):</span><br><span class=\"line\">        sum_not_carry = <span class=\"string\">''</span>.join([str(int(a[i]) ^ int(b[i])) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(a))])</span><br><span class=\"line\">        carry = <span class=\"string\">''</span>.join([str(int(a[i]) &amp; int(b[i])) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(a))])</span><br><span class=\"line\">        a, b = <span class=\"string\">\"0\"</span>+sum_not_carry, carry+<span class=\"string\">'0'</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.lstrip(<span class=\"string\">'0'</span>) <span class=\"keyword\">if</span> a != <span class=\"string\">'0'</span> <span class=\"keyword\">else</span> <span class=\"string\">'0'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"202-Happy-Number\"><a href=\"#202-Happy-Number\" class=\"headerlink\" title=\"202. Happy Number\"></a>202. Happy Number</h3><h4 id=\"判断是否是欢乐数。进行所有位的平方和运算，最后为1的是欢乐数。原题\"><a href=\"#判断是否是欢乐数。进行所有位的平方和运算，最后为1的是欢乐数。原题\" class=\"headerlink\" title=\"判断是否是欢乐数。进行所有位的平方和运算，最后为1的是欢乐数。原题\"></a>判断是否是欢乐数。进行所有位的平方和运算，最后为1的是欢乐数。<a href=\"https://leetcode.com/problems/happy-number/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: 19</span><br><span class=\"line\">Output: true</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">1**2 + 9**2 &#x3D; 82</span><br><span class=\"line\">8**2 + 2**2 &#x3D; 68</span><br><span class=\"line\">6**2 + 8**2 &#x3D; 100</span><br><span class=\"line\">1**2 + 0**2 + 0**2 &#x3D; 1</span><br></pre></td></tr></table></figure>\n<p>方法一：思路，使用一个字典映射0~9的平方值，然后如果死循环的话，各位数的和一定存在着一种循环，所以用一个<code>set</code>来判断是否重复。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isHappy</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">    squares = &#123;str(k): k**<span class=\"number\">2</span> <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, <span class=\"number\">10</span>)&#125;</span><br><span class=\"line\">    sum_digit = set()</span><br><span class=\"line\">    <span class=\"keyword\">while</span> n != <span class=\"number\">1</span>:</span><br><span class=\"line\">        n = sum(squares[digit] <span class=\"keyword\">for</span> digit <span class=\"keyword\">in</span> str(n))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n <span class=\"keyword\">in</span> sum_digit:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            sum_digit.add(n)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"231-Power-of-Two\"><a href=\"#231-Power-of-Two\" class=\"headerlink\" title=\"231. Power of Two\"></a>231. Power of Two</h3><h4 id=\"判断一个数是否是2的n次方。思路也就是判断这个数的二进制形式是否只有一个’1’。原题\"><a href=\"#判断一个数是否是2的n次方。思路也就是判断这个数的二进制形式是否只有一个’1’。原题\" class=\"headerlink\" title=\"判断一个数是否是2的n次方。思路也就是判断这个数的二进制形式是否只有一个’1’。原题\"></a>判断一个数是否是2的n次方。思路也就是判断这个数的二进制形式是否只有一个’1’。<a href=\"https://leetcode.com/problems/power-of-two\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：可以用作通用方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isPowerOfTwo</span><span class=\"params\">(self, n, power=<span class=\"number\">2</span>)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>: <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> n % power == <span class=\"number\">0</span>:</span><br><span class=\"line\">        n //= power</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n == <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>方法二：二进制统计1。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isPowerOfTwo</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> n &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> bin(n).count(<span class=\"string\">'1'</span>) == <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>方法三：如果一个数n的二进制只有一个1，那么<code>n&amp;(n-1)</code>一定为0。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isPowerOfTwo</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> n &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> (n&amp;n<span class=\"number\">-1</span>) == <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"342-Power-of-Four\"><a href=\"#342-Power-of-Four\" class=\"headerlink\" title=\"342. Power of Four\"></a>342. Power of Four</h3><h4 id=\"判断一个数是否是4的n次方。原题\"><a href=\"#判断一个数是否是4的n次方。原题\" class=\"headerlink\" title=\"判断一个数是否是4的n次方。原题\"></a>判断一个数是否是4的n次方。<a href=\"https://leetcode.com/problems/power-of-four/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：从简单入手通过231题，了解到了2的n次方特点是，二进制形式只有一个’1’，那么4的n次方就是不但只有一个’1’，后面还跟了偶数个’0’。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isPowerOfFour</span><span class=\"params\">(self, num)</span>:</span></span><br><span class=\"line\">    single_1 = num &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> (num &amp; num<span class=\"number\">-1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> single_1:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> num &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> num == <span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                num &gt;&gt;= <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：上述代码看起来更像是java代码，我们使用count来判断0的个数是否为偶数个。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isPowerOfFour</span><span class=\"params\">(self, num)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># return num &gt; 0 and (num &amp; num-1)==0 and bin(num)[2:].count('0')&amp;1==0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> num &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> (num &amp; num<span class=\"number\">-1</span>)==<span class=\"number\">0</span> <span class=\"keyword\">and</span> len(bin(num))&amp;<span class=\"number\">1</span>==<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>方法三：也可以使用正则。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isPowerOfFour</span><span class=\"params\">(self, num)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">import</span> re</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bool(re.match(<span class=\"string\">r'^0b1(00)*$'</span>,bin(num)))</span><br></pre></td></tr></table></figure>\n<h3 id=\"292-Nim-Game\"><a href=\"#292-Nim-Game\" class=\"headerlink\" title=\"292. Nim Game\"></a>292. Nim Game</h3><h4 id=\"说，有这么一堆石头，一次只能拿1-3个，拿到最后一个石头的人获胜。求n堆石头，你先拿是否可以获胜。原题\"><a href=\"#说，有这么一堆石头，一次只能拿1-3个，拿到最后一个石头的人获胜。求n堆石头，你先拿是否可以获胜。原题\" class=\"headerlink\" title=\"说，有这么一堆石头，一次只能拿1~3个，拿到最后一个石头的人获胜。求n堆石头，你先拿是否可以获胜。原题\"></a>说，有这么一堆石头，一次只能拿1~3个，拿到最后一个石头的人获胜。求n堆石头，你先拿是否可以获胜。<a href=\"https://leetcode.com/problems/nim-game/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>思路：找规律，发现只有最后剩4个石头的时候，此时轮到谁，谁输。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">canWinNim</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> n % <span class=\"number\">4</span> != <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"400-Nth-Digit\"><a href=\"#400-Nth-Digit\" class=\"headerlink\" title=\"400. Nth Digit\"></a>400. Nth Digit</h3><h4 id=\"找出无限整数序列中的第n个数字。原题\"><a href=\"#找出无限整数序列中的第n个数字。原题\" class=\"headerlink\" title=\"找出无限整数序列中的第n个数字。原题\"></a>找出无限整数序列中的第n个数字。<a href=\"https://leetcode.com/problems/nth-digit/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">11</span><br><span class=\"line\">Output:</span><br><span class=\"line\">0</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.</span><br></pre></td></tr></table></figure>\n<p>思路，根据n的位数，将无限序列分为几个范围。</p>\n<table>\n<thead>\n<tr>\n<th>size of n</th>\n<th>step</th>\n<th>start</th>\n<th>~</th>\n<th>stop</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>9</td>\n<td>1</td>\n<td>~</td>\n<td>9</td>\n</tr>\n<tr>\n<td>2</td>\n<td>90</td>\n<td>10</td>\n<td>~</td>\n<td>99</td>\n</tr>\n<tr>\n<td>3</td>\n<td>900</td>\n<td>100</td>\n<td>~</td>\n<td>999</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li>寻找范围。寻找n处于哪个范围，是1~9，还是10~99，例如n=15。则需要跳过1~9的范围，而这个范围有<code>size*step</code>个数字，所以问题变成在10~99范围上寻找第<code>15-1*9=6</code>个数。</li>\n<li>定位数字。10~99范围中是从10开始的，每一个数都有两位数字，所以最终数字为<code>10+(6-1)//2</code>，因为索引从0开始，所以需要-1。</li>\n<li>定位数字的位。上一步找到了数字为12，对size求余就可以知道，<code>&#39;12&#39;[(6-1)%2]=&#39;2&#39;</code>。</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findNthDigit</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">    start, step, size = <span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> n &gt; size * step:</span><br><span class=\"line\">        n, start, step, size = n-size*step, start*<span class=\"number\">10</span>, step*<span class=\"number\">10</span>, size+<span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> int(str(start + (n<span class=\"number\">-1</span>)//size)[(n<span class=\"number\">-1</span>) % size])</span><br></pre></td></tr></table></figure>\n<h3 id=\"415-Add-Stings\"><a href=\"#415-Add-Stings\" class=\"headerlink\" title=\"415. Add Stings\"></a>415. Add Stings</h3><h4 id=\"给定两个字符串表示的数字，把它们相加，这两个数的长度小于5100，不能使用任何BitIntegr库或是直接将其转换为整数。ps-题中要求不将输入直接转换成int，所以我个人认为int还是可以使用的，有一些答案中是使用了ord来做运算。原题\"><a href=\"#给定两个字符串表示的数字，把它们相加，这两个数的长度小于5100，不能使用任何BitIntegr库或是直接将其转换为整数。ps-题中要求不将输入直接转换成int，所以我个人认为int还是可以使用的，有一些答案中是使用了ord来做运算。原题\" class=\"headerlink\" title=\"给定两个字符串表示的数字，把它们相加，这两个数的长度小于5100，不能使用任何BitIntegr库或是直接将其转换为整数。ps: 题中要求不将输入直接转换成int，所以我个人认为int还是可以使用的，有一些答案中是使用了ord来做运算。原题\"></a>给定两个字符串表示的数字，把它们相加，这两个数的长度小于5100，不能使用任何BitIntegr库或是直接将其转换为整数。ps: 题中要求不将输入直接转换成int，所以我个人认为int还是可以使用的，有一些答案中是使用了ord来做运算。<a href=\"https://leetcode.com/problems/add-strings/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：不使用标准库。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addStrings</span><span class=\"params\">(self, num1, num2)</span>:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(num1) &gt; len(num2):</span><br><span class=\"line\">        num2 = num2.zfill(len(num1))</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        num1 = num1.zfill(len(num2))</span><br><span class=\"line\"></span><br><span class=\"line\">    res, carry = <span class=\"string\">''</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    n1, n2 = len(num1)<span class=\"number\">-1</span>, len(num2)<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n1 &gt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> n2 &gt;= <span class=\"number\">0</span>) <span class=\"keyword\">or</span> carry:</span><br><span class=\"line\">        v1 = int(num1[n1]) <span class=\"keyword\">if</span> n1 &gt;= <span class=\"number\">0</span> <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br><span class=\"line\">        v2 = int(num2[n2]) <span class=\"keyword\">if</span> n2 &gt;= <span class=\"number\">0</span> <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br><span class=\"line\">        carry, val = divmod(v1+v2+carry, <span class=\"number\">10</span>)</span><br><span class=\"line\">        res = str(val) + res</span><br><span class=\"line\">        n1 -= <span class=\"number\">1</span></span><br><span class=\"line\">        n2 -= <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\"><strong>方法二：使用zip_longest。</strong></font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addStrings</span><span class=\"params\">(self, num1, num2)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> itertools <span class=\"keyword\">import</span> zip_longest</span><br><span class=\"line\">    nums = list(zip_longest(num1[::<span class=\"number\">-1</span>], num2[::<span class=\"number\">-1</span>], fillvalue=<span class=\"string\">'0'</span>))</span><br><span class=\"line\">    carry, res = <span class=\"number\">0</span>, <span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> digits <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        d1, d2 = map(int, digits)</span><br><span class=\"line\">        carry, val = divmod(d1+d2+carry, <span class=\"number\">10</span>)</span><br><span class=\"line\">        res = res + str(val)</span><br><span class=\"line\">    res = res <span class=\"keyword\">if</span> carry==<span class=\"number\">0</span> <span class=\"keyword\">else</span> res+str(carry)        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> res[::<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"492-Construct-the-Rectangle\"><a href=\"#492-Construct-the-Rectangle\" class=\"headerlink\" title=\"492. Construct the Rectangle\"></a>492. Construct the Rectangle</h3><h4 id=\"给定一个面积，求组成这个面积的长高差最小。原题\"><a href=\"#给定一个面积，求组成这个面积的长高差最小。原题\" class=\"headerlink\" title=\"给定一个面积，求组成这个面积的长高差最小。原题\"></a>给定一个面积，求组成这个面积的长高差最小。<a href=\"https://leetcode.com/problems/construct-the-rectangle/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: 4</span><br><span class=\"line\">Output: [2, 2]</span><br><span class=\"line\">Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. </span><br><span class=\"line\">But according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.</span><br></pre></td></tr></table></figure>\n<font color=\"#FF0000\" size=\"3\"><strong>方法一：一开始我居然这样写。结果超时了，后来发现L+=1，循环次数要比L-=1要多。</strong></font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">constructRectangle</span><span class=\"params\">(self, area)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">import</span> math</span><br><span class=\"line\">    squre = math.sqrt(area)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> int(squre) == squre:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [int(squre), int(squre)]</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        L = int(squre) + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> area % L != <span class=\"number\">0</span>:</span><br><span class=\"line\">            L += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> [L, area//L]</span><br></pre></td></tr></table></figure>\n<p>方法二：整理一下思路其实很简单，之前想多了还以为有二分的方法。递减肯定是会优先退出循环的，但是我还不知道怎么证明这个结论。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">constructRectangle</span><span class=\"params\">(self, area)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">import</span> math</span><br><span class=\"line\">    w = int(math.sqrt(area))</span><br><span class=\"line\">    <span class=\"keyword\">while</span> area % w != <span class=\"number\">0</span>:</span><br><span class=\"line\">        w -= <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [area//w, w]</span><br></pre></td></tr></table></figure>\n<h3 id=\"504-Base-7\"><a href=\"#504-Base-7\" class=\"headerlink\" title=\"504. Base 7\"></a>504. Base 7</h3><h4 id=\"10进制转7进制。原题\"><a href=\"#10进制转7进制。原题\" class=\"headerlink\" title=\"10进制转7进制。原题\"></a>10进制转7进制。<a href=\"https://leetcode.com/problems/base-7/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: 100</span><br><span class=\"line\">Output: &quot;202&quot;</span><br><span class=\"line\">Input: -7</span><br><span class=\"line\">Output: &quot;-10&quot;</span><br></pre></td></tr></table></figure>\n<p>方法一：需要注意负数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">convertToBase7</span><span class=\"params\">(self, num: int)</span> -&gt; str:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> num == <span class=\"number\">0</span>: <span class=\"keyword\">return</span> <span class=\"string\">'0'</span></span><br><span class=\"line\">    n, ans = abs(num), <span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> n:</span><br><span class=\"line\">        n, val = divmod(n, <span class=\"number\">7</span>)</span><br><span class=\"line\">        ans = str(val) + ans</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans <span class=\"keyword\">if</span> num &gt; <span class=\"number\">0</span> <span class=\"keyword\">else</span> <span class=\"string\">'-'</span>+ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"970-Powerful-Integers\"><a href=\"#970-Powerful-Integers\" class=\"headerlink\" title=\"970. Powerful Integers\"></a>970. Powerful Integers</h3><h4 id=\"求满足x-i-y-j-lt-bound的所有和。原题\"><a href=\"#求满足x-i-y-j-lt-bound的所有和。原题\" class=\"headerlink\" title=\"求满足x^i+y^j &lt;= bound的所有和。原题\"></a>求满足x^i+y^j &lt;= bound的所有和。<a href=\"https://leetcode.com/contest/weekly-contest-118/problems/powerful-integers/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: x &#x3D; 2, y &#x3D; 3, bound &#x3D; 10</span><br><span class=\"line\">Output: [2,3,4,5,7,9,10]</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">2 &#x3D; 2^0 + 3^0</span><br><span class=\"line\">3 &#x3D; 2^1 + 3^0</span><br><span class=\"line\">4 &#x3D; 2^0 + 3^1</span><br><span class=\"line\">5 &#x3D; 2^1 + 3^1</span><br><span class=\"line\">7 &#x3D; 2^2 + 3^1</span><br><span class=\"line\">9 &#x3D; 2^3 + 3^0</span><br><span class=\"line\">10 &#x3D; 2^0 + 3^2</span><br></pre></td></tr></table></figure>\n<p>方法一：这题难得地方在于两个循环的临界值，貌似我这样写也不是最优解，原题的Solution中给定了2**18&gt;bound的最大值。所以两个范围都是18。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">powerfulIntegers</span><span class=\"params\">(self, x, y, bound)</span>:</span></span><br><span class=\"line\">    res = set()</span><br><span class=\"line\">    imax = self.get_max(x, bound) + <span class=\"number\">1</span></span><br><span class=\"line\">    jmax = self.get_max(y, bound) + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(imax):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(jmax):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> x**i + y**j &lt;= bound:</span><br><span class=\"line\">                res.add(x**i+y**j)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list(res)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_max</span><span class=\"params\">(self, n, bound)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(bound//n + <span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> n ** i &gt;= bound:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bound//n + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"973-K-Closest-Points-to-Origin\"><a href=\"#973-K-Closest-Points-to-Origin\" class=\"headerlink\" title=\"973. K Closest Points to Origin\"></a>973. K Closest Points to Origin</h3><h4 id=\"求离原点最近的K个坐标点。原题\"><a href=\"#求离原点最近的K个坐标点。原题\" class=\"headerlink\" title=\"求离原点最近的K个坐标点。原题\"></a>求离原点最近的K个坐标点。<a href=\"https://leetcode.com/contest/weekly-contest-119/problems/k-closest-points-to-origin/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: points &#x3D; [[1,3],[-2,2]], K &#x3D; 1</span><br><span class=\"line\">Output: [[-2,2]]</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">The distance between (1, 3) and the origin is sqrt(10).</span><br><span class=\"line\">The distance between (-2, 2) and the origin is sqrt(8).</span><br><span class=\"line\">Since sqrt(8) &lt; sqrt(10), (-2, 2) is closer to the origin.</span><br><span class=\"line\">We only want the closest K &#x3D; 1 points from the origin, so the answer is just [[-2,2]].</span><br></pre></td></tr></table></figure>\n<p>方法一：很简单。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">kClosest</span><span class=\"params\">(self, points, K)</span>:</span></span><br><span class=\"line\">    res = sorted(points, key=<span class=\"keyword\">lambda</span> x: x[<span class=\"number\">0</span>]**<span class=\"number\">2</span> + x[<span class=\"number\">1</span>]**<span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res[:K]</span><br></pre></td></tr></table></figure>\n<h3 id=\"976-Largest-Perimeter-Triangle\"><a href=\"#976-Largest-Perimeter-Triangle\" class=\"headerlink\" title=\"976. Largest Perimeter Triangle\"></a>976. Largest Perimeter Triangle</h3><h4 id=\"给定一个边长数组，求能组成的三角形的最长周长。原题\"><a href=\"#给定一个边长数组，求能组成的三角形的最长周长。原题\" class=\"headerlink\" title=\"给定一个边长数组，求能组成的三角形的最长周长。原题\"></a>给定一个边长数组，求能组成的三角形的最长周长。<a href=\"https://leetcode.com/contest/weekly-contest-119/problems/largest-perimeter-triangle/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：这个也不难，就是长度为3的滑动窗口。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">largestPerimeter</span><span class=\"params\">(self, A)</span>:</span></span><br><span class=\"line\">    res = sorted(A, reverse=<span class=\"literal\">True</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(res)<span class=\"number\">-2</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> sum(res[i+<span class=\"number\">1</span>:i+<span class=\"number\">3</span>]) &gt; res[i]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> sum(res[i:i+<span class=\"number\">3</span>])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"628-Maximum-Product-of-Three-Numbers\"><a href=\"#628-Maximum-Product-of-Three-Numbers\" class=\"headerlink\" title=\"628. Maximum Product of Three Numbers\"></a>628. Maximum Product of Three Numbers</h3><h4 id=\"数组中三个数的最大乘积。元素范围-1000-1000-。原题\"><a href=\"#数组中三个数的最大乘积。元素范围-1000-1000-。原题\" class=\"headerlink\" title=\"数组中三个数的最大乘积。元素范围[-1000, 1000]。原题\"></a>数组中三个数的最大乘积。元素范围[-1000, 1000]。<a href=\"https://leetcode.com/problems/maximum-product-of-three-numbers/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [1,2,3,4]</span><br><span class=\"line\">Output: 24</span><br></pre></td></tr></table></figure>\n<p>方法一：排序。在正数个数大于等于3的时候，显然最大的三个数就可以产生最大的乘积。而当正数个数不够的时候，那么必须需要两个最小的负数（即绝对值最大），和一个最大的正数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maximumProduct</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">    ary = sorted(nums)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max((ary[<span class=\"number\">0</span>]*ary[<span class=\"number\">1</span>]*ary[<span class=\"number\">-1</span>], ary[<span class=\"number\">-3</span>]*ary[<span class=\"number\">-2</span>]*ary[<span class=\"number\">-1</span>]))</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：使用heapq.</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maximumProduct</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">import</span> heapq</span><br><span class=\"line\">    <span class=\"keyword\">from</span> operator <span class=\"keyword\">import</span> mul</span><br><span class=\"line\">    <span class=\"keyword\">from</span> functools <span class=\"keyword\">import</span> reduce</span><br><span class=\"line\">    three_max = heapq.nlargest(<span class=\"number\">3</span>, nums)</span><br><span class=\"line\">    two_min = heapq.nsmallest(<span class=\"number\">2</span>, nums)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(reduce(mul, three_max), reduce(mul, two_min + three_max[:<span class=\"number\">1</span>]))</span><br></pre></td></tr></table></figure>\n<h3 id=\"728-Self-Dividing-Numbers\"><a href=\"#728-Self-Dividing-Numbers\" class=\"headerlink\" title=\"728. Self Dividing Numbers\"></a>728. Self Dividing Numbers</h3><h4 id=\"自整除数字，一个数字能够被本身的每个数字整除，并且不能有0，求某个范围内所有的数。原题\"><a href=\"#自整除数字，一个数字能够被本身的每个数字整除，并且不能有0，求某个范围内所有的数。原题\" class=\"headerlink\" title=\"自整除数字，一个数字能够被本身的每个数字整除，并且不能有0，求某个范围内所有的数。原题\"></a>自整除数字，一个数字能够被本身的每个数字整除，并且不能有0，求某个范围内所有的数。<a href=\"https://leetcode.com/problems/self-dividing-numbers/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: </span><br><span class=\"line\">left &#x3D; 1, right &#x3D; 22</span><br><span class=\"line\">Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]</span><br></pre></td></tr></table></figure>\n<p>方法一：Brute Force. 此题强行使用列表生成式没有意义。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">selfDividingNumbers</span><span class=\"params\">(self, left, right)</span>:</span></span><br><span class=\"line\">    res = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(left, right+<span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> char <span class=\"keyword\">in</span> str(i):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> int(char)==<span class=\"number\">0</span> <span class=\"keyword\">or</span> i % int(char)!=<span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            res.append(i)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"836-Rectangle-Overlap\"><a href=\"#836-Rectangle-Overlap\" class=\"headerlink\" title=\"836. Rectangle Overlap\"></a>836. Rectangle Overlap</h3><h4 id=\"矩形是否重叠，矩形的边平行于坐标轴。原题\"><a href=\"#矩形是否重叠，矩形的边平行于坐标轴。原题\" class=\"headerlink\" title=\"矩形是否重叠，矩形的边平行于坐标轴。原题\"></a>矩形是否重叠，矩形的边平行于坐标轴。<a href=\"https://leetcode.com/problems/rectangle-overlap/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: rec1 &#x3D; [0,0,2,2], rec2 &#x3D; [1,1,3,3]</span><br><span class=\"line\">Output: true</span><br></pre></td></tr></table></figure>\n<p>方法一：通过画图找出的规律。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isRectangleOverlap</span><span class=\"params\">(self, rec1: <span class=\"string\">'List[int]'</span>, rec2: <span class=\"string\">'List[int]'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\">    x_overlap = (rec2[<span class=\"number\">0</span>]-rec1[<span class=\"number\">2</span>]) * (rec2[<span class=\"number\">2</span>]-rec1[<span class=\"number\">0</span>]) &lt; <span class=\"number\">0</span></span><br><span class=\"line\">    y_overlap = (rec2[<span class=\"number\">1</span>]-rec1[<span class=\"number\">3</span>]) * (rec2[<span class=\"number\">3</span>]-rec1[<span class=\"number\">1</span>]) &lt; <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x_overlap <span class=\"keyword\">and</span> y_overlap</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：方法一还是想复杂了。</font>\n\n<p>Given 2 segment <code>(left1, right1)</code>, <code>(left2, right2)</code>, how can we check whether they overlap?<br>If these two intervals overlap, it should exist an number <code>x</code>,</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">left1 &lt; x &lt; right1 &amp;&amp; left2 &lt; x &lt; right2</span><br><span class=\"line\">left1 &lt; x &lt; right2 &amp;&amp; left2 &lt; x &lt; right1</span><br><span class=\"line\">left1 &lt; right2 &amp;&amp; left2 &lt; right1</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isRectangleOverlap</span><span class=\"params\">(self, rec1: <span class=\"string\">'List[int]'</span>, rec2: <span class=\"string\">'List[int]'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> rec2[<span class=\"number\">0</span>] &lt; rec1[<span class=\"number\">2</span>] <span class=\"keyword\">and</span> rec1[<span class=\"number\">0</span>] &lt; rec2[<span class=\"number\">2</span>] <span class=\"keyword\">and</span> \\</span><br><span class=\"line\">           rec2[<span class=\"number\">1</span>] &lt; rec1[<span class=\"number\">3</span>] <span class=\"keyword\">and</span> rec1[<span class=\"number\">1</span>] &lt; rec2[<span class=\"number\">3</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"991-Broken-Calculator\"><a href=\"#991-Broken-Calculator\" class=\"headerlink\" title=\"991. Broken Calculator\"></a>991. Broken Calculator</h3><h4 id=\"坏掉的计算器，只能-2或者-1，使X变为Y。原题\"><a href=\"#坏掉的计算器，只能-2或者-1，使X变为Y。原题\" class=\"headerlink\" title=\"坏掉的计算器，只能*2或者-1，使X变为Y。原题\"></a>坏掉的计算器，只能*2或者-1，使X变为Y。<a href=\"https://leetcode.com/problems/broken-calculator/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: X &#x3D; 5, Y &#x3D; 8</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: Use decrement and then double &#123;5 -&gt; 4 -&gt; 8&#125;.</span><br></pre></td></tr></table></figure>\n<p>解析：如果从X到Y问题会变得复杂，不确定什么时候该*2或者是-1。所以逆向思维从Y变成X。</p>\n<blockquote>\n<p> If <code>Y &lt;= X</code>, we won’t do <code>Y / 2</code> anymore.<br>We will increase <code>Y</code> until it equals to <code>X</code></p>\n<p>So before that, while <code>Y &gt; X</code>, we’ll keep reducing <code>Y</code>, until it’s smaller than <code>X</code>.<br>If <code>Y</code> is odd, we can do only <code>Y = Y + 1</code><br>If <code>Y</code> is even, if we plus 1 to <code>Y</code>, then <code>Y</code> is odd, we need to plus another 1.<br>And because <code>(Y + 1 + 1) / 2 = (Y / 2) + 1</code>, 3 operations are more than 2.<br>We always choose <code>Y / 2</code> if <code>Y</code> is even.</p>\n</blockquote>\n<p>方法一：iteratively.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">brokenCalc</span><span class=\"params\">(self, X: <span class=\"string\">'int'</span>, Y: <span class=\"string\">'int'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> X &lt; Y:</span><br><span class=\"line\">        ans += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> Y &amp; <span class=\"number\">1</span> == <span class=\"number\">1</span>:</span><br><span class=\"line\">            Y += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            Y //= <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans + X - Y</span><br></pre></td></tr></table></figure>\n<p>方法二：方法一变形。因为如果Y是奇数，那么必定在+1操作后要/2，这里将其合并</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">brokenCalc</span><span class=\"params\">(self, X: <span class=\"string\">'int'</span>, Y: <span class=\"string\">'int'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> X &lt; Y:</span><br><span class=\"line\">        ans += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> Y &amp; <span class=\"number\">1</span> == <span class=\"number\">1</span>:</span><br><span class=\"line\">            Y += <span class=\"number\">1</span></span><br><span class=\"line\">            ans += <span class=\"number\">1</span></span><br><span class=\"line\">        Y = Y // <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans + X - Y</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：方法二再变形，看到Y是奇数时，ans + 2，所以可以用<code>ans += (Y&amp;1) + 1</code>表示，而<code>Y</code>在是奇数时先+1再//2即<code>Y = (Y + 1) // 2</code>，偶数时<code>Y = Y // 2</code>，其实，对于偶数来说<code>Y=(Y+1)//2</code>和<code>Y=Y//2</code>结果一样。所以可以写成。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">brokenCalc</span><span class=\"params\">(self, X: <span class=\"string\">'int'</span>, Y: <span class=\"string\">'int'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> X &lt; Y:</span><br><span class=\"line\">        ans += (Y &amp; <span class=\"number\">1</span>) + <span class=\"number\">1</span></span><br><span class=\"line\">        Y = (Y + <span class=\"number\">1</span>) // <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans + X - Y</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法四：递归写法。<code>Y&amp;1</code>必须括号</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">brokenCalc</span><span class=\"params\">(self, X: <span class=\"string\">'int'</span>, Y: <span class=\"string\">'int'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> X - Y <span class=\"keyword\">if</span> X &gt;= Y <span class=\"keyword\">else</span> <span class=\"number\">1</span>+(Y&amp;<span class=\"number\">1</span>)+self.brokenCalc(X, (Y+<span class=\"number\">1</span>)//<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"908-Smallest-Range-I\"><a href=\"#908-Smallest-Range-I\" class=\"headerlink\" title=\"908. Smallest Range I\"></a>908. Smallest Range I</h3><h4 id=\"给定一个数组，和一个K，数组里的数加上-k-lt-x-lt-k的任意一个数字后，求数组最大数和最小数的，最小差。原题\"><a href=\"#给定一个数组，和一个K，数组里的数加上-k-lt-x-lt-k的任意一个数字后，求数组最大数和最小数的，最小差。原题\" class=\"headerlink\" title=\"给定一个数组，和一个K，数组里的数加上-k&lt;=x&lt;=k的任意一个数字后，求数组最大数和最小数的，最小差。原题\"></a>给定一个数组，和一个K，数组里的数加上-k&lt;=x&lt;=k的任意一个数字后，求数组最大数和最小数的，最小差。<a href=\"https://leetcode.com/problems/smallest-range-i/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: A &#x3D; [0,10], K &#x3D; 2</span><br><span class=\"line\">Output: 6</span><br><span class=\"line\">Explanation: B &#x3D; [2,8]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">smallestRangeI</span><span class=\"params\">(self, A: <span class=\"string\">'List[int]'</span>, K: <span class=\"string\">'int'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(max(A) - min(A) - <span class=\"number\">2</span>*K, <span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"949-Largest-Time-for-Given-Digits\"><a href=\"#949-Largest-Time-for-Given-Digits\" class=\"headerlink\" title=\"949. Largest Time for Given Digits\"></a>949. Largest Time for Given Digits</h3><h4 id=\"给定四个数字，返回能生成的最大时间。24小时制。原题\"><a href=\"#给定四个数字，返回能生成的最大时间。24小时制。原题\" class=\"headerlink\" title=\"给定四个数字，返回能生成的最大时间。24小时制。原题\"></a>给定四个数字，返回能生成的最大时间。24小时制。<a href=\"https://leetcode.com/problems/largest-time-for-given-digits/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [1,2,3,4]</span><br><span class=\"line\">Output: &quot;23:41&quot;</span><br></pre></td></tr></table></figure>\n<p>方法一：排序。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">largestTimeFromDigits</span><span class=\"params\">(self, A: <span class=\"string\">'List[int]'</span>)</span> -&gt; 'str':</span></span><br><span class=\"line\">    p = itertools.permutations(A)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> a, b, c, d <span class=\"keyword\">in</span> sorted(p, reverse=<span class=\"literal\">True</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"number\">0</span> &lt;= a*<span class=\"number\">10</span>+b &lt;= <span class=\"number\">23</span> <span class=\"keyword\">and</span> <span class=\"number\">0</span> &lt;= <span class=\"number\">10</span>*c+d &lt;= <span class=\"number\">59</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">'&#123;&#125;&#123;&#125;:&#123;&#125;&#123;&#125;'</span>.format(a, b, c, d)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">''</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">largestTimeFromDigits</span><span class=\"params\">(self, A: <span class=\"string\">'List[int]'</span>)</span> -&gt; 'str':</span></span><br><span class=\"line\">    p = itertools.permutations(A)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max([<span class=\"string\">'&#123;&#125;&#123;&#125;:&#123;&#125;&#123;&#125;'</span>.format(*d) <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> p </span><br><span class=\"line\">                <span class=\"keyword\">if</span> d[:<span class=\"number\">2</span>] &lt; (<span class=\"number\">2</span>, <span class=\"number\">4</span>) <span class=\"keyword\">and</span> d[<span class=\"number\">2</span>] &lt; <span class=\"number\">6</span>] <span class=\"keyword\">or</span> [<span class=\"string\">''</span>])</span><br></pre></td></tr></table></figure>\n<h3 id=\"914-X-of-a-Kind-in-a-Deck-of-Cards\"><a href=\"#914-X-of-a-Kind-in-a-Deck-of-Cards\" class=\"headerlink\" title=\"914. X of a Kind in a Deck of Cards\"></a>914. X of a Kind in a Deck of Cards</h3><h4 id=\"有这样一堆数字卡牌，问是否存在一个X-gt-2，使得将同样数字的卡牌分为每X个一组，并且刚好所有的卡牌分完。原题\"><a href=\"#有这样一堆数字卡牌，问是否存在一个X-gt-2，使得将同样数字的卡牌分为每X个一组，并且刚好所有的卡牌分完。原题\" class=\"headerlink\" title=\"有这样一堆数字卡牌，问是否存在一个X&gt;=2，使得将同样数字的卡牌分为每X个一组，并且刚好所有的卡牌分完。原题\"></a>有这样一堆数字卡牌，问是否存在一个X&gt;=2，使得将同样数字的卡牌分为每X个一组，并且刚好所有的卡牌分完。<a href=\"https://leetcode.com/problems/x-of-a-kind-in-a-deck-of-cards\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>思路：使用<code>Counter</code>来统计每个数字的个数，然后求这些数字的最大公约数是否大于等于2，这里思路卡了一下，因为没想到最大公约数可以通过<code>reduce</code>来计算，没考虑到是可以累积的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hasGroupsSizeX</span><span class=\"params\">(self, deck)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Counter</span><br><span class=\"line\">    <span class=\"keyword\">from</span> math <span class=\"keyword\">import</span> gcd</span><br><span class=\"line\">    <span class=\"keyword\">from</span> functools <span class=\"keyword\">import</span> reduce</span><br><span class=\"line\">    <span class=\"keyword\">return</span> reduce(gcd, Counter(deck).values()) &gt;= <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"470-Implement-Rand10-Using-Rand7\"><a href=\"#470-Implement-Rand10-Using-Rand7\" class=\"headerlink\" title=\"470. Implement Rand10() Using Rand7()\"></a>470. Implement Rand10() Using Rand7()</h3><h4 id=\"使用rand7实现rand10原题\"><a href=\"#使用rand7实现rand10原题\" class=\"headerlink\" title=\"使用rand7实现rand10原题\"></a>使用<code>rand7</code>实现<code>rand10</code><a href=\"https://leetcode.com/problems/implement-rand10-using-rand7/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: 3</span><br><span class=\"line\">Output: [8,1,10]</span><br></pre></td></tr></table></figure>\n<p>方法一：先将rand7-1变为[0, 6]然后乘7，[0,7,14,21,28,35,42]然后+[0,6]这样能将这6个数均匀地分配到每段中，得到了[0, 48]然后舍弃[40,48]剩下[0,39]然后取余得[0,9]最后加一。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rand10</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">        x = (rand7()<span class=\"number\">-1</span>)*<span class=\"number\">7</span> + rand7()<span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> x &lt; <span class=\"number\">40</span>: </span><br><span class=\"line\">            <span class=\"keyword\">return</span> x%<span class=\"number\">10</span> + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1006-Clumsy-Factorial\"><a href=\"#1006-Clumsy-Factorial\" class=\"headerlink\" title=\"1006. Clumsy Factorial\"></a>1006. Clumsy Factorial</h3><h4 id=\"将一个阶乘的式子用-替代，给出结果。原题\"><a href=\"#将一个阶乘的式子用-替代，给出结果。原题\" class=\"headerlink\" title=\"将一个阶乘的式子用*/+-替代，给出结果。原题\"></a>将一个阶乘的式子用<code>*/+-</code>替代，给出结果。<a href=\"https://leetcode.com/problems/clumsy-factorial/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: 10</span><br><span class=\"line\">Output: 12</span><br><span class=\"line\">Explanation: 12 &#x3D; 10 * 9 &#x2F; 8 + 7 - 6 * 5 &#x2F; 4 + 3 - 2 * 1</span><br></pre></td></tr></table></figure>\n<p>方法一：python此题有作弊的方法，我看排行榜中大神有的特意切到python做这道题，不过没我写得好。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">clumsy</span><span class=\"params\">(self, N: int)</span> -&gt; int:</span></span><br><span class=\"line\">    op = itertools.cycle([<span class=\"string\">'*'</span>, <span class=\"string\">'//'</span>, <span class=\"string\">'+'</span>, <span class=\"string\">'-'</span>])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> eval(<span class=\"string\">''</span>.join(str(n)+next(op) <span class=\"keyword\">if</span> n!=<span class=\"number\">1</span> <span class=\"keyword\">else</span> str(n) </span><br><span class=\"line\">                        <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> range(N, <span class=\"number\">0</span>, <span class=\"number\">-1</span>)))</span><br></pre></td></tr></table></figure>\n<h3 id=\"1022-Smallest-Integer-Divisible-by-K\"><a href=\"#1022-Smallest-Integer-Divisible-by-K\" class=\"headerlink\" title=\"1022. Smallest Integer Divisible by K\"></a>1022. Smallest Integer Divisible by K</h3><h4 id=\"最小的由1组成的能被K整除。原题\"><a href=\"#最小的由1组成的能被K整除。原题\" class=\"headerlink\" title=\"最小的由1组成的能被K整除。原题\"></a>最小的由1组成的能被K整除。<a href=\"https://leetcode.com/problems/smallest-integer-divisible-by-k/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: 2</span><br><span class=\"line\">Output: -1</span><br><span class=\"line\">Explanation: There is no such positive integer N divisible by 2.</span><br></pre></td></tr></table></figure>\n<p>如果有<code>2</code>或<code>5</code>的质因数，那么不能整除。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">smallestRepunitDivByK</span><span class=\"params\">(self, K: int)</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> K % <span class=\"number\">2</span> == <span class=\"number\">0</span> <span class=\"keyword\">or</span> K % <span class=\"number\">5</span> == <span class=\"number\">0</span>: <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    r = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> N <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, K + <span class=\"number\">1</span>):</span><br><span class=\"line\">        r = (r * <span class=\"number\">10</span> + <span class=\"number\">1</span>) % K</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> r: <span class=\"keyword\">return</span> N</span><br></pre></td></tr></table></figure>\n<h3 id=\"1028-Convert-to-Base-2\"><a href=\"#1028-Convert-to-Base-2\" class=\"headerlink\" title=\"1028. Convert to Base -2\"></a>1028. Convert to Base -2</h3><h4 id=\"10进制转成-2进制。原题\"><a href=\"#10进制转成-2进制。原题\" class=\"headerlink\" title=\"10进制转成-2进制。原题\"></a>10进制转成-2进制。<a href=\"https://leetcode.com/problems/convert-to-base-2/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：负数进制时，如果余数为负数，那么商+1。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">baseNeg2</span><span class=\"params\">(self, N: int)</span> -&gt; str:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> N:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'0'</span></span><br><span class=\"line\">    ans = <span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> N:</span><br><span class=\"line\">        remainder = N % (<span class=\"number\">-2</span>)</span><br><span class=\"line\">        ans += str(abs(remainder))</span><br><span class=\"line\">        N //= <span class=\"number\">-2</span></span><br><span class=\"line\">        N += (remainder &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans[::<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<p>方法二：在二进制上加一个负号。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">baseNeg2</span><span class=\"params\">(self, N: int)</span> -&gt; str:</span></span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> N:</span><br><span class=\"line\">        ans.append(N &amp; <span class=\"number\">1</span>)</span><br><span class=\"line\">        N = -(N &gt;&gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(map(str, ans[::<span class=\"number\">-1</span>] <span class=\"keyword\">or</span> [<span class=\"number\">0</span>]))</span><br></pre></td></tr></table></figure>\n<h3 id=\"313-Super-Ugly-Number\"><a href=\"#313-Super-Ugly-Number\" class=\"headerlink\" title=\"313. Super Ugly Number\"></a>313. Super Ugly Number</h3><h4 id=\"根据指定的质数序列，找出第n个超级丑数。原题\"><a href=\"#根据指定的质数序列，找出第n个超级丑数。原题\" class=\"headerlink\" title=\"根据指定的质数序列，找出第n个超级丑数。原题\"></a>根据指定的质数序列，找出第n个超级丑数。<a href=\"https://leetcode.com/problems/super-ugly-number/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>和剑指offer中，丑数一题很像，只不过那题是固定的2,3,5三个质数。</p>\n<p>方法一：根据之前的方法进行微调。时间要1s左右，因为遍历了两次<code>primes</code>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">nthSuperUglyNumber</span><span class=\"params\">(self, n: int, primes: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    ans = [<span class=\"number\">1</span>]</span><br><span class=\"line\">    last_index = [<span class=\"number\">0</span>] * len(primes)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n<span class=\"number\">-1</span>):</span><br><span class=\"line\">        ugly = min(ans[last_index[i]]*p <span class=\"keyword\">for</span> i, p <span class=\"keyword\">in</span> enumerate(primes))</span><br><span class=\"line\">        ans.append(ugly)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, p <span class=\"keyword\">in</span> enumerate(primes):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ans[last_index[i]] * p == ugly:</span><br><span class=\"line\">                last_index[i] += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans[<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：304ms。开始想到了生成器和堆，其他结构差不多，但是生成器内部实现想错了。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">nthSuperUglyNumber</span><span class=\"params\">(self, n: int, primes: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">import</span> heapq <span class=\"keyword\">as</span> hq</span><br><span class=\"line\">    uglies = [<span class=\"number\">1</span>]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">gen_ugly</span><span class=\"params\">(prime)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> ugly <span class=\"keyword\">in</span> uglies:</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> ugly * prime</span><br><span class=\"line\">            </span><br><span class=\"line\">    merged = hq.merge(*map(gen_ugly, primes))</span><br><span class=\"line\">    <span class=\"keyword\">while</span> len(uglies) &lt; n:</span><br><span class=\"line\">        ugly = next(merged)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ugly != uglies[<span class=\"number\">-1</span>]:</span><br><span class=\"line\">            uglies.append(ugly)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> uglies[<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"869-Reordered-Power-of-2\"><a href=\"#869-Reordered-Power-of-2\" class=\"headerlink\" title=\"869. Reordered Power of 2\"></a>869. Reordered Power of 2</h3><h4 id=\"重新排列一个数字的各位数，判断是否能组成2的幂。原题\"><a href=\"#重新排列一个数字的各位数，判断是否能组成2的幂。原题\" class=\"headerlink\" title=\"重新排列一个数字的各位数，判断是否能组成2的幂。原题\"></a>重新排列一个数字的各位数，判断是否能组成2的幂。<a href=\"https://leetcode.com/problems/reordered-power-of-2/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>这题我看到是，显示拆成两个子问题，全排列和判断是否是2的幂，结果超时了，不知道为什么，我看Solution中也有这种解法，我还提交了好几次。</p>\n<p>所以此题需要换一种思路，2的幂是指数上升的，所以，在范围内的数一共也没有几个。那么使用Counter来判断是否能组成这个数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reorderedPowerOf2</span><span class=\"params\">(self, N: int)</span> -&gt; bool:</span></span><br><span class=\"line\">    c = Counter(str(N))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> any(c==Counter(str(<span class=\"number\">1</span>&lt;&lt;i)) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, <span class=\"number\">30</span>))</span><br></pre></td></tr></table></figure>\n<h3 id=\"1025-Divisor-Game\"><a href=\"#1025-Divisor-Game\" class=\"headerlink\" title=\"1025. Divisor Game\"></a>1025. Divisor Game</h3><h4 id=\"两个人做游戏，黑板上有个数N，每次找到一个0-lt-x-lt-N的数，并且N能被x整除，然后替换这个N，直到找不出这样x，就输了。问给出这样一个数N，第一个人是否能赢。原题\"><a href=\"#两个人做游戏，黑板上有个数N，每次找到一个0-lt-x-lt-N的数，并且N能被x整除，然后替换这个N，直到找不出这样x，就输了。问给出这样一个数N，第一个人是否能赢。原题\" class=\"headerlink\" title=\"两个人做游戏，黑板上有个数N，每次找到一个0 &lt;x&lt;N的数，并且N能被x整除，然后替换这个N，直到找不出这样x，就输了。问给出这样一个数N，第一个人是否能赢。原题\"></a>两个人做游戏，黑板上有个数N，每次找到一个0 &lt;x&lt;N的数，并且N能被x整除，然后替换这个N，直到找不出这样x，就输了。问给出这样一个数N，第一个人是否能赢。<a href=\"https://leetcode.com/problems/divisor-game/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：写了一个动态规划，最后一分析实际上只要N为偶数就能赢。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">ans = []</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">divisorGame</span><span class=\"params\">(self, N: int)</span> -&gt; bool:</span></span><br><span class=\"line\">    <span class=\"comment\"># for i in range(1, N+1):</span></span><br><span class=\"line\">    <span class=\"comment\">#     for j in range(1, i):</span></span><br><span class=\"line\">    <span class=\"comment\">#         if i % (i-j)==0 and not ans[j]:</span></span><br><span class=\"line\">    <span class=\"comment\">#             print('&#123;&#125; % &#123;&#125;'.format(i, j))</span></span><br><span class=\"line\">    <span class=\"comment\">#             ans.append(True)</span></span><br><span class=\"line\">    <span class=\"comment\">#             break</span></span><br><span class=\"line\">    <span class=\"comment\">#     # for j in range(1, len(ans)):</span></span><br><span class=\"line\">    <span class=\"comment\">#     #     if i % (i-j)== 0 and not ans[j]:</span></span><br><span class=\"line\">    <span class=\"comment\">#     #         ans.append(True)</span></span><br><span class=\"line\">    <span class=\"comment\">#     #         break</span></span><br><span class=\"line\">    <span class=\"comment\">#     else:</span></span><br><span class=\"line\">    <span class=\"comment\">#         ans.append(False)</span></span><br><span class=\"line\">    <span class=\"comment\">#     print('count &#123;&#125; &#123;&#125;'.format(i, ans[-1]))</span></span><br><span class=\"line\">    <span class=\"comment\"># print(ans)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> N &amp; <span class=\"number\">1</span> == <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1037-Valid-Boomerang\"><a href=\"#1037-Valid-Boomerang\" class=\"headerlink\" title=\"1037. Valid Boomerang\"></a>1037. Valid Boomerang</h3><h4 id=\"验证三个坐标点是否共线。原题\"><a href=\"#验证三个坐标点是否共线。原题\" class=\"headerlink\" title=\"验证三个坐标点是否共线。原题\"></a>验证三个坐标点是否共线。<a href>原题</a></h4><p>方法一：需要注意的是，除数为0 的情况，所以这里改成了乘法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isBoomerang</span><span class=\"params\">(self, points: List[List[int]])</span> -&gt; bool:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (points[<span class=\"number\">1</span>][<span class=\"number\">1</span>]-points[<span class=\"number\">0</span>][<span class=\"number\">1</span>])*(points[<span class=\"number\">2</span>][<span class=\"number\">0</span>]-points[<span class=\"number\">1</span>][<span class=\"number\">0</span>]) != \\</span><br><span class=\"line\">           (points[<span class=\"number\">2</span>][<span class=\"number\">1</span>]-points[<span class=\"number\">1</span>][<span class=\"number\">1</span>])*(points[<span class=\"number\">1</span>][<span class=\"number\">0</span>]-points[<span class=\"number\">0</span>][<span class=\"number\">0</span>])</span><br></pre></td></tr></table></figure>\n<h3 id=\"1041-Robot-Bounded-In-Circle\"><a href=\"#1041-Robot-Bounded-In-Circle\" class=\"headerlink\" title=\"1041. Robot Bounded In Circle\"></a>1041. Robot Bounded In Circle</h3><h4 id=\"一个面向北的机器人进行三种操作，一种是前进，或者向左向右转。问一系列的操作中，无限循环时，机器人是否在绕圈。原题\"><a href=\"#一个面向北的机器人进行三种操作，一种是前进，或者向左向右转。问一系列的操作中，无限循环时，机器人是否在绕圈。原题\" class=\"headerlink\" title=\"一个面向北的机器人进行三种操作，一种是前进，或者向左向右转。问一系列的操作中，无限循环时，机器人是否在绕圈。原题\"></a>一个面向北的机器人进行三种操作，一种是前进，或者向左向右转。问一系列的操作中，无限循环时，机器人是否在绕圈。<a href=\"https://leetcode.com/problems/robot-bounded-in-circle/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：将操作反复4次，判断是否回到原点。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isRobotBounded</span><span class=\"params\">(self, instructions: str)</span> -&gt; bool:</span></span><br><span class=\"line\">    instruction = instructions * <span class=\"number\">4</span></span><br><span class=\"line\">    operations = [(<span class=\"string\">'+0'</span>, <span class=\"string\">'+1'</span>), (<span class=\"string\">'-1'</span>, <span class=\"string\">'+0'</span>), (<span class=\"string\">'+0'</span>, <span class=\"string\">'-1'</span>), (<span class=\"string\">'+1'</span>, <span class=\"string\">'+0'</span>)]</span><br><span class=\"line\">    cur_op = <span class=\"number\">0</span></span><br><span class=\"line\">    x, y = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> inst <span class=\"keyword\">in</span> instruction:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> inst == <span class=\"string\">'G'</span>:</span><br><span class=\"line\">            x_op, y_op = operations[cur_op]</span><br><span class=\"line\">            x, y = eval(str(x)+x_op), eval(str(y)+y_op)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> inst == <span class=\"string\">'L'</span>:</span><br><span class=\"line\">            cur_op = (cur_op+<span class=\"number\">1</span>) % <span class=\"number\">4</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            cur_op = (cur_op<span class=\"number\">-1</span>) % <span class=\"number\">4</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x == y == <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<p>方法二：不需要循环四次，在一次之后，如果面向的不再是北，那么最后将会绕圈。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isRobotBounded</span><span class=\"params\">(self, instructions: str)</span> -&gt; bool:</span></span><br><span class=\"line\">    x, y, dx, dy = <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> inst <span class=\"keyword\">in</span> instructions:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> inst == <span class=\"string\">'G'</span>: x, y = x+dx, y+dy</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> inst == <span class=\"string\">'L'</span>: dx, dy = -dy, dx</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> inst == <span class=\"string\">'R'</span>: dx, dy = dy, -dx</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (x == y == <span class=\"number\">0</span>) <span class=\"keyword\">or</span> (dx, dy) != (<span class=\"number\">0</span>, <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"1137-N-th-Tribonacci-Number\"><a href=\"#1137-N-th-Tribonacci-Number\" class=\"headerlink\" title=\"1137. N-th Tribonacci Number\"></a>1137. N-th Tribonacci Number</h3><h4 id=\"三个数的斐波那契数列。原题\"><a href=\"#三个数的斐波那契数列。原题\" class=\"headerlink\" title=\"三个数的斐波那契数列。原题\"></a>三个数的斐波那契数列。<a href=\"https://leetcode.com/problems/n-th-tribonacci-number/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 4</span><br><span class=\"line\">Output: 4</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">T_3 &#x3D; 0 + 1 + 1 &#x3D; 2</span><br><span class=\"line\">T_4 &#x3D; 1 + 1 + 2 &#x3D; 4</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">tribonacci</span><span class=\"params\">(self, n: int)</span> -&gt; int:</span></span><br><span class=\"line\">    a, b, c = <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">        a, b, c = b, c, a+b+c</span><br><span class=\"line\">    <span class=\"keyword\">return</span> c</span><br></pre></td></tr></table></figure>\n<h3 id=\"1073-Adding-Two-Negabinary-Numbers\"><a href=\"#1073-Adding-Two-Negabinary-Numbers\" class=\"headerlink\" title=\"1073. Adding Two Negabinary Numbers\"></a>1073. Adding Two Negabinary Numbers</h3><h4 id=\"两个-2进制的数相加。原题\"><a href=\"#两个-2进制的数相加。原题\" class=\"headerlink\" title=\"两个-2进制的数相加。原题\"></a>两个-2进制的数相加。<a href=\"https://leetcode.com/problems/adding-two-negabinary-numbers/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：转成十进制相加，再转回-2进制。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addNegabinary</span><span class=\"params\">(self, arr1: List[int], arr2: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">to_ten</span><span class=\"params\">(arr)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum(d*(<span class=\"number\">-2</span>)**i <span class=\"keyword\">for</span> i, d <span class=\"keyword\">in</span> enumerate(arr[::<span class=\"number\">-1</span>]))</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">to_neg_binary</span><span class=\"params\">(n)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> n:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">'0'</span></span><br><span class=\"line\">        ans = <span class=\"string\">''</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> n:</span><br><span class=\"line\">            remainder = n % (<span class=\"number\">-2</span>)</span><br><span class=\"line\">            ans += str(abs(remainder))</span><br><span class=\"line\">            n //= <span class=\"number\">-2</span></span><br><span class=\"line\">            n += (remainder &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans[::<span class=\"number\">-1</span>]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> to_neg_binary(to_ten(arr1) + to_ten(arr2))</span><br></pre></td></tr></table></figure>\n<h3 id=\"1154-Day-of-the-Year\"><a href=\"#1154-Day-of-the-Year\" class=\"headerlink\" title=\"1154. Day of the Year\"></a>1154. Day of the Year</h3><h4 id=\"根据输入的日期，返回它是一年中的第几天。原题\"><a href=\"#根据输入的日期，返回它是一年中的第几天。原题\" class=\"headerlink\" title=\"根据输入的日期，返回它是一年中的第几天。原题\"></a>根据输入的日期，返回它是一年中的第几天。<a href=\"https://leetcode.com/problems/ordinal-number-of-date/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：使用了datetime库，开始还自己手动减，后来看评论发现有这样的方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dayOfYear</span><span class=\"params\">(self, date: str)</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">import</span> datetime</span><br><span class=\"line\">    date = datetime.datetime.strptime(date, <span class=\"string\">'%Y-%m-%d'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> date.timetuple().tm_yday</span><br></pre></td></tr></table></figure>\n<h3 id=\"1155-Number-of-Dice-Rolls-With-Target-Sum\"><a href=\"#1155-Number-of-Dice-Rolls-With-Target-Sum\" class=\"headerlink\" title=\"1155. Number of Dice Rolls With Target Sum\"></a>1155. Number of Dice Rolls With Target Sum</h3><h4 id=\"扔一个f面的-骰子d次，结果为target的次数。原题\"><a href=\"#扔一个f面的-骰子d次，结果为target的次数。原题\" class=\"headerlink\" title=\"扔一个f面的 骰子d次，结果为target的次数。原题\"></a>扔一个f面的 骰子d次，结果为target的次数。<a href=\"https://leetcode.com/problems/number-of-dice-rolls-with-target-sum/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: d &#x3D; 2, f &#x3D; 6, target &#x3D; 7</span><br><span class=\"line\">Output: 6</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">You throw two dice, each with 6 faces.  There are 6 ways to get a sum of 7:</span><br><span class=\"line\">1+6, 2+5, 3+4, 4+3, 5+2, 6+1.</span><br></pre></td></tr></table></figure>\n<p>方法一：竞赛时用的数组，后来发现字典效率更高。此题和剑指offer中骰子题类似。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numRollsToTarget</span><span class=\"params\">(self, d: int, f: int, target: int)</span> -&gt; int:</span></span><br><span class=\"line\">    last_p = collections.defaultdict(int)</span><br><span class=\"line\">    last_p.update(&#123;d: <span class=\"number\">1</span> <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, f+<span class=\"number\">1</span>)&#125;)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>, d+<span class=\"number\">1</span>):</span><br><span class=\"line\">        new_p = collections.defaultdict(int)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i, i*f+<span class=\"number\">1</span>):</span><br><span class=\"line\">            new_p[j] = sum(last_p[j-k] <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, f+<span class=\"number\">1</span>))</span><br><span class=\"line\">        last_p = new_p</span><br><span class=\"line\">    <span class=\"keyword\">return</span> last_p[target] % (<span class=\"number\">10</span>**<span class=\"number\">9</span>+<span class=\"number\">7</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"1093-Statistics-from-a-Large-Sample\"><a href=\"#1093-Statistics-from-a-Large-Sample\" class=\"headerlink\" title=\"1093. Statistics from a Large Sample\"></a>1093. Statistics from a Large Sample</h3><h4 id=\"统计大量的样本数据，求最小值，最大值，平均值，众数。原题\"><a href=\"#统计大量的样本数据，求最小值，最大值，平均值，众数。原题\" class=\"headerlink\" title=\"统计大量的样本数据，求最小值，最大值，平均值，众数。原题\"></a>统计大量的样本数据，求最小值，最大值，平均值，众数。<a href=\"https://leetcode.com/problems/statistics-from-a-large-sample/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: count &#x3D; [0,1,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]</span><br><span class=\"line\">Output: [1.00000,3.00000,2.37500,2.50000,3.00000]</span><br></pre></td></tr></table></figure>\n<p>方法一：中位数的求法这里没想到，使用二分可以完美的解决奇偶问题。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sampleStats</span><span class=\"params\">(self, count: List[int])</span> -&gt; List[float]:</span></span><br><span class=\"line\">    n = sum(count)</span><br><span class=\"line\">    mi = next(i <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">255</span>) <span class=\"keyword\">if</span> count[i]) * <span class=\"number\">1.0</span></span><br><span class=\"line\">    ma = next(i <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">255</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>) <span class=\"keyword\">if</span> count[i]) * <span class=\"number\">1.0</span></span><br><span class=\"line\">    mean = sum(i * val <span class=\"keyword\">for</span> i, val <span class=\"keyword\">in</span> enumerate(count)) * <span class=\"number\">1.0</span> / n</span><br><span class=\"line\">    mode = count.index(max(count)) * <span class=\"number\">1.0</span></span><br><span class=\"line\">    cc = list(itertools.accumulate(count))</span><br><span class=\"line\">    left = bisect.bisect(cc, (n<span class=\"number\">-1</span>)//<span class=\"number\">2</span>)</span><br><span class=\"line\">    right = bisect.bisect(cc, n//<span class=\"number\">2</span>)</span><br><span class=\"line\">    median = (left + right) / <span class=\"number\">2.0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> mi, ma, mean, median, mode</span><br></pre></td></tr></table></figure>\n<h3 id=\"1103-Distribute-Candies-to-People\"><a href=\"#1103-Distribute-Candies-to-People\" class=\"headerlink\" title=\"1103. Distribute Candies to People\"></a>1103. Distribute Candies to People</h3><h4 id=\"发糖果，按照顺序每个人比上一人多一颗，发到最后再循环。原题\"><a href=\"#发糖果，按照顺序每个人比上一人多一颗，发到最后再循环。原题\" class=\"headerlink\" title=\"发糖果，按照顺序每个人比上一人多一颗，发到最后再循环。原题\"></a>发糖果，按照顺序每个人比上一人多一颗，发到最后再循环。<a href=\"https://leetcode.com/problems/distribute-candies-to-people/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: candies &#x3D; 7, num_people &#x3D; 4</span><br><span class=\"line\">Output: [1,2,3,1]</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">On the first turn, ans[0] +&#x3D; 1, and the array is [1,0,0,0].</span><br><span class=\"line\">On the second turn, ans[1] +&#x3D; 2, and the array is [1,2,0,0].</span><br><span class=\"line\">On the third turn, ans[2] +&#x3D; 3, and the array is [1,2,3,0].</span><br><span class=\"line\">On the fourth turn, ans[3] +&#x3D; 1 (because there is only one candy left), and the final array is [1,2,3,1].</span><br></pre></td></tr></table></figure>\n<p>方法一：此题做法和Lee神不谋而合。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">distributeCandies</span><span class=\"params\">(self, candies: int, n: int)</span> -&gt; List[int]:</span></span><br><span class=\"line\">    ans = [<span class=\"number\">0</span>] * n</span><br><span class=\"line\">    cur = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> candies &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">        ans[cur%n<span class=\"number\">-1</span>] += min(candies, cur)</span><br><span class=\"line\">        candies -= cur</span><br><span class=\"line\">        cur += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"1109-Corporate-Flight-Bookings\"><a href=\"#1109-Corporate-Flight-Bookings\" class=\"headerlink\" title=\"1109. Corporate Flight Bookings\"></a>1109. Corporate Flight Bookings</h3><h4 id=\"通过给定的一些区间，确定每天的座位数。原题\"><a href=\"#通过给定的一些区间，确定每天的座位数。原题\" class=\"headerlink\" title=\"通过给定的一些区间，确定每天的座位数。原题\"></a>通过给定的一些区间，确定每天的座位数。<a href=\"https://leetcode.com/problems/corporate-flight-bookings/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: bookings &#x3D; [[1,2,10],[2,3,20],[2,5,25]], n &#x3D; 5</span><br><span class=\"line\">Output: [10,55,45,25,25]</span><br></pre></td></tr></table></figure>\n<p>方法一：此题暴力法会超时。核心在于记录变化的状态，然后累加求结果。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">corpFlightBookings</span><span class=\"params\">(self, bookings: List[List[int]], n: int)</span> -&gt; List[int]:</span></span><br><span class=\"line\">    ans = [<span class=\"number\">0</span>] * (n+<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> s, e, v <span class=\"keyword\">in</span> bookings:</span><br><span class=\"line\">        ans[s<span class=\"number\">-1</span>] += v</span><br><span class=\"line\">        ans[e] -= v</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list(itertools.accumulate(ans))[:<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"1175-Prime-Arrangements\"><a href=\"#1175-Prime-Arrangements\" class=\"headerlink\" title=\"1175. Prime Arrangements\"></a>1175. Prime Arrangements</h3><h4 id=\"质数排列。原题\"><a href=\"#质数排列。原题\" class=\"headerlink\" title=\"质数排列。原题\"></a>质数排列。<a href=\"https://leetcode.com/problems/prime-arrangements/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 5</span><br><span class=\"line\">Output: 12</span><br><span class=\"line\">Explanation: For example [1,2,5,4,3] is a valid permutation, but [5,2,3,4,1] is not because the prime number 5 is at index 1.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numPrimeArrangements</span><span class=\"params\">(self, n: int)</span> -&gt; int:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countPrimes</span><span class=\"params\">(n)</span>:</span></span><br><span class=\"line\">        is_prime = [<span class=\"literal\">False</span>]*<span class=\"number\">2</span> + [<span class=\"literal\">True</span>]*(n<span class=\"number\">-2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>, int(n ** <span class=\"number\">0.5</span>)+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> is_prime[i]:</span><br><span class=\"line\">                is_prime[i*i:n:i] = [<span class=\"literal\">False</span>] * len(is_prime[i*i:n:i])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum(is_prime)</span><br><span class=\"line\">    c = countPrimes(n+<span class=\"number\">1</span>)</span><br><span class=\"line\">    ans = math.factorial(c) * math.factorial(n-c)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans % (<span class=\"number\">10</span>**<span class=\"number\">9</span>+<span class=\"number\">7</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"1360-Number-of-Days-Between-Two-Dates\"><a href=\"#1360-Number-of-Days-Between-Two-Dates\" class=\"headerlink\" title=\"1360. Number of Days Between Two Dates\"></a>1360. Number of Days Between Two Dates</h3><h4 id=\"计算两个日期之间的天数。原题\"><a href=\"#计算两个日期之间的天数。原题\" class=\"headerlink\" title=\"计算两个日期之间的天数。原题\"></a>计算两个日期之间的天数。<a href=\"https://leetcode.com/problems/number-of-days-between-two-dates/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: date1 &#x3D; &quot;2020-01-15&quot;, date2 &#x3D; &quot;2019-12-31&quot;</span><br><span class=\"line\">Output: 15</span><br></pre></td></tr></table></figure>\n<p>方法一：简单的<code>datetime</code>模块方式。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">daysBetweenDates</span><span class=\"params\">(self, date1: str, date2: str)</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</span><br><span class=\"line\">    d1 = datetime.strptime(date1, <span class=\"string\">'%Y-%m-%d'</span>)</span><br><span class=\"line\">    d2 = datetime.strptime(date2, <span class=\"string\">'%Y-%m-%d'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> abs((d2-d1).days)</span><br></pre></td></tr></table></figure>\n<p>方法二：有个公式，如果将1月二月看成是13月和14月，那么月份转化天数有个公式<code>(153 * m + 8) // 5</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">daysBetweenDates</span><span class=\"params\">(self, date1: str, date2: str)</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(date)</span>:</span></span><br><span class=\"line\">        y, m, d = map(int, date.split(<span class=\"string\">'-'</span>))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> m &lt; <span class=\"number\">3</span>:</span><br><span class=\"line\">            m += <span class=\"number\">12</span></span><br><span class=\"line\">            y -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">365</span> * y + y // <span class=\"number\">4</span> + y // <span class=\"number\">400</span> - y // <span class=\"number\">100</span> + d + (<span class=\"number\">153</span> * m + <span class=\"number\">8</span>) // <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> abs(f(date1) - f(date2))</span><br></pre></td></tr></table></figure>\n<h3 id=\"1363-Largest-Multiple-of-Three\"><a href=\"#1363-Largest-Multiple-of-Three\" class=\"headerlink\" title=\"1363. Largest Multiple of Three\"></a>1363. Largest Multiple of Three</h3><h4 id=\"组成的最大的3的倍数。原题\"><a href=\"#组成的最大的3的倍数。原题\" class=\"headerlink\" title=\"组成的最大的3的倍数。原题\"></a>组成的最大的3的倍数。<a href=\"https://leetcode.com/problems/largest-multiple-of-three/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: digits &#x3D; [8,1,9]</span><br><span class=\"line\">Output: &quot;981</span><br></pre></td></tr></table></figure>\n<p>方法一：数学。</p>\n<ol>\n<li>Calculate the sum of digits <code>total = sum(A)</code></li>\n<li>If <code>total % 3 == 0</code>, we got it directly</li>\n<li>If <code>total % 3 == 1</code> and we have one of 1,4,7 in A:<br>we try to remove one digit of 1,4,7</li>\n<li>If <code>total % 3 == 2</code> and we have one of 2,5,8 in A:<br>we try to remove one digit of 2,5,8</li>\n<li>If <code>total % 3 == 2</code>:<br>we try to remove two digits of 1,4,7</li>\n<li>If <code>total % 3 == 1</code>:<br>we try to remove two digits of 2,5,8</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">largestMultipleOfThree</span><span class=\"params\">(self, A)</span>:</span></span><br><span class=\"line\">    total = sum(A)</span><br><span class=\"line\">    count = collections.Counter(A)</span><br><span class=\"line\">    A.sort(reverse=<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(i)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> count[i]:</span><br><span class=\"line\">            A.remove(i)</span><br><span class=\"line\">            count[i] -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> A: <span class=\"keyword\">return</span> <span class=\"string\">''</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> any(A): <span class=\"keyword\">return</span> <span class=\"string\">'0'</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> sum(A) % <span class=\"number\">3</span> == <span class=\"number\">0</span>: <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(map(str, A))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> total % <span class=\"number\">3</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f(<span class=\"number\">-1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> total % <span class=\"number\">3</span> == <span class=\"number\">1</span> <span class=\"keyword\">and</span> count[<span class=\"number\">1</span>] + count[<span class=\"number\">4</span>] + count[<span class=\"number\">7</span>]:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f(<span class=\"number\">1</span>) <span class=\"keyword\">or</span> f(<span class=\"number\">4</span>) <span class=\"keyword\">or</span> f(<span class=\"number\">7</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> total % <span class=\"number\">3</span> == <span class=\"number\">2</span> <span class=\"keyword\">and</span> count[<span class=\"number\">2</span>] + count[<span class=\"number\">5</span>] + count[<span class=\"number\">8</span>]:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f(<span class=\"number\">2</span>) <span class=\"keyword\">or</span> f(<span class=\"number\">5</span>) <span class=\"keyword\">or</span> f(<span class=\"number\">8</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> total % <span class=\"number\">3</span> == <span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f(<span class=\"number\">1</span>) <span class=\"keyword\">or</span> f(<span class=\"number\">1</span>) <span class=\"keyword\">or</span> f(<span class=\"number\">4</span>) <span class=\"keyword\">or</span> f(<span class=\"number\">4</span>) <span class=\"keyword\">or</span> f(<span class=\"number\">7</span>) <span class=\"keyword\">or</span> f(<span class=\"number\">7</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f(<span class=\"number\">2</span>) <span class=\"keyword\">or</span> f(<span class=\"number\">2</span>) <span class=\"keyword\">or</span> f(<span class=\"number\">5</span>) <span class=\"keyword\">or</span> f(<span class=\"number\">5</span>) <span class=\"keyword\">or</span> f(<span class=\"number\">8</span>) <span class=\"keyword\">or</span> f(<span class=\"number\">8</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"1493-Longest-Subarray-of-1’s-After-Deleting-One-Element\"><a href=\"#1493-Longest-Subarray-of-1’s-After-Deleting-One-Element\" class=\"headerlink\" title=\"1493. Longest Subarray of 1’s After Deleting One Element\"></a>1493. Longest Subarray of 1’s After Deleting One Element</h3><h4 id=\"删除一个元素，子数组有最长的1、子数组长度。原题\"><a href=\"#删除一个元素，子数组有最长的1、子数组长度。原题\" class=\"headerlink\" title=\"删除一个元素，子数组有最长的1、子数组长度。原题\"></a>删除一个元素，子数组有最长的1、子数组长度。<a href=\"https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [1,1,0,1]</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: After deleting the number in position 2, [1,1,1] contains 3 numbers with value of 1&#39;s.</span><br></pre></td></tr></table></figure>\n<p>方法一：双端队列，其实是求最多包含1个0的滑动窗口长度。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestSubarray</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    ans = k = <span class=\"number\">0</span></span><br><span class=\"line\">    q = collections.deque()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        q.append(num)</span><br><span class=\"line\">        k += num==<span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> k == <span class=\"number\">2</span>:</span><br><span class=\"line\">            <span class=\"keyword\">while</span> q.popleft()!=<span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">pass</span></span><br><span class=\"line\">            k -= <span class=\"number\">1</span></span><br><span class=\"line\">        ans = max(ans, len(q)<span class=\"number\">-1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法二：Lee215的解法，还是选择维持了一个最大的长度，所以没用while 而是if，这样也不用每次max来求值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestSubarray</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    k, i = <span class=\"number\">1</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(nums)):</span><br><span class=\"line\">        k -= nums[j]==<span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> k &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            k += nums[i]==<span class=\"number\">0</span></span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> j - i</span><br></pre></td></tr></table></figure>\n<h3 id=\"537-Complex-Number-Multiplication\"><a href=\"#537-Complex-Number-Multiplication\" class=\"headerlink\" title=\"537. Complex Number Multiplication\"></a>537. Complex Number Multiplication</h3><h4 id=\"两个负数相乘。求结果，需要注意的是这里会多一个-。原题\"><a href=\"#两个负数相乘。求结果，需要注意的是这里会多一个-。原题\" class=\"headerlink\" title=\"两个负数相乘。求结果，需要注意的是这里会多一个+。原题\"></a>两个负数相乘。求结果，需要注意的是这里会多一个+。<a href=\"https://leetcode.com/problems/complex-number-multiplication/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: &quot;1+-1i&quot;, &quot;1+-1i&quot;</span><br><span class=\"line\">Output: &quot;0+-2i&quot;</span><br><span class=\"line\">Explanation: (1 - i) * (1 - i) &#x3D; 1 + i2 - 2 * i &#x3D; -2i, and you need convert it to the form of 0+-2i.</span><br></pre></td></tr></table></figure>\n<p>方法一：内置库。这里format时不能用d，因为都是float。但是%却可以做到。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">complexNumberMultiply</span><span class=\"params\">(self, a: str, b: str)</span> -&gt; str:</span></span><br><span class=\"line\">    a = complex(a.replace(<span class=\"string\">'+-'</span>, <span class=\"string\">'-'</span>).replace(<span class=\"string\">'i'</span>, <span class=\"string\">'j'</span>))</span><br><span class=\"line\">    b = complex(b.replace(<span class=\"string\">'+-'</span>, <span class=\"string\">'-'</span>).replace(<span class=\"string\">'i'</span>, <span class=\"string\">'j'</span>))</span><br><span class=\"line\">    c = a * b</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'&#123;:.0f&#125;+&#123;:.0f&#125;i'</span>.format(c.real, c.imag)</span><br><span class=\"line\">\t<span class=\"comment\"># return '%d+%di' % (c.real, c.imag)</span></span><br></pre></td></tr></table></figure>\n<p>方法二：不用内置库。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">complexNumberMultiply</span><span class=\"params\">(self, a: str, b: str)</span> -&gt; str:</span></span><br><span class=\"line\">    a_real, a_imag = map(int, re.match(<span class=\"string\">r'(\\-?\\d+)\\+(\\-?\\d+)i'</span>, a).groups())</span><br><span class=\"line\">    b_real, b_imag = map(int, re.match(<span class=\"string\">r'(\\-?\\d+)\\+(\\-?\\d+)i'</span>, b).groups())</span><br><span class=\"line\">    real = a_real*b_real - a_imag*b_imag</span><br><span class=\"line\">    imag = a_real*b_imag + b_real*a_imag</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'&#123;&#125;+&#123;&#125;i'</span>.format(real, imag)</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：我还搁这groups呢，人家stefan一行就搞定了。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">complexNumberMultiply</span><span class=\"params\">(self, a, b)</span>:</span></span><br><span class=\"line\">    a, ai, b, bi = map(int, re.findall(<span class=\"string\">'-?\\d+'</span>, a+b))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'%d+%di'</span> % (a*b - ai*bi, a*bi + ai*b)</span><br></pre></td></tr></table></figure>\n<h3 id=\"794-Valid-Tic-Tac-Toe-State\"><a href=\"#794-Valid-Tic-Tac-Toe-State\" class=\"headerlink\" title=\"794. Valid Tic-Tac-Toe State\"></a>794. Valid Tic-Tac-Toe State</h3><h4 id=\"在一个九宫格里下棋，谁连上3个就算赢，问给出一个棋子局面，判断是否可能下出来。原题\"><a href=\"#在一个九宫格里下棋，谁连上3个就算赢，问给出一个棋子局面，判断是否可能下出来。原题\" class=\"headerlink\" title=\"在一个九宫格里下棋，谁连上3个就算赢，问给出一个棋子局面，判断是否可能下出来。原题\"></a>在一个九宫格里下棋，谁连上3个就算赢，问给出一个棋子局面，判断是否可能下出来。<a href=\"https://leetcode.com/problems/valid-tic-tac-toe-state/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：case挺多的，需要想明白判断条件，基本就是请求x,o的分别连3的个数，然后和分别的棋子数，最后判断。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">validTicTacToe</span><span class=\"params\">(self, b: List[str])</span> -&gt; bool:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    fb = <span class=\"string\">''</span>.join(b)</span><br><span class=\"line\">    x_cnt, o_cnt = fb.count(<span class=\"string\">'X'</span>), fb.count(<span class=\"string\">'O'</span>)</span><br><span class=\"line\">    cnt = &#123;<span class=\"string\">'X'</span>: <span class=\"number\">0</span>, <span class=\"string\">'O'</span>: <span class=\"number\">0</span>&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> b:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(set(row))==<span class=\"number\">1</span> <span class=\"keyword\">and</span> row[<span class=\"number\">0</span>]!=<span class=\"string\">' '</span>:</span><br><span class=\"line\">            cnt[row[<span class=\"number\">0</span>]] += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> col <span class=\"keyword\">in</span> zip(*b):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(set(col))==<span class=\"number\">1</span> <span class=\"keyword\">and</span> col[<span class=\"number\">0</span>]!=<span class=\"string\">' '</span>:</span><br><span class=\"line\">            cnt[col[<span class=\"number\">0</span>]] += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> b[<span class=\"number\">1</span>][<span class=\"number\">1</span>] != <span class=\"string\">' '</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(set(b[i][i] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">3</span>))) == <span class=\"number\">1</span>:</span><br><span class=\"line\">            cnt[b[<span class=\"number\">1</span>][<span class=\"number\">1</span>]] += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(set(b[i][<span class=\"number\">2</span>-i] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">3</span>))) == <span class=\"number\">1</span>:</span><br><span class=\"line\">            cnt[b[<span class=\"number\">1</span>][<span class=\"number\">1</span>]] += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"comment\"># print(x_cnt, o_cnt, cnt)  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> o_cnt&lt;=x_cnt&lt;=o_cnt+<span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> cnt[<span class=\"string\">'X'</span>] <span class=\"keyword\">and</span> x_cnt!=o_cnt+<span class=\"number\">1</span>: </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> cnt[<span class=\"string\">'O'</span>] <span class=\"keyword\">and</span> (cnt[<span class=\"string\">'X'</span>] <span class=\"keyword\">or</span> x_cnt!=o_cnt):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：stefan的答案，判断精简了，求连子过程也精简了。当X&gt;O时，那么O必然没有连3。相等时，X必然没有连3。用了一个切片求出是否出现了连3。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">b = <span class=\"string\">'|'</span>.join(board)</span><br><span class=\"line\">    x, o = (any(p*<span class=\"number\">3</span> <span class=\"keyword\">in</span> b[s::d] <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> range(<span class=\"number\">9</span>) <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> (<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)) <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> <span class=\"string\">'XO'</span>)</span><br><span class=\"line\">    m = b.count(<span class=\"string\">'X'</span>) - b.count(<span class=\"string\">'O'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m == (<span class=\"keyword\">not</span> o) <span class=\"keyword\">if</span> m <span class=\"keyword\">else</span> <span class=\"keyword\">not</span> x</span><br></pre></td></tr></table></figure>\n<h3 id=\"227-Basic-Calculator-II\"><a href=\"#227-Basic-Calculator-II\" class=\"headerlink\" title=\"227. Basic Calculator II\"></a>227. Basic Calculator II</h3><h4 id=\"计算式子，没有括号，包含加减乘除和小数点。原题\"><a href=\"#计算式子，没有括号，包含加减乘除和小数点。原题\" class=\"headerlink\" title=\"计算式子，没有括号，包含加减乘除和小数点。原题\"></a>计算式子，没有括号，包含加减乘除和小数点。<a href=\"https://leetcode.com/problems/basic-calculator-ii/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: &quot; 3+5 &#x2F; 2 &quot;</span><br><span class=\"line\">Output: 5</span><br></pre></td></tr></table></figure>\n<p>方法一：eval算是作弊了，这个stefan的方法不错。用了生成器。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">calculate</span><span class=\"params\">(self, s: str)</span> -&gt; int:</span></span><br><span class=\"line\">    tokens = iter(re.findall(<span class=\"string\">'\\d+|\\S'</span>, s))</span><br><span class=\"line\">    total, sign = <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> token <span class=\"keyword\">in</span> tokens:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> token <span class=\"keyword\">in</span> <span class=\"string\">'+-'</span>:</span><br><span class=\"line\">            total += sign * term</span><br><span class=\"line\">            sign = <span class=\"string\">' +'</span>.find(token)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> token <span class=\"keyword\">in</span> <span class=\"string\">'*/'</span>:</span><br><span class=\"line\">            n = int(next(tokens))</span><br><span class=\"line\">            term = term*n <span class=\"keyword\">if</span> token == <span class=\"string\">'*'</span> <span class=\"keyword\">else</span> term//n</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            term = int(token)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> total + sign * term</span><br></pre></td></tr></table></figure>\n<h3 id=\"640-Solve-the-Equation\"><a href=\"#640-Solve-the-Equation\" class=\"headerlink\" title=\"640. Solve the Equation\"></a>640. Solve the Equation</h3><h4 id=\"解方程，方程中只有x一个变量，只有加减操作。原题\"><a href=\"#解方程，方程中只有x一个变量，只有加减操作。原题\" class=\"headerlink\" title=\"解方程，方程中只有x一个变量，只有加减操作。原题\"></a>解方程，方程中只有x一个变量，只有加减操作。<a href=\"https://leetcode.com/problems/solve-the-equation/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: &quot;x+5-3+x&#x3D;6+x-2&quot;</span><br><span class=\"line\">Output: &quot;x&#x3D;2&quot;</span><br><span class=\"line\">Input: &quot;x&#x3D;x&quot;</span><br><span class=\"line\">Output: &quot;Infinite solutions&quot;</span><br><span class=\"line\">Input: &quot;2x+3x-6x&#x3D;x+2&quot;</span><br><span class=\"line\">Output: &quot;x&#x3D;-1&quot;</span><br></pre></td></tr></table></figure>\n<p>方法一：首次AC的方法。正则调了半天，因为不止一为数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">solveEquation</span><span class=\"params\">(self, equation: str)</span> -&gt; str:</span></span><br><span class=\"line\">    left, right = equation.split(<span class=\"string\">'='</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">short</span><span class=\"params\">(s)</span>:</span></span><br><span class=\"line\">        coe, d = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">        vs = re.findall(<span class=\"string\">r'[+|-]?\\d+x|[+|-]?\\d+|[+|-]?x'</span>, s)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> v <span class=\"keyword\">in</span> vs:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"string\">'x'</span> <span class=\"keyword\">in</span> v:</span><br><span class=\"line\">                c = v[:<span class=\"number\">-1</span>]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> c <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> c[<span class=\"number\">-1</span>].isdigit():</span><br><span class=\"line\">                    c += <span class=\"string\">'1'</span></span><br><span class=\"line\">                coe += int(c)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                d += int(v)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> coe, d</span><br><span class=\"line\">    </span><br><span class=\"line\">    l_c, l_d = short(left)</span><br><span class=\"line\">    r_c, r_d = short(right)</span><br><span class=\"line\">    f_c, f_d = l_c-r_c, r_d-l_d</span><br><span class=\"line\">    <span class=\"keyword\">if</span> f_c == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"string\">'No solution'</span>, <span class=\"string\">'Infinite solutions'</span>)[f_d==<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'x=&#123;&#125;'</span>.format(f_d//f_c)</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：看了stefan的答案。replace呀，这种题可以替换一些字符串产生简单的操作。复数的操作我在想的时候思路一闪而过，然后不知道怎么实现就没往下想。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">solveEquation</span><span class=\"params\">(self, equation: str)</span> -&gt; str:</span></span><br><span class=\"line\">    z = eval(equation.replace(<span class=\"string\">'x'</span>, <span class=\"string\">'j'</span>).replace(<span class=\"string\">'='</span>, <span class=\"string\">'-('</span>) + <span class=\"string\">')'</span>, &#123;<span class=\"string\">'j'</span>: <span class=\"number\">1j</span>&#125;)</span><br><span class=\"line\">    a, x = z.real, -z.imag</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'x=%d'</span> % (a / x) <span class=\"keyword\">if</span> x <span class=\"keyword\">else</span> <span class=\"string\">'No solution'</span> <span class=\"keyword\">if</span> a <span class=\"keyword\">else</span> <span class=\"string\">'Infinite solutions'</span></span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：左右可以一起算，通过=来改变一个符号。+的变成-，-变成+，正则分成4个组没有想到。头铁就想把它们塞到一起，那样反而判断得更多了。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">solveEquation</span><span class=\"params\">(self, equation: str)</span> -&gt; str:</span></span><br><span class=\"line\">    x = a = <span class=\"number\">0</span></span><br><span class=\"line\">    side = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> eq, sign, num, isx <span class=\"keyword\">in</span> re.findall(<span class=\"string\">'(=)|([-+]?)(\\d*)(x?)'</span>, equation):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> eq:</span><br><span class=\"line\">            side = <span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> isx:</span><br><span class=\"line\">            x += side * int(sign + <span class=\"string\">'1'</span>) * int(num <span class=\"keyword\">or</span> <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> num:</span><br><span class=\"line\">            a -= side * int(sign + num)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'x=%d'</span> % (a / x) <span class=\"keyword\">if</span> x <span class=\"keyword\">else</span> <span class=\"string\">'No solution'</span> <span class=\"keyword\">if</span> a <span class=\"keyword\">else</span> <span class=\"string\">'Infinite solutions'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"319-Bulb-Switcher\"><a href=\"#319-Bulb-Switcher\" class=\"headerlink\" title=\"319. Bulb Switcher\"></a>319. Bulb Switcher</h3><h4 id=\"有n个开关控制n个初始化为关的灯泡。从1开始，每次隔1-2-3-4-n开这些开关，问最后有多少个开着的灯。原题\"><a href=\"#有n个开关控制n个初始化为关的灯泡。从1开始，每次隔1-2-3-4-n开这些开关，问最后有多少个开着的灯。原题\" class=\"headerlink\" title=\"有n个开关控制n个初始化为关的灯泡。从1开始，每次隔1,2,3,4..n开这些开关，问最后有多少个开着的灯。原题\"></a>有n个开关控制n个初始化为关的灯泡。从1开始，每次隔1,2,3,4..n开这些开关，问最后有多少个开着的灯。<a href=\"https://leetcode.com/problems/bulb-switcher/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：这题有点像脑筋急转弯，我分析出了只有1~n的数有奇数个约数，那么最后就是开着的。然后什么样的数有奇数个约数，看了stefan后恍然大悟，原来是开方。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bulbSwitch</span><span class=\"params\">(self, n: int)</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> int(math.sqrt(n))</span><br></pre></td></tr></table></figure>\n<h3 id=\"592-Fraction-Addition-and-Subtraction\"><a href=\"#592-Fraction-Addition-and-Subtraction\" class=\"headerlink\" title=\"592. Fraction Addition and Subtraction\"></a><a href=\"https://leetcode.com/problems/fraction-addition-and-subtraction/\" target=\"_blank\" rel=\"noopener\">592. Fraction Addition and Subtraction</a></h3><h4 id=\"分数运算，有负数，只有-操作，最后要返回一个分数，如果是整数的话，需要分母1。\"><a href=\"#分数运算，有负数，只有-操作，最后要返回一个分数，如果是整数的话，需要分母1。\" class=\"headerlink\" title=\"分数运算，有负数，只有+-操作，最后要返回一个分数，如果是整数的话，需要分母1。\"></a>分数运算，有负数，只有+-操作，最后要返回一个分数，如果是整数的话，需要分母1。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input:&quot;-1&#x2F;2+1&#x2F;2&quot;</span><br><span class=\"line\">Output: &quot;0&#x2F;1&quot;</span><br><span class=\"line\">Input:&quot;-1&#x2F;2+1&#x2F;2+1&#x2F;3&quot;</span><br><span class=\"line\">Output: &quot;1&#x2F;3&quot;</span><br><span class=\"line\">Input:&quot;1&#x2F;3-1&#x2F;2&quot;</span><br><span class=\"line\">Output: &quot;-1&#x2F;6&quot;</span><br></pre></td></tr></table></figure>\n<p>方法一：cheat 写法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fractionAddition</span><span class=\"params\">(self, expression: str)</span> -&gt; str:</span></span><br><span class=\"line\">    <span class=\"keyword\">import</span> fractions</span><br><span class=\"line\">    tokens = iter(re.findall(<span class=\"string\">r'-?\\d+\\/-?\\d+|[+-]'</span>, expression))</span><br><span class=\"line\">    ans, sign = fractions.Fraction(<span class=\"number\">0</span>), <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> token <span class=\"keyword\">in</span> tokens:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> token <span class=\"keyword\">in</span> <span class=\"string\">'+-'</span>:</span><br><span class=\"line\">            sign = <span class=\"string\">' +'</span>.find(token)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            ans += sign * fractions.Fraction(token)</span><br><span class=\"line\">    ans = str(ans) + (<span class=\"string\">'/'</span> <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> str(ans)) * <span class=\"string\">'/1'</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法二：自己实现了一个。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fractionAddition</span><span class=\"params\">(self, expression: str)</span> -&gt; str:</span></span><br><span class=\"line\">    tokens = iter(re.findall(<span class=\"string\">r'-?\\d+\\/-?\\d+|[+-]'</span>, expression))</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">cal</span><span class=\"params\">(a, b, sign=<span class=\"number\">1</span>)</span>:</span></span><br><span class=\"line\">        na, da = map(int, a.split(<span class=\"string\">'/'</span>))</span><br><span class=\"line\">        nb, db = map(int, b.split(<span class=\"string\">'/'</span>))</span><br><span class=\"line\">        dc = da*db // math.gcd(da, db)</span><br><span class=\"line\">        nc = dc//da*na + sign*dc//db*nb</span><br><span class=\"line\">        r = math.gcd(nc, dc)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'&#123;&#125;/&#123;&#125;'</span>.format(nc//r, dc//r)</span><br><span class=\"line\">        </span><br><span class=\"line\">    ans, sign = <span class=\"string\">'0/1'</span>, <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> token <span class=\"keyword\">in</span> tokens:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> token <span class=\"keyword\">in</span> <span class=\"string\">'+-'</span>:</span><br><span class=\"line\">            sign = <span class=\"string\">' +'</span>.find(token)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            ans = cal(ans, token, sign)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：受到评论区大佬启发，优化一下，首先对正则优化，可以将分子分母都拆分出来，然后一次取两个。Stefan的答案，我居然把分数累加的公式都给忘了。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fractionAddition</span><span class=\"params\">(self, expression: str)</span> -&gt; str:</span></span><br><span class=\"line\">    nums = iter(map(int, re.findall(<span class=\"string\">r'[+-]?\\d+'</span>, expression)))</span><br><span class=\"line\">    na, da = <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> nb <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        db = next(nums)</span><br><span class=\"line\">        na = na*db + da*nb</span><br><span class=\"line\">        da *= db</span><br><span class=\"line\">        r = math.gcd(na, da)</span><br><span class=\"line\">        na //= r</span><br><span class=\"line\">        da //= r</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'&#123;&#125;/&#123;&#125;'</span>.format(na, da)</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法四：Lee的写法，是我愚钝了。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fractionAddition</span><span class=\"params\">(self, expression: str)</span> -&gt; str:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> fractions <span class=\"keyword\">import</span> Fraction <span class=\"keyword\">as</span> f</span><br><span class=\"line\">    ans = sum(map(f, re.findall(<span class=\"string\">r'[+-]?\\d+/\\d+'</span>, expression)))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'&#123;&#125;/&#123;&#125;'</span>.format(ans.numerator, ans.denominator)</span><br></pre></td></tr></table></figure>\n<h3 id=\"397-Integer-Replacement\"><a href=\"#397-Integer-Replacement\" class=\"headerlink\" title=\"397. Integer Replacement\"></a><a href=\"https://leetcode.com/problems/integer-replacement/\" target=\"_blank\" rel=\"noopener\">397. Integer Replacement</a></h3><h4 id=\"给定一个数，偶数可以-2，奇数可以-1，-1，问最少多少步能到1。\"><a href=\"#给定一个数，偶数可以-2，奇数可以-1，-1，问最少多少步能到1。\" class=\"headerlink\" title=\"给定一个数，偶数可以/2，奇数可以+1，-1，问最少多少步能到1。\"></a>给定一个数，偶数可以/2，奇数可以+1，-1，问最少多少步能到1。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">8</span><br><span class=\"line\"></span><br><span class=\"line\">Output:</span><br><span class=\"line\">3</span><br><span class=\"line\"></span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">8 -&gt; 4 -&gt; 2 -&gt; 1</span><br></pre></td></tr></table></figure>\n<p>方法一：递归。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">integerReplacement</span><span class=\"params\">(self, n: int)</span> -&gt; int:</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">    @lru_cache(None)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dp</span><span class=\"params\">(i)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == <span class=\"number\">1</span>: <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i &amp; <span class=\"number\">1</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> dp(i//<span class=\"number\">2</span>) + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> min(dp(i+<span class=\"number\">1</span>), dp(i<span class=\"number\">-1</span>)) + <span class=\"number\">1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp(n)</span><br></pre></td></tr></table></figure>\n<p>方法二：这是一个贪心的方法。首先需要推导证明。//2的方式一定是最快的，因为2/1也只用了1步。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">f(1) &#x3D; 0</span><br><span class=\"line\">f(2n) &#x3D; 1 + f(n)</span><br><span class=\"line\">f(2n+1) &#x3D; min(f(2n)+1, f(2n+2)+1)</span><br><span class=\"line\">f(2n+2) &#x3D; f(n+1) + 1</span><br><span class=\"line\">f(2n+1) &#x3D; min(f(2n)+1, f(n+1)+2)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">integerReplacement</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">    rtn = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> n &gt; <span class=\"number\">1</span>:</span><br><span class=\"line\">        rtn += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n % <span class=\"number\">2</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">            n //= <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> n % <span class=\"number\">4</span> == <span class=\"number\">1</span> <span class=\"keyword\">or</span> n == <span class=\"number\">3</span>:</span><br><span class=\"line\">            n -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            n += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> rtn</span><br></pre></td></tr></table></figure>\n<h3 id=\"372-Super-Pow\"><a href=\"#372-Super-Pow\" class=\"headerlink\" title=\"372. Super Pow\"></a><a href=\"https://leetcode.com/problems/super-pow/\" target=\"_blank\" rel=\"noopener\">372. Super Pow</a></h3><h4 id=\"求大数的幂。幂也可以很大。对1337的余数。\"><a href=\"#求大数的幂。幂也可以很大。对1337的余数。\" class=\"headerlink\" title=\"求大数的幂。幂也可以很大。对1337的余数。\"></a>求大数的幂。幂也可以很大。对1337的余数。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: a &#x3D; 2, b &#x3D; [1,0]</span><br><span class=\"line\">Output: 1024</span><br></pre></td></tr></table></figure>\n<p>方法一：我用<code>math.pow()</code>， 超过了<code>range error</code>了。而stefan的pow就可以，难道因为取余运算放到方法里就很快？即使是这种方式，将1337用%取余也会超时。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">superPow</span><span class=\"params\">(self, a: int, b: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> pow(a, int(<span class=\"string\">''</span>.join(map(str, b))), <span class=\"number\">1337</span>)</span><br></pre></td></tr></table></figure>\n<p>方法二：Stefan的方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">superPow</span><span class=\"params\">(self, a: int, b: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    ans = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> digit <span class=\"keyword\">in</span> b:</span><br><span class=\"line\">        ans = (pow(ans, <span class=\"number\">10</span>, <span class=\"number\">1337</span>) * pow(a, digit, <span class=\"number\">1337</span>)) % <span class=\"number\">1337</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h4 id=\"面试题-16-14-最佳直线\"><a href=\"#面试题-16-14-最佳直线\" class=\"headerlink\" title=\"面试题 16.14. 最佳直线\"></a><a href=\"https://leetcode-cn.com/problems/best-line-lcci/\" target=\"_blank\" rel=\"noopener\">面试题 16.14. 最佳直线</a></h4><h4 id=\"平面上有一些点，画一条直线，问穿过做多点的线，最开始的两个点的索引是什么。\"><a href=\"#平面上有一些点，画一条直线，问穿过做多点的线，最开始的两个点的索引是什么。\" class=\"headerlink\" title=\"平面上有一些点，画一条直线，问穿过做多点的线，最开始的两个点的索引是什么。\"></a>平面上有一些点，画一条直线，问穿过做多点的线，最开始的两个点的索引是什么。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入： [[0,0],[1,1],[1,0],[2,0]]</span><br><span class=\"line\">输出： [0,2]</span><br><span class=\"line\">解释： 所求直线穿过的3个点的编号为[0,2,3]</span><br></pre></td></tr></table></figure>\n<p>方法一：暴力,O(n^3)。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bestLine</span><span class=\"params\">(self, points: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    N = len(points)</span><br><span class=\"line\">    ans, cnt = [], <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, p1 <span class=\"keyword\">in</span> enumerate(points):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j, p2 <span class=\"keyword\">in</span> enumerate(itertools.islice(points, i+<span class=\"number\">1</span>, N), i+<span class=\"number\">1</span>):</span><br><span class=\"line\">            x1, y1 = p2[<span class=\"number\">0</span>]-p1[<span class=\"number\">0</span>], p2[<span class=\"number\">1</span>]-p1[<span class=\"number\">1</span>]</span><br><span class=\"line\">            c = <span class=\"number\">2</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> p3 <span class=\"keyword\">in</span> itertools.islice(points, j+<span class=\"number\">1</span>, N):</span><br><span class=\"line\">                x2, y2 = p3[<span class=\"number\">0</span>]-p1[<span class=\"number\">0</span>], p3[<span class=\"number\">1</span>]-p1[<span class=\"number\">1</span>]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> x1*y2 == x2*y1:</span><br><span class=\"line\">                    c += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> c &gt; cnt:</span><br><span class=\"line\">                cnt = c</span><br><span class=\"line\">                ans = [i, j]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法二：评论区学到的方法，改了一下。哈希表记录，一条直线有斜率和截距来确定。以此为hash。截距怎么求都忘了，推导了半天。这里索引比较乱，所以用了namedtuple。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bestLine</span><span class=\"params\">(self, points: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(p1, p2)</span> -&gt; tuple:</span></span><br><span class=\"line\">        <span class=\"comment\"># 返回两个点的斜率和纵截距</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> p1.x == p2.x:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> float(<span class=\"string\">'inf'</span>), p1.x</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ((p2.y-p1.y) / (p2.x-p1.x),</span><br><span class=\"line\">                    (p1.y*p2.x-p2.y*p1.x) / (p2.x-p1.x))</span><br><span class=\"line\"></span><br><span class=\"line\">    d, N = &#123;&#125;, len(points)</span><br><span class=\"line\">    x = y = max_cnt = <span class=\"number\">0</span></span><br><span class=\"line\">    Point = namedtuple(<span class=\"string\">'Point'</span>, <span class=\"string\">'x y'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, coor1 <span class=\"keyword\">in</span> enumerate(points):</span><br><span class=\"line\">        p1 = Point(*coor1)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j, coor2 <span class=\"keyword\">in</span> enumerate(islice(points, i+<span class=\"number\">1</span>, N), i+<span class=\"number\">1</span>):</span><br><span class=\"line\">            p2 = Point(*coor2)</span><br><span class=\"line\">            k, b = f(p1, p2)</span><br><span class=\"line\">            d.setdefault((k, b), [<span class=\"number\">0</span>, (i, j)])</span><br><span class=\"line\">            d[k, b][<span class=\"number\">0</span>] += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> d[k, b][<span class=\"number\">0</span>]&gt;max_cnt <span class=\"keyword\">or</span> (d[k, b][<span class=\"number\">0</span>]==max_cnt <span class=\"keyword\">and</span> (x, y) &gt; d[k, b][<span class=\"number\">1</span>]):</span><br><span class=\"line\">                max_cnt = d[k, b][<span class=\"number\">0</span>]</span><br><span class=\"line\">                x, y = d[k, b][<span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x, y</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：这个方法很效率，时间空间是前两种的一半。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bestLine</span><span class=\"params\">(self, points: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    N, max_cnt = len(points), <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, p1 <span class=\"keyword\">in</span> enumerate(points):</span><br><span class=\"line\">        slope = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j, p2 <span class=\"keyword\">in</span> enumerate(islice(points, i+<span class=\"number\">1</span>, N), i+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> p1[<span class=\"number\">0</span>] == p2[<span class=\"number\">0</span>]:</span><br><span class=\"line\">                k = <span class=\"literal\">None</span>   <span class=\"comment\"># 这里赋值什么都行，只要别和斜率重复</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                k = (p2[<span class=\"number\">1</span>]-p1[<span class=\"number\">1</span>]) / (p2[<span class=\"number\">0</span>]-p1[<span class=\"number\">0</span>])</span><br><span class=\"line\">            slope.setdefault(k, [i])</span><br><span class=\"line\">            slope[k].append(j)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> idx <span class=\"keyword\">in</span> slope.values():</span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(idx) &gt; max_cnt:</span><br><span class=\"line\">                max_cnt = len(idx)</span><br><span class=\"line\">                ans = idx[:<span class=\"number\">2</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"60-Permutation-Sequence\"><a href=\"#60-Permutation-Sequence\" class=\"headerlink\" title=\"60. Permutation Sequence\"></a>60. Permutation Sequence</h3><h4 id=\"全排列中的第k个。原题\"><a href=\"#全排列中的第k个。原题\" class=\"headerlink\" title=\"全排列中的第k个。原题\"></a>全排列中的第k个。<a href=\"https://leetcode.com/problems/permutation-sequence/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 3, k &#x3D; 3</span><br><span class=\"line\">Output: &quot;213&quot;</span><br></pre></td></tr></table></figure>\n<p>方法一：这道题写法进行了一些改进，严格意义上来说不算回溯，不知道为什么官方标签贴了一个回溯，只是做了剪枝。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getPermutation</span><span class=\"params\">(self, n: int, k: int)</span> -&gt; str:</span></span><br><span class=\"line\">    self.k = k - <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(s, rest)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> rest:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(s)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(rest)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.k &gt;= math.factorial(len(rest)<span class=\"number\">-1</span>):</span><br><span class=\"line\">                self.k -= math.factorial(len(rest)<span class=\"number\">-1</span>)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            s += rest[i]</span><br><span class=\"line\">            <span class=\"keyword\">return</span> dfs(s, rest[:i]+rest[i+<span class=\"number\">1</span>:])</span><br><span class=\"line\"></span><br><span class=\"line\">    nums = list(map(str, range(<span class=\"number\">1</span>, n+<span class=\"number\">1</span>)))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dfs([], nums)</span><br></pre></td></tr></table></figure>\n<p>方法二：改变一下思路，根据k的大小来确定每个位置的数。这道题想了不到个小时，最终原创出自己的写法。耗时36ms，beats 99%。果然数据规律才是致命的降维打击。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getPermutation</span><span class=\"params\">(self, n: int, k: int)</span> -&gt; str:</span></span><br><span class=\"line\">    ans = <span class=\"string\">''</span></span><br><span class=\"line\">    nums = list(map(str, range(<span class=\"number\">1</span>, n+<span class=\"number\">1</span>)))</span><br><span class=\"line\">    fact = math.factorial(len(nums)<span class=\"number\">-1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> k != <span class=\"number\">1</span>:</span><br><span class=\"line\">        i = (k - <span class=\"number\">1</span>) // fact</span><br><span class=\"line\">        k -= i * fact</span><br><span class=\"line\">        ans += nums.pop(i)</span><br><span class=\"line\">        fact //= len(nums)            </span><br><span class=\"line\">    ans += <span class=\"string\">''</span>.join(nums)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：根据solution中调整了一些点。关于k索引的问题可以在一开始就-1，然后循环中便可以使用<code>divmod</code>内置函数来求值。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getPermutation</span><span class=\"params\">(self, n: int, k: int)</span> -&gt; str:</span></span><br><span class=\"line\">    ans = <span class=\"string\">''</span></span><br><span class=\"line\">    nums = list(map(str, range(<span class=\"number\">1</span>, n+<span class=\"number\">1</span>)))</span><br><span class=\"line\">    fact = math.factorial(len(nums)<span class=\"number\">-1</span>)</span><br><span class=\"line\">    k -= <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> k:</span><br><span class=\"line\">        i, k = divmod(k, fact)</span><br><span class=\"line\">        ans += nums.pop(i)</span><br><span class=\"line\">        fact //= len(nums)            </span><br><span class=\"line\">    ans += <span class=\"string\">''</span>.join(nums)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"1643-Kth-Smallest-Instructions\"><a href=\"#1643-Kth-Smallest-Instructions\" class=\"headerlink\" title=\"1643. Kth Smallest Instructions\"></a><a href=\"https://leetcode.com/problems/kth-smallest-instructions/\" target=\"_blank\" rel=\"noopener\">1643. Kth Smallest Instructions</a></h3><h4 id=\"第k个最小的指令，其实是求R-39-V-39-C-39-H-39-的第k个最小的非重复的全排列。\"><a href=\"#第k个最小的指令，其实是求R-39-V-39-C-39-H-39-的第k个最小的非重复的全排列。\" class=\"headerlink\" title=\"第k个最小的指令，其实是求R*&#39;V&#39;+C*&#39;H&#39;的第k个最小的非重复的全排列。\"></a>第k个最小的指令，其实是求<code>R*&#39;V&#39;+C*&#39;H&#39;</code>的第k个最小的非重复的全排列。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: destination &#x3D; [2,3], k &#x3D; 1</span><br><span class=\"line\">Output: &quot;HHHVV&quot;</span><br><span class=\"line\">Explanation: All the instructions that reach (2, 3) in lexicographic order are as follows:</span><br><span class=\"line\">[&quot;HHHVV&quot;, &quot;HHVHV&quot;, &quot;HHVVH&quot;, &quot;HVHHV&quot;, &quot;HVHVH&quot;, &quot;HVVHH&quot;, &quot;VHHHV&quot;, &quot;VHHVH&quot;, &quot;VHVHH&quot;, &quot;VVHHH&quot;].</span><br></pre></td></tr></table></figure>\n<p>方法一：可惜，比赛时没有足够时间来做，是想到了数学法，也想起来和60题很像，区别在于60题没有重复，这里需要去重。评论区的一个解法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">kthSmallestPath</span><span class=\"params\">(self, destination: List[int], k: int)</span> -&gt; str:</span></span><br><span class=\"line\">    ans = <span class=\"string\">''</span></span><br><span class=\"line\">    R, C = destination</span><br><span class=\"line\">    left_v = R</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(R+C):</span><br><span class=\"line\">        left_p = R+C - i - <span class=\"number\">1</span></span><br><span class=\"line\">        com = comb(left_p, left_v)\t\t<span class=\"comment\"># H开头的有多少种</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> com &lt; k:</span><br><span class=\"line\">            ans += <span class=\"string\">'V'</span></span><br><span class=\"line\">            left_v -= <span class=\"number\">1</span></span><br><span class=\"line\">            k -= com</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            ans += <span class=\"string\">'H'</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"1621-Number-of-Sets-of-K-Non-Overlapping-Line-Segments\"><a href=\"#1621-Number-of-Sets-of-K-Non-Overlapping-Line-Segments\" class=\"headerlink\" title=\"1621. Number of Sets of K Non-Overlapping Line Segments\"></a><a href=\"https://leetcode.com/problems/number-of-sets-of-k-non-overlapping-line-segments/\" target=\"_blank\" rel=\"noopener\">1621. Number of Sets of K Non-Overlapping Line Segments</a></h3><h4 id=\"给你一维空间的-n-个点，其中第-i-个点（编号从-0-到-n-1）位于-x-i-处，请你找到-恰好-k-个不重叠-线段且每个线段至少覆盖两个点的方案数。线段的两个端点必须都是-整数坐标-。这-k-个线段不需要全部覆盖全部-n-个点，且它们的端点-可以-重合。返回方案数。\"><a href=\"#给你一维空间的-n-个点，其中第-i-个点（编号从-0-到-n-1）位于-x-i-处，请你找到-恰好-k-个不重叠-线段且每个线段至少覆盖两个点的方案数。线段的两个端点必须都是-整数坐标-。这-k-个线段不需要全部覆盖全部-n-个点，且它们的端点-可以-重合。返回方案数。\" class=\"headerlink\" title=\"给你一维空间的 n 个点，其中第 i 个点（编号从 0 到 n-1）位于 x = i 处，请你找到 恰好 k 个不重叠 线段且每个线段至少覆盖两个点的方案数。线段的两个端点必须都是 整数坐标 。这 k 个线段不需要全部覆盖全部 n 个点，且它们的端点 可以 重合。返回方案数。\"></a>给你一维空间的 n 个点，其中第 i 个点（编号从 0 到 n-1）位于 x = i 处，请你找到 恰好 k 个不重叠 线段且每个线段至少覆盖两个点的方案数。线段的两个端点必须都是 整数坐标 。这 k 个线段不需要全部覆盖全部 n 个点，且它们的端点 可以 重合。返回方案数。</h4><p>方法一：比赛时没做出来，卡在第二题，想到了组合。看到了Lee的答案。给你n个点，k个线段可以共享端点。这个问题可以转化成：</p>\n<p>给你n+k-1个点，每个线段不可以共享端点。在k个线段之间各补一个点。所以只需要求出从这些点出选出2k个点的组合。因为每两个相邻的点连成一段，所以是2k。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numberOfSets</span><span class=\"params\">(self, n: int, k: int)</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> math.comb(n+k<span class=\"number\">-1</span>, <span class=\"number\">2</span>*k) % (<span class=\"number\">10</span>**<span class=\"number\">9</span>+<span class=\"number\">7</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"458-Poor-Pigs\"><a href=\"#458-Poor-Pigs\" class=\"headerlink\" title=\"458. Poor Pigs\"></a><a href=\"https://leetcode.com/problems/poor-pigs/\" target=\"_blank\" rel=\"noopener\">458. Poor Pigs</a></h3><h4 id=\"说有这么1000桶里面装了水，其中有一桶里面是毒药。你可以让无数头猪来这些水，但是每头猪15分钟只能喝一次，不过可以同时喝若干桶水。你要在1个小时之内知道哪个桶是有毒药的。最少需要多少头猪。\"><a href=\"#说有这么1000桶里面装了水，其中有一桶里面是毒药。你可以让无数头猪来这些水，但是每头猪15分钟只能喝一次，不过可以同时喝若干桶水。你要在1个小时之内知道哪个桶是有毒药的。最少需要多少头猪。\" class=\"headerlink\" title=\"说有这么1000桶里面装了水，其中有一桶里面是毒药。你可以让无数头猪来这些水，但是每头猪15分钟只能喝一次，不过可以同时喝若干桶水。你要在1个小时之内知道哪个桶是有毒药的。最少需要多少头猪。\"></a>说有这么1000桶里面装了水，其中有一桶里面是毒药。你可以让无数头猪来这些水，但是每头猪15分钟只能喝一次，不过可以同时喝若干桶水。你要在1个小时之内知道哪个桶是有毒药的。最少需要多少头猪。</h4><p>方法一：数学方法。这题比较难想。从一只猪开始思考。60分钟一共可以喝4次，不过可以检测5个桶，因为喝完最后的没有死，所有毒药在没有喝的桶。然后是两只猪，可以检测5**2个桶，将25个桶想象成一个平面。一只猪每次按照行来喝，另一只猪按照列来喝。最后通过行列可以确定毒药的位置。3只猪的时候要想象成三维的平面，每次每只猪要喝25桶的水，分别按照x, y, z轴的顺序。最后三个维度的坐标可以确定。本质上此题是一道信息论的题。知乎有个大佬通过信息熵来解此题，<a href=\"https://www.zhihu.com/question/60227816/answer/1274071217\" target=\"_blank\" rel=\"noopener\">不明觉厉。</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">poorPigs</span><span class=\"params\">(self, buckets: int, minutesToDie: int, minutesToTest: int)</span> -&gt; int:</span></span><br><span class=\"line\">    pigs = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (minutesToTest // minutesToDie + <span class=\"number\">1</span>) ** pigs &lt; buckets:</span><br><span class=\"line\">        pigs += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> pigs</span><br></pre></td></tr></table></figure>\n<h3 id=\"1744-Can-You-Eat-Your-Favorite-Candy-on-Your-Favorite-Day\"><a href=\"#1744-Can-You-Eat-Your-Favorite-Candy-on-Your-Favorite-Day\" class=\"headerlink\" title=\"1744. Can You Eat Your Favorite Candy on Your Favorite Day?\"></a><a href=\"https://leetcode.com/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/\" target=\"_blank\" rel=\"noopener\">1744. Can You Eat Your Favorite Candy on Your Favorite Day?</a></h3><h4 id=\"能否在某一天吃到某种特定的糖果。三个规则：每天至少吃一个；从类型小的吃，吃完才能吃下个类型；查询条件中限制每天最多吃多少糖果。\"><a href=\"#能否在某一天吃到某种特定的糖果。三个规则：每天至少吃一个；从类型小的吃，吃完才能吃下个类型；查询条件中限制每天最多吃多少糖果。\" class=\"headerlink\" title=\"能否在某一天吃到某种特定的糖果。三个规则：每天至少吃一个；从类型小的吃，吃完才能吃下个类型；查询条件中限制每天最多吃多少糖果。\"></a>能否在某一天吃到某种特定的糖果。三个规则：每天至少吃一个；从类型小的吃，吃完才能吃下个类型；查询条件中限制每天最多吃多少糖果。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: candiesCount &#x3D; [7,4,5,3,8], queries &#x3D; [[0,2,2],[4,2,4],[2,13,1000000000]]</span><br><span class=\"line\">Output: [true,false,true]</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">1- If you eat 2 candies (type 0) on day 0 and 2 candies (type 0) on day 1, you will eat a candy of type 0 on day 2.</span><br><span class=\"line\">2- You can eat at most 4 candies each day.</span><br><span class=\"line\">   If you eat 4 candies every day, you will eat 4 candies (type 0) on day 0 and 4 candies (type 0 and type 1) on day 1.</span><br><span class=\"line\">   On day 2, you can only eat 4 candies (type 1 and type 2), so you cannot eat a candy of type 4 on day 2.</span><br><span class=\"line\">3- If you eat 1 candy each day, you will eat a candy of type 2 on day 13.</span><br></pre></td></tr></table></figure>\n<p>方法一：比赛时没有做出来，结束后18分钟做出来了。一个条件想错了应该是<code>pre_sum[can+1]&gt;=day+1</code>，而不是<code>pre_sum[can]&gt;=day</code>。</p>\n<p>其实能否吃到，只有两个条件。一个是那一天能不能够到指定的糖果，每天按照最多的吃。另一个是每天只吃一个，到了那天该种糖果还有没有剩余。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">canEat</span><span class=\"params\">(self, candiesCount: List[int], queries: List[List[int]])</span> -&gt; List[bool]:</span></span><br><span class=\"line\">    pre_sum = list(accumulate([<span class=\"number\">0</span>]+candiesCount))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [pre_sum[can] &lt; (day+<span class=\"number\">1</span>)*limit <span class=\"keyword\">and</span> (pre_sum[can+<span class=\"number\">1</span>]&gt;=day+<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> can, day, limit <span class=\"keyword\">in</span> queries]</span><br></pre></td></tr></table></figure>\n<h3 id=\"1780-Check-if-Number-is-a-Sum-of-Powers-of-Three\"><a href=\"#1780-Check-if-Number-is-a-Sum-of-Powers-of-Three\" class=\"headerlink\" title=\"1780. Check if Number is a Sum of Powers of Three\"></a><a href=\"https://leetcode.com/problems/check-if-number-is-a-sum-of-powers-of-three/\" target=\"_blank\" rel=\"noopener\">1780. Check if Number is a Sum of Powers of Three</a></h3><h4 id=\"判断一个数是否由不一样3的幂，组成。\"><a href=\"#判断一个数是否由不一样3的幂，组成。\" class=\"headerlink\" title=\"判断一个数是否由不一样3的幂，组成。\"></a>判断一个数是否由不一样3的幂，组成。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 91</span><br><span class=\"line\">Output: true</span><br><span class=\"line\">Explanation: 91 &#x3D; 30 + 32 + 34</span><br></pre></td></tr></table></figure>\n<p>方法一：比赛时，暴力求出了所有的可能的结果，然后判断。1500ms。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        p3 = [<span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">while</span> p3[<span class=\"number\">-1</span>] &lt; <span class=\"number\">10</span>**<span class=\"number\">7</span>:</span><br><span class=\"line\">            p3.append(p3[<span class=\"number\">-1</span>]*<span class=\"number\">3</span>)</span><br><span class=\"line\">        cand = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(p3)+<span class=\"number\">1</span>):</span><br><span class=\"line\">            cand.extend(map(sum, combinations(p3, i)))</span><br><span class=\"line\">        self.cand = set(cand)</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">checkPowersOfThree</span><span class=\"params\">(self, n: int)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> n <span class=\"keyword\">in</span> self.cand</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：10 = <code>1 * 3^0</code> + <code>0 * 3^1</code> + <code>1 * 3^2</code> -&gt; True<br>11 = <code>2 * 3^0</code> + <code>0 * 3^1</code> + <code>1 * 3^2</code> -&gt; False, because there is a <code>2</code> as coeficient。如果余数出现2，就不能组成这个数。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">checkPowersOfThree</span><span class=\"params\">(self, n: int)</span> -&gt; bool:</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> n &gt; <span class=\"number\">1</span>:</span><br><span class=\"line\">        n, r = divmod(n, <span class=\"number\">3</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> r == <span class=\"number\">2</span>: <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1819-Number-of-Different-Subsequences-GCDs\"><a href=\"#1819-Number-of-Different-Subsequences-GCDs\" class=\"headerlink\" title=\"1819. Number of Different Subsequences GCDs\"></a>1819. Number of Different Subsequences GCDs</h3><h4 id=\"求一个数组的任意子序列所有的数的最大公约数，有多少种。\"><a href=\"#求一个数组的任意子序列所有的数的最大公约数，有多少种。\" class=\"headerlink\" title=\"求一个数组的任意子序列所有的数的最大公约数，有多少种。\"></a>求一个数组的任意子序列所有的数的最大公约数，有多少种。</h4><img src=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%95%B0%E5%AD%A6%E7%AF%87%EF%BC%89Math/1819q.png\" class>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [6,10,3]</span><br><span class=\"line\">Output: 5</span><br><span class=\"line\">Explanation: The figure shows all the non-empty subsequences and their GCDs.</span><br><span class=\"line\">The different GCDs are 6, 10, 3, 2, and 1.</span><br></pre></td></tr></table></figure>\n<p>方法一：竞赛没有参加，比较是比赛写不出来的题。看别人的答案看了很久。首先，枚举子序列一定会超时，这里要用逆向思维，枚举公约数。当指定了公约数之后，找会不会有这样一个子序列能满足这个公约数。这些子序列中的数一定是这个公约数的倍数。y表示公约数，x为组成子序列的数，g值会逐渐减小，直到等于y表示，找到了这样一个子序列的最大公约数为g。这里迷惑了很久为什么要break，因为题中要求的是种类的个数。所以不需要再往下进行。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countDifferentSubsequenceGCDs</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    nums = set(nums)</span><br><span class=\"line\">    c = max(nums)</span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> y <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, c + <span class=\"number\">1</span>):</span><br><span class=\"line\">        g = <span class=\"literal\">None</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(y, c + <span class=\"number\">1</span>, y):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> x <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> g:</span><br><span class=\"line\">                    g = x</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    g = math.gcd(g, x)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> g == y:</span><br><span class=\"line\">                    ans += <span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"523-Continuous-Subarray-Sum\"><a href=\"#523-Continuous-Subarray-Sum\" class=\"headerlink\" title=\"523. Continuous Subarray Sum\"></a><a href=\"https://leetcode.com/problems/continuous-subarray-sum/\" target=\"_blank\" rel=\"noopener\">523. Continuous Subarray Sum</a></h3><h4 id=\"是否存在连续的子数组和为k的倍数。\"><a href=\"#是否存在连续的子数组和为k的倍数。\" class=\"headerlink\" title=\"是否存在连续的子数组和为k的倍数。\"></a>是否存在连续的子数组和为k的倍数。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [23,2,4,6,7], k &#x3D; 6</span><br><span class=\"line\">Output: true</span><br><span class=\"line\">Explanation: [2, 4] is a continuous subarray of size 2 whose elements sum up to 6.</span><br></pre></td></tr></table></figure>\n<p>方法一：前缀和+哈希。没有想出来。很关键的一点，是当<code>pre_sum[j]-pre_sum[i]=n*k</code>即<code>pre_sum[j]</code>和<code>pre_sum[i]</code>对k取余有相同的结果。想明白这点，此题就很简单。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">checkSubarraySum</span><span class=\"params\">(self, nums: List[int], k: int)</span> -&gt; bool:</span></span><br><span class=\"line\">    pre_sum = list(accumulate(nums))</span><br><span class=\"line\">    remider = &#123;<span class=\"number\">0</span>: <span class=\"number\">-1</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, s <span class=\"keyword\">in</span> enumerate(pre_sum):</span><br><span class=\"line\">        mod = s % k</span><br><span class=\"line\">        remider.setdefault(mod, i)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i - remider[mod] &gt; <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n","categories":["算法"],"tags":["LeetCode","Python","Algorithm","Math"]},{"title":"LeetCode算法题整理（字符串篇）String","url":"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AF%87%EF%BC%89String/","content":"<h3 id=\"14-Longest-Common-Prefix\"><a href=\"#14-Longest-Common-Prefix\" class=\"headerlink\" title=\"14. Longest Common Prefix\"></a>14. Longest Common Prefix</h3><p>返回最长公共前缀字符串。<a href=\"https://leetcode.com/problems/longest-common-prefix/description/\" target=\"_blank\" rel=\"noopener\">原题</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class=\"line\">Output: &quot;fl&quot;</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longest_common_prefix</span><span class=\"params\">(strs)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> strs:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> itertools <span class=\"keyword\">import</span> takewhile</span><br><span class=\"line\">    max_pre_len = len(list(takewhile(<span class=\"keyword\">lambda</span> x: len(set(x))==<span class=\"number\">1</span>, zip(*strs))))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> strs[<span class=\"number\">0</span>][:max_pre_len]</span><br></pre></td></tr></table></figure>\n<h3 id=\"20-Valid-Parentheses\"><a href=\"#20-Valid-Parentheses\" class=\"headerlink\" title=\"20. Valid Parentheses\"></a>20. Valid Parentheses</h3><p>判断括号是否成对出现，并且嵌套正确。<a href=\"https://leetcode.com/problems/valid-parentheses/description/\" target=\"_blank\" rel=\"noopener\">原题</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: &quot;()[]&#123;&#125;&quot;</span><br><span class=\"line\">Output: true</span><br><span class=\"line\">Input: &quot;&#123;[]&#125;&quot;</span><br><span class=\"line\">Output: true</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_valid</span><span class=\"params\">(s)</span>:</span></span><br><span class=\"line\">    pairs = &#123;<span class=\"string\">')'</span>: <span class=\"string\">'('</span>, <span class=\"string\">'&#125;'</span>: <span class=\"string\">'&#123;'</span>, <span class=\"string\">']'</span>: <span class=\"string\">'['</span>&#125;</span><br><span class=\"line\">    stack = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> paren <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> paren <span class=\"keyword\">in</span> pairs.values():</span><br><span class=\"line\">            stack.append(paren)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> paren <span class=\"keyword\">in</span> pairs.keys():</span><br><span class=\"line\">            <span class=\"keyword\">if</span> stack == [] <span class=\"keyword\">or</span> stack.pop() != pairs[paren]:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> stack == []</span><br></pre></td></tr></table></figure>\n<h3 id=\"921-Minimum-Add-to-Make-Parentheses-Valid\"><a href=\"#921-Minimum-Add-to-Make-Parentheses-Valid\" class=\"headerlink\" title=\"921. Minimum Add to Make Parentheses Valid\"></a>921. Minimum Add to Make Parentheses Valid</h3><h4 id=\"给定一个只包含小括号的字符串。返回需要多少个”-“或”-”使其成为完整的括号表达式。原题\"><a href=\"#给定一个只包含小括号的字符串。返回需要多少个”-“或”-”使其成为完整的括号表达式。原题\" class=\"headerlink\" title=\"给定一个只包含小括号的字符串。返回需要多少个”(“或”)”使其成为完整的括号表达式。原题\"></a>给定一个只包含小括号的字符串。返回需要多少个”(“或”)”使其成为完整的括号表达式。<a href=\"https://leetcode.com/contest/weekly-contest-106/problems/minimum-add-to-make-parentheses-valid/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: &quot;())&quot;</span><br><span class=\"line\">Output: 1</span><br><span class=\"line\">Input: &quot;()))((&quot;</span><br><span class=\"line\">Output: 4</span><br><span class=\"line\">Input: &quot;()&quot;</span><br><span class=\"line\">Output: 0</span><br><span class=\"line\">Input: &quot;(((&quot;</span><br><span class=\"line\">Output: 3</span><br></pre></td></tr></table></figure>\n<p>方法一：平衡问题。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minAddToMakeValid</span><span class=\"params\">(self, S: str)</span> -&gt; int:</span></span><br><span class=\"line\">    ans = bal = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> symbol <span class=\"keyword\">in</span> S:</span><br><span class=\"line\">        bal += <span class=\"number\">1</span> <span class=\"keyword\">if</span> symbol==<span class=\"string\">'('</span> <span class=\"keyword\">else</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> bal == <span class=\"number\">-1</span>:</span><br><span class=\"line\">            ans += <span class=\"number\">1</span></span><br><span class=\"line\">            bal += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans + bal</span><br></pre></td></tr></table></figure>\n<h3 id=\"28-Implement-strStr\"><a href=\"#28-Implement-strStr\" class=\"headerlink\" title=\"28. Implement strStr()\"></a>28. Implement strStr()</h3><h4 id=\"实现index。原题\"><a href=\"#实现index。原题\" class=\"headerlink\" title=\"实现index。原题\"></a>实现index。<a href=\"https://leetcode.com/problems/implement-strstr/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: haystack &#x3D; &quot;hello&quot;, needle &#x3D; &quot;ll&quot;</span><br><span class=\"line\">Output: 2</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">str_index</span><span class=\"params\">(haystack, needle)</span>:</span></span><br><span class=\"line\">    h = len(haystack)</span><br><span class=\"line\">    n = len(needle)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(h-n+<span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> haystack[i:i+n] == needle:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> i</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"38-Count-and-Say\"><a href=\"#38-Count-and-Say\" class=\"headerlink\" title=\"38. Count and Say\"></a>38. Count and Say</h3><h4 id=\"原题\"><a href=\"#原题\" class=\"headerlink\" title=\"原题\"></a><a href=\"https://leetcode.com/problems/count-and-say/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">1.     1</span><br><span class=\"line\">2.     11</span><br><span class=\"line\">3.     21</span><br><span class=\"line\">4.     1211</span><br><span class=\"line\">5.     111221</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countAndSay</span><span class=\"params\">(self, n: int)</span> -&gt; str:</span></span><br><span class=\"line\">    ans = <span class=\"string\">'1'</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n<span class=\"number\">-1</span>):</span><br><span class=\"line\">        ans = <span class=\"string\">''</span>.join(str(len(list(c)))+d </span><br><span class=\"line\">                      <span class=\"keyword\">for</span> d, c <span class=\"keyword\">in</span> itertools.groupby(ans))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"443-String-Compression\"><a href=\"#443-String-Compression\" class=\"headerlink\" title=\"443. String Compression\"></a>443. String Compression</h3><h4 id=\"字符串压缩，实际是要将重复的字符串以个数来表示。要求O-1-空间复杂度，就地修改原数组。原题\"><a href=\"#字符串压缩，实际是要将重复的字符串以个数来表示。要求O-1-空间复杂度，就地修改原数组。原题\" class=\"headerlink\" title=\"字符串压缩，实际是要将重复的字符串以个数来表示。要求O(1)空间复杂度，就地修改原数组。原题\"></a>字符串压缩，实际是要将重复的字符串以个数来表示。要求O(1)空间复杂度，就地修改原数组。<a href=\"https://leetcode.com/problems/string-compression/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>思路：看上去和38题差不多，但是有些不同，不同的地方在于如果个数为1，则不显示。个数为两位数，要显示两个元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input &#x3D; [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]</span><br><span class=\"line\">Output &#x3D; [&quot;a&quot;,&quot;2&quot;,&quot;b&quot;,&quot;2&quot;,&quot;c&quot;,&quot;3&quot;]</span><br><span class=\"line\">Input &#x3D; [&quot;a&quot;]</span><br><span class=\"line\">Output &#x3D; [&quot;a&quot;]</span><br><span class=\"line\">Input &#x3D; [&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;]</span><br><span class=\"line\">Output &#x3D; [&quot;a&quot;,&quot;b&quot;,&quot;1&quot;,&quot;2&quot;]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">compress</span><span class=\"params\">(self, chars: List[str])</span> -&gt; int:</span></span><br><span class=\"line\">    anchor, write = <span class=\"number\">0</span>, <span class=\"number\">0</span>   <span class=\"comment\"># anchor为每组连续的第一个位置。</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> r, char <span class=\"keyword\">in</span> enumerate(chars):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> r == len(chars)<span class=\"number\">-1</span> <span class=\"keyword\">or</span> char != chars[r+<span class=\"number\">1</span>]:</span><br><span class=\"line\">            chars[write] = chars[anchor]</span><br><span class=\"line\">            write += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> r &gt; anchor:</span><br><span class=\"line\">                <span class=\"keyword\">for</span> digit <span class=\"keyword\">in</span> str(r - anchor + <span class=\"number\">1</span>):</span><br><span class=\"line\">                    chars[write] = digit</span><br><span class=\"line\">                    write += <span class=\"number\">1</span></span><br><span class=\"line\">            anchor = r + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> write</span><br></pre></td></tr></table></figure>\n<h3 id=\"125-Valid-Palindrome\"><a href=\"#125-Valid-Palindrome\" class=\"headerlink\" title=\"125. Valid Palindrome\"></a>125. Valid Palindrome</h3><h4 id=\"验证回文字符串，只判断字母数字，忽略大小写。原题\"><a href=\"#验证回文字符串，只判断字母数字，忽略大小写。原题\" class=\"headerlink\" title=\"验证回文字符串，只判断字母数字，忽略大小写。原题\"></a>验证回文字符串，只判断字母数字，忽略大小写。<a href=\"https://leetcode.com/problems/valid-palindrome/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class=\"line\">Output: true</span><br></pre></td></tr></table></figure>\n<p>方法一：切片</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_palindrome</span><span class=\"params\">(s)</span>:</span></span><br><span class=\"line\">    s_alnum = filter(str.isalnum, s.lower())</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s_alnum == s_alnum[::<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<p>方法二：双指针</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_palindrome</span><span class=\"params\">(s)</span>:</span></span><br><span class=\"line\">    s_alnum = list(filter(str.isalnum, s.lower()))</span><br><span class=\"line\">    mid = len(s_alnum) // <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(mid):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> s_alnum[i] != s_alnum[-i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"680-Valid-Palindrome-II\"><a href=\"#680-Valid-Palindrome-II\" class=\"headerlink\" title=\"680. Valid Palindrome II\"></a>680. Valid Palindrome II</h3><h4 id=\"验证是否是回文数，只包含小写字母，但是允许最多去掉一个字母之后是回文数。原题\"><a href=\"#验证是否是回文数，只包含小写字母，但是允许最多去掉一个字母之后是回文数。原题\" class=\"headerlink\" title=\"验证是否是回文数，只包含小写字母，但是允许最多去掉一个字母之后是回文数。原题\"></a>验证是否是回文数，只包含小写字母，但是允许最多去掉一个字母之后是回文数。<a href>原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: &quot;abca&quot;</span><br><span class=\"line\">Output: True</span><br><span class=\"line\">Explanation: You could delete the character &#39;c&#39;.</span><br></pre></td></tr></table></figure>\n<p>方法一：一开始想的方法。切片由于可能<code>i=0</code>，所以必须反序切片再倒置。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">validPalindrome</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">    i, res = self.is_palindrome(s)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> res:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        _, s1 = self.is_palindrome(s[:i]+s[i+<span class=\"number\">1</span>:]) </span><br><span class=\"line\">        left = slice(<span class=\"number\">0</span>, -i<span class=\"number\">-1</span>)</span><br><span class=\"line\">        right = slice(<span class=\"number\">-1</span>, -i<span class=\"number\">-1</span>, <span class=\"number\">-1</span>)</span><br><span class=\"line\">        _, s2 = self.is_palindrome(s[left]+s[right][::<span class=\"number\">-1</span>])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s1 <span class=\"keyword\">or</span> s2</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_palindrome</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">    mid = len(s) // <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"comment\"># print(s)</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(mid):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> s[i] != s[-i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">            <span class=\"comment\"># print('&#123;&#125; [&#123;&#125;] != [&#123;&#125;]'.format(s, s[i], s[-i-1]))</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> i, <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">None</span>, <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：双指针方法。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">validPalindrome</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">    l, r = <span class=\"number\">0</span>, len(s)<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> l &lt; r:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> s[l] != s[r]:</span><br><span class=\"line\">            one, two = s[l:r], s[l+<span class=\"number\">1</span>:r+<span class=\"number\">1</span>]</span><br><span class=\"line\">            <span class=\"keyword\">return</span> one==one[::<span class=\"number\">-1</span>] <span class=\"keyword\">or</span> two==two[::<span class=\"number\">-1</span>]</span><br><span class=\"line\">        l, r = l+<span class=\"number\">1</span>, r<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<p>方法三：贪心解法，留坑。</p>\n<h3 id=\"151-Reverse-Words-in-a-String\"><a href=\"#151-Reverse-Words-in-a-String\" class=\"headerlink\" title=\"151. Reverse Words in a String\"></a>151. Reverse Words in a String</h3><h4 id=\"倒置一句话中的单词。原题\"><a href=\"#倒置一句话中的单词。原题\" class=\"headerlink\" title=\"倒置一句话中的单词。原题\"></a>倒置一句话中的单词。<a href=\"https://leetcode.com/problems/reverse-words-in-a-string/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: &quot;the sky is blue&quot;,</span><br><span class=\"line\">Output: &quot;blue is sky the&quot;.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverse_words</span><span class=\"params\">(s)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">' '</span>.join(s.split()[::<span class=\"number\">-1</span>])</span><br></pre></td></tr></table></figure>\n<h3 id=\"344-Reverse-String\"><a href=\"#344-Reverse-String\" class=\"headerlink\" title=\"344. Reverse String\"></a>344. Reverse String</h3><h4 id=\"倒置字符串。原题\"><a href=\"#倒置字符串。原题\" class=\"headerlink\" title=\"倒置字符串。原题\"></a>倒置字符串。<a href=\"https://leetcode.com/problems/reverse-string/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class=\"line\">Output: &quot;amanaP :lanac a ,nalp a ,nam A&quot;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverse_str</span><span class=\"params\">(s)</span>:</span></span><br><span class=\"line\">    n = len(s)</span><br><span class=\"line\">    res = list(s)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n//<span class=\"number\">2</span>):</span><br><span class=\"line\">        res[i], res[-i<span class=\"number\">-1</span>] = res[-i<span class=\"number\">-1</span>], res[i]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(res)</span><br></pre></td></tr></table></figure>\n<h3 id=\"242-Valid-Anagram\"><a href=\"#242-Valid-Anagram\" class=\"headerlink\" title=\"242. Valid Anagram\"></a>242. Valid Anagram</h3><h4 id=\"验证回文构词法，即两个字符串由同样个数的字符组成。原题\"><a href=\"#验证回文构词法，即两个字符串由同样个数的字符组成。原题\" class=\"headerlink\" title=\"验证回文构词法，即两个字符串由同样个数的字符组成。原题\"></a>验证回文构词法，即两个字符串由同样个数的字符组成。<a href=\"https://leetcode.com/problems/valid-anagram/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;anagram&quot;, t &#x3D; &quot;nagaram&quot;</span><br><span class=\"line\">Output: true</span><br></pre></td></tr></table></figure>\n<p>方法一： sort</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_anagram</span><span class=\"params\">(s, t)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sorted(s) == sorted(t)</span><br></pre></td></tr></table></figure>\n<p>方法二：Counter</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_anagram</span><span class=\"params\">(s, t)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Counter</span><br><span class=\"line\">    c1 = Counter(s)</span><br><span class=\"line\">    c2 = Counter(t)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> c1 == c2</span><br></pre></td></tr></table></figure>\n<h3 id=\"438-Find-All-Anagrams-in-a-String\"><a href=\"#438-Find-All-Anagrams-in-a-String\" class=\"headerlink\" title=\"438. Find All Anagrams in a String\"></a>438. Find All Anagrams in a String</h3><h4 id=\"找出字符串中所有的回文构词。原题\"><a href=\"#找出字符串中所有的回文构词。原题\" class=\"headerlink\" title=\"找出字符串中所有的回文构词。原题\"></a>找出字符串中所有的回文构词。<a href=\"https://leetcode.com/problems/find-all-anagrams-in-a-string\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：有个小地方注意就是，如果计数为0要删除，否则等式将不成立。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findAnagrams</span><span class=\"params\">(self, s, p)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Counter</span><br><span class=\"line\">    ns, np = len(s), len(p)</span><br><span class=\"line\">    cur_c = Counter(s[:np<span class=\"number\">-1</span>])</span><br><span class=\"line\">    c_p = Counter(p)</span><br><span class=\"line\">    res = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(np<span class=\"number\">-1</span>, ns):</span><br><span class=\"line\">        cur_c[s[i]] += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> cur_c == c_p:</span><br><span class=\"line\">            res.append(i-np+<span class=\"number\">1</span>)</span><br><span class=\"line\">        cur_c[s[i-np+<span class=\"number\">1</span>]] -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> cur_c[s[i-np+<span class=\"number\">1</span>]] == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">del</span> cur_c[s[i-np+<span class=\"number\">1</span>]]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-Longest-Substring-Without-Repeating-Characters\"><a href=\"#3-Longest-Substring-Without-Repeating-Characters\" class=\"headerlink\" title=\"3. Longest Substring Without Repeating Characters\"></a>3. Longest Substring Without Repeating Characters</h3><h4 id=\"最长不含重复字符的子字符串。原题\"><a href=\"#最长不含重复字符的子字符串。原题\" class=\"headerlink\" title=\"最长不含重复字符的子字符串。原题\"></a>最长不含重复字符的子字符串。<a href=\"https://leetcode.com/problems/longest-substring-without-repeating-characters/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p><del>方法一：暴力法，果然超时了。</del></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">    max_len, n = <span class=\"number\">0</span>, len(s)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i+<span class=\"number\">1</span>, n+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(s[i:j]) == len(set(s[i:j])):</span><br><span class=\"line\">                max_len = max(max_len, len(s[i:j]))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max_len</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：找到重复值时，更新start的值，为什么使用max，因为start有可能大于<code>dic[s[end]]+1</code>，比如当<code>s=&#39;abba&#39;</code>，end走到最后的时候，上一次start因为b做了更新变为了2。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">    res, start = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    dic = &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> end <span class=\"keyword\">in</span> range(len(s)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> s[end] <span class=\"keyword\">in</span> dic:</span><br><span class=\"line\">            start = max(start, dic[s[end]]+<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"comment\"># start = dic[s[end]] + 1</span></span><br><span class=\"line\">        dic[s[end]] = end</span><br><span class=\"line\">        res = max(res, end-start+<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<p>也可以把max判断放到条件里。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">    res, start = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    dic = &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> end <span class=\"keyword\">in</span> range(len(s)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> s[end] <span class=\"keyword\">in</span> dic <span class=\"keyword\">and</span> start &lt;= dic[s[end]]:</span><br><span class=\"line\">            start = dic[s[end]] + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            res = max(res, end-start+<span class=\"number\">1</span>)</span><br><span class=\"line\">        dic[s[end]] = end</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"387-First-Unique-Character-in-a-String\"><a href=\"#387-First-Unique-Character-in-a-String\" class=\"headerlink\" title=\"387. First Unique Character in a String\"></a>387. First Unique Character in a String</h3><h4 id=\"返回第一个不重复的字符。原题\"><a href=\"#返回第一个不重复的字符。原题\" class=\"headerlink\" title=\"返回第一个不重复的字符。原题\"></a>返回第一个不重复的字符。<a href=\"https://leetcode.com/problems/first-unique-character-in-a-string/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">s &#x3D; &quot;leetcode&quot;</span><br><span class=\"line\">return 0.</span><br><span class=\"line\">s &#x3D; &quot;loveleetcode&quot;,</span><br><span class=\"line\">return 2.</span><br></pre></td></tr></table></figure>\n<p>Time-O(N), Space-O(N)。暂时没发现更快的算法了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">firstUniqChar</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Counter</span><br><span class=\"line\">    c = Counter(s)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, ch <span class=\"keyword\">in</span> enumerate(s):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> c[ch] == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> i</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"58-Length-of-Last-Word\"><a href=\"#58-Length-of-Last-Word\" class=\"headerlink\" title=\"58. Length of Last Word\"></a>58. Length of Last Word</h3><h4 id=\"输入一个字符串，通过空格分割，然后返回最后一个单词的长度，空串不算。原题\"><a href=\"#输入一个字符串，通过空格分割，然后返回最后一个单词的长度，空串不算。原题\" class=\"headerlink\" title=\"输入一个字符串，通过空格分割，然后返回最后一个单词的长度，空串不算。原题\"></a>输入一个字符串，通过空格分割，然后返回最后一个单词的长度，空串不算。<a href=\"https://leetcode.com/problems/length-of-last-word/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">s &#x3D; &quot;Hello World&quot;</span><br><span class=\"line\">return 5</span><br><span class=\"line\">s &#x3D; &quot;a &quot;</span><br><span class=\"line\">return 1</span><br><span class=\"line\">s &#x3D; &quot;    &quot;</span><br><span class=\"line\">return 0</span><br></pre></td></tr></table></figure>\n<p>方法一：直观的方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lengthOfLastWord</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">    ss = s.split(<span class=\"string\">' '</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ch <span class=\"keyword\">in</span> ss[::<span class=\"number\">-1</span>]:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ch:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> len(ch)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<p>方法二：使用列表生成式，理论上时间复杂度比上述方法稍微高一点，不过实际时间差不多，估计是list comprehension做了优化。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lengthOfLastWord</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">    ss =[x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> s.split(<span class=\"string\">' '</span>) <span class=\"keyword\">if</span> x]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> len(ss[<span class=\"number\">-1</span>]) <span class=\"keyword\">if</span> ss <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"205-Isomorphic-Strings\"><a href=\"#205-Isomorphic-Strings\" class=\"headerlink\" title=\"205. Isomorphic Strings\"></a>205. Isomorphic Strings</h3><h4 id=\"判断两个字符串是否具有一样的形式。s和t长度一样。原题\"><a href=\"#判断两个字符串是否具有一样的形式。s和t长度一样。原题\" class=\"headerlink\" title=\"判断两个字符串是否具有一样的形式。s和t长度一样。原题\"></a>判断两个字符串是否具有一样的形式。s和t长度一样。<a href=\"https://leetcode.com/problems/isomorphic-strings\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;egg&quot;, t &#x3D; &quot;add&quot;</span><br><span class=\"line\">Output: true</span><br><span class=\"line\"></span><br><span class=\"line\">Input: s &#x3D; &quot;foo&quot;, t &#x3D; &quot;bar&quot;</span><br><span class=\"line\">Output: false</span><br><span class=\"line\"></span><br><span class=\"line\">Input: s &#x3D; &quot;paper&quot;, t &#x3D; &quot;title&quot;</span><br><span class=\"line\">Output: true</span><br></pre></td></tr></table></figure>\n<p>方法一：使用<code>dict</code>保存每个字母的位置。这里使用了<code>OrderedDict</code>保存了<code>values</code>的顺序，也可以使用<code>sorted</code>对<code>values</code>排序。最后说明一下在<code>Python3</code>中需要使用<code>list</code>格式化一下，因为<code>values()</code>返回一个<code>dict_values</code>对象，而这个对象如果直接使用<code>==</code>判断，会返回<code>False</code>，即使有相同的值，这里还不清楚内部的<code>__eq__</code>方法是如何实现的。而在<code>Python2</code>中可以直接比较。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isIsomorphic</span><span class=\"params\">(self, s, t)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> OrderedDict</span><br><span class=\"line\">    d1, d2 = OrderedDict(), OrderedDict()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, val <span class=\"keyword\">in</span> enumerate(s):</span><br><span class=\"line\">        d1[val] = d1.get(val, []) + [i]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, val <span class=\"keyword\">in</span> enumerate(t):</span><br><span class=\"line\">        d2[val] = d2.get(val, []) + [i]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list(d1.values()) == list(d2.values())</span><br></pre></td></tr></table></figure>\n<p>方法二：使用<code>zip</code>并行输出。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; list(zip(<span class=\"string\">'paper'</span>, <span class=\"string\">'title'</span>))</span><br><span class=\"line\">[(<span class=\"string\">'p'</span>, <span class=\"string\">'t'</span>), (<span class=\"string\">'a'</span>, <span class=\"string\">'i'</span>), (<span class=\"string\">'p'</span>, <span class=\"string\">'t'</span>), (<span class=\"string\">'e'</span>, <span class=\"string\">'l'</span>), (<span class=\"string\">'r'</span>, <span class=\"string\">'e'</span>)]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isIsomorphic</span><span class=\"params\">(self, s, t)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> len(set(zip(s, t))) == len(set(s)) == len(set(t))</span><br></pre></td></tr></table></figure>\n<p>方法三：两个字符串每个位置的字符，第一次出现的<code>index</code>是否相同。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isIsomorphic</span><span class=\"params\">(self, s, t)</span>:</span> </span><br><span class=\"line\">    <span class=\"comment\"># return [s.find(i) for i in s] == [t.find(j) for j in t]</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> list(map(s.find, s)) == list(map(t.find, t))</span><br></pre></td></tr></table></figure>\n<p>方法四：setdeault妙用。Lee215。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isIsomorphic</span><span class=\"params\">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(w)</span>:</span></span><br><span class=\"line\">        m = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [m.setdefault(c, len(m)) <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> w]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> f(s) == f(t)</span><br></pre></td></tr></table></figure>\n<h3 id=\"290-Word-Pattern\"><a href=\"#290-Word-Pattern\" class=\"headerlink\" title=\"290. Word Pattern\"></a>290. Word Pattern</h3><h4 id=\"匹配字符串和空格分隔的字符串是否具有相同形式，此题和上一题相似，只不过将其中一个换成了数组。另一个区别是长度不一定相等。原题\"><a href=\"#匹配字符串和空格分隔的字符串是否具有相同形式，此题和上一题相似，只不过将其中一个换成了数组。另一个区别是长度不一定相等。原题\" class=\"headerlink\" title=\"匹配字符串和空格分隔的字符串是否具有相同形式，此题和上一题相似，只不过将其中一个换成了数组。另一个区别是长度不一定相等。原题\"></a>匹配字符串和空格分隔的字符串是否具有相同形式，此题和上一题相似，只不过将其中一个换成了数组。另一个区别是长度不一定相等。<a href=\"https://leetcode.com/problems/word-pattern\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: pattern &#x3D; &quot;abba&quot;, str &#x3D; &quot;dog cat cat dog&quot;</span><br><span class=\"line\">Output: true</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wordPattern</span><span class=\"params\">(self, pattern, str)</span>:</span></span><br><span class=\"line\">    s = pattern</span><br><span class=\"line\">    t = str.split()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list(map(s.find, s)) == list(map(t.index, t))</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wordPattern</span><span class=\"params\">(self, pattern, str)</span>:</span></span><br><span class=\"line\">    s = pattern</span><br><span class=\"line\">    t = str.split()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> len(set(zip(s, t))) == len(set(s)) == len(set(t)) \\</span><br><span class=\"line\">           <span class=\"keyword\">and</span> len(s) == len(t)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wordPattern</span><span class=\"params\">(self, pattern: str, str: str)</span> -&gt; bool:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(w)</span>:</span></span><br><span class=\"line\">        m = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [m.setdefault(c, len(m)) <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> w]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> f(pattern) == f(str.split())</span><br></pre></td></tr></table></figure>\n<h3 id=\"890-Find-and-Replace-Pattern\"><a href=\"#890-Find-and-Replace-Pattern\" class=\"headerlink\" title=\"890. Find and Replace Pattern\"></a>890. Find and Replace Pattern</h3><h4 id=\"找到和pattern一样模式的字符串。和290，205一样。原题\"><a href=\"#找到和pattern一样模式的字符串。和290，205一样。原题\" class=\"headerlink\" title=\"找到和pattern一样模式的字符串。和290，205一样。原题\"></a>找到和pattern一样模式的字符串。和290，205一样。<a href=\"https://leetcode.com/problems/find-and-replace-pattern/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: words &#x3D; [&quot;abc&quot;,&quot;deq&quot;,&quot;mee&quot;,&quot;aqq&quot;,&quot;dkd&quot;,&quot;ccc&quot;], pattern &#x3D; &quot;abb&quot;</span><br><span class=\"line\">Output: [&quot;mee&quot;,&quot;aqq&quot;]</span><br><span class=\"line\">Explanation: &quot;mee&quot; matches the pattern because there is a permutation &#123;a -&gt; m, b -&gt; e, ...&#125;. </span><br><span class=\"line\">&quot;ccc&quot; does not match the pattern because &#123;a -&gt; c, b -&gt; c, ...&#125; is not a permutation,</span><br><span class=\"line\">since a and b map to the same letter.</span><br></pre></td></tr></table></figure>\n<p>方法一：我使用zip和set来判断的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findAndReplacePattern</span><span class=\"params\">(self, words: List[str], pattern: str)</span> -&gt; List[str]:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">same</span><span class=\"params\">(a, b)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> len(set(a)) == len(set(b)) == len(set(zip(a, b)))</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> [word <span class=\"keyword\">for</span> word, p <span class=\"keyword\">in</span> zip(words, itertools.repeat(pattern)) </span><br><span class=\"line\">            <span class=\"keyword\">if</span> same(word, p)]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：Lee215的方法。setdefault的妙用。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findAndReplacePattern</span><span class=\"params\">(self, words: List[str], p: str)</span> -&gt; List[str]:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">F</span><span class=\"params\">(w)</span>:</span></span><br><span class=\"line\">        m = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [m.setdefault(c, len(m)) <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> w]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> [w <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> words <span class=\"keyword\">if</span> F(w) == F(p)]</span><br></pre></td></tr></table></figure>\n<h3 id=\"917-Reverse-Only-Letters\"><a href=\"#917-Reverse-Only-Letters\" class=\"headerlink\" title=\"917. Reverse Only Letters\"></a>917. Reverse Only Letters</h3><h4 id=\"倒置一个字符串的字母。原题\"><a href=\"#倒置一个字符串的字母。原题\" class=\"headerlink\" title=\"倒置一个字符串的字母。原题\"></a>倒置一个字符串的字母。<a href=\"https://leetcode.com/problems/reverse-only-letters\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: &quot;ab-cd&quot;</span><br><span class=\"line\">Output: &quot;dc-ba&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">Input: &quot;a-bC-dEf-ghIj&quot;</span><br><span class=\"line\">Output: &quot;j-Ih-gfE-dCba&quot;</span><br></pre></td></tr></table></figure>\n<p>注意：不能使用<code>l &lt;= r</code>作为条件，因为会打乱正确结果的排序。输出<code>&quot;dcb-a&quot;</code>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseOnlyLetters</span><span class=\"params\">(self, S)</span>:</span></span><br><span class=\"line\">    l, r = <span class=\"number\">0</span>, len(S)<span class=\"number\">-1</span></span><br><span class=\"line\">    res = list(S)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> l &lt; r:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> l&lt;r <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> res[l].isalpha():</span><br><span class=\"line\">            l += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> l&lt;r <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> res[r].isalpha():</span><br><span class=\"line\">            r -= <span class=\"number\">1</span></span><br><span class=\"line\">        res[l], res[r] = res[r], res[l]</span><br><span class=\"line\">        l += <span class=\"number\">1</span></span><br><span class=\"line\">        r -= <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(res)</span><br></pre></td></tr></table></figure>\n<h3 id=\"345-Reverse-Vowels-of-a-String\"><a href=\"#345-Reverse-Vowels-of-a-String\" class=\"headerlink\" title=\"345.Reverse Vowels of a String\"></a>345.Reverse Vowels of a String</h3><h4 id=\"倒置一个字符串中的元音字母。原题\"><a href=\"#倒置一个字符串中的元音字母。原题\" class=\"headerlink\" title=\"倒置一个字符串中的元音字母。原题\"></a>倒置一个字符串中的元音字母。<a href=\"https://leetcode.com/problems/reverse-vowels-of-a-string/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Example 2:</span><br><span class=\"line\"></span><br><span class=\"line\">Input: &quot;leetcode&quot;</span><br><span class=\"line\">Output: &quot;leotcede&quot;</span><br></pre></td></tr></table></figure>\n<p>方法一：和917题一样，换汤不换药。只需定义一个<code>vowels={&#39;a&#39;, &#39;e&#39;, &#39;i&#39;, &#39;o&#39;, &#39;u&#39;}</code>然后条件改成<code>while l&lt;r and res[l].lower() not in vowels:</code>，提交了一下<code>beat</code>有68%左右，应该还有更效率的方法。</p>\n<p>方法二：改了一下，不再使用lower方法了，把大写字母加上，beat变为99.88%。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseVowels</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">    l, r = <span class=\"number\">0</span>, len(s)<span class=\"number\">-1</span></span><br><span class=\"line\">    vowels = set(list(<span class=\"string\">'aeiouAEIOU'</span>))</span><br><span class=\"line\">    res = list(s)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> l &lt; r:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> l&lt;r <span class=\"keyword\">and</span> res[l] <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> vowels:</span><br><span class=\"line\">            l += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> l&lt;r <span class=\"keyword\">and</span> res[r] <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> vowels:</span><br><span class=\"line\">            r -= <span class=\"number\">1</span></span><br><span class=\"line\">        res[l], res[r] = res[r], res[l]</span><br><span class=\"line\">        l += <span class=\"number\">1</span></span><br><span class=\"line\">        r -= <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(res)</span><br></pre></td></tr></table></figure>\n<p>方法三：正则</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseVowels</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">    vowels = re.findall(<span class=\"string\">'(?i)[aeiou]'</span>, s)   <span class=\"comment\"># (?i)表示忽略大小写</span></span><br><span class=\"line\">    <span class=\"comment\"># repl参数每次返回一个值，用来替换s匹配pattern的字符。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> re.sub(<span class=\"string\">'(?i)[aeiou]'</span>, <span class=\"keyword\">lambda</span> m: vowels.pop(), s)</span><br></pre></td></tr></table></figure>\n<h3 id=\"383-Ransom-Note\"><a href=\"#383-Ransom-Note\" class=\"headerlink\" title=\"383. Ransom Note\"></a>383. Ransom Note</h3><h4 id=\"判断是否magazine可以构成ransomNote。原题\"><a href=\"#判断是否magazine可以构成ransomNote。原题\" class=\"headerlink\" title=\"判断是否magazine可以构成ransomNote。原题\"></a>判断是否<code>magazine</code>可以构成<code>ransomNote</code>。<a href=\"https://leetcode.com/problems/ransom-note/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">canConstruct(&quot;a&quot;, &quot;b&quot;) -&gt; false</span><br><span class=\"line\">canConstruct(&quot;aa&quot;, &quot;ab&quot;) -&gt; false</span><br><span class=\"line\">canConstruct(&quot;aa&quot;, &quot;aab&quot;) -&gt; true</span><br></pre></td></tr></table></figure>\n<p>方法一：使用count。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">canConstruct</span><span class=\"params\">(self, ransomNote, magazine)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> set(ransomNote):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> magazine.count(item) &lt; ransomNote.count(item):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：one-liner.</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">canConstruct</span><span class=\"params\">(self, ransomNote, magazine)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> all(ransomNote.count(char) &lt;= magazine.count(char) </span><br><span class=\"line\">               <span class=\"keyword\">for</span> char <span class=\"keyword\">in</span> set(ransomNote))</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\"><strong>方法三：Counter。时间复杂度比二稍高。</strong></font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">canConstruct</span><span class=\"params\">(self, ransomNote, magazine)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Counter</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">not</span> Counter(ransomNote) - Counter(magazine)</span><br></pre></td></tr></table></figure>\n<h3 id=\"925-Long-Pressed-Name\"><a href=\"#925-Long-Pressed-Name\" class=\"headerlink\" title=\"925. Long Pressed Name\"></a>925. Long Pressed Name</h3><h4 id=\"说有这么一个破键盘，老是连键，有时候打一个字母c，出来好几个。给定一个目标字符串和打出来的字符串，判断是否是这个破键盘输出的。原题\"><a href=\"#说有这么一个破键盘，老是连键，有时候打一个字母c，出来好几个。给定一个目标字符串和打出来的字符串，判断是否是这个破键盘输出的。原题\" class=\"headerlink\" title=\"说有这么一个破键盘，老是连键，有时候打一个字母c，出来好几个。给定一个目标字符串和打出来的字符串，判断是否是这个破键盘输出的。原题\"></a>说有这么一个破键盘，老是连键，有时候打一个字母c，出来好几个。给定一个目标字符串和打出来的字符串，判断是否是这个破键盘输出的。<a href=\"https://leetcode.com/problems/long-pressed-name/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: name = \"alex\", typed = \"aaleex\"</span><br><span class=\"line\">Output: true</span><br><span class=\"line\">Explanation: 'a' and 'e' in 'alex' were long pressed.</span><br><span class=\"line\"></span><br><span class=\"line\">Input: name = \"saeed\", typed = \"ssaaedd\"</span><br><span class=\"line\">Output: false</span><br><span class=\"line\">Explanation: 'e' must have been pressed twice, but it wasn't in the typed output.</span><br></pre></td></tr></table></figure>\n<p>思路：一开始还想用Counter，后来发现不对，因为它将所有的一样的字符聚合到了一起。所以此题可以使用<code>groupby</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isLongPressedName</span><span class=\"params\">(self, name, typed)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> itertools <span class=\"keyword\">import</span> groupby</span><br><span class=\"line\">    name_groups = [(ch, len(list(g))) <span class=\"keyword\">for</span> ch, g <span class=\"keyword\">in</span> groupby(name)]</span><br><span class=\"line\">    typed_groups = [(ch, len(list(g))) <span class=\"keyword\">for</span> ch, g <span class=\"keyword\">in</span> groupby(typed)]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(typed_groups) &lt; len(name_groups):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(name_groups)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> typed_groups[i][<span class=\"number\">0</span>] != name_groups[i][<span class=\"number\">0</span>] <span class=\"keyword\">or</span> \\</span><br><span class=\"line\">            typed_groups[i][<span class=\"number\">1</span>] &lt; name_groups[i][<span class=\"number\">1</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：简单的写法。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isLongPressedName</span><span class=\"params\">(self, name: str, typed: str)</span> -&gt; bool:</span></span><br><span class=\"line\">    ngroups = itertools.groupby(name)</span><br><span class=\"line\">    tgroups = itertools.groupby(typed)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (nl, nc), (tl, tc) <span class=\"keyword\">in</span> itertools.zip_longest(</span><br><span class=\"line\">            ngroups, tgroups, fillvalue=(<span class=\"string\">'~'</span>, [])):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> nl != tl <span class=\"keyword\">or</span> len(list(nc)) &gt;len(list(tc)):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"929-Unique-Email-Addresses\"><a href=\"#929-Unique-Email-Addresses\" class=\"headerlink\" title=\"929. Unique Email Addresses\"></a>929. Unique Email Addresses</h3><h4 id=\"统计不同的email地址。原题\"><a href=\"#统计不同的email地址。原题\" class=\"headerlink\" title=\"统计不同的email地址。原题\"></a>统计不同的email地址。<a href=\"https://leetcode.com/problems/unique-email-addresses\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numUniqueEmails</span><span class=\"params\">(self, emails)</span>:</span></span><br><span class=\"line\">    res = set()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> email <span class=\"keyword\">in</span> emails:</span><br><span class=\"line\">        local, domain = email.split(<span class=\"string\">'@'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"string\">'+'</span> <span class=\"keyword\">in</span> local:</span><br><span class=\"line\">            local = local[:local.index(<span class=\"string\">'+'</span>)]</span><br><span class=\"line\">        local = local.replace(<span class=\"string\">'.'</span>, <span class=\"string\">''</span>)</span><br><span class=\"line\">        res.add((local, domain))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> len(res)</span><br></pre></td></tr></table></figure>\n<h3 id=\"409-Longest-Palindrome\"><a href=\"#409-Longest-Palindrome\" class=\"headerlink\" title=\"409. Longest Palindrome\"></a>409. Longest Palindrome</h3><h4 id=\"给你一堆字符串，返回用它组成的最长的回文串的长度，可以不使用所有的字符。原题\"><a href=\"#给你一堆字符串，返回用它组成的最长的回文串的长度，可以不使用所有的字符。原题\" class=\"headerlink\" title=\"给你一堆字符串，返回用它组成的最长的回文串的长度，可以不使用所有的字符。原题\"></a>给你一堆字符串，返回用它组成的最长的回文串的长度，可以不使用所有的字符。<a href=\"https://leetcode.com/problems/longest-palindrome/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：每对一样的数字可以放在两边来组成回文。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Counter</span><br><span class=\"line\">    c = Counter(s)</span><br><span class=\"line\">    res = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> count <span class=\"keyword\">in</span> c.values():</span><br><span class=\"line\">        res += count // <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res*<span class=\"number\">2</span> + (len(s) &gt; res*<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\"><strong>方法二：从奇数的角度考虑。</strong></font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Counter</span><br><span class=\"line\">    odds = sum(v &amp; <span class=\"number\">1</span> <span class=\"keyword\">for</span> v <span class=\"keyword\">in</span> Counter(s).values())</span><br><span class=\"line\">    <span class=\"keyword\">return</span> len(s) - odds + bool(odds)  <span class=\"comment\"># 如果有奇数，总能将其放到中间</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"434-Number-of-Segments-in-a-String\"><a href=\"#434-Number-of-Segments-in-a-String\" class=\"headerlink\" title=\"434. Number of Segments in a String\"></a>434. Number of Segments in a String</h3><h4 id=\"统计字符串中有多少个以空格分割的字符串。原题\"><a href=\"#统计字符串中有多少个以空格分割的字符串。原题\" class=\"headerlink\" title=\"统计字符串中有多少个以空格分割的字符串。原题\"></a>统计字符串中有多少个以空格分割的字符串。<a href=\"https://leetcode.com/problems/number-of-segments-in-a-string/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><font color=\"#32CD32\" size=\"3\"><strong>方法一：Time-O(n), Space-O(1)</strong></font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countSegments</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">    segment_count = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(s)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> <span class=\"keyword\">or</span> s[i<span class=\"number\">-1</span>] == <span class=\"string\">' '</span>) <span class=\"keyword\">and</span> s[i] != <span class=\"string\">' '</span>:</span><br><span class=\"line\">            segment_count += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> segment_count</span><br></pre></td></tr></table></figure>\n<p>方法二：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countSegments</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> len(s.split())</span><br></pre></td></tr></table></figure>\n<h3 id=\"500-Keyboard-Row\"><a href=\"#500-Keyboard-Row\" class=\"headerlink\" title=\"500. Keyboard Row\"></a>500. Keyboard Row</h3><h4 id=\"输入一个字符串数组，返回字符在键盘同一行的字符串。原题\"><a href=\"#输入一个字符串数组，返回字符在键盘同一行的字符串。原题\" class=\"headerlink\" title=\"输入一个字符串数组，返回字符在键盘同一行的字符串。原题\"></a>输入一个字符串数组，返回字符在键盘同一行的字符串。<a href=\"https://leetcode.com/problems/keyboard-row/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [&quot;Hello&quot;, &quot;Alaska&quot;, &quot;Dad&quot;, &quot;Peace&quot;]</span><br><span class=\"line\">Output: [&quot;Alaska&quot;, &quot;Dad&quot;]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findWords</span><span class=\"params\">(self, words)</span>:</span></span><br><span class=\"line\">        self.first = &#123;<span class=\"string\">'Q'</span>, <span class=\"string\">'W'</span>, <span class=\"string\">'E'</span>, <span class=\"string\">'R'</span>, <span class=\"string\">'T'</span>, <span class=\"string\">'Y'</span>, <span class=\"string\">'U'</span>, <span class=\"string\">'I'</span>, <span class=\"string\">'O'</span>, <span class=\"string\">'P'</span>&#125;</span><br><span class=\"line\">        self.second = &#123;<span class=\"string\">'A'</span>, <span class=\"string\">'S'</span>, <span class=\"string\">'D'</span>, <span class=\"string\">'F'</span>, <span class=\"string\">'G'</span>, <span class=\"string\">'H'</span>, <span class=\"string\">'J'</span>, <span class=\"string\">'K'</span>, <span class=\"string\">'L'</span>&#125;        </span><br><span class=\"line\">        self.third = &#123;<span class=\"string\">'Z'</span>, <span class=\"string\">'X'</span>, <span class=\"string\">'C'</span>, <span class=\"string\">'V'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'N'</span>, <span class=\"string\">'M'</span>&#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list(filter(self.same_line, words))</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">same_line</span><span class=\"params\">(self, word)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> set(word.upper()) &lt;= set(self.first) <span class=\"keyword\">or</span> \\</span><br><span class=\"line\">               set(word.upper()) &lt;= set(self.second) <span class=\"keyword\">or</span> \\</span><br><span class=\"line\">               set(word.upper()) &lt;= set(self.third)</span><br></pre></td></tr></table></figure>\n<h3 id=\"520-Detect-Capital\"><a href=\"#520-Detect-Capital\" class=\"headerlink\" title=\"520. Detect Capital\"></a>520. Detect Capital</h3><h4 id=\"判断一个字符串的大写是否使用正确。要么全大写，要么全小写，或者首字母大写。原题\"><a href=\"#判断一个字符串的大写是否使用正确。要么全大写，要么全小写，或者首字母大写。原题\" class=\"headerlink\" title=\"判断一个字符串的大写是否使用正确。要么全大写，要么全小写，或者首字母大写。原题\"></a>判断一个字符串的大写是否使用正确。要么全大写，要么全小写，或者首字母大写。<a href=\"https://leetcode.com/problems/detect-capital/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: &quot;USA&quot;</span><br><span class=\"line\">Output: True</span><br></pre></td></tr></table></figure>\n<p>方法一：太简单了，一下子就写出来了，看评论居然好多人不知道<code>istitle</code>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">detectCapitalUse</span><span class=\"params\">(self, word)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> word.islower() <span class=\"keyword\">or</span> word.isupper() <span class=\"keyword\">or</span> word.istitle()</span><br></pre></td></tr></table></figure>\n<h3 id=\"541-Reverse-String-II\"><a href=\"#541-Reverse-String-II\" class=\"headerlink\" title=\"541. Reverse String II\"></a>541. Reverse String II</h3><h4 id=\"按照2k的长度划分一个字符串，把其中每段前k个字符倒置。原题\"><a href=\"#按照2k的长度划分一个字符串，把其中每段前k个字符倒置。原题\" class=\"headerlink\" title=\"按照2k的长度划分一个字符串，把其中每段前k个字符倒置。原题\"></a>按照2k的长度划分一个字符串，把其中每段前k个字符倒置。<a href=\"https://leetcode.com/problems/reverse-string-ii/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;abcdefg&quot;, k &#x3D; 2</span><br><span class=\"line\">Output: &quot;bacdfeg&quot;</span><br></pre></td></tr></table></figure>\n<p>方法一：比较简单的一题，使用Python的切片。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseStr</span><span class=\"params\">(self, s, k)</span>:</span></span><br><span class=\"line\">    letters = list(s)</span><br><span class=\"line\">    n = len(letters)</span><br><span class=\"line\">    <span class=\"comment\"># for i in range(n//(2*k)+1):</span></span><br><span class=\"line\">        <span class=\"comment\"># letters[2*k*i:k+2*k*i] = reversed(letters[2*k*i:k+2*k*i])</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, n, <span class=\"number\">2</span>*k):</span><br><span class=\"line\">        letters[i:k+i] = reversed(letters[i:k+i])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(letters)</span><br></pre></td></tr></table></figure>\n<h3 id=\"551-Student-Attendance-Record-I\"><a href=\"#551-Student-Attendance-Record-I\" class=\"headerlink\" title=\"551. Student Attendance Record I\"></a>551. Student Attendance Record I</h3><h4 id=\"判断一个学生是否有奖励，缺席次数小于等于一天，没有三次连续的迟到。原题\"><a href=\"#判断一个学生是否有奖励，缺席次数小于等于一天，没有三次连续的迟到。原题\" class=\"headerlink\" title=\"判断一个学生是否有奖励，缺席次数小于等于一天，没有三次连续的迟到。原题\"></a>判断一个学生是否有奖励，缺席次数小于等于一天，没有三次连续的迟到。<a href=\"https://leetcode.com/problems/student-attendance-record-i/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: &quot;PPALLP&quot;</span><br><span class=\"line\">Output: True</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">checkRecord</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.count(<span class=\"string\">'A'</span>)&lt;= <span class=\"number\">1</span> <span class=\"keyword\">and</span> <span class=\"string\">'LLL'</span> <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> s</span><br></pre></td></tr></table></figure>\n<h3 id=\"557-Reverse-Words-in-a-String-III\"><a href=\"#557-Reverse-Words-in-a-String-III\" class=\"headerlink\" title=\"557. Reverse Words in a String III\"></a>557. Reverse Words in a String III</h3><h4 id=\"倒置一句话中的每个单词。所有单词均已一个空格分隔。原题\"><a href=\"#倒置一句话中的每个单词。所有单词均已一个空格分隔。原题\" class=\"headerlink\" title=\"倒置一句话中的每个单词。所有单词均已一个空格分隔。原题\"></a>倒置一句话中的每个单词。所有单词均已一个空格分隔。<a href=\"https://leetcode.com/problems/reverse-words-in-a-string-iii/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: &quot;Let&#39;s take LeetCode contest&quot;</span><br><span class=\"line\">Output: &quot;s&#39;teL ekat edoCteeL tsetnoc&quot;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseWords</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">' '</span>.join([word[::<span class=\"number\">-1</span>] <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> s.split()])</span><br></pre></td></tr></table></figure>\n<h3 id=\"657-Robot-Return-to-Origin\"><a href=\"#657-Robot-Return-to-Origin\" class=\"headerlink\" title=\"657. Robot Return to Origin\"></a>657. Robot Return to Origin</h3><h4 id=\"机器人是否能回到原点。’UDLR’分别表示上下左右，每次移动的距离一样。原题\"><a href=\"#机器人是否能回到原点。’UDLR’分别表示上下左右，每次移动的距离一样。原题\" class=\"headerlink\" title=\"机器人是否能回到原点。’UDLR’分别表示上下左右，每次移动的距离一样。原题\"></a>机器人是否能回到原点。’UDLR’分别表示上下左右，每次移动的距离一样。<a href=\"https://leetcode.com/problems/robot-return-to-origin/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: &quot;UD&quot;</span><br><span class=\"line\">Output: true </span><br><span class=\"line\">Explanation: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true.</span><br></pre></td></tr></table></figure>\n<p>方法一：就是看上下和左右的次数是否一样。此题过于简单。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">judgeCircle</span><span class=\"params\">(self, moves)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> moves.count(<span class=\"string\">'L'</span>) == moves.count(<span class=\"string\">'R'</span>) <span class=\"keyword\">and</span> \\</span><br><span class=\"line\">           moves.count(<span class=\"string\">'U'</span>) == moves.count(<span class=\"string\">'D'</span>)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">judgeCircle</span><span class=\"params\">(self, moves)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Counter</span><br><span class=\"line\">    c = Counter(moves)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> c[<span class=\"string\">'U'</span>] == c[<span class=\"string\">'D'</span>] <span class=\"keyword\">and</span> c[<span class=\"string\">'L'</span>] == c[<span class=\"string\">'R'</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"696-Count-Binary-Substrings\"><a href=\"#696-Count-Binary-Substrings\" class=\"headerlink\" title=\"696. Count Binary Substrings\"></a>696. Count Binary Substrings</h3><h4 id=\"二进制字符串计数，有多少个连续的子字符串，由相同的0和1组成，如’10’，’1100’。原题\"><a href=\"#二进制字符串计数，有多少个连续的子字符串，由相同的0和1组成，如’10’，’1100’。原题\" class=\"headerlink\" title=\"二进制字符串计数，有多少个连续的子字符串，由相同的0和1组成，如’10’，’1100’。原题\"></a>二进制字符串计数，有多少个连续的子字符串，由相同的0和1组成，如’10’，’1100’。<a href=\"https://leetcode.com/problems/count-binary-substrings/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: &quot;00110011&quot;</span><br><span class=\"line\">Output: 6</span><br><span class=\"line\">Explanation: There are 6 substrings that have equal number of consecutive 1&#39;s and 0&#39;s: &quot;0011&quot;, &quot;01&quot;, &quot;1100&quot;, &quot;10&quot;, &quot;0011&quot;, and &quot;01&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">Notice that some of these substrings repeat and are counted the number of times they occur.</span><br><span class=\"line\"></span><br><span class=\"line\">Also, &quot;00110011&quot; is not a valid substring because all the 0&#39;s (and 1&#39;s) are not grouped together.</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法一：正则要比groupby快.</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countBinarySubstrings</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> itertools <span class=\"keyword\">import</span> groupby</span><br><span class=\"line\">    <span class=\"comment\"># groups = [len(list(v)) for _, v in groupby(s)]</span></span><br><span class=\"line\">    groups = list(map(len, re.findall(<span class=\"string\">'0+|1+'</span>, s)))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(min(a, b) <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> zip(groups, groups[<span class=\"number\">1</span>:]))</span><br></pre></td></tr></table></figure>\n<p>方法二：变量，常数空间复杂度。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countBinarySubstrings</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">    res, prev, cur = <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(s)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> s[i] != s[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">            res += min(prev, cur)</span><br><span class=\"line\">            prev, cur = cur, <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            cur += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res + min(prev, cur)</span><br></pre></td></tr></table></figure>\n<h3 id=\"709-To-Lower-Case\"><a href=\"#709-To-Lower-Case\" class=\"headerlink\" title=\"709. To Lower Case\"></a>709. To Lower Case</h3><h4 id=\"实现字符串的lower方法。原题\"><a href=\"#实现字符串的lower方法。原题\" class=\"headerlink\" title=\"实现字符串的lower方法。原题\"></a>实现字符串的<code>lower</code>方法。<a href=\"https://leetcode.com/problems/to-lower-case/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: &quot;Hello&quot;</span><br><span class=\"line\">Output: &quot;hello&quot;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">toLowerCase</span><span class=\"params\">(self, str)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(chr(ord(c)+<span class=\"number\">32</span>) <span class=\"keyword\">if</span> <span class=\"number\">65</span>&lt;=ord(c)&lt;=<span class=\"number\">90</span> <span class=\"keyword\">else</span> c</span><br><span class=\"line\">                   <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> str)</span><br></pre></td></tr></table></figure>\n<h3 id=\"771-Jewels-and-Stones\"><a href=\"#771-Jewels-and-Stones\" class=\"headerlink\" title=\"771. Jewels and Stones\"></a>771. Jewels and Stones</h3><h4 id=\"判断S里有多少个在J里，J为不重复元素。原题\"><a href=\"#判断S里有多少个在J里，J为不重复元素。原题\" class=\"headerlink\" title=\"判断S里有多少个在J里，J为不重复元素。原题\"></a>判断S里有多少个在J里，J为不重复元素。<a href=\"https://leetcode.com/problems/jewels-and-stones/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: J &#x3D; &quot;aA&quot;, S &#x3D; &quot;aAAbbbb&quot;</span><br><span class=\"line\">Output: 3</span><br></pre></td></tr></table></figure>\n<p>方法一：使用set.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numJewelsInStones</span><span class=\"params\">(self, J: <span class=\"string\">'str'</span>, S: <span class=\"string\">'str'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    jewels = set(J)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(s <span class=\"keyword\">in</span> jewels <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> S)</span><br></pre></td></tr></table></figure>\n<p>方法二：count. count的值只会是0和1，因为J没有重复元素。由于这个特性，所以反过来也是一样。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numJewelsInStones</span><span class=\"params\">(self, J: <span class=\"string\">'str'</span>, S: <span class=\"string\">'str'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    <span class=\"comment\"># return sum(map(J.count, S))</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum(map(S.count, J))</span><br></pre></td></tr></table></figure>\n<h3 id=\"784-Letter-Case-Permutation\"><a href=\"#784-Letter-Case-Permutation\" class=\"headerlink\" title=\"784. Letter Case Permutation\"></a>784. Letter Case Permutation</h3><h4 id=\"字母组合，给定一个字符串，其中的字母可大写可小写，返回所有可能的字符串。原题\"><a href=\"#字母组合，给定一个字符串，其中的字母可大写可小写，返回所有可能的字符串。原题\" class=\"headerlink\" title=\"字母组合，给定一个字符串，其中的字母可大写可小写，返回所有可能的字符串。原题\"></a>字母组合，给定一个字符串，其中的字母可大写可小写，返回所有可能的字符串。<a href=\"https://leetcode.com/problems/letter-case-permutation/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Examples:</span><br><span class=\"line\">Input: S &#x3D; &quot;a1b2&quot;</span><br><span class=\"line\">Output: [&quot;a1b2&quot;, &quot;a1B2&quot;, &quot;A1b2&quot;, &quot;A1B2&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">Input: S &#x3D; &quot;3z4&quot;</span><br><span class=\"line\">Output: [&quot;3z4&quot;, &quot;3Z4&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">Input: S &#x3D; &quot;12345&quot;</span><br><span class=\"line\">Output: [&quot;12345&quot;]</span><br></pre></td></tr></table></figure>\n<p>方法一：提取字母，然后<code>format</code>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">letterCasePermutation</span><span class=\"params\">(self, S: <span class=\"string\">'str'</span>)</span> -&gt; 'List[str]':</span></span><br><span class=\"line\">    letters = <span class=\"string\">''</span>.join(x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> S <span class=\"keyword\">if</span> x.isalpha())</span><br><span class=\"line\">    s = re.sub(<span class=\"string\">r'[A-Za-z]'</span>, <span class=\"string\">'&#123;&#125;'</span>, S)</span><br><span class=\"line\">    ans = [<span class=\"string\">''</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> l <span class=\"keyword\">in</span> letters:</span><br><span class=\"line\">        ans = [pre+x <span class=\"keyword\">for</span> pre <span class=\"keyword\">in</span> ans <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> (l.lower(), l.upper())]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [s.format(*f) <span class=\"keyword\">for</span> f <span class=\"keyword\">in</span> ans]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：一开始被题目误导了，以为是排列，后来想到了笛卡尔乘积，但是没想到可以这样写。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">letterCasePermutation</span><span class=\"params\">(self, S: <span class=\"string\">'str'</span>)</span> -&gt; 'List[str]':</span></span><br><span class=\"line\">    L = ((s.lower(), s.upper()) <span class=\"keyword\">if</span> s.isalpha() <span class=\"keyword\">else</span> s <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> S)</span><br><span class=\"line\">    <span class=\"comment\"># [('a', 'A'), '1', ('b', 'B'), '2']</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"string\">''</span>.join(c) <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> itertools.product(*L)]</span><br></pre></td></tr></table></figure>\n<h3 id=\"788-Rotated-Digits\"><a href=\"#788-Rotated-Digits\" class=\"headerlink\" title=\"788. Rotated Digits\"></a>788. Rotated Digits</h3><h4 id=\"可旋转的数字，说把一个数的所有数字旋转180度，是一个正确的数字。并且和原来不同。给定一个N，返回1-N所有这样的数的个数。原题\"><a href=\"#可旋转的数字，说把一个数的所有数字旋转180度，是一个正确的数字。并且和原来不同。给定一个N，返回1-N所有这样的数的个数。原题\" class=\"headerlink\" title=\"可旋转的数字，说把一个数的所有数字旋转180度，是一个正确的数字。并且和原来不同。给定一个N，返回1~N所有这样的数的个数。原题\"></a>可旋转的数字，说把一个数的所有数字旋转180度，是一个正确的数字。并且和原来不同。给定一个N，返回1~N所有这样的数的个数。<a href=\"https://leetcode.com/problems/rotated-digits/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Example:</span><br><span class=\"line\">Input: 10</span><br><span class=\"line\">Output: 4</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">There are four good numbers in the range [1, 10] : 2, 5, 6, 9.</span><br><span class=\"line\">Note that 1 and 10 are not good numbers, since they remain unchanged after rotating.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rotatedDigits</span><span class=\"params\">(self, N: <span class=\"string\">'int'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    changed = &#123;<span class=\"string\">'2'</span>, <span class=\"string\">'5'</span>, <span class=\"string\">'6'</span>, <span class=\"string\">'9'</span>&#125;</span><br><span class=\"line\">    valid = changed | &#123;<span class=\"string\">'0'</span>, <span class=\"string\">'1'</span>, <span class=\"string\">'8'</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(bool(set(str(i))&lt;=valid <span class=\"keyword\">and</span> set(str(i))&amp;changed)</span><br><span class=\"line\">               <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, N+<span class=\"number\">1</span>))</span><br></pre></td></tr></table></figure>\n<h3 id=\"796-Rotate-String\"><a href=\"#796-Rotate-String\" class=\"headerlink\" title=\"796. Rotate String\"></a>796. Rotate String</h3><h4 id=\"判断一个字符串A是否可以旋转成B。原题\"><a href=\"#判断一个字符串A是否可以旋转成B。原题\" class=\"headerlink\" title=\"判断一个字符串A是否可以旋转成B。原题\"></a>判断一个字符串A是否可以旋转成B。<a href=\"https://leetcode.com/problems/rotate-string/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Example 1:</span><br><span class=\"line\">Input: A &#x3D; &#39;abcde&#39;, B &#x3D; &#39;cdeab&#39;</span><br><span class=\"line\">Output: true</span><br><span class=\"line\"></span><br><span class=\"line\">Example 2:</span><br><span class=\"line\">Input: A &#x3D; &#39;abcde&#39;, B &#x3D; &#39;abced&#39;</span><br><span class=\"line\">Output: false</span><br></pre></td></tr></table></figure>\n<p>方法一：Brute Force. Time: O(N²), Space: O(N²).</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rotateString</span><span class=\"params\">(self, A: <span class=\"string\">'str'</span>, B: <span class=\"string\">'str'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(len(A)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> A[-k:] + A[:-k] == B:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span> <span class=\"keyword\">if</span> A <span class=\"keyword\">else</span> A==B</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：Time O(N²). Space O(N).</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rotateString</span><span class=\"params\">(self, A: <span class=\"string\">'str'</span>, B: <span class=\"string\">'str'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> len(A)==len(B) <span class=\"keyword\">and</span> B <span class=\"keyword\">in</span> A*<span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<p>方法三：KMP算法。留坑。</p>\n<p>方法四：Rolling Hash算法。留坑。</p>\n<h3 id=\"804-Unique-Morse-Code-Words\"><a href=\"#804-Unique-Morse-Code-Words\" class=\"headerlink\" title=\"804. Unique Morse Code Words\"></a>804. Unique Morse Code Words</h3><h4 id=\"不重复的莫斯密码，给定一句话，求不重复的单词的莫斯密码个数。原题\"><a href=\"#不重复的莫斯密码，给定一句话，求不重复的单词的莫斯密码个数。原题\" class=\"headerlink\" title=\"不重复的莫斯密码，给定一句话，求不重复的单词的莫斯密码个数。原题\"></a>不重复的莫斯密码，给定一句话，求不重复的单词的莫斯密码个数。<a href=\"https://leetcode.com/problems/unique-morse-code-words/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Example:</span><br><span class=\"line\">Input: words &#x3D; [&quot;gin&quot;, &quot;zen&quot;, &quot;gig&quot;, &quot;msg&quot;]</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">The transformation of each word is:</span><br><span class=\"line\">&quot;gin&quot; -&gt; &quot;--...-.&quot;</span><br><span class=\"line\">&quot;zen&quot; -&gt; &quot;--...-.&quot;</span><br><span class=\"line\">&quot;gig&quot; -&gt; &quot;--...--.&quot;</span><br><span class=\"line\">&quot;msg&quot; -&gt; &quot;--...--.&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">There are 2 different transformations, &quot;--...-.&quot; and &quot;--...--.&quot;.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">uniqueMorseRepresentations</span><span class=\"params\">(self, words: <span class=\"string\">'List[str]'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    codes = [<span class=\"string\">\".-\"</span>,<span class=\"string\">\"-...\"</span>,<span class=\"string\">\"-.-.\"</span>,<span class=\"string\">\"-..\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\"..-.\"</span>,<span class=\"string\">\"--.\"</span>,<span class=\"string\">\"....\"</span>,<span class=\"string\">\"..\"</span>,<span class=\"string\">\".---\"</span>,<span class=\"string\">\"-.-\"</span>,<span class=\"string\">\".-..\"</span>,<span class=\"string\">\"--\"</span>,<span class=\"string\">\"-.\"</span>,<span class=\"string\">\"---\"</span>,<span class=\"string\">\".--.\"</span>,<span class=\"string\">\"--.-\"</span>,<span class=\"string\">\".-.\"</span>,<span class=\"string\">\"...\"</span>,<span class=\"string\">\"-\"</span>,<span class=\"string\">\"..-\"</span>,<span class=\"string\">\"...-\"</span>,<span class=\"string\">\".--\"</span>,<span class=\"string\">\"-..-\"</span>,<span class=\"string\">\"-.--\"</span>,<span class=\"string\">\"--..\"</span>]</span><br><span class=\"line\">    <span class=\"comment\"># morse = dict(zip(string.ascii_lowercase, codes))</span></span><br><span class=\"line\">    <span class=\"comment\"># seen = &#123;''.join(morse[c] for c in word) for word in words&#125;</span></span><br><span class=\"line\">    seen = &#123;<span class=\"string\">''</span>.join(codes[ord(c)-ord(<span class=\"string\">'a'</span>)] <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> word) </span><br><span class=\"line\">           <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> words&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> len(seen)</span><br></pre></td></tr></table></figure>\n<h3 id=\"806-Number-of-Lines-To-Write-String\"><a href=\"#806-Number-of-Lines-To-Write-String\" class=\"headerlink\" title=\"806. Number of Lines To Write String\"></a>806. Number of Lines To Write String</h3><h4 id=\"单词换行，已知每个字母的宽度，每100一换行，写不下一个字母时，换行，最一个字符串需要多少行和末尾行的宽度。原题\"><a href=\"#单词换行，已知每个字母的宽度，每100一换行，写不下一个字母时，换行，最一个字符串需要多少行和末尾行的宽度。原题\" class=\"headerlink\" title=\"单词换行，已知每个字母的宽度，每100一换行，写不下一个字母时，换行，最一个字符串需要多少行和末尾行的宽度。原题\"></a>单词换行，已知每个字母的宽度，每100一换行，写不下一个字母时，换行，最一个字符串需要多少行和末尾行的宽度。<a href=\"https://leetcode.com/problems/number-of-lines-to-write-string/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Example :</span><br><span class=\"line\">Input: </span><br><span class=\"line\">widths &#x3D; [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]</span><br><span class=\"line\">S &#x3D; &quot;abcdefghijklmnopqrstuvwxyz&quot;</span><br><span class=\"line\">Output: [3, 60]</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">All letters have the same length of 10. To write all 26 letters,</span><br><span class=\"line\">we need two full lines and one line with 60 units.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numberOfLines</span><span class=\"params\">(self, widths: <span class=\"string\">'List[int]'</span>, S: <span class=\"string\">'str'</span>)</span> -&gt; 'List[int]':</span></span><br><span class=\"line\">    width = dict(zip(string.ascii_letters, widths))</span><br><span class=\"line\">    lines, line = <span class=\"number\">1</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> S:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> line + width[s] &gt; <span class=\"number\">100</span>:</span><br><span class=\"line\">            lines += <span class=\"number\">1</span></span><br><span class=\"line\">            line = <span class=\"number\">0</span></span><br><span class=\"line\">        line += width[s]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lines, line</span><br></pre></td></tr></table></figure>\n<h3 id=\"819-Most-Common-Word\"><a href=\"#819-Most-Common-Word\" class=\"headerlink\" title=\"819. Most Common Word\"></a>819. Most Common Word</h3><h4 id=\"最常见的单词，从输入的段落中找到出现频率最高并且不在banned列表中的单词。原题\"><a href=\"#最常见的单词，从输入的段落中找到出现频率最高并且不在banned列表中的单词。原题\" class=\"headerlink\" title=\"最常见的单词，从输入的段落中找到出现频率最高并且不在banned列表中的单词。原题\"></a>最常见的单词，从输入的段落中找到出现频率最高并且不在banned列表中的单词。<a href=\"https://leetcode.com/problems/most-common-word/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: </span><br><span class=\"line\">paragraph &#x3D; &quot;Bob hit a ball, the hit BALL flew far after it was hit.&quot;</span><br><span class=\"line\">banned &#x3D; [&quot;hit&quot;]</span><br><span class=\"line\">Output: &quot;ball&quot;</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">&quot;hit&quot; occurs 3 times, but it is a banned word.</span><br><span class=\"line\">&quot;ball&quot; occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. </span><br><span class=\"line\">Note that words in the paragraph are not case sensitive,</span><br><span class=\"line\">that punctuation is ignored (even if adjacent to words, such as &quot;ball,&quot;), </span><br><span class=\"line\">and that &quot;hit&quot; isn&#39;t the answer even though it occurs more because it is banned.</span><br></pre></td></tr></table></figure>\n<p>方法一：一开始写的方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mostCommonWord</span><span class=\"params\">(self, paragraph: <span class=\"string\">'str'</span>, banned: <span class=\"string\">'List[str]'</span>)</span> -&gt; 'str':</span></span><br><span class=\"line\">    words = re.split(<span class=\"string\">r'[!?\\',;. ]'</span>, paragraph.lower())</span><br><span class=\"line\">    c = collections.Counter(words)</span><br><span class=\"line\">    banned = set(banned)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> word, count <span class=\"keyword\">in</span> c.most_common():</span><br><span class=\"line\">        <span class=\"keyword\">if</span> word <span class=\"keyword\">and</span> word <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> banned:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> word</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">''</span></span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：上述方法的优化。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mostCommonWord</span><span class=\"params\">(self, paragraph: <span class=\"string\">'str'</span>, banned: <span class=\"string\">'List[str]'</span>)</span> -&gt; 'str':</span></span><br><span class=\"line\">    words = re.findall(<span class=\"string\">r'\\w+'</span>, paragraph.lower())</span><br><span class=\"line\">    banset = set(banned)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> collections.Counter(</span><br><span class=\"line\">        (w <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> words <span class=\"keyword\">if</span> w <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> banset)).most_common(<span class=\"number\">1</span>)[<span class=\"number\">0</span>][<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"821-Shortest-Distance-to-a-Character\"><a href=\"#821-Shortest-Distance-to-a-Character\" class=\"headerlink\" title=\"821. Shortest Distance to a Character\"></a>821. Shortest Distance to a Character</h3><h4 id=\"根据已知字符串S-求目标字符C和左右index最近的距离。原题\"><a href=\"#根据已知字符串S-求目标字符C和左右index最近的距离。原题\" class=\"headerlink\" title=\"根据已知字符串S, 求目标字符C和左右index最近的距离。原题\"></a>根据已知字符串S, 求目标字符C和左右index最近的距离。<a href=\"https://leetcode.com/problems/shortest-distance-to-a-character/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: S &#x3D; &quot;loveleetcode&quot;, C &#x3D; &#39;e&#39;</span><br><span class=\"line\">Output: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]</span><br></pre></td></tr></table></figure>\n<p>方法一：前后遍历两次，分别求距离。本想通过一次，结果实现过于繁琐。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">shortestToChar</span><span class=\"params\">(self, S: <span class=\"string\">'str'</span>, C: <span class=\"string\">'str'</span>)</span> -&gt; 'List[int]':</span></span><br><span class=\"line\">    n = len(S)</span><br><span class=\"line\">    ans = [<span class=\"number\">0</span> <span class=\"keyword\">if</span> x == C <span class=\"keyword\">else</span> n <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> S]</span><br><span class=\"line\">    pos = -n</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> list(range(n)) + list(range(n)[::<span class=\"number\">-1</span>]):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ans[i] == <span class=\"number\">0</span>: pos = i</span><br><span class=\"line\">        ans[i] = min(ans[i], abs(pos-i))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"824-Goat-Latin\"><a href=\"#824-Goat-Latin\" class=\"headerlink\" title=\"824. Goat Latin\"></a>824. Goat Latin</h3><h4 id=\"山羊拉丁口音，把一句话中的每个单词根据规则，生成一句新的话。原题\"><a href=\"#山羊拉丁口音，把一句话中的每个单词根据规则，生成一句新的话。原题\" class=\"headerlink\" title=\"山羊拉丁口音，把一句话中的每个单词根据规则，生成一句新的话。原题\"></a>山羊拉丁口音，把一句话中的每个单词根据规则，生成一句新的话。<a href=\"https://leetcode.com/problems/goat-latin/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: &quot;The quick brown fox jumped over the lazy dog&quot;</span><br><span class=\"line\">Output: &quot;heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa&quot;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">toGoatLatin</span><span class=\"params\">(self, S: <span class=\"string\">'str'</span>)</span> -&gt; 'str':</span></span><br><span class=\"line\">    vowels = set(<span class=\"string\">'aeiouAEIOU'</span>)</span><br><span class=\"line\">    words = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, word <span class=\"keyword\">in</span> enumerate(S.split(), start=<span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> word[<span class=\"number\">0</span>] <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> vowels:</span><br><span class=\"line\">            word = word[<span class=\"number\">1</span>:] + word[<span class=\"number\">0</span>]</span><br><span class=\"line\">        word += <span class=\"string\">'ma'</span>+<span class=\"string\">'a'</span>*i</span><br><span class=\"line\">        words.append(word)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">' '</span>.join(words)</span><br></pre></td></tr></table></figure>\n<h3 id=\"844-Backspace-String-Compare\"><a href=\"#844-Backspace-String-Compare\" class=\"headerlink\" title=\"844. Backspace String Compare\"></a>844. Backspace String Compare</h3><h4 id=\"退格键字符串比较。比较两个带有退格-的字符串，判断最后输出是否一致。原题\"><a href=\"#退格键字符串比较。比较两个带有退格-的字符串，判断最后输出是否一致。原题\" class=\"headerlink\" title=\"退格键字符串比较。比较两个带有退格#的字符串，判断最后输出是否一致。原题\"></a>退格键字符串比较。比较两个带有退格<code>#</code>的字符串，判断最后输出是否一致。<a href=\"https://leetcode.com/problems/backspace-string-compare/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: S &#x3D; &quot;ab#c&quot;, T &#x3D; &quot;ad#c&quot;</span><br><span class=\"line\">Output: true</span><br><span class=\"line\">Explanation: Both S and T become &quot;ac&quot;.</span><br></pre></td></tr></table></figure>\n<p>方法一：首先想到<code>stack</code>.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backspaceCompare</span><span class=\"params\">(self, S: <span class=\"string\">'str'</span>, T: <span class=\"string\">'str'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">type_text</span><span class=\"params\">(s)</span>:</span></span><br><span class=\"line\">        stack = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> c != <span class=\"string\">'#'</span>:</span><br><span class=\"line\">                stack.append(c)</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> stack:</span><br><span class=\"line\">                stack.pop()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> stack</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> type_text(S) == type_text(T)</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：two pointers. Space Complexity: O(1). </font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backspaceCompare</span><span class=\"params\">(self, S: <span class=\"string\">'str'</span>, T: <span class=\"string\">'str'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">type_c</span><span class=\"params\">(s)</span>:</span></span><br><span class=\"line\">        skip = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> reversed(s):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> x == <span class=\"string\">'#'</span>:</span><br><span class=\"line\">                skip += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> skip:</span><br><span class=\"line\">                skip -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">yield</span> x</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> all(x==y <span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> itertools.zip_longest(type_c(S), type_c(T)))</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：这个方法也很有意思，理论上效率不高，但实际上也并无差别。使用reduce然后切片去掉上次结果的末尾元素。最后一个空串的参数表明了一个初始化参数。如果没有它，<code>#a#c</code>的结果会变成<code>#c</code>。因为第一次循环相当于<code>back(&#39;#&#39;, &#39;a&#39;)</code>所以第一个<code>#</code>会一直保留。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backspaceCompare</span><span class=\"params\">(self, S: <span class=\"string\">'str'</span>, T: <span class=\"string\">'str'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> functools <span class=\"keyword\">import</span> reduce</span><br><span class=\"line\">    back = <span class=\"keyword\">lambda</span> res, c: res[:<span class=\"number\">-1</span>] <span class=\"keyword\">if</span> c == <span class=\"string\">'#'</span> <span class=\"keyword\">else</span> res + c</span><br><span class=\"line\">    <span class=\"keyword\">return</span> reduce(back, S, <span class=\"string\">''</span>) == reduce(back, T, <span class=\"string\">''</span>)</span><br></pre></td></tr></table></figure>\n<p>查看文档中reduce实现：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reduce</span><span class=\"params\">(function, iterable, initializer=None)</span>:</span></span><br><span class=\"line\">    it = iter(iterable)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> initializer <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">        value = next(it)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        value = initializer</span><br><span class=\"line\">    <span class=\"keyword\">for</span> element <span class=\"keyword\">in</span> it:</span><br><span class=\"line\">        value = function(value, element)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value</span><br></pre></td></tr></table></figure>\n<h3 id=\"859-Buddy-Strings\"><a href=\"#859-Buddy-Strings\" class=\"headerlink\" title=\"859. Buddy Strings\"></a>859. Buddy Strings</h3><h4 id=\"好友字符串。指A通过一次交换两个字符变成B。判断是否是好友字符串。原题\"><a href=\"#好友字符串。指A通过一次交换两个字符变成B。判断是否是好友字符串。原题\" class=\"headerlink\" title=\"好友字符串。指A通过一次交换两个字符变成B。判断是否是好友字符串。原题\"></a>好友字符串。指A通过一次交换两个字符变成B。判断是否是好友字符串。<a href=\"https://leetcode.com/problems/buddy-strings/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: A &#x3D; &quot;ab&quot;, B &#x3D; &quot;ba&quot;</span><br><span class=\"line\">Output: true</span><br><span class=\"line\">Input: A &#x3D; &quot;ab&quot;, B &#x3D; &quot;ab&quot;</span><br><span class=\"line\">Output: false</span><br></pre></td></tr></table></figure>\n<p>方法一：Brute Force. 效率很低。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">buddyStrings</span><span class=\"params\">(self, A: <span class=\"string\">'str'</span>, B: <span class=\"string\">'str'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(A) != len(B) <span class=\"keyword\">or</span> set(A) != set(B):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    seen = set()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(A)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> A[i] <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> seen:</span><br><span class=\"line\">            seen.add(A[i])</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i+<span class=\"number\">1</span>, len(A)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> A[:i] + A[j] + A[i+<span class=\"number\">1</span>:j] + A[i] + A[j+<span class=\"number\">1</span>:] == B:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：此题分为两种情况，一种是A==B，此时判断是否有重复元素；另一种找到不相等的对，有且只能有一对。结尾len(pairs)的判断虽然显得有些重复，不过可以在某些情况提前退出提高效率，所以没有写成列表生成式的形式。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">buddyStrings</span><span class=\"params\">(self, A: <span class=\"string\">'str'</span>, B: <span class=\"string\">'str'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(A) != len(B): <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> A == B:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> len(A) != len(set(A))</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        pairs = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> zip(A, B):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> a != b:</span><br><span class=\"line\">                pairs.append((a, b))</span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(pairs) &gt;= <span class=\"number\">3</span>: <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> len(pairs) == <span class=\"number\">2</span> <span class=\"keyword\">and</span> pairs[<span class=\"number\">0</span>] == pairs[<span class=\"number\">1</span>][::<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"893-Groups-of-Special-Equivalent-Strings\"><a href=\"#893-Groups-of-Special-Equivalent-Strings\" class=\"headerlink\" title=\"893. Groups of Special-Equivalent Strings\"></a>893. Groups of Special-Equivalent Strings</h3><h4 id=\"特殊等价字符串组。这题Contest就没做出来，描述有问题，讨论区一堆diss的评论。总的来说就是把A的字符串分组，能够改变偶数位的字符，或奇数位的字符能使之相等的为一组，求一共有多少个组。原题\"><a href=\"#特殊等价字符串组。这题Contest就没做出来，描述有问题，讨论区一堆diss的评论。总的来说就是把A的字符串分组，能够改变偶数位的字符，或奇数位的字符能使之相等的为一组，求一共有多少个组。原题\" class=\"headerlink\" title=\"特殊等价字符串组。这题Contest就没做出来，描述有问题，讨论区一堆diss的评论。总的来说就是把A的字符串分组，能够改变偶数位的字符，或奇数位的字符能使之相等的为一组，求一共有多少个组。原题\"></a>特殊等价字符串组。这题Contest就没做出来，描述有问题，讨论区一堆diss的评论。总的来说就是把A的字符串分组，能够改变偶数位的字符，或奇数位的字符能使之相等的为一组，求一共有多少个组。<a href=\"https://leetcode.com/problems/groups-of-special-equivalent-strings/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;a&quot;,&quot;c&quot;,&quot;c&quot;]</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: 3 groups [&quot;a&quot;,&quot;a&quot;], [&quot;b&quot;], [&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">Input: [&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: 3 groups [&quot;abc&quot;,&quot;cba&quot;], [&quot;acb&quot;,&quot;bca&quot;], [&quot;bac&quot;,&quot;cab&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">Input: [&quot;abcd&quot;,&quot;cdab&quot;,&quot;adcb&quot;,&quot;cbad&quot;]</span><br><span class=\"line\">Output: 1</span><br><span class=\"line\">Explanation: 1 group [&quot;abcd&quot;,&quot;cdab&quot;,&quot;adcb&quot;,&quot;cbad&quot;]</span><br></pre></td></tr></table></figure>\n<p>方法一：数组保留索引。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numSpecialEquivGroups</span><span class=\"params\">(self, A: <span class=\"string\">'List[str]'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">count</span><span class=\"params\">(A)</span>:</span></span><br><span class=\"line\">        ans = [<span class=\"number\">0</span>] * <span class=\"number\">52</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, letter <span class=\"keyword\">in</span> enumerate(A):</span><br><span class=\"line\">            ans[ord(letter) - ord(<span class=\"string\">'a'</span>) + <span class=\"number\">26</span> * (i%<span class=\"number\">2</span>)] += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> tuple(ans)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> len(&#123;count(word) <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> A&#125;)</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：切片字符串排序。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numSpecialEquivGroups</span><span class=\"params\">(self, A: <span class=\"string\">'List[str]'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> len(&#123;<span class=\"string\">''</span>.join(sorted(s[<span class=\"number\">0</span>::<span class=\"number\">2</span>])) + <span class=\"string\">''</span>.join(sorted(s[<span class=\"number\">1</span>::<span class=\"number\">2</span>]))</span><br><span class=\"line\">                <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> A&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"1003-Check-If-Word-Is-Valid-After-Substitutions\"><a href=\"#1003-Check-If-Word-Is-Valid-After-Substitutions\" class=\"headerlink\" title=\"1003. Check If Word Is Valid After Substitutions\"></a>1003. Check If Word Is Valid After Substitutions</h3><h4 id=\"判断字符串是否由abc无限插入得到。原题\"><a href=\"#判断字符串是否由abc无限插入得到。原题\" class=\"headerlink\" title=\"判断字符串是否由abc无限插入得到。原题\"></a>判断字符串是否由<code>abc</code>无限插入得到。<a href=\"https://leetcode.com/problems/check-if-word-is-valid-after-substitutions/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: &quot;aabcbc&quot;</span><br><span class=\"line\">Output: true</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">We start with the valid string &quot;abc&quot;.</span><br><span class=\"line\">Then we can insert another &quot;abc&quot; between &quot;a&quot; and &quot;bc&quot;, resulting in &quot;a&quot; + &quot;abc&quot; + &quot;bc&quot; which is &quot;aabcbc&quot;.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isValid</span><span class=\"params\">(self, S: str)</span> -&gt; bool:</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> len(S) &gt;= <span class=\"number\">3</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"string\">'abc'</span> <span class=\"keyword\">in</span> S:</span><br><span class=\"line\">            i = S.index(<span class=\"string\">'abc'</span>)</span><br><span class=\"line\">            S = S[:i] + S[i+<span class=\"number\">3</span>:]</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> S == <span class=\"string\">''</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"17-Letter-Combinations-of-a-Phone-Number\"><a href=\"#17-Letter-Combinations-of-a-Phone-Number\" class=\"headerlink\" title=\"17. Letter Combinations of a Phone Number\"></a>17. Letter Combinations of a Phone Number</h3><h4 id=\"电话的数字可以组成的字符串组合。原题\"><a href=\"#电话的数字可以组成的字符串组合。原题\" class=\"headerlink\" title=\"电话的数字可以组成的字符串组合。原题\"></a>电话的数字可以组成的字符串组合。<a href=\"https://leetcode.com/problems/letter-combinations-of-a-phone-number/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: &quot;23&quot;</span><br><span class=\"line\">Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</span><br></pre></td></tr></table></figure>\n<p>方法一：recursive.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">letterCombinations</span><span class=\"params\">(self, digits: str)</span> -&gt; List[str]:</span></span><br><span class=\"line\">    phone = &#123;<span class=\"string\">'2'</span>: <span class=\"string\">'abc'</span>, <span class=\"string\">'3'</span>: <span class=\"string\">'def'</span>, <span class=\"string\">'4'</span>: <span class=\"string\">'ghi'</span>, <span class=\"string\">'5'</span>: <span class=\"string\">'jkl'</span>, </span><br><span class=\"line\">             <span class=\"string\">'6'</span>: <span class=\"string\">'mno'</span>, <span class=\"string\">'7'</span>: <span class=\"string\">'pqrs'</span>, <span class=\"string\">'8'</span>: <span class=\"string\">'tuv'</span>, <span class=\"string\">'9'</span>: <span class=\"string\">'wxyz'</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> digits:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">helper</span><span class=\"params\">(digits)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> digits:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [<span class=\"string\">''</span>]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [c + suffix <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> phone[digits[<span class=\"number\">0</span>]]</span><br><span class=\"line\">                <span class=\"keyword\">for</span> suffix <span class=\"keyword\">in</span> helper(digits[<span class=\"number\">1</span>:])]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> helper(digits)</span><br></pre></td></tr></table></figure>\n<p>方法二：使用<code>product</code>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">letterCombinations</span><span class=\"params\">(self, digits: str)</span> -&gt; List[str]:</span></span><br><span class=\"line\">    phone = &#123;<span class=\"string\">'2'</span>: <span class=\"string\">'abc'</span>, <span class=\"string\">'3'</span>: <span class=\"string\">'def'</span>, <span class=\"string\">'4'</span>: <span class=\"string\">'ghi'</span>, <span class=\"string\">'5'</span>: <span class=\"string\">'jkl'</span>, </span><br><span class=\"line\">             <span class=\"string\">'6'</span>: <span class=\"string\">'mno'</span>, <span class=\"string\">'7'</span>: <span class=\"string\">'pqrs'</span>, <span class=\"string\">'8'</span>: <span class=\"string\">'tuv'</span>, <span class=\"string\">'9'</span>: <span class=\"string\">'wxyz'</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">from</span> itertools <span class=\"keyword\">import</span> product</span><br><span class=\"line\">    <span class=\"keyword\">return</span> digits <span class=\"keyword\">and</span> list(map(<span class=\"string\">''</span>.join, product(*(phone[d] <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> digits)))) <span class=\"keyword\">or</span> []</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：实现<code>product</code>。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">letterCombinations</span><span class=\"params\">(self, digits: str)</span> -&gt; List[str]:</span></span><br><span class=\"line\">    phone = &#123;<span class=\"string\">'2'</span>: <span class=\"string\">'abc'</span>, <span class=\"string\">'3'</span>: <span class=\"string\">'def'</span>, <span class=\"string\">'4'</span>: <span class=\"string\">'ghi'</span>, <span class=\"string\">'5'</span>: <span class=\"string\">'jkl'</span>, </span><br><span class=\"line\">             <span class=\"string\">'6'</span>: <span class=\"string\">'mno'</span>, <span class=\"string\">'7'</span>: <span class=\"string\">'pqrs'</span>, <span class=\"string\">'8'</span>: <span class=\"string\">'tuv'</span>, <span class=\"string\">'9'</span>: <span class=\"string\">'wxyz'</span>&#125;</span><br><span class=\"line\">    ans = [<span class=\"string\">''</span>]</span><br><span class=\"line\">    letters = (phone[d] <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> digits)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> key <span class=\"keyword\">in</span> letters:</span><br><span class=\"line\">        ans = [x+char <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> ans <span class=\"keyword\">for</span> char <span class=\"keyword\">in</span> key]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> digits <span class=\"keyword\">and</span> ans <span class=\"keyword\">or</span> []</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法四：评论里看到的<code>reduce</code>方法。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">letterCombinations</span><span class=\"params\">(self, digits: str)</span> -&gt; List[str]:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> functools <span class=\"keyword\">import</span> reduce</span><br><span class=\"line\">    phone = &#123;<span class=\"string\">'2'</span>: <span class=\"string\">'abc'</span>, <span class=\"string\">'3'</span>: <span class=\"string\">'def'</span>, <span class=\"string\">'4'</span>: <span class=\"string\">'ghi'</span>, <span class=\"string\">'5'</span>: <span class=\"string\">'jkl'</span>, </span><br><span class=\"line\">             <span class=\"string\">'6'</span>: <span class=\"string\">'mno'</span>, <span class=\"string\">'7'</span>: <span class=\"string\">'pqrs'</span>, <span class=\"string\">'8'</span>: <span class=\"string\">'tuv'</span>, <span class=\"string\">'9'</span>: <span class=\"string\">'wxyz'</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> digits: <span class=\"keyword\">return</span> []</span><br><span class=\"line\">    <span class=\"keyword\">return</span> reduce(<span class=\"keyword\">lambda</span> acc, digit: [x + y <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> acc <span class=\"keyword\">for</span> y <span class=\"keyword\">in</span> phone[digit]], digits, [<span class=\"string\">''</span>])</span><br></pre></td></tr></table></figure>\n<p>方法五：Solution中的回溯法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">letterCombinations</span><span class=\"params\">(self, digits: str)</span> -&gt; List[str]:</span></span><br><span class=\"line\">    phone = &#123;<span class=\"string\">'2'</span>: <span class=\"string\">'abc'</span>, <span class=\"string\">'3'</span>: <span class=\"string\">'def'</span>, <span class=\"string\">'4'</span>: <span class=\"string\">'ghi'</span>, <span class=\"string\">'5'</span>: <span class=\"string\">'jkl'</span>, </span><br><span class=\"line\">             <span class=\"string\">'6'</span>: <span class=\"string\">'mno'</span>, <span class=\"string\">'7'</span>: <span class=\"string\">'pqrs'</span>, <span class=\"string\">'8'</span>: <span class=\"string\">'tuv'</span>, <span class=\"string\">'9'</span>: <span class=\"string\">'wxyz'</span>&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtrack</span><span class=\"params\">(combination, digits)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> digits:</span><br><span class=\"line\">            ans.append(combination)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> letter <span class=\"keyword\">in</span> phone[digits[<span class=\"number\">0</span>]]:</span><br><span class=\"line\">                backtrack(combination + letter, digits[<span class=\"number\">1</span>:])</span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    <span class=\"keyword\">if</span> digits:</span><br><span class=\"line\">        backtrack(<span class=\"string\">''</span>, digits)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"1023-Binary-String-With-Substrings-Representing-1-To-N\"><a href=\"#1023-Binary-String-With-Substrings-Representing-1-To-N\" class=\"headerlink\" title=\"1023. Binary String With Substrings Representing 1 To N\"></a>1023. Binary String With Substrings Representing 1 To N</h3><h4 id=\"二进制子串，从1到N。原题\"><a href=\"#二进制子串，从1到N。原题\" class=\"headerlink\" title=\"二进制子串，从1到N。原题\"></a>二进制子串，从1到N。<a href=\"https://leetcode.com/problems/binary-string-with-substrings-representing-1-to-n/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: S &#x3D; &quot;0110&quot;, N &#x3D; 3</span><br><span class=\"line\">Output: true</span><br></pre></td></tr></table></figure>\n<p>方法一：暴力法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">queryString</span><span class=\"params\">(self, S: str, N: int)</span> -&gt; bool:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> all(bin(n)[<span class=\"number\">2</span>:] <span class=\"keyword\">in</span> S <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, N+<span class=\"number\">1</span>))</span><br></pre></td></tr></table></figure>\n<p>方法二：对于任意的<code>i&lt;N/2</code>的数<code>i*2</code>的二进制表示形式一定包含<code>i</code>。因为左移一位。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">queryString</span><span class=\"params\">(self, S: str, N: int)</span> -&gt; bool:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> all(bin(n)[<span class=\"number\">2</span>:] <span class=\"keyword\">in</span> S <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> range(N, N//<span class=\"number\">2</span>, <span class=\"number\">-1</span>))</span><br></pre></td></tr></table></figure>\n<h3 id=\"482-License-Key-Formatting\"><a href=\"#482-License-Key-Formatting\" class=\"headerlink\" title=\"482. License Key Formatting\"></a>482. License Key Formatting</h3><h4 id=\"根据要求格式化字符串。原题\"><a href=\"#根据要求格式化字符串。原题\" class=\"headerlink\" title=\"根据要求格式化字符串。原题\"></a>根据要求格式化字符串。<a href=\"https://leetcode.com/problems/license-key-formatting/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: S &#x3D; &quot;5F3Z-2e-9-w&quot;, K &#x3D; 4</span><br><span class=\"line\">Output: &quot;5F3Z-2E9W&quot;</span><br></pre></td></tr></table></figure>\n<p>方法一：使用内置方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">licenseKeyFormatting</span><span class=\"params\">(self, S: str, K: int)</span> -&gt; str:</span></span><br><span class=\"line\">    s = S.replace(<span class=\"string\">'-'</span>, <span class=\"string\">''</span>).upper()[::<span class=\"number\">-1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'-'</span>.join(s[i:i+K] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(s), K))[::<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<p>方法二：完整实现。one-pass.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">licenseKeyFormatting</span><span class=\"params\">(self, S: str, K: int)</span> -&gt; str:</span></span><br><span class=\"line\">    s = S.replace(<span class=\"string\">'-'</span>, <span class=\"string\">''</span>).upper()</span><br><span class=\"line\">    ans, n = <span class=\"string\">''</span>, len(s)</span><br><span class=\"line\">    f = n % K</span><br><span class=\"line\">    ans += s[:f]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(f, n, K):</span><br><span class=\"line\">        ans += <span class=\"string\">'-'</span> + s[i:i+K]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans.strip(<span class=\"string\">'-'</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"1071-Greatest-Common-Divisor-of-Strings\"><a href=\"#1071-Greatest-Common-Divisor-of-Strings\" class=\"headerlink\" title=\"1071. Greatest Common Divisor of Strings\"></a>1071. Greatest Common Divisor of Strings</h3><h4 id=\"最长公共被整除的字符串。原题\"><a href=\"#最长公共被整除的字符串。原题\" class=\"headerlink\" title=\"最长公共被整除的字符串。原题\"></a>最长公共被整除的字符串。<a href=\"https://leetcode.com/problems/greatest-common-divisor-of-strings/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: str1 &#x3D; &quot;ABCABC&quot;, str2 &#x3D; &quot;ABC&quot;</span><br><span class=\"line\">Output: &quot;ABC&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">Input: str1 &#x3D; &quot;ABABAB&quot;, str2 &#x3D; &quot;ABAB&quot;</span><br><span class=\"line\">Output: &quot;AB&quot;</span><br></pre></td></tr></table></figure>\n<p>方法一：这里我是从小找一个公共串，并记录重复次数。再从两个重复的次数中取最大公约数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">gcdOfStrings</span><span class=\"params\">(self, str1: str, str2: str)</span> -&gt; str:</span></span><br><span class=\"line\">    n1, n2 = len(str1), len(str2)</span><br><span class=\"line\">    <span class=\"keyword\">from</span> math <span class=\"keyword\">import</span> gcd</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">repeat</span><span class=\"params\">(word)</span>:</span></span><br><span class=\"line\">        n = len(word)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n//<span class=\"number\">2</span>+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(i):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> len(&#123;word[j] <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(k, n, i)&#125;) != <span class=\"number\">1</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> word[:i], n // i</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">''</span>, <span class=\"number\">1</span></span><br><span class=\"line\">    common1, num1 = repeat(str1)</span><br><span class=\"line\">    common2, num2 = repeat(str2)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gcd(num1, num2) * common1</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：递归。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">gcdOfStrings</span><span class=\"params\">(self, str1: str, str2: str)</span> -&gt; str:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(str1) == len(str2):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> str1 <span class=\"keyword\">if</span> str1==str2 <span class=\"keyword\">else</span> <span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(str1) &lt; len(str2):</span><br><span class=\"line\">            str1, str2 = str2, str1</span><br><span class=\"line\">        <span class=\"keyword\">if</span> str1[:len(str2)] == str2:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.gcdOfStrings(str1[len(str2):], str2)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">''</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1156-Swap-For-Longest-Repeated-Character-Substring\"><a href=\"#1156-Swap-For-Longest-Repeated-Character-Substring\" class=\"headerlink\" title=\"1156. Swap For Longest Repeated Character Substring\"></a>1156. Swap For Longest Repeated Character Substring</h3><h4 id=\"最多交换一次两个字符，求连续重复的字符最大个数是多少。原题\"><a href=\"#最多交换一次两个字符，求连续重复的字符最大个数是多少。原题\" class=\"headerlink\" title=\"最多交换一次两个字符，求连续重复的字符最大个数是多少。原题\"></a>最多交换一次两个字符，求连续重复的字符最大个数是多少。<a href=\"https://leetcode.com/problems/swap-for-maximum-repeated-substring/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: text &#x3D; &quot;aaabaaa&quot;</span><br><span class=\"line\">Output: 6</span><br><span class=\"line\">Explanation: Swap &#39;b&#39; with the last &#39;a&#39; (or the first &#39;a&#39;), and we get longest repeated character substring &quot;aaaaaa&quot;, which its length is 6.</span><br><span class=\"line\"></span><br><span class=\"line\">Input: text &#x3D; &quot;aaabbaaa&quot;</span><br><span class=\"line\">Output: 4</span><br></pre></td></tr></table></figure>\n<p>方法一：竞赛没在规定时间内完成，思路是对的，使用groupby，第二个例子那里小细节没有处理好。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxRepOpt1</span><span class=\"params\">(self, text: str)</span> -&gt; int:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    gg = [(d, len(list(g))) <span class=\"keyword\">for</span> d, g <span class=\"keyword\">in</span> itertools.groupby(text)]</span><br><span class=\"line\">    count = collections.Counter(text)</span><br><span class=\"line\">    ans = max(min(c+<span class=\"number\">1</span>, count[k]) <span class=\"keyword\">for</span> k, c <span class=\"keyword\">in</span> gg)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(gg)<span class=\"number\">-1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> gg[i<span class=\"number\">-1</span>][<span class=\"number\">0</span>]==gg[i+<span class=\"number\">1</span>][<span class=\"number\">0</span>] <span class=\"keyword\">and</span> gg[i][<span class=\"number\">1</span>]==<span class=\"number\">1</span>:</span><br><span class=\"line\">            ans = max(ans, min(gg[i<span class=\"number\">-1</span>][<span class=\"number\">1</span>]+gg[i+<span class=\"number\">1</span>][<span class=\"number\">1</span>]+<span class=\"number\">1</span>, count[gg[i+<span class=\"number\">1</span>][<span class=\"number\">0</span>]]))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"1106-Parsing-A-Boolean-Expression\"><a href=\"#1106-Parsing-A-Boolean-Expression\" class=\"headerlink\" title=\"1106. Parsing A Boolean Expression\"></a>1106. Parsing A Boolean Expression</h3><h4 id=\"转换-amp-操作符，返回结果。原题\"><a href=\"#转换-amp-操作符，返回结果。原题\" class=\"headerlink\" title=\"转换&amp;|~操作符，返回结果。原题\"></a>转换&amp;|~操作符，返回结果。<a href=\"https://leetcode.com/problems/parsing-a-boolean-expression/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: expression &#x3D; &quot;|(&amp;(t,f,t),!(t))&quot;</span><br><span class=\"line\">Output: false</span><br></pre></td></tr></table></figure>\n<p>方法一：这题很有意思，马上就能想到用<code>eval</code>来作弊，但是<code>~</code>没有处理好，看了Lee神答案后恍然大悟。这里需要将非符号转成any数组。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parseBoolExpr</span><span class=\"params\">(self, expression: str)</span> -&gt; bool:</span></span><br><span class=\"line\">    t, f = <span class=\"literal\">True</span>, <span class=\"literal\">False</span></span><br><span class=\"line\">    expression = expression.replace(<span class=\"string\">'!'</span>, <span class=\"string\">'not |'</span>).replace(<span class=\"string\">'&amp;('</span>, <span class=\"string\">'all(['</span>).replace(<span class=\"string\">'|('</span>, <span class=\"string\">'any(['</span>).replace(<span class=\"string\">')'</span>, <span class=\"string\">'])'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> eval(expression)</span><br></pre></td></tr></table></figure>\n<h3 id=\"1408-String-Matching-in-an-Array\"><a href=\"#1408-String-Matching-in-an-Array\" class=\"headerlink\" title=\"1408. String Matching in an Array\"></a>1408. String Matching in an Array</h3><h4 id=\"找出字符串是其它子串的字符串。原题\"><a href=\"#找出字符串是其它子串的字符串。原题\" class=\"headerlink\" title=\"找出字符串是其它子串的字符串。原题\"></a>找出字符串是其它子串的字符串。<a href=\"https://leetcode.com/problems/string-matching-in-an-array/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: words &#x3D; [&quot;mass&quot;,&quot;as&quot;,&quot;hero&quot;,&quot;superhero&quot;]</span><br><span class=\"line\">Output: [&quot;as&quot;,&quot;hero&quot;]</span><br><span class=\"line\">Explanation: &quot;as&quot; is substring of &quot;mass&quot; and &quot;hero&quot; is substring of &quot;superhero&quot;.</span><br><span class=\"line\">[&quot;hero&quot;,&quot;as&quot;] is also a valid answer.</span><br></pre></td></tr></table></figure>\n<p>方法一：排序暴力法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">stringMatching</span><span class=\"params\">(self, words: List[str])</span> -&gt; List[str]:</span></span><br><span class=\"line\">    words.sort(key=len)</span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(words)<span class=\"number\">-1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i+<span class=\"number\">1</span>, len(words)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> words[i] <span class=\"keyword\">in</span> words[j]:</span><br><span class=\"line\">                ans.append(words[i])</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"791-Custom-Sort-String\"><a href=\"#791-Custom-Sort-String\" class=\"headerlink\" title=\"791. Custom Sort String\"></a>791. Custom Sort String</h3><h4 id=\"自定义排序字符串，按照S中字母顺序排序T。原题\"><a href=\"#自定义排序字符串，按照S中字母顺序排序T。原题\" class=\"headerlink\" title=\"自定义排序字符串，按照S中字母顺序排序T。原题\"></a>自定义排序字符串，按照S中字母顺序排序T。<a href=\"https://leetcode.com/problems/custom-sort-string/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Example :</span><br><span class=\"line\">Input: </span><br><span class=\"line\">S &#x3D; &quot;cba&quot;</span><br><span class=\"line\">T &#x3D; &quot;abcd&quot;</span><br><span class=\"line\">Output: &quot;cbad&quot;</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">&quot;a&quot;, &quot;b&quot;, &quot;c&quot; appear in S, so the order of &quot;a&quot;, &quot;b&quot;, &quot;c&quot; should be &quot;c&quot;, &quot;b&quot;, and &quot;a&quot;. </span><br><span class=\"line\">Since &quot;d&quot; does not appear in S, it can be at any position in T. &quot;dcba&quot;, &quot;cdba&quot;, &quot;cbda&quot; are also valid outputs.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">customSortString</span><span class=\"params\">(self, S: str, T: str)</span> -&gt; str:</span></span><br><span class=\"line\">    <span class=\"comment\"># return ''.join(sorted(T, key=S.find))</span></span><br><span class=\"line\">    d = &#123;k: i <span class=\"keyword\">for</span> i, k <span class=\"keyword\">in</span> enumerate(S)&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(sorted(T, key=<span class=\"keyword\">lambda</span> x: d.get(x, <span class=\"number\">-1</span>)))</span><br></pre></td></tr></table></figure>\n<h3 id=\"678-Valid-Parenthesis-String\"><a href=\"#678-Valid-Parenthesis-String\" class=\"headerlink\" title=\"678. Valid Parenthesis String\"></a>678. Valid Parenthesis String</h3><h4 id=\"匹配括号，-可以表示左右或者空。原题\"><a href=\"#匹配括号，-可以表示左右或者空。原题\" class=\"headerlink\" title=\"匹配括号，*可以表示左右或者空。原题\"></a>匹配括号，*可以表示左右或者空。<a href=\"https://leetcode.com/problems/valid-parenthesis-string/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: &quot;(*))&quot;</span><br><span class=\"line\">Output: True</span><br></pre></td></tr></table></figure>\n<p>方法一：这题一开始想歪了，想用栈和递归的方式实现，结果没想出来。这里用了Lee215的方法。<code>cmin</code>表示至少需要<code>)</code>, <code>cmax</code>表示最多。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">checkValidString</span><span class=\"params\">(self, s: str)</span> -&gt; bool:</span></span><br><span class=\"line\">    cmin = cmax = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> c == <span class=\"string\">'('</span>:</span><br><span class=\"line\">            cmin += <span class=\"number\">1</span></span><br><span class=\"line\">            cmax += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> c == <span class=\"string\">')'</span>:</span><br><span class=\"line\">            cmax -= <span class=\"number\">1</span></span><br><span class=\"line\">            cmin = max(cmin - <span class=\"number\">1</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> c == <span class=\"string\">'*'</span>:</span><br><span class=\"line\">            cmax += <span class=\"number\">1</span></span><br><span class=\"line\">            cmin = max(cmin - <span class=\"number\">1</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cmax &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> cmin == <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1419-Minimum-Number-of-Frogs-Croaking\"><a href=\"#1419-Minimum-Number-of-Frogs-Croaking\" class=\"headerlink\" title=\"1419. Minimum Number of Frogs Croaking\"></a>1419. Minimum Number of Frogs Croaking</h3><h4 id=\"有n个青蛙🐸一起叫，叫声混到了一起，求最小青蛙的个数。原题\"><a href=\"#有n个青蛙🐸一起叫，叫声混到了一起，求最小青蛙的个数。原题\" class=\"headerlink\" title=\"有n个青蛙🐸一起叫，叫声混到了一起，求最小青蛙的个数。原题\"></a>有n个青蛙🐸一起叫，叫声混到了一起，求最小青蛙的个数。<a href=\"https://leetcode.com/problems/minimum-number-of-frogs-croaking/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: croakOfFrogs &#x3D; &quot;crcoakroak&quot;</span><br><span class=\"line\">Output: 2 </span><br><span class=\"line\">Explanation: The minimum number of frogs is two. </span><br><span class=\"line\">The first frog could yell &quot;crcoakroak&quot;.</span><br><span class=\"line\">The second frog could yell later &quot;crcoakroak&quot;.</span><br></pre></td></tr></table></figure>\n<p>方法一：记录每个字母的个数，注意叫的过程中字母数量的顺序。<code>inuse</code>表示同时叫的青蛙。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minNumberOfFrogs</span><span class=\"params\">(self, croakOfFrogs: str)</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> defaultdict</span><br><span class=\"line\">    c = defaultdict(int)</span><br><span class=\"line\">    inuse = <span class=\"number\">0</span></span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> f <span class=\"keyword\">in</span> croakOfFrogs:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> f == <span class=\"string\">'c'</span>:</span><br><span class=\"line\">            inuse += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> f == <span class=\"string\">'k'</span>:</span><br><span class=\"line\">            inuse -= <span class=\"number\">1</span></span><br><span class=\"line\">        c[f] += <span class=\"number\">1</span></span><br><span class=\"line\">        ans = max(ans, inuse)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> c[<span class=\"string\">'c'</span>] &gt;= c[<span class=\"string\">'r'</span>] &gt;= c[<span class=\"string\">'o'</span>] &gt;= c[<span class=\"string\">'a'</span>] &gt;= c[<span class=\"string\">'k'</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> inuse==<span class=\"number\">0</span> <span class=\"keyword\">and</span> len(set(c.values()))==<span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1358-Number-of-Substrings-Containing-All-Three-Characters\"><a href=\"#1358-Number-of-Substrings-Containing-All-Three-Characters\" class=\"headerlink\" title=\"1358. Number of Substrings Containing All Three Characters\"></a>1358. Number of Substrings Containing All Three Characters</h3><h4 id=\"包含’abc’子串的个数。原题\"><a href=\"#包含’abc’子串的个数。原题\" class=\"headerlink\" title=\"包含’abc’子串的个数。原题\"></a>包含’abc’子串的个数。<a href=\"https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;abcabc&quot;</span><br><span class=\"line\">Output: 10</span><br><span class=\"line\">Explanation: The substrings containing at least one occurrence of the characters a, b and c are &quot;abc&quot;, &quot;abca&quot;, &quot;abcab&quot;, &quot;abcabc&quot;, &quot;bca&quot;, &quot;bcab&quot;, &quot;bcabc&quot;, &quot;cab&quot;, &quot;cabc&quot; and &quot;abc&quot; (again).</span><br></pre></td></tr></table></figure>\n<p>方法一：滑动窗口。记录abc的数量，当无法组成时退出，此时最左的索引为i-1。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numberOfSubstrings</span><span class=\"params\">(self, s: str)</span> -&gt; int:</span></span><br><span class=\"line\">    res = i = <span class=\"number\">0</span></span><br><span class=\"line\">    count = &#123;c: <span class=\"number\">0</span> <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> <span class=\"string\">'abc'</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(s)):</span><br><span class=\"line\">        count[s[j]] += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> all(count.values()):</span><br><span class=\"line\">            count[s[i]] -= <span class=\"number\">1</span></span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">        res += i</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<p>方法二：数学方法。以右侧点为准，向左累加。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numberOfSubstrings</span><span class=\"params\">(self, s: str)</span> -&gt; int:</span></span><br><span class=\"line\">    res = <span class=\"number\">0</span></span><br><span class=\"line\">    last = [<span class=\"number\">-1</span>] * <span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, c <span class=\"keyword\">in</span> enumerate(s):</span><br><span class=\"line\">        last[ord(c) - <span class=\"number\">97</span>] = i</span><br><span class=\"line\">        res += <span class=\"number\">1</span> + min(last)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"1309-Decrypt-String-from-Alphabet-to-Integer-Mapping\"><a href=\"#1309-Decrypt-String-from-Alphabet-to-Integer-Mapping\" class=\"headerlink\" title=\"1309. Decrypt String from Alphabet to Integer Mapping\"></a>1309. Decrypt String from Alphabet to Integer Mapping</h3><h4 id=\"数字到字母的一个映射。原题\"><a href=\"#数字到字母的一个映射。原题\" class=\"headerlink\" title=\"数字到字母的一个映射。原题\"></a>数字到字母的一个映射。<a href=\"https://leetcode.com/problems/decrypt-string-from-alphabet-to-integer-mapping/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;10#11#12&quot;</span><br><span class=\"line\">Output: &quot;jkab&quot;</span><br><span class=\"line\">Explanation: &quot;j&quot; -&gt; &quot;10#&quot; , &quot;k&quot; -&gt; &quot;11#&quot; , &quot;a&quot; -&gt; &quot;1&quot; , &quot;b&quot; -&gt; &quot;2&quot;.</span><br></pre></td></tr></table></figure>\n<p>方法一：比赛时的答案过于繁琐。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">freqAlphabets</span><span class=\"params\">(self, s: str)</span> -&gt; str:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(chr(int(i[:<span class=\"number\">2</span>]) + <span class=\"number\">96</span>) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> re.findall(<span class=\"string\">r'\\d\\d#|\\d'</span>, s))</span><br></pre></td></tr></table></figure>\n<h3 id=\"1545-Find-Kth-Bit-in-Nth-Binary-String\"><a href=\"#1545-Find-Kth-Bit-in-Nth-Binary-String\" class=\"headerlink\" title=\"1545. Find Kth Bit in Nth Binary String\"></a>1545. Find Kth Bit in Nth Binary String</h3><h4 id=\"找到第n个字符串的第k位。原题\"><a href=\"#找到第n个字符串的第k位。原题\" class=\"headerlink\" title=\"找到第n个字符串的第k位。原题\"></a>找到第n个字符串的第k位。<a href=\"https://leetcode.com/problems/find-kth-bit-in-nth-binary-string/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><ul>\n<li><code>S1 = &quot;0&quot;</code></li>\n<li><code>S2 = &quot;0**1**1&quot;</code></li>\n<li><code>S3 = &quot;011**1**001&quot;</code></li>\n<li><code>S4 = &quot;0111001**1**0110001&quot;</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 3, k &#x3D; 1</span><br><span class=\"line\">Output: &quot;0&quot;</span><br><span class=\"line\">Explanation: S3 is &quot;0111001&quot;. The first bit is &quot;0&quot;.</span><br></pre></td></tr></table></figure>\n<p>方法一：比赛时是按照题意的方式写的，效率慢了10倍，这题用逆向思维。by@lee215.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findKthBit</span><span class=\"params\">(self, n: int, k: int)</span> -&gt; str:</span></span><br><span class=\"line\">    flip = <span class=\"number\">0</span></span><br><span class=\"line\">    l = <span class=\"number\">2</span> ** n - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> k &gt; <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> k == l // <span class=\"number\">2</span> + <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> str(<span class=\"number\">1</span> ^ flip)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> k &gt; l // <span class=\"number\">2</span>:</span><br><span class=\"line\">            k = l + <span class=\"number\">1</span> - k</span><br><span class=\"line\">            flip = <span class=\"number\">1</span> - flip</span><br><span class=\"line\">        l //= <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> str(flip)</span><br></pre></td></tr></table></figure>\n<h3 id=\"777-Swap-Adjacent-in-LR-String\"><a href=\"#777-Swap-Adjacent-in-LR-String\" class=\"headerlink\" title=\"777. Swap Adjacent in LR String\"></a>777. Swap Adjacent in LR String</h3><h4 id=\"转换成目标字符串，可以将”XL”变成”LX”，或者将”RX”变成”XR”。原题\"><a href=\"#转换成目标字符串，可以将”XL”变成”LX”，或者将”RX”变成”XR”。原题\" class=\"headerlink\" title=\"转换成目标字符串，可以将”XL”变成”LX”，或者将”RX”变成”XR”。原题\"></a>转换成目标字符串，可以将”XL”变成”LX”，或者将”RX”变成”XR”。<a href=\"https://leetcode.com/problems/swap-adjacent-in-lr-string/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: start &#x3D; &quot;RXXLRXRXL&quot;, end &#x3D; &quot;XRLXXRRLX&quot;</span><br><span class=\"line\">Output: True</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">We can transform start to end following these steps:</span><br><span class=\"line\">RXXLRXRXL -&gt;</span><br><span class=\"line\">XRXLRXRXL -&gt;</span><br><span class=\"line\">XRLXRXRXL -&gt;</span><br><span class=\"line\">XRLXXRRXL -&gt;</span><br><span class=\"line\">XRLXXRRLX</span><br></pre></td></tr></table></figure>\n<p>方法一：一开始想错了，以为互换倒过来也行。这个变换有点像将L向左移，R向右移，而且不能跨越其它的R或者L也就是可以将X想象成空位。所以这里计算时要将LR一起考虑。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">canTransform</span><span class=\"params\">(self, start: str, end: str)</span> -&gt; bool:</span></span><br><span class=\"line\">    left = [(c, i) <span class=\"keyword\">for</span> i, c <span class=\"keyword\">in</span> enumerate(start) <span class=\"keyword\">if</span> c!=<span class=\"string\">'X'</span>]</span><br><span class=\"line\">    right = [(c, i) <span class=\"keyword\">for</span> i, c <span class=\"keyword\">in</span> enumerate(end) <span class=\"keyword\">if</span> c!=<span class=\"string\">'X'</span>]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(left) != len(right): <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (c1, i), (c2, j) <span class=\"keyword\">in</span> zip(left, right):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> c1 != c2: <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> c1 == <span class=\"string\">'L'</span> <span class=\"keyword\">and</span> i &lt; j: <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> c1 == <span class=\"string\">'R'</span> <span class=\"keyword\">and</span> i &gt; j: <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"539-Minimum-Time-Difference\"><a href=\"#539-Minimum-Time-Difference\" class=\"headerlink\" title=\"539. Minimum Time Difference\"></a>539. Minimum Time Difference</h3><h4 id=\"两个时间的最小分钟差的绝对值。原题\"><a href=\"#两个时间的最小分钟差的绝对值。原题\" class=\"headerlink\" title=\"两个时间的最小分钟差的绝对值。原题\"></a>两个时间的最小分钟差的绝对值。<a href=\"https://leetcode.com/problems/minimum-time-difference/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [&quot;23:59&quot;,&quot;00:00&quot;]</span><br><span class=\"line\">Output: 1</span><br></pre></td></tr></table></figure>\n<p>方法一：Lee的方法，自己想的一样，优化一下写法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findMinDifference</span><span class=\"params\">(self, timePoints: List[str])</span> -&gt; int:</span></span><br><span class=\"line\">    time = sorted(int(t[:<span class=\"number\">2</span>])*<span class=\"number\">60</span>+int(t[<span class=\"number\">-2</span>:]) <span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> timePoints)</span><br><span class=\"line\">    time.append(time[<span class=\"number\">0</span>]+<span class=\"number\">60</span>*<span class=\"number\">24</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min(b-a <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> zip(time, time[<span class=\"number\">1</span>:]))</span><br></pre></td></tr></table></figure>\n<h3 id=\"459-Repeated-Substring-Pattern\"><a href=\"#459-Repeated-Substring-Pattern\" class=\"headerlink\" title=\"459. Repeated Substring Pattern\"></a>459. Repeated Substring Pattern</h3><h4 id=\"字符串中是否包含重复的子串模式。原题\"><a href=\"#字符串中是否包含重复的子串模式。原题\" class=\"headerlink\" title=\"字符串中是否包含重复的子串模式。原题\"></a>字符串中是否包含重复的子串模式。<a href=\"https://leetcode.com/problems/repeated-substring-pattern/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: &quot;abcabcabcabc&quot;</span><br><span class=\"line\">Output: True</span><br><span class=\"line\">Explanation: It&#39;s the substring &quot;abc&quot; four times. (And the substring &quot;abcabc&quot; twice.)</span><br></pre></td></tr></table></figure>\n<p>方法一：如果s包含一个重复的子串，那么通过旋转s在n-1次之内，一定会又出现s本身。如<code>s=&#39;abcabc&#39;</code>那么旋转三次就会得到它。判断是否出现重复那么只要出现两次就算。于是将s+s得到s2。并将头尾去掉，这样s2包含了所有的旋转可能。如果s在其中，那么就说明至少有2次以上的子串重复。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">repeatedSubstringPattern</span><span class=\"params\">(self, s: str)</span> -&gt; bool:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> s <span class=\"keyword\">in</span> (s * <span class=\"number\">2</span>)[<span class=\"number\">1</span>:<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"165-Compare-Version-Numbers\"><a href=\"#165-Compare-Version-Numbers\" class=\"headerlink\" title=\"165. Compare Version Numbers\"></a>165. Compare Version Numbers</h3><h4 id=\"比较两个版本号，版本的大小。原题\"><a href=\"#比较两个版本号，版本的大小。原题\" class=\"headerlink\" title=\"比较两个版本号，版本的大小。原题\"></a>比较两个版本号，版本的大小。<a href=\"https://leetcode.com/problems/compare-version-numbers/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: version1 &#x3D; &quot;7.5.2.4&quot;, version2 &#x3D; &quot;7.5.3&quot;</span><br><span class=\"line\">Output: -1</span><br></pre></td></tr></table></figure>\n<p>方法一：这题写完直接自信提交。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">compareVersion</span><span class=\"params\">(self, version1: str, version2: str)</span> -&gt; int:</span></span><br><span class=\"line\">    v1, v2 = map(int, version1.split(<span class=\"string\">'.'</span>)), map(int, version2.split(<span class=\"string\">'.'</span>))</span><br><span class=\"line\">    <span class=\"keyword\">for</span> d1, d2 <span class=\"keyword\">in</span> itertools.zip_longest(v1, v2, fillvalue=<span class=\"number\">0</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> d1 &gt; d2:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> d2 &gt; d1:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<p>方法二：学学stefan的写法。其实就是cmp函数，python3没有这个函数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">compareVersion</span><span class=\"params\">(self, version1: str, version2: str)</span> -&gt; int:</span></span><br><span class=\"line\">    v1, v2 = map(int, version1.split(<span class=\"string\">'.'</span>)), map(int, version2.split(<span class=\"string\">'.'</span>))</span><br><span class=\"line\">    v1, v2 = zip(*itertools.zip_longest(v1, v2, fillvalue=<span class=\"number\">0</span>))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">-1</span>][(v1&gt;v2)-(v2&gt;v1)]</span><br></pre></td></tr></table></figure>\n<h3 id=\"1371-Find-the-Longest-Substring-Containing-Vowels-in-Even-Counts\"><a href=\"#1371-Find-the-Longest-Substring-Containing-Vowels-in-Even-Counts\" class=\"headerlink\" title=\"1371. Find the Longest Substring Containing Vowels in Even Counts\"></a>1371. Find the Longest Substring Containing Vowels in Even Counts</h3><h4 id=\"找到最长的包含偶数个元音字母的字符串，这道题非常的典型。原题\"><a href=\"#找到最长的包含偶数个元音字母的字符串，这道题非常的典型。原题\" class=\"headerlink\" title=\"找到最长的包含偶数个元音字母的字符串，这道题非常的典型。原题\"></a>找到最长的包含偶数个元音字母的字符串，这道题非常的典型。<a href=\"https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;eleetminicoworoep&quot;</span><br><span class=\"line\">Output: 13</span><br><span class=\"line\">Explanation: The longest substring is &quot;leetminicowor&quot; which contains two each of the vowels: e, i and o and zero of the vowels: a and u.</span><br></pre></td></tr></table></figure>\n<p>方法一：自己研究了半天的写法，其实感觉2个数组记录属实有点多余。对于变化的形态，一种有32种状态，我这里是记录了这个状态最开始时上个状态+1的索引，因为这种状态可以通过非元音往两侧延伸。然后记录了每种状态最后的索引。结果就是两个索引的差值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findTheLongestSubstring</span><span class=\"params\">(self, s: str)</span> -&gt; int:</span></span><br><span class=\"line\">    vowels = <span class=\"string\">'aeiou'</span></span><br><span class=\"line\">    mask = last_mask = <span class=\"number\">0</span></span><br><span class=\"line\">    first = [<span class=\"number\">-1</span>] + [float(<span class=\"string\">'inf'</span>)] * <span class=\"number\">31</span></span><br><span class=\"line\">    last = [<span class=\"number\">-1</span>] + [float(<span class=\"string\">'-inf'</span>)] * <span class=\"number\">31</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, c <span class=\"keyword\">in</span> enumerate(s):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> c <span class=\"keyword\">in</span> set(vowels):</span><br><span class=\"line\">            j = vowels.index(c)</span><br><span class=\"line\">            last_mask, mask = mask, mask ^ (<span class=\"number\">1</span>&lt;&lt;j)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> first[mask] == float(<span class=\"string\">'inf'</span>):</span><br><span class=\"line\">                first[mask] = last[last_mask] + <span class=\"number\">1</span> </span><br><span class=\"line\">        last[mask] = i</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(j-i <span class=\"keyword\">for</span> i, j <span class=\"keyword\">in</span> zip(first, last))</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：Lee的写法。思路是一样的，写法上有了改进，setdefault我也想到了，但是last数组没想到怎么消除。原来要每次计算一下。<code>1&lt;&lt;i&gt;&gt;1</code>是为了将其他find为0的变成0。不过大佬的方法比我的慢了200ms，可能因为’aeiou‘的反复遍历。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findTheLongestSubstring</span><span class=\"params\">(self, s: str)</span> -&gt; int:</span></span><br><span class=\"line\">    seen = &#123;<span class=\"number\">0</span>: <span class=\"number\">-1</span>&#125;</span><br><span class=\"line\">    res = cur = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, c <span class=\"keyword\">in</span> enumerate(s):</span><br><span class=\"line\">        cur ^= <span class=\"number\">1</span> &lt;&lt; (<span class=\"string\">'aeiou'</span>.find(c) + <span class=\"number\">1</span>) &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">        seen.setdefault(cur, i)</span><br><span class=\"line\">        res = max(res, i - seen[cur])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"443-String-Compression-1\"><a href=\"#443-String-Compression-1\" class=\"headerlink\" title=\"443. String Compression\"></a>443. String Compression</h3><h4 id=\"原地压缩一个字符数组，如果是1则不需要补数量。原题\"><a href=\"#原地压缩一个字符数组，如果是1则不需要补数量。原题\" class=\"headerlink\" title=\"原地压缩一个字符数组，如果是1则不需要补数量。原题\"></a>原地压缩一个字符数组，如果是1则不需要补数量。<a href=\"https://leetcode.com/problems/string-compression/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: chars &#x3D; [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]</span><br><span class=\"line\">Output: Return 6, and the first 6 characters of the input array should be: [&quot;a&quot;,&quot;2&quot;,&quot;b&quot;,&quot;2&quot;,&quot;c&quot;,&quot;3&quot;]</span><br><span class=\"line\">Explanation: The groups are &quot;aa&quot;, &quot;bb&quot;, and &quot;ccc&quot;. This compresses to &quot;a2b2c3&quot;.</span><br><span class=\"line\">Input: chars &#x3D; [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;a&quot;,&quot;a&quot;]</span><br><span class=\"line\">Output: Return 6, and the first 6 characters of the input array should be: [&quot;a&quot;,&quot;3&quot;,&quot;b&quot;,&quot;2&quot;,&quot;a&quot;,&quot;2&quot;].</span><br><span class=\"line\">Explanation: The groups are &quot;aaa&quot;, &quot;bb&quot;, and &quot;aa&quot;. This compresses to &quot;a3b2a2&quot;. Note that each group is independent even if two groups have the same character.</span><br></pre></td></tr></table></figure>\n<p>方法一：因为不能使用其它的空间，所以只能是通过指针来改变。0作为一个结尾符号，因为还可能包含其它符号，而不会出现数字。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">compress</span><span class=\"params\">(self, chars: List[str])</span> -&gt; int:</span></span><br><span class=\"line\">    i, j, cnt, last = <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"string\">''</span></span><br><span class=\"line\">    chars.append(<span class=\"string\">'0'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j, s <span class=\"keyword\">in</span> enumerate(chars):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> s == last:</span><br><span class=\"line\">            cnt += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            to_add = last + (str(cnt) <span class=\"keyword\">if</span> cnt!=<span class=\"number\">1</span> <span class=\"keyword\">else</span> <span class=\"string\">''</span>)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> to_add:</span><br><span class=\"line\">                chars[i] = c</span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">            cnt = <span class=\"number\">1</span></span><br><span class=\"line\">            last = s</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i</span><br></pre></td></tr></table></figure>\n<h3 id=\"809-Expressive-Words\"><a href=\"#809-Expressive-Words\" class=\"headerlink\" title=\"809. Expressive Words\"></a>809. Expressive Words</h3><h4 id=\"情感丰富的单词，给定一个单词列表，判断有多少个可以变成S，规则是可以重复一个字母，但是至少要重复到3次。原题\"><a href=\"#情感丰富的单词，给定一个单词列表，判断有多少个可以变成S，规则是可以重复一个字母，但是至少要重复到3次。原题\" class=\"headerlink\" title=\"情感丰富的单词，给定一个单词列表，判断有多少个可以变成S，规则是可以重复一个字母，但是至少要重复到3次。原题\"></a>情感丰富的单词，给定一个单词列表，判断有多少个可以变成S，规则是可以重复一个字母，但是至少要重复到3次。<a href=\"https://leetcode.com/problems/expressive-words/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Example:</span><br><span class=\"line\">Input: </span><br><span class=\"line\">S &#x3D; &quot;heeellooo&quot;</span><br><span class=\"line\">words &#x3D; [&quot;hello&quot;, &quot;hi&quot;, &quot;helo&quot;]</span><br><span class=\"line\">Output: 1</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">We can extend &quot;e&quot; and &quot;o&quot; in the word &quot;hello&quot; to get &quot;heeellooo&quot;.</span><br><span class=\"line\">We can&#39;t extend &quot;helo&quot; to get &quot;heeellooo&quot; because the group &quot;ll&quot; is not size 3 or more.</span><br></pre></td></tr></table></figure>\n<p>方法一：首次AC的方法，<code>groupby</code>注意只能遍历一次，哪怕是求len，也会导致其中嵌套的生成器被消耗掉。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">expressiveWords</span><span class=\"params\">(self, S: str, words: List[str])</span> -&gt; int:</span></span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> words:</span><br><span class=\"line\">        sg = itertools.groupby(S)</span><br><span class=\"line\">        wg = itertools.groupby(word)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (sc, sgs), (wc, wgs) <span class=\"keyword\">in</span> itertools.zip_longest(</span><br><span class=\"line\">            sg, wg, fillvalue=(<span class=\"string\">'0'</span>, <span class=\"literal\">None</span>)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> sc != wc: <span class=\"keyword\">break</span></span><br><span class=\"line\">            cnt_s, cnt_w = len(list(sgs)), len(list(wgs))</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cnt_s==<span class=\"number\">2</span> <span class=\"keyword\">and</span> cnt_w==<span class=\"number\">1</span>) <span class=\"keyword\">or</span> (cnt_s&lt;cnt_w):</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            ans += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：solution中的方法，和我的思想一样，但是我的写法没有这个好。首先遍历一次然后记录个数就行了，所以为什么要遍历很多次呢，再一个判断时使用满足+1，就可以避免使 用<code>zip_longest</code>。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">expressiveWords</span><span class=\"params\">(self, S: str, words: List[str])</span> -&gt; int:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rle</span><span class=\"params\">(s)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> zip(*[(k, len(list(grp)))</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> k, grp <span class=\"keyword\">in</span> itertools.groupby(s)])</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> S: <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    R, count = rle(S)  <span class=\"comment\"># [('h', 'e', 'l', 'o'), (1, 3, 2, 3)]</span></span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> words:</span><br><span class=\"line\">        R2, count2 = rle(word)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> R != R2: <span class=\"keyword\">continue</span></span><br><span class=\"line\">        ans += all(c1&gt;=max(c2, <span class=\"number\">3</span>) <span class=\"keyword\">or</span> c1==c2</span><br><span class=\"line\">                  <span class=\"keyword\">for</span> c1, c2 <span class=\"keyword\">in</span> zip(count, count2))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"833-Find-And-Replace-in-String\"><a href=\"#833-Find-And-Replace-in-String\" class=\"headerlink\" title=\"833. Find And Replace in String\"></a>833. Find And Replace in String</h3><h4 id=\"找到匹配并替换，注意是所有的同时替换，因为替换长度不同可能会导致索引不一致，所以不能用切片直接修改。原题\"><a href=\"#找到匹配并替换，注意是所有的同时替换，因为替换长度不同可能会导致索引不一致，所以不能用切片直接修改。原题\" class=\"headerlink\" title=\"找到匹配并替换，注意是所有的同时替换，因为替换长度不同可能会导致索引不一致，所以不能用切片直接修改。原题\"></a>找到匹配并替换，注意是所有的同时替换，因为替换长度不同可能会导致索引不一致，所以不能用切片直接修改。<a href=\"https://leetcode.com/problems/find-and-replace-in-string/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: S &#x3D; &quot;abcd&quot;, indexes &#x3D; [0,2], sources &#x3D; [&quot;ab&quot;,&quot;ec&quot;], targets &#x3D; [&quot;eee&quot;,&quot;ffff&quot;]</span><br><span class=\"line\">Output: &quot;eeecd&quot;</span><br><span class=\"line\">Explanation: &quot;ab&quot; starts at index 0 in S, so it&#39;s replaced by &quot;eee&quot;. </span><br><span class=\"line\">&quot;ec&quot; doesn&#39;t starts at index 2 in the original S, so we do nothing.</span><br></pre></td></tr></table></figure>\n<p>方法一：注意last_i要更新，还有一点是，islice用的不熟，以为<code>islice(S, 0)</code>是从0开始呢，原来是到0截止。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findReplaceString</span><span class=\"params\">(self, S: str, indexes: List[int], sources: List[str], targets: List[str])</span> -&gt; str:</span></span><br><span class=\"line\">    ans, last_i = [], <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, r, t <span class=\"keyword\">in</span> sorted(zip(indexes, sources, targets)):</span><br><span class=\"line\">        ans.append(S[last_i:i])</span><br><span class=\"line\">        last_i, j = i, len(r)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> all(c1==c2 <span class=\"keyword\">for</span> c1, c2 <span class=\"keyword\">in</span> zip(itertools.islice(S, i, i+j), r)):</span><br><span class=\"line\">            ans.append(t)</span><br><span class=\"line\">            last_i += j</span><br><span class=\"line\">    ans += S[last_i:]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(ans)</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：by Lee215，我看了一眼就写出来了，直接使用了切片，因为逆序不影响索引。理论上方法一要快一点，因为没有产生多余的切片，但实际上二者时间相差无几。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findReplaceString</span><span class=\"params\">(self, S: str, indexes: List[int], sources: List[str], targets: List[str])</span> -&gt; str:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, r, t <span class=\"keyword\">in</span> sorted(zip(indexes, sources, targets), reverse=<span class=\"literal\">True</span>):</span><br><span class=\"line\">        S = S[:i] + t + S[i+len(r):] <span class=\"keyword\">if</span> S[i:i+len(r)]==r <span class=\"keyword\">else</span> S</span><br><span class=\"line\">    <span class=\"keyword\">return</span> S</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：倒序改方法一。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findReplaceString</span><span class=\"params\">(self, S: str, indexes: List[int], sources: List[str], targets: List[str])</span> -&gt; str:</span></span><br><span class=\"line\">    s = list(S)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, r, t <span class=\"keyword\">in</span> sorted(zip(indexes, sources, targets), reverse=<span class=\"literal\">True</span>):</span><br><span class=\"line\">        j = len(r)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> all(c1==c2 <span class=\"keyword\">for</span> c1, c2 <span class=\"keyword\">in</span> zip(itertools.islice(s, i, i+j), r)):</span><br><span class=\"line\">            s[i:i+j] = t</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(s)</span><br></pre></td></tr></table></figure>\n<h3 id=\"面试题-17-15-最长单词\"><a href=\"#面试题-17-15-最长单词\" class=\"headerlink\" title=\"面试题 17.15. 最长单词\"></a><a href=\"https://leetcode-cn.com/problems/longest-word-lcci/\" target=\"_blank\" rel=\"noopener\">面试题 17.15. 最长单词</a></h3><h4 id=\"给定一组单词words，编写一个程序，找出其中的最长单词，且该单词由这组单词中的其他单词组合而成。若有多个长度相同的结果，返回其中字典序最小的一项，若没有符合要求的单词则返回空字符串。\"><a href=\"#给定一组单词words，编写一个程序，找出其中的最长单词，且该单词由这组单词中的其他单词组合而成。若有多个长度相同的结果，返回其中字典序最小的一项，若没有符合要求的单词则返回空字符串。\" class=\"headerlink\" title=\"给定一组单词words，编写一个程序，找出其中的最长单词，且该单词由这组单词中的其他单词组合而成。若有多个长度相同的结果，返回其中字典序最小的一项，若没有符合要求的单词则返回空字符串。\"></a>给定一组单词words，编写一个程序，找出其中的最长单词，且该单词由这组单词中的其他单词组合而成。若有多个长度相同的结果，返回其中字典序最小的一项，若没有符合要求的单词则返回空字符串。</h4><p>方法一：dfs。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestWord</span><span class=\"params\">(self, words: List[str])</span> -&gt; str:</span></span><br><span class=\"line\">    words.sort(key=<span class=\"keyword\">lambda</span> w: (-len(w), w))</span><br><span class=\"line\">    N = len(words)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">gen_word</span><span class=\"params\">(cur, w)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> w:</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> words:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> w.startswith(word) <span class=\"keyword\">and</span> word!=cur:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> gen_word(cur, w[len(word):]):</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> next((word <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> words <span class=\"keyword\">if</span> gen_word(word, word)), <span class=\"string\">''</span>)</span><br><span class=\"line\">    <span class=\"comment\"># return next(word for word in words if gen_word(word, word))</span></span><br><span class=\"line\">    <span class=\"comment\"># 这句话不行，会导致没有任何输出，而且还会影响别的用例。和输出顺序有关。</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"面试题-16-18-模式匹配\"><a href=\"#面试题-16-18-模式匹配\" class=\"headerlink\" title=\"面试题 16.18. 模式匹配\"></a><a href=\"https://leetcode-cn.com/problems/pattern-matching-lcci/\" target=\"_blank\" rel=\"noopener\">面试题 16.18. 模式匹配</a></h3><h4 id=\"你有两个字符串，即pattern和value。-pattern字符串由字母”a”和”b”组成，用于描述字符串中的模式。例如，字符串”catcatgocatgo”匹配模式”aabab”（其中”cat”是”a”，”go”是”b”），该字符串也匹配像”a”、”ab”和”b”这样的模式。但需注意”a”和”b”不能同时表示相同的字符串。编写一个方法判断value字符串是否匹配pattern字符串。\"><a href=\"#你有两个字符串，即pattern和value。-pattern字符串由字母”a”和”b”组成，用于描述字符串中的模式。例如，字符串”catcatgocatgo”匹配模式”aabab”（其中”cat”是”a”，”go”是”b”），该字符串也匹配像”a”、”ab”和”b”这样的模式。但需注意”a”和”b”不能同时表示相同的字符串。编写一个方法判断value字符串是否匹配pattern字符串。\" class=\"headerlink\" title=\"你有两个字符串，即pattern和value。 pattern字符串由字母”a”和”b”组成，用于描述字符串中的模式。例如，字符串”catcatgocatgo”匹配模式”aabab”（其中”cat”是”a”，”go”是”b”），该字符串也匹配像”a”、”ab”和”b”这样的模式。但需注意”a”和”b”不能同时表示相同的字符串。编写一个方法判断value字符串是否匹配pattern字符串。\"></a>你有两个字符串，即pattern和value。 pattern字符串由字母”a”和”b”组成，用于描述字符串中的模式。例如，字符串”catcatgocatgo”匹配模式”aabab”（其中”cat”是”a”，”go”是”b”），该字符串也匹配像”a”、”ab”和”b”这样的模式。但需注意”a”和”b”不能同时表示相同的字符串。编写一个方法判断value字符串是否匹配pattern字符串。</h4><p>方法一：这题边界条件挺多的。写了很长时间。不是最优的时间复杂度，但是速度还可以。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">patternMatching</span><span class=\"params\">(self, pattern: str, value: str)</span> -&gt; bool:</span></span><br><span class=\"line\">    N, M = len(pattern), len(value)</span><br><span class=\"line\">    first, first_val = pattern[<span class=\"number\">0</span>], <span class=\"string\">''</span></span><br><span class=\"line\">    another = <span class=\"string\">'ab'</span>[first==<span class=\"string\">'a'</span>]</span><br><span class=\"line\">    cnt_another = pattern.count(another)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> (value + <span class=\"string\">'#'</span>):</span><br><span class=\"line\">        <span class=\"comment\"># print(first_val)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> cnt_another == <span class=\"number\">0</span>:</span><br><span class=\"line\">            len_another = <span class=\"number\">0</span></span><br><span class=\"line\">            another_val = <span class=\"string\">''</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            len_another = (M - (len(first_val)*(N-cnt_another))) / cnt_another</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> len_another.is_integer():  <span class=\"comment\"># 不能整除则跳过</span></span><br><span class=\"line\">                first_val += c</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                len_another = int(len_another)</span><br><span class=\"line\">            j = pattern.find(another)</span><br><span class=\"line\">            another_val = value[j*len(first_val):j*len(first_val)+len_another]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pattern.replace(another, <span class=\"string\">'#'</span>).replace(first, first_val).replace(<span class=\"string\">'#'</span>, another_val)==value) <span class=\"keyword\">and</span> (cnt_another==<span class=\"number\">0</span> <span class=\"keyword\">or</span> first_val!=another_val):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        first_val += c</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1638-Count-Substrings-That-Differ-by-One-Character\"><a href=\"#1638-Count-Substrings-That-Differ-by-One-Character\" class=\"headerlink\" title=\"1638. Count Substrings That Differ by One Character\"></a><a href=\"https://leetcode.com/problems/count-substrings-that-differ-by-one-character/\" target=\"_blank\" rel=\"noopener\">1638. Count Substrings That Differ by One Character</a></h3><h4 id=\"两个字符串的连续子串中刚好差一个字符的一共有多少对。\"><a href=\"#两个字符串的连续子串中刚好差一个字符的一共有多少对。\" class=\"headerlink\" title=\"两个字符串的连续子串中刚好差一个字符的一共有多少对。\"></a>两个字符串的连续子串中刚好差一个字符的一共有多少对。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;aba&quot;, t &#x3D; &quot;baba&quot;</span><br><span class=\"line\">Output: 6</span><br><span class=\"line\">Explanation: The following are the pairs of substrings from s and t that differ by exactly 1 character:</span><br><span class=\"line\">(&quot;aba&quot;, &quot;baba&quot;)</span><br><span class=\"line\">(&quot;aba&quot;, &quot;baba&quot;)</span><br><span class=\"line\">(&quot;aba&quot;, &quot;baba&quot;)</span><br><span class=\"line\">(&quot;aba&quot;, &quot;baba&quot;)</span><br><span class=\"line\">(&quot;aba&quot;, &quot;baba&quot;)</span><br><span class=\"line\">(&quot;aba&quot;, &quot;baba&quot;)</span><br><span class=\"line\">The underlined portions are the substrings that are chosen from s and t.</span><br><span class=\"line\">Input: s &#x3D; &quot;abe&quot;, t &#x3D; &quot;bbc&quot;</span><br><span class=\"line\">Output: 10</span><br></pre></td></tr></table></figure>\n<p>方法一: 比赛时暴力过的。复杂度很高，时间1000ms+，不过居然能过。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countSubstrings</span><span class=\"params\">(self, s: str, t: str)</span> -&gt; int:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check</span><span class=\"params\">(s1, s2)</span>:</span></span><br><span class=\"line\">        count = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> zip(s1, s2):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> a != b:</span><br><span class=\"line\">                count += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> count == <span class=\"number\">2</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> count == <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    min_len = min(len(t), len(s))</span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, min_len+<span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(s)-d+<span class=\"number\">1</span>):</span><br><span class=\"line\">            s1 = s[i:i+d]</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(t)-d+<span class=\"number\">1</span>):</span><br><span class=\"line\">                s2 = t[j:j+d]</span><br><span class=\"line\">                <span class=\"comment\"># print(s1, s2, check(s1, s2))</span></span><br><span class=\"line\">                ans += check(s1, s2)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：Lee的方法好太多了，44ms。当字符不相等时重置为0，否则累加。这个写法挺难理解的，cur表示相等的数的累加，不相等时重置为0，然后交给pre来处理。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countSubstrings</span><span class=\"params\">(self, s: str, t: str)</span> -&gt; int:</span></span><br><span class=\"line\">    M, N = len(s), len(t)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check</span><span class=\"params\">(i, j)</span>:</span></span><br><span class=\"line\">        res = pre = cur = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(min(M-i, N-j)):</span><br><span class=\"line\">            cur += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> s[i+k] != t[j+k]:</span><br><span class=\"line\">                pre, cur = cur, <span class=\"number\">0</span></span><br><span class=\"line\">            res += pre</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(check(i, <span class=\"number\">0</span>) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(M)) + sum(check(<span class=\"number\">0</span>, j) <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, N))</span><br></pre></td></tr></table></figure>\n","categories":["算法"],"tags":["String","LeetCode","Python","Algorithm"]},{"title":"剑指Offer","url":"/%E5%89%91%E6%8C%87Offer/","content":"<h3 id=\"2-实现Singleton模式\"><a href=\"#2-实现Singleton模式\" class=\"headerlink\" title=\"2. 实现Singleton模式\"></a>2. 实现Singleton模式</h3><h4 id=\"使用-new-控制实例创建过程\"><a href=\"#使用-new-控制实例创建过程\" class=\"headerlink\" title=\"使用__new__控制实例创建过程\"></a>使用<code>__new__</code>控制实例创建过程</h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span>:</span></span><br><span class=\"line\">    _instance = <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__new__</span><span class=\"params\">(cls, *args, **kw)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> cls._instance:</span><br><span class=\"line\">            cls._instance = super().__new__(cls)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cls._instance</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span><span class=\"params\">(Singleton)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h4 id=\"使用decorator\"><a href=\"#使用decorator\" class=\"headerlink\" title=\"使用decorator\"></a>使用decorator</h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> functools <span class=\"keyword\">import</span> wraps</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">singleton</span><span class=\"params\">(cls)</span>:</span></span><br><span class=\"line\">    instances = &#123;&#125;</span><br><span class=\"line\"><span class=\"meta\">    @wraps(cls)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_instance</span><span class=\"params\">(*args, **kw)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> cls <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> instances:</span><br><span class=\"line\">            instances[cls] = cls(*args, **kw)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instances[cls]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> get_instance</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@singleton</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Myclass</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"使用元类\"><a href=\"#使用元类\" class=\"headerlink\" title=\"使用元类\"></a>使用元类</h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span><span class=\"params\">(type)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, *args, **kwargs)</span>:</span></span><br><span class=\"line\">        self.__instance = <span class=\"literal\">None</span></span><br><span class=\"line\">        super().__init__(*args, **kwargs)</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__call__</span><span class=\"params\">(self, *args, **kwargs)</span>:</span> </span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.__instance <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            self.__instance = super().__call__(*args, **kwargs)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.__instance </span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.__instance</span><br><span class=\"line\"><span class=\"comment\"># Example</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Spam</span><span class=\"params\">(metaclass=Singleton)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">\t\tprint(<span class=\"string\">'Creating Spam'</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-数组中重复的数字\"><a href=\"#3-数组中重复的数字\" class=\"headerlink\" title=\"3 数组中重复的数字\"></a>3 数组中重复的数字</h3><h4 id=\"牛客网传送门\"><a href=\"#牛客网传送门\" class=\"headerlink\" title=\"牛客网传送门\"></a><a href=\"https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&amp;tqId=11203&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking\" target=\"_blank\" rel=\"noopener\">牛客网传送门</a></h4><p>书中参数还传了一个数组用来保存重复的数字，身为一个Pythoner，直接返回tuple。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">duplicate</span><span class=\"params\">(nums: list)</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, num <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">        <span class=\"keyword\">while</span> i != num:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> num == nums[num]:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">True</span>, num</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                nums[i], nums[num] = nums[num], nums[i]</span><br><span class=\"line\">                num = nums[i]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span>, <span class=\"literal\">None</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-1-数组中重复的数字，不能修改数组\"><a href=\"#3-1-数组中重复的数字，不能修改数组\" class=\"headerlink\" title=\"3_1 数组中重复的数字，不能修改数组\"></a>3_1 数组中重复的数字，不能修改数组</h3><h4 id=\"AcWing传送门\"><a href=\"#AcWing传送门\" class=\"headerlink\" title=\"AcWing传送门\"></a><a href=\"https://www.acwing.com/problem/content/15/\" target=\"_blank\" rel=\"noopener\">AcWing传送门</a></h4><p>元素范围变成了1~n。此方法有缺陷，不能找出所有的重复的数字，因为在1~2的范围里有1和2两个数字，这个范围的数字也出现两次，不能确定是每个数字各出现一次还是某个数字出现了两次。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">find_duplicate</span><span class=\"params\">(nums: list)</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">count_range</span><span class=\"params\">(i, j)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum(i&lt;=num&lt;=j <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums)</span><br><span class=\"line\"></span><br><span class=\"line\">    lo = <span class=\"number\">1</span></span><br><span class=\"line\">    hi = len(nums) - <span class=\"number\">1</span>     <span class=\"comment\"># n为范围</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> lo &lt;= hi:</span><br><span class=\"line\">        mid = (lo + hi) // <span class=\"number\">2</span></span><br><span class=\"line\">        count = count_range(lo, mid)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> lo == hi:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> count &gt; <span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> lo</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> count &gt; mid-lo+<span class=\"number\">1</span>:</span><br><span class=\"line\">            hi = mid</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            lo = mid + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"4-二维数组中的查找\"><a href=\"#4-二维数组中的查找\" class=\"headerlink\" title=\"4. 二维数组中的查找\"></a>4. 二维数组中的查找</h3><h4 id=\"牛客网传送门-1\"><a href=\"#牛客网传送门-1\" class=\"headerlink\" title=\"牛客网传送门\"></a><a href=\"https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&amp;tqId=11154&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking\" target=\"_blank\" rel=\"noopener\">牛客网传送门</a></h4><h4 id=\"AcWing传送门-1\"><a href=\"#AcWing传送门-1\" class=\"headerlink\" title=\"AcWing传送门\"></a><a href=\"https://www.acwing.com/problem/content/16/\" target=\"_blank\" rel=\"noopener\">AcWing传送门</a></h4><h4 id=\"LeetCode传送门\"><a href=\"#LeetCode传送门\" class=\"headerlink\" title=\"LeetCode传送门\"></a><a href=\"https://leetcode.com/problems/search-a-2d-matrix-ii/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><p>选取右上角为起始点。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">find</span><span class=\"params\">(target, array)</span>:</span></span><br><span class=\"line\">    row = <span class=\"number\">0</span></span><br><span class=\"line\">    col = len(array[<span class=\"number\">0</span>]) - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> col &gt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> row &lt;= len(array)<span class=\"number\">-1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> array[row][col] &gt; target:</span><br><span class=\"line\">            col -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> array[row][col] &lt; target:</span><br><span class=\"line\">            row += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<p>更为优雅的方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">searchMatrix</span><span class=\"params\">(self, matrix, target)</span>:</span></span><br><span class=\"line\">    j = <span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> matrix:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> j + len(row) <span class=\"keyword\">and</span> row[j] &gt; target:</span><br><span class=\"line\">            j -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> row[j] == target:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"5-替换空格\"><a href=\"#5-替换空格\" class=\"headerlink\" title=\"5.替换空格\"></a>5.替换空格</h3><h4 id=\"牛客网传送门-2\"><a href=\"#牛客网传送门-2\" class=\"headerlink\" title=\"牛客网传送门\"></a><a href=\"https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&amp;tqId=11155&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking\" target=\"_blank\" rel=\"noopener\">牛客网传送门</a></h4><h4 id=\"AcWing传送门-2\"><a href=\"#AcWing传送门-2\" class=\"headerlink\" title=\"AcWing传送门\"></a><a href=\"https://www.acwing.com/problem/content/17/\" target=\"_blank\" rel=\"noopener\">AcWing传送门</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">replaceSpace</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(c <span class=\"keyword\">if</span> c!=<span class=\"string\">' '</span> <span class=\"keyword\">else</span> <span class=\"string\">'%20'</span> <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> s)</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-从尾到头打印链表\"><a href=\"#6-从尾到头打印链表\" class=\"headerlink\" title=\"6.从尾到头打印链表\"></a>6.从尾到头打印链表</h3><h4 id=\"AcWing传送门-3\"><a href=\"#AcWing传送门-3\" class=\"headerlink\" title=\"AcWing传送门\"></a><a href=\"https://www.acwing.com/problem/content/18/\" target=\"_blank\" rel=\"noopener\">AcWing传送门</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">printListFromTailToHead</span><span class=\"params\">(self, listNode)</span>:</span></span><br><span class=\"line\">    stack, h = [], listNode</span><br><span class=\"line\">    <span class=\"keyword\">while</span> h:</span><br><span class=\"line\">        stack.append(h.val)</span><br><span class=\"line\">        h = h.next</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stack[::<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"7-重建二叉树\"><a href=\"#7-重建二叉树\" class=\"headerlink\" title=\"7.重建二叉树\"></a>7.重建二叉树</h3><h4 id=\"LeetCode传送门-1\"><a href=\"#LeetCode传送门-1\" class=\"headerlink\" title=\"LeetCode传送门\"></a><a href=\"https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><p>说明：根据前序遍历和中序遍历重建二叉树，假设遍历结果中不包含重复的数字。<br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">buildTree</span><span class=\"params\">(preorder, inorder)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> preorder == []:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">    root_val = preorder[<span class=\"number\">0</span>]</span><br><span class=\"line\">    root = TreeNode(root_val)</span><br><span class=\"line\">    cut = inorder.index(root_val)</span><br><span class=\"line\">    root.left = buildTree(preorder[<span class=\"number\">1</span>:cut+<span class=\"number\">1</span>], inorder[:cut])</span><br><span class=\"line\">    root.right = buildTree(preorder[cut+<span class=\"number\">1</span>:], inorder[cut+<span class=\"number\">1</span>:])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br></pre></td></tr></table></figure><br>方法二：空间复杂度更低的解法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">buildTree</span><span class=\"params\">(self, preorder: <span class=\"string\">'List[int]'</span>, inorder: <span class=\"string\">'List[int]'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">build</span><span class=\"params\">(stop)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> inorder <span class=\"keyword\">and</span> inorder[<span class=\"number\">-1</span>] != stop:</span><br><span class=\"line\">            root = TreeNode(preorder.pop())</span><br><span class=\"line\">            root.left = build(root.val)</span><br><span class=\"line\">            inorder.pop()</span><br><span class=\"line\">            root.right = build(stop)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root</span><br><span class=\"line\">    preorder.reverse()</span><br><span class=\"line\">    inorder.reverse()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> build(<span class=\"literal\">None</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"8-二叉树的下一个节点\"><a href=\"#8-二叉树的下一个节点\" class=\"headerlink\" title=\"8 二叉树的下一个节点\"></a>8 二叉树的下一个节点</h3><h4 id=\"牛客网传送门-3\"><a href=\"#牛客网传送门-3\" class=\"headerlink\" title=\"牛客网传送门\"></a><a href=\"https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&amp;tqId=11210&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&amp;tPage=3\" target=\"_blank\" rel=\"noopener\">牛客网传送门</a></h4><h4 id=\"AcWing传送门-4\"><a href=\"#AcWing传送门-4\" class=\"headerlink\" title=\"AcWing传送门\"></a><a href=\"https://www.acwing.com/problem/content/31/\" target=\"_blank\" rel=\"noopener\">AcWing传送门</a></h4><p>如果节点有右子树，那么下一个节点为右子树中的最左节点；</p>\n<p>如果节点是父节点的左子节点，那么父节点就是下一个节点；</p>\n<p>如果节点是父节点的右子节点，沿着父节点向上遍历找到祖先节点中，为父节点左子节点的点，这个左子节点的父节点就是下一个节点。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">GetNext</span><span class=\"params\">(self, pNode)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># write code here</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> pNode:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"comment\"># 有右子树，右子树中最左节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> pNode.right:</span><br><span class=\"line\">        pre = pNode.right</span><br><span class=\"line\">        <span class=\"keyword\">while</span> pre.left:</span><br><span class=\"line\">            pre = pre.left</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pre</span><br><span class=\"line\">    <span class=\"keyword\">while</span> pNode.next:</span><br><span class=\"line\">        parent = pNode.next</span><br><span class=\"line\">        <span class=\"keyword\">if</span> parent.left == pNode:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> parent</span><br><span class=\"line\">        pNode = parent</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"9-用两个栈实现队列\"><a href=\"#9-用两个栈实现队列\" class=\"headerlink\" title=\"9.用两个栈实现队列\"></a>9.用两个栈实现队列</h3><h4 id=\"LeetCode传送门-2\"><a href=\"#LeetCode传送门-2\" class=\"headerlink\" title=\"LeetCode传送门\"></a><a href=\"https://leetcode.com/problems/implement-queue-using-stacks/description/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyQueue</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.s1 = []</span><br><span class=\"line\">        self.s2 = []</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">push</span><span class=\"params\">(self, x: int)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> self.s1:</span><br><span class=\"line\">            self.s2.append(self.s1.pop())</span><br><span class=\"line\">        self.s1.append(x)</span><br><span class=\"line\">        <span class=\"keyword\">while</span> self.s2:</span><br><span class=\"line\">            self.s1.append(self.s2.pop())</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pop</span><span class=\"params\">(self)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.s1.pop()</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">peek</span><span class=\"params\">(self)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.s1[<span class=\"number\">-1</span>]</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">empty</span><span class=\"params\">(self)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.s1 == []</span><br></pre></td></tr></table></figure>\n<h3 id=\"9-1用两个队列实现栈\"><a href=\"#9-1用两个队列实现栈\" class=\"headerlink\" title=\"9.1用两个队列实现栈\"></a>9.1用两个队列实现栈</h3><h4 id=\"LeetCode传送门-3\"><a href=\"#LeetCode传送门-3\" class=\"headerlink\" title=\"LeetCode传送门\"></a><a href=\"https://leetcode.com/problems/implement-stack-using-queues/description/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><p>两个队列<br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyStack</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> deque</span><br><span class=\"line\">        self.q1, self.q2 = deque(), deque()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">push</span><span class=\"params\">(self, x: int)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        self.q2.append(x)</span><br><span class=\"line\">        <span class=\"keyword\">while</span> self.q1:</span><br><span class=\"line\">            self.q2.append(self.q1.popleft())</span><br><span class=\"line\">        self.q1, self.q2 = self.q2, self.q1</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pop</span><span class=\"params\">(self)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.q1.popleft()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">top</span><span class=\"params\">(self)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.q1[<span class=\"number\">0</span>]</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">empty</span><span class=\"params\">(self)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">not</span> self.q1</span><br></pre></td></tr></table></figure><br>单队列旋转<br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyStack</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> deque</span><br><span class=\"line\">        self.q = deque()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">push</span><span class=\"params\">(self, x: int)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        self.q.append(x)</span><br><span class=\"line\">        <span class=\"comment\"># self.q.rotate(1)  这里是用了双端队列的特性</span></span><br><span class=\"line\">        <span class=\"comment\"># self.q.rotate(1-len(self.q))  这里和下面循环是一样的效果</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(len(self.q)<span class=\"number\">-1</span>):</span><br><span class=\"line\">            self.q.append(self.q.popleft())</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pop</span><span class=\"params\">(self)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.q.popleft()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">top</span><span class=\"params\">(self)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.q[<span class=\"number\">0</span>]</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">empty</span><span class=\"params\">(self)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">not</span> self.q</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"10-斐波那契数列\"><a href=\"#10-斐波那契数列\" class=\"headerlink\" title=\"10.斐波那契数列\"></a>10.斐波那契数列</h3><h4 id=\"LeetCode传送门-4\"><a href=\"#LeetCode传送门-4\" class=\"headerlink\" title=\"LeetCode传送门\"></a><a href=\"https://leetcode.com/problems/fibonacci-number/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fibonacci</span><span class=\"params\">(n)</span>:</span></span><br><span class=\"line\">    a = b = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n<span class=\"number\">-1</span>):</span><br><span class=\"line\">        a, b = b, a+b</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b</span><br></pre></td></tr></table></figure>\n<h3 id=\"11-旋转数组的最小数字\"><a href=\"#11-旋转数组的最小数字\" class=\"headerlink\" title=\"11.旋转数组的最小数字\"></a>11.旋转数组的最小数字</h3><h4 id=\"LeetCode传送门-5\"><a href=\"#LeetCode传送门-5\" class=\"headerlink\" title=\"LeetCode传送门\"></a><a href=\"https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><p>思路：通过二分法不断缩小范围，由于mid是整除，最后l==mid，并且nums[mid] &gt; nums[r]的。<br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">find_min</span><span class=\"params\">(nums)</span>:</span></span><br><span class=\"line\">    l, r = <span class=\"number\">0</span>, len(nums)<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> nums[l] &lt; nums[r]:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[l]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> l &lt;= r:</span><br><span class=\"line\">        mid = (l+r) // <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[mid] &gt; nums[l]:</span><br><span class=\"line\">            l = mid</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> nums[mid] &lt; nums[r]:</span><br><span class=\"line\">            r = mid</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums[r]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"12-矩阵中的路径\"><a href=\"#12-矩阵中的路径\" class=\"headerlink\" title=\"12.矩阵中的路径\"></a>12.矩阵中的路径</h3><h4 id=\"LeetCode传送门-6\"><a href=\"#LeetCode传送门-6\" class=\"headerlink\" title=\"LeetCode传送门\"></a><a href=\"https://leetcode.com/problems/word-search/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">exist</span><span class=\"params\">(self, board: List[List[str]], word: str)</span> -&gt; bool:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(i, j, remain)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> remain: <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        origin, board[i][j] = board[i][j], <span class=\"string\">'-'</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> ((i+<span class=\"number\">1</span>, j), (i<span class=\"number\">-1</span>, j), (i, j<span class=\"number\">-1</span>), (i, j+<span class=\"number\">1</span>)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=x&lt;M <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=y&lt;N <span class=\"keyword\">and</span> remain[<span class=\"number\">0</span>]==board[x][y]:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> dfs(x, y, remain[<span class=\"number\">1</span>:]):</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        board[i][j] = origin</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">    M, N = len(board), len(board[<span class=\"number\">0</span>])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> any(dfs(i, j, word[<span class=\"number\">1</span>:]) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(M) <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(N) <span class=\"keyword\">if</span> word[<span class=\"number\">0</span>]==board[i][j])</span><br></pre></td></tr></table></figure>\n<h3 id=\"13-机器人的运动范围\"><a href=\"#13-机器人的运动范围\" class=\"headerlink\" title=\"13. 机器人的运动范围\"></a>13. 机器人的运动范围</h3><h4 id=\"AcWing传送门-5\"><a href=\"#AcWing传送门-5\" class=\"headerlink\" title=\"AcWing传送门\"></a><a href=\"https://www.acwing.com/problem/content/22/\" target=\"_blank\" rel=\"noopener\">AcWing传送门</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">movingCount</span><span class=\"params\">(self, m: int, n: int, k: int)</span> -&gt; int:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    visited = [[<span class=\"literal\">False</span>]*n <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(m)]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_arive</span><span class=\"params\">(i, j)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum(map(int, str(i)+str(j))) &lt;= k</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(i, j)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> is_arive(i, j):</span><br><span class=\"line\">            visited[i][j] = <span class=\"literal\">True</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> ((i+<span class=\"number\">1</span>, j), (i<span class=\"number\">-1</span>, j), (i, j<span class=\"number\">-1</span>), (i, j+<span class=\"number\">1</span>)):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=x&lt;m <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=y&lt;n <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> visited[x][y]:</span><br><span class=\"line\">                    dfs(x, y)</span><br><span class=\"line\"></span><br><span class=\"line\">    dfs(<span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(sum(visited, []))</span><br></pre></td></tr></table></figure>\n<h3 id=\"14-剪绳子\"><a href=\"#14-剪绳子\" class=\"headerlink\" title=\"14.剪绳子\"></a>14.剪绳子</h3><h4 id=\"AcWing传送门-6\"><a href=\"#AcWing传送门-6\" class=\"headerlink\" title=\"AcWing传送门\"></a><a href=\"https://www.acwing.com/problem/content/24/\" target=\"_blank\" rel=\"noopener\">AcWing传送门</a></h4><p>说明：数学思想，当<code>n&gt;=5</code>时，<code>2(n-2)&gt;n</code>并且<code>3(n-3)&gt;n</code>，而且<code>3(n-3) &gt;= 2(n-2)</code>，所以尽可能多剪长度为3的绳子。如果长度为4的时候，<code>2*2&gt;3*1</code>，所以4的时候就剪成<code>2*2</code>的两段。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">cut_rope</span><span class=\"params\">(length)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> length &lt; <span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> length == <span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> length == <span class=\"number\">3</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">2</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 尽可能剪出3</span></span><br><span class=\"line\">    timesOf3 = length // <span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"comment\"># 如果最后余1，则留一段4分成两半</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> length-timesOf3*<span class=\"number\">3</span> == <span class=\"number\">1</span>:</span><br><span class=\"line\">        timeOf3 -= <span class=\"number\">1</span></span><br><span class=\"line\">    timesOf2 = (length-timesOf3*<span class=\"number\">3</span>) // <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"number\">3</span>**timesOf3) * (<span class=\"number\">2</span>**timesOf2)</span><br></pre></td></tr></table></figure>\n<h3 id=\"15-二进制中1的个数\"><a href=\"#15-二进制中1的个数\" class=\"headerlink\" title=\"15.二进制中1的个数\"></a>15.二进制中1的个数</h3><h4 id=\"LeetCode传送门-7\"><a href=\"#LeetCode传送门-7\" class=\"headerlink\" title=\"LeetCode传送门\"></a><a href=\"https://leetcode.com/problems/number-of-1-bits/description/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><p>方法一：常规解法，使用1与n作与运算，如果不是0说明，含有一个1。<br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hamming_weight</span><span class=\"params\">(n)</span>:</span></span><br><span class=\"line\">    count = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(<span class=\"number\">32</span>):</span><br><span class=\"line\">        count += (n&amp;<span class=\"number\">1</span>==<span class=\"number\">1</span>)</span><br><span class=\"line\">        n &gt;&gt;= <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> count</span><br></pre></td></tr></table></figure><br>方法二：关键点是，一个数n和n-1的与运算操作，相当于去掉了最右面的1。<br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hamming_weigth</span><span class=\"params\">(n)</span>:</span></span><br><span class=\"line\">    bits = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> n:</span><br><span class=\"line\">        bits += <span class=\"number\">1</span></span><br><span class=\"line\">        n = (n<span class=\"number\">-1</span>) &amp; n</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bits</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"16-数值的整数次方\"><a href=\"#16-数值的整数次方\" class=\"headerlink\" title=\"16.数值的整数次方\"></a>16.数值的整数次方</h3><h4 id=\"LeetCode传送门-8\"><a href=\"#LeetCode传送门-8\" class=\"headerlink\" title=\"LeetCode传送门\"></a><a href=\"https://leetcode.com/problems/powx-n/description/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><p>这里需要注意的一点<code>ans *= ans</code>不能写成<code>ans = ans**2</code>因为浮点数是有范围的，可能会超出范围报错。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">myPow</span><span class=\"params\">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pow_with_unsigned</span><span class=\"params\">(x, n)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> x</span><br><span class=\"line\">        ans = pow_with_unsigned(x, n&gt;&gt;<span class=\"number\">1</span>)</span><br><span class=\"line\">        ans *= ans</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &amp; <span class=\"number\">1</span> == <span class=\"number\">1</span>:</span><br><span class=\"line\">            ans *= x</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span> / pow_with_unsigned(x, -n)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pow_with_unsigned(x, n)</span><br></pre></td></tr></table></figure>\n<h3 id=\"17-打印从1到最大的n位数\"><a href=\"#17-打印从1到最大的n位数\" class=\"headerlink\" title=\"17 打印从1到最大的n位数\"></a>17 打印从1到最大的n位数</h3><h4 id=\"404\"><a href=\"#404\" class=\"headerlink\" title=\"404.\"></a>404.</h4><p>打印呗，反正Python的int没有长度限制。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">print_n</span><span class=\"params\">(n: int)</span>:</span></span><br><span class=\"line\">    n = <span class=\"number\">10</span> ** (n)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n):</span><br><span class=\"line\">        print(i)</span><br></pre></td></tr></table></figure>\n<h3 id=\"18-删除链表中的节点\"><a href=\"#18-删除链表中的节点\" class=\"headerlink\" title=\"18.删除链表中的节点\"></a>18.删除链表中的节点</h3><h4 id=\"LeetCode传送门-9\"><a href=\"#LeetCode传送门-9\" class=\"headerlink\" title=\"LeetCode传送门\"></a><a href=\"https://leetcode.com/problems/delete-node-in-a-linked-list/description/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><p>开始看到这题的思路是，要是能拿到父节点就好了，然后这道题需要别的思路，其关键在于复制<br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">deleteNode</span><span class=\"params\">(self, node)</span>:</span></span><br><span class=\"line\">    node.val = node.next.val  <span class=\"comment\"># 4-&gt;1-&gt;1-&gt;9</span></span><br><span class=\"line\">    node.next = node.next.next  <span class=\"comment\"># 4-&gt;1-&gt;9</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"19-正则表达式\"><a href=\"#19-正则表达式\" class=\"headerlink\" title=\"19.正则表达式\"></a>19.正则表达式</h3><h4 id=\"LeetCode传送门-10\"><a href=\"#LeetCode传送门-10\" class=\"headerlink\" title=\"LeetCode传送门\"></a><a href=\"https://leetcode.com/problems/regular-expression-matching/description/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><p>先考虑没有<code>*</code>的情况，通过一个递归逐个字符判断</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">match</span><span class=\"params\">(text, pattern)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> pattern: <span class=\"keyword\">return</span> <span class=\"keyword\">not</span> text</span><br><span class=\"line\">    first_match = bool(text) <span class=\"keyword\">and</span> pattern[<span class=\"number\">0</span>] <span class=\"keyword\">in</span> &#123;text[<span class=\"number\">0</span>], <span class=\"string\">'.'</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> first_match <span class=\"keyword\">and</span> match(text[<span class=\"number\">1</span>:], pattern[<span class=\"number\">1</span>:])</span><br></pre></td></tr></table></figure>\n<p>当<code>*</code>出现时，一定会在前面跟一个其他字符，所以一定会出现在pattern[1]的位置。一种情况是我们忽略这对pattern，因为可以出现0次；另一种情况是匹配上这个字符，用递归的方式匹配下一个。</p>\n<p>一定要用f_match = bool(s)，否则结果可能输出<code>&#39;&#39;</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@lru_cache(None)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">match</span><span class=\"params\">(self, s, pattern)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> pattern: <span class=\"keyword\">return</span> <span class=\"keyword\">not</span> s</span><br><span class=\"line\">    f_match = bool(s) <span class=\"keyword\">and</span> pattern[<span class=\"number\">0</span>] <span class=\"keyword\">in</span> &#123;s[<span class=\"number\">0</span>], <span class=\"string\">'.'</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(pattern) &gt; <span class=\"number\">1</span> <span class=\"keyword\">and</span> pattern[<span class=\"number\">1</span>] == <span class=\"string\">'*'</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (self.match(s, pattern[<span class=\"number\">2</span>:]) <span class=\"keyword\">or</span></span><br><span class=\"line\">                (f_match <span class=\"keyword\">and</span> self.match(s[<span class=\"number\">1</span>:], pattern)))</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f_match <span class=\"keyword\">and</span> self.match(s[<span class=\"number\">1</span>:], pattern[<span class=\"number\">1</span>:])</span><br></pre></td></tr></table></figure>\n<h3 id=\"20-表示数值的字符串\"><a href=\"#20-表示数值的字符串\" class=\"headerlink\" title=\"20. 表示数值的字符串\"></a>20. 表示数值的字符串</h3><h4 id=\"65-Valid-Number\"><a href=\"#65-Valid-Number\" class=\"headerlink\" title=\"65. Valid Number\"></a><a href=\"https://leetcode.com/problems/valid-number/discuss/23728/A-simple-solution-in-Python-based-on-DFA\" target=\"_blank\" rel=\"noopener\">65. Valid Number</a></h4><p>此处留坑，<a href=\"https://leetcode.com/problems/valid-number/discuss/23728/A-simple-solution-in-Python-based-on-DFA\" target=\"_blank\" rel=\"noopener\">排名第一的python答案</a>暂时没有理解。</p>\n<h3 id=\"21-调整数组顺序使奇数位于偶数前面\"><a href=\"#21-调整数组顺序使奇数位于偶数前面\" class=\"headerlink\" title=\"21.调整数组顺序使奇数位于偶数前面\"></a>21.调整数组顺序使奇数位于偶数前面</h3><h4 id=\"AcWing传送门-7\"><a href=\"#AcWing传送门-7\" class=\"headerlink\" title=\"AcWing传送门\"></a><a href=\"https://www.acwing.com/problem/content/30/\" target=\"_blank\" rel=\"noopener\">AcWing传送门</a></h4><p>生成器写法，</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">exchange</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    odd = (num <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums <span class=\"keyword\">if</span> num&amp;<span class=\"number\">1</span>)</span><br><span class=\"line\">    even = (num <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums <span class=\"keyword\">if</span> num&amp;<span class=\"number\">1</span>==<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list(chain(odd, even))</span><br></pre></td></tr></table></figure>\n<p>时间：O(n), 空间O(1)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reOrderArray</span><span class=\"params\">(self, array)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># write code here</span></span><br><span class=\"line\">    l, r = <span class=\"number\">0</span>, len(array)<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> l &lt; r:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> l &lt; r <span class=\"keyword\">and</span> array[l]&amp;<span class=\"number\">1</span> == <span class=\"number\">1</span>:</span><br><span class=\"line\">            l += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> l &lt; r <span class=\"keyword\">and</span> array[r]&amp;<span class=\"number\">1</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">            r -= <span class=\"number\">1</span></span><br><span class=\"line\">        array[l], array[r] = array[r], array[l]</span><br></pre></td></tr></table></figure>\n<p>看了一下没有通过牛客网的测试用例，因为题目有些不同，牛客网要求奇数和奇数，偶数和偶数之前的相对位置不变。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reOrderArray</span><span class=\"params\">(array)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sorted(array, key=<span class=\"keyword\">lambda</span> x:x&amp;<span class=\"number\">1</span>==<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n<p>不使用sort</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reOrderArray</span><span class=\"params\">(self, array)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># write code here</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> deque</span><br><span class=\"line\">    q = deque()</span><br><span class=\"line\">    n = len(array)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> array[-i<span class=\"number\">-1</span>] &amp; <span class=\"number\">1</span> == <span class=\"number\">1</span>:  <span class=\"comment\"># 从后找奇数</span></span><br><span class=\"line\">            q.appendleft(array[-i<span class=\"number\">-1</span>])</span><br><span class=\"line\">        <span class=\"keyword\">if</span> array[i] &amp; <span class=\"number\">1</span> == <span class=\"number\">0</span>:  <span class=\"comment\">#从前找偶数</span></span><br><span class=\"line\">            q.append(array[i])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> q</span><br></pre></td></tr></table></figure>\n<h3 id=\"22-链表中倒数第k个节点\"><a href=\"#22-链表中倒数第k个节点\" class=\"headerlink\" title=\"22.链表中倒数第k个节点\"></a>22.链表中倒数第k个节点</h3><h4 id=\"AcWing传送门-8\"><a href=\"#AcWing传送门-8\" class=\"headerlink\" title=\"AcWing传送门\"></a><a href=\"https://www.acwing.com/problem/content/32/\" target=\"_blank\" rel=\"noopener\">AcWing传送门</a></h4><p>思路：两个指针，快指针先走k步，然后两个一起走，快指针走到尾节点时，慢指针在倒数第k个节点。<br>需考虑k=0时和fast已经走到尾节点的情况。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">FindKthToTail</span><span class=\"params\">(self, head, k)</span>:</span></span><br><span class=\"line\">    fast = slow = head</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(k):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> fast:</span><br><span class=\"line\">            fast = fast.next</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> fast:</span><br><span class=\"line\">        slow, fast = slow.next, fast.next</span><br><span class=\"line\">    <span class=\"keyword\">return</span> slow</span><br></pre></td></tr></table></figure>\n<h3 id=\"23-链表中环的入口节点\"><a href=\"#23-链表中环的入口节点\" class=\"headerlink\" title=\"23.链表中环的入口节点\"></a>23.链表中环的入口节点</h3><h4 id=\"LeetCode传送门-11\"><a href=\"#LeetCode传送门-11\" class=\"headerlink\" title=\"LeetCode传送门\"></a><a href=\"https://leetcode.com/problems/linked-list-cycle-ii/description/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><ul>\n<li>首先判断此链表是否有环。</li>\n<li>然后再相交点和头结点一起走，一定会在入口相遇。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">detectCycle</span><span class=\"params\">(self, head)</span>:</span>        </span><br><span class=\"line\">    fast = slow = head</span><br><span class=\"line\">    <span class=\"comment\"># 检测是否有环</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> fast <span class=\"keyword\">and</span> fast.next:</span><br><span class=\"line\">        slow, fast = slow.next, fast.next.next</span><br><span class=\"line\">        <span class=\"keyword\">if</span> slow <span class=\"keyword\">is</span> fast:</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"comment\"># 找出入口节点</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> head <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> slow:</span><br><span class=\"line\">        head, slow = head.next, slow.next</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head</span><br></pre></td></tr></table></figure>\n<h3 id=\"24-反转链表\"><a href=\"#24-反转链表\" class=\"headerlink\" title=\"24.反转链表\"></a>24.反转链表</h3><h4 id=\"LeetCode传送门-12\"><a href=\"#LeetCode传送门-12\" class=\"headerlink\" title=\"LeetCode传送门\"></a><a href=\"https://leetcode.com/problems/reverse-linked-list/description/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseList</span><span class=\"params\">(self, head)</span>:</span></span><br><span class=\"line\">    prev = <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> head:</span><br><span class=\"line\">        head.next, prev, head = prev, head, head.next</span><br><span class=\"line\">    <span class=\"keyword\">return</span> prev</span><br></pre></td></tr></table></figure>\n<h3 id=\"25-合并两个有序链表\"><a href=\"#25-合并两个有序链表\" class=\"headerlink\" title=\"25.合并两个有序链表\"></a>25.合并两个有序链表</h3><h4 id=\"LeetCode传送门-13\"><a href=\"#LeetCode传送门-13\" class=\"headerlink\" title=\"LeetCode传送门\"></a><a href=\"https://leetcode.com/problems/merge-two-sorted-lists/description/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><p>方法1：iteratively 迭代</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergeTwoLists</span><span class=\"params\">(l1, l2)</span>:</span></span><br><span class=\"line\">    l = head = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> l1 <span class=\"keyword\">and</span> l2:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> l1.val &lt;= l2.val:</span><br><span class=\"line\">            l.next, l1 = l1, l1.next</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            l.next, l2 = l2, l2.next</span><br><span class=\"line\">        l = l.next</span><br><span class=\"line\">    l.next = l1 <span class=\"keyword\">or</span> l2</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head.next</span><br></pre></td></tr></table></figure>\n<p>方法2：recursively 递归</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergeTwoLists</span><span class=\"params\">(l1, l2)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 判断是否存在None</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> l1 <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> l2:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l1 <span class=\"keyword\">or</span> l2</span><br><span class=\"line\">    <span class=\"keyword\">if</span> l1.val &lt; l2.val:</span><br><span class=\"line\">        l1.next = mergeTwoLists(l1.next, l2)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l1</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        l2.next = mergeTwoLists(l1, l2.next)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l2</span><br></pre></td></tr></table></figure>\n<h3 id=\"26-树的子结构\"><a href=\"#26-树的子结构\" class=\"headerlink\" title=\"26.树的子结构\"></a>26.树的子结构</h3><a href=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AF%87%EF%BC%89Tree/\" title=\"572. Subtree of Another Tree\">572. Subtree of Another Tree</a>\n<p>二刷的时候突然发现，此题和LeetCode中不同。LeetCode中子树<code>4-1-2</code>返回False因为2下边还有节点，所以不一样；而书中认为True，不考虑2下边的节点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">    3</span><br><span class=\"line\">   &#x2F; \\</span><br><span class=\"line\">  4   5</span><br><span class=\"line\"> &#x2F; \\</span><br><span class=\"line\">1   2</span><br><span class=\"line\">   &#x2F;</span><br><span class=\"line\">  0</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isSubStructure</span><span class=\"params\">(self, s: TreeNode, t: TreeNode)</span> -&gt; bool:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_same</span><span class=\"params\">(t1, t2)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> t2:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> t1:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> t1.val==t2.val <span class=\"keyword\">and</span> is_same(t1.left, t2.left) <span class=\"keyword\">and</span> is_same(t1.right, t2.right)     </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> s <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> t: <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    stack = s <span class=\"keyword\">and</span> [s]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> stack:</span><br><span class=\"line\">        node = stack.pop()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> is_same(node, t):</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">            stack.append(node.right)</span><br><span class=\"line\">            stack.append(node.left)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<p>方法二：学到一个递归写法，更简单。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isSubStructure</span><span class=\"params\">(self, A: TreeNode, B: TreeNode)</span> -&gt; bool:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">recur</span><span class=\"params\">(A, B)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> B: <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> A <span class=\"keyword\">or</span> A.val != B.val: <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> recur(A.left, B.left) <span class=\"keyword\">and</span> recur(A.right, B.right)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> bool(A <span class=\"keyword\">and</span> B) <span class=\"keyword\">and</span> (recur(A, B) <span class=\"keyword\">or</span> self.isSubStructure(A.left, B) <span class=\"keyword\">or</span> self.isSubStructure(A.right, B))</span><br></pre></td></tr></table></figure>\n<h3 id=\"27-二叉树的镜像\"><a href=\"#27-二叉树的镜像\" class=\"headerlink\" title=\"27.二叉树的镜像\"></a>27.二叉树的镜像</h3><h4 id=\"AcWing传送门-9\"><a href=\"#AcWing传送门-9\" class=\"headerlink\" title=\"AcWing传送门\"></a><a href=\"https://www.acwing.com/problem/content/37/\" target=\"_blank\" rel=\"noopener\">AcWing传送门</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">Mirror</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> root:</span><br><span class=\"line\">        root.left, root.right = root.right, root.left</span><br><span class=\"line\">        self.Mirror(root.left)</span><br><span class=\"line\">        self.Mirror(root.right)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> root</span><br></pre></td></tr></table></figure>\n<p>迭代</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">Mirror</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">    stack = root <span class=\"keyword\">and</span> [root]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> stack:</span><br><span class=\"line\">        n = stack.pop()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n:</span><br><span class=\"line\">            n.left, n.right = n.right, n.left</span><br><span class=\"line\">            stack += n.right, n.left</span><br></pre></td></tr></table></figure>\n<h3 id=\"28-对称的二叉树\"><a href=\"#28-对称的二叉树\" class=\"headerlink\" title=\"28.对称的二叉树\"></a>28.对称的二叉树</h3><h4 id=\"LeetCode传送门-14\"><a href=\"#LeetCode传送门-14\" class=\"headerlink\" title=\"LeetCode传送门\"></a><a href=\"https://leetcode.com/problems/symmetric-tree/description/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">    1</span><br><span class=\"line\">   &#x2F; \\</span><br><span class=\"line\">  2   2</span><br><span class=\"line\"> &#x2F; \\ &#x2F; \\</span><br><span class=\"line\">3  4 4  3</span><br></pre></td></tr></table></figure>\n<p>方法一：recursively.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isSymmetric</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">symmetric</span><span class=\"params\">(p1, p2)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> p1 <span class=\"keyword\">and</span> p2:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (p1.val == p2.val <span class=\"keyword\">and</span> symmetric(p1.left, p2.right) <span class=\"keyword\">and</span> </span><br><span class=\"line\">                    symmetric(p1.right, p2.left))</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> p1 <span class=\"keyword\">is</span> p2</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> symmetric(root.left, root.right)</span><br></pre></td></tr></table></figure>\n<p>方法二：iteratively.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isSymmetric</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\">    stack = root <span class=\"keyword\">and</span> [(root.left, root.right)]        </span><br><span class=\"line\">    <span class=\"keyword\">while</span> stack:</span><br><span class=\"line\">        p1, p2 = stack.pop()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> p1 <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> p2: <span class=\"keyword\">continue</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> p1 <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> p2: <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> p1.val != p2.val: <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        stack.append((p1.left, p2.right))</span><br><span class=\"line\">        stack.append((p1.right, p2.left))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"29-顺时针打印矩阵\"><a href=\"#29-顺时针打印矩阵\" class=\"headerlink\" title=\"29.顺时针打印矩阵\"></a>29.顺时针打印矩阵</h3><h4 id=\"LeetCode传送门-15\"><a href=\"#LeetCode传送门-15\" class=\"headerlink\" title=\"LeetCode传送门\"></a><a href=\"https://leetcode.com/problems/spiral-matrix/description/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><p>这里注意一点<code>matrix.pop(0)</code>需要转成list，因为zip函数中的每个元素是一个tuple，如果不转变成了一个<code>tuple+list</code>，会抛出异常。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">spiralOrder</span><span class=\"params\">(self, matrix)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (matrix <span class=\"keyword\">and</span> list(matrix.pop(<span class=\"number\">0</span>)) + </span><br><span class=\"line\">            self.spiralOrder(list(zip(*matrix))[::<span class=\"number\">-1</span>]))</span><br></pre></td></tr></table></figure>\n<p>方法二：迭代。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">spiralOrder</span><span class=\"params\">(self, matrix: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> matrix: <span class=\"keyword\">return</span> []</span><br><span class=\"line\">    M, N = len(matrix), len(matrix[<span class=\"number\">0</span>])</span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    seen = [[<span class=\"literal\">False</span>]*N <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(M)]</span><br><span class=\"line\">    x, y, di, dj = <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> len(ans) &lt; M*N:</span><br><span class=\"line\">        seen[x][y] = <span class=\"literal\">True</span></span><br><span class=\"line\">        ans.append(matrix[x][y])        </span><br><span class=\"line\">        nx, ny = x+di, y+dj</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> (<span class=\"number\">0</span>&lt;=nx&lt;M <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=ny&lt;N <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> seen[nx][ny]):</span><br><span class=\"line\">            di, dj = dj, -di</span><br><span class=\"line\">        x, y = x+di, y+dj</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>此题有个变形，如果逆时针该如何打印。这样的话情况稍微复杂一些。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">anti_clock_wise</span><span class=\"params\">(self, matrix)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">if</span> <span class=\"title\">not</span> <span class=\"title\">matrix</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> []</span><br><span class=\"line\">    clock_wise = list(zip(*(matrix[::<span class=\"number\">-1</span>])))</span><br><span class=\"line\">    a = list(clock_wise.pop(<span class=\"number\">0</span>))[::<span class=\"number\">-1</span>]</span><br><span class=\"line\">    b = self.anti_clock_wise(clock_wise)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b</span><br></pre></td></tr></table></figure>\n<h3 id=\"30-包含min函数的栈\"><a href=\"#30-包含min函数的栈\" class=\"headerlink\" title=\"30.包含min函数的栈\"></a>30.包含min函数的栈</h3><h4 id=\"LeetCode传送门-16\"><a href=\"#LeetCode传送门-16\" class=\"headerlink\" title=\"LeetCode传送门\"></a><a href=\"https://leetcode.com/problems/min-stack/description/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MinStack</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self._stack = []</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">push</span><span class=\"params\">(self, x: int)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        cur_min = self.getMin()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> x &lt; cur_min:</span><br><span class=\"line\">            cur_min = x</span><br><span class=\"line\">        self._stack.append((x, cur_min))</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pop</span><span class=\"params\">(self)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        self._stack.pop()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">top</span><span class=\"params\">(self)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self._stack:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self._stack[<span class=\"number\">-1</span>][<span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getMin</span><span class=\"params\">(self)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self._stack:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> float(<span class=\"string\">'inf'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self._stack[<span class=\"number\">-1</span>][<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"31-栈的压入、弹出序列\"><a href=\"#31-栈的压入、弹出序列\" class=\"headerlink\" title=\"31.栈的压入、弹出序列\"></a>31.栈的压入、弹出序列</h3><h4 id=\"LeetCode传送门-17\"><a href=\"#LeetCode传送门-17\" class=\"headerlink\" title=\"LeetCode传送门\"></a><a href=\"https://leetcode.com/problems/validate-stack-sequences/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">validateStackSequences</span><span class=\"params\">(self, pushed: <span class=\"string\">'List[int]'</span>, popped: <span class=\"string\">'List[int]'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\">    stack = []</span><br><span class=\"line\">    j = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> pushed:</span><br><span class=\"line\">        stack.append(num)</span><br><span class=\"line\">        <span class=\"keyword\">while</span> stack <span class=\"keyword\">and</span> stack[<span class=\"number\">-1</span>] == popped[j]:</span><br><span class=\"line\">            stack.pop()</span><br><span class=\"line\">            j += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> j == len(popped)</span><br></pre></td></tr></table></figure>\n<h3 id=\"32-从上到下打印二叉树\"><a href=\"#32-从上到下打印二叉树\" class=\"headerlink\" title=\"32.从上到下打印二叉树\"></a>32.从上到下打印二叉树</h3><h4 id=\"AcWing传送门-10\"><a href=\"#AcWing传送门-10\" class=\"headerlink\" title=\"AcWing传送门\"></a><a href=\"https://www.acwing.com/problem/content/41/\" target=\"_blank\" rel=\"noopener\">AcWing传送门</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">levelOrder</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class=\"line\">    ans, q = [], [root]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> node <span class=\"keyword\">in</span> q:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            ans.append(node.val)</span><br><span class=\"line\">            q.append(node.left)</span><br><span class=\"line\">            q.append(node.right)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"32-1分层从上到下打印二叉树\"><a href=\"#32-1分层从上到下打印二叉树\" class=\"headerlink\" title=\"32.1分层从上到下打印二叉树\"></a>32.1分层从上到下打印二叉树</h3><h4 id=\"LeetCode传送门-18\"><a href=\"#LeetCode传送门-18\" class=\"headerlink\" title=\"LeetCode传送门\"></a><a href=\"https://leetcode.com/problems/binary-tree-level-order-traversal/description/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">levelOrder</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'List[List[int]]':</span></span><br><span class=\"line\">    ans, level = [], root <span class=\"keyword\">and</span> [root]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> level:</span><br><span class=\"line\">        ans.append([n.val <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> level])</span><br><span class=\"line\">        level = [k <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> level <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> (n.left, n.right) <span class=\"keyword\">if</span> k]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"32-2之字形打印二叉树\"><a href=\"#32-2之字形打印二叉树\" class=\"headerlink\" title=\"32.2之字形打印二叉树\"></a>32.2之字形打印二叉树</h3><h4 id=\"LeetCode传送门-19\"><a href=\"#LeetCode传送门-19\" class=\"headerlink\" title=\"LeetCode传送门\"></a><a href=\"https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">zigzagLevelOrder</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'List[List[int]]':</span></span><br><span class=\"line\">    ans, level, order = [], root <span class=\"keyword\">and</span> [root], <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> level:</span><br><span class=\"line\">        ans.append([n.val <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> level][::order])</span><br><span class=\"line\">        order *= <span class=\"number\">-1</span></span><br><span class=\"line\">        level = [kid <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> level <span class=\"keyword\">for</span> kid <span class=\"keyword\">in</span> (n.left, n.right) <span class=\"keyword\">if</span> kid]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"33-是否是二叉树的后序遍历\"><a href=\"#33-是否是二叉树的后序遍历\" class=\"headerlink\" title=\"33.是否是二叉树的后序遍历\"></a>33.是否是二叉树的后序遍历</h3><h4 id=\"AcWing传送门-11\"><a href=\"#AcWing传送门-11\" class=\"headerlink\" title=\"AcWing传送门\"></a><a href=\"https://www.acwing.com/problem/content/44/\" target=\"_blank\" rel=\"noopener\">AcWing传送门</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">VerifySquenceOfBST</span><span class=\"params\">(self, seq)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> itertools <span class=\"keyword\">import</span> takewhile</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> seq:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    p = seq[<span class=\"number\">-1</span>]</span><br><span class=\"line\">    left_sub = list(takewhile(<span class=\"keyword\">lambda</span> x: x &lt; p, seq[:<span class=\"number\">-1</span>]))</span><br><span class=\"line\">    right_sub = seq[len(left_sub):<span class=\"number\">-1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> all(x&gt;p <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> right_sub):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    left = right = <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> left_sub:</span><br><span class=\"line\">        left = self.VerifySquenceOfBST(left_sub)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> right_sub:</span><br><span class=\"line\">        right = self.VerifySquenceOfBST(right_sub)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> left <span class=\"keyword\">and</span> right</span><br></pre></td></tr></table></figure>\n<h3 id=\"34-二叉树和为某一值的路径\"><a href=\"#34-二叉树和为某一值的路径\" class=\"headerlink\" title=\"34.二叉树和为某一值的路径\"></a>34.二叉树和为某一值的路径</h3><h4 id=\"LeetCode传送门-20\"><a href=\"#LeetCode传送门-20\" class=\"headerlink\" title=\"LeetCode传送门\"></a><a href=\"https://leetcode.com/problems/path-sum-ii/description/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sum &#x3D; 22</span><br><span class=\"line\"></span><br><span class=\"line\">      5</span><br><span class=\"line\">     &#x2F; \\</span><br><span class=\"line\">    4   8</span><br><span class=\"line\">   &#x2F;   &#x2F; \\</span><br><span class=\"line\">  11  13  4</span><br><span class=\"line\"> &#x2F;  \\    &#x2F; \\</span><br><span class=\"line\">7    2  5   1</span><br><span class=\"line\">[</span><br><span class=\"line\">   [5,4,11,2],</span><br><span class=\"line\">   [5,8,4,5]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法一：iteratively. 举一反三。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pathSum</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>, total: <span class=\"string\">'int'</span>)</span> -&gt; 'List[List[int]]':</span></span><br><span class=\"line\">    stack = root <span class=\"keyword\">and</span> [(root, [root.val], total)]</span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> stack:</span><br><span class=\"line\">        n, v, t = stack.pop()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> n.left <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> n.right <span class=\"keyword\">and</span> n.val==t:</span><br><span class=\"line\">            ans.append(v)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n.right:</span><br><span class=\"line\">            stack.append((n.right, v+[n.right.val], t-n.val))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n.left:</span><br><span class=\"line\">            stack.append((n.left, v+[n.left.val], t-n.val))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>recursively. 先找出所有路径，再过滤，实际上和257题一样。不过这并没有把这道题的特性涵盖进去。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pathSum</span><span class=\"params\">(self, root, sum_val)</span>:</span></span><br><span class=\"line\">    paths = self.all_paths(root)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [path <span class=\"keyword\">for</span> path <span class=\"keyword\">in</span> paths <span class=\"keyword\">if</span> sum(path)==sum_val]</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">all_paths</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> []</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[root.val]+path</span><br><span class=\"line\">            <span class=\"keyword\">for</span> kid <span class=\"keyword\">in</span> (root.left, root.right) <span class=\"keyword\">if</span> kid</span><br><span class=\"line\">            <span class=\"keyword\">for</span> path <span class=\"keyword\">in</span> self.all_paths(kid)] <span class=\"keyword\">or</span> [[root.val]]</span><br></pre></td></tr></table></figure>\n<p>方法二：模板写法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pathSum</span><span class=\"params\">(self, root: TreeNode, total: int)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(node, s, p)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            p.append(node.val)</span><br><span class=\"line\">            s -= node.val</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node.left <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> node.right <span class=\"keyword\">and</span> s==<span class=\"number\">0</span>:</span><br><span class=\"line\">                ans.append(p[:])</span><br><span class=\"line\">            dfs(node.left, s, p)</span><br><span class=\"line\">            dfs(node.right, s, p)</span><br><span class=\"line\">            p.pop()</span><br><span class=\"line\"></span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    dfs(root, total, [])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：recursively. </font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pathSum</span><span class=\"params\">(self, root, sum)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> []</span><br><span class=\"line\">    val, *kids = root.val, root.left, root.right</span><br><span class=\"line\">    <span class=\"keyword\">if</span> any(kids):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [[val] + path</span><br><span class=\"line\">                <span class=\"keyword\">for</span> kid <span class=\"keyword\">in</span> kids <span class=\"keyword\">if</span> kid</span><br><span class=\"line\">                <span class=\"keyword\">for</span> path <span class=\"keyword\">in</span> self.pathSum(kid, sum-val)]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[val]] <span class=\"keyword\">if</span> val==sum <span class=\"keyword\">else</span> []</span><br></pre></td></tr></table></figure>\n<h3 id=\"35-复杂链表的复制\"><a href=\"#35-复杂链表的复制\" class=\"headerlink\" title=\"35.复杂链表的复制\"></a>35.复杂链表的复制</h3><h4 id=\"LeetCode传送门-21\"><a href=\"#LeetCode传送门-21\" class=\"headerlink\" title=\"LeetCode传送门\"></a><a href=\"https://leetcode.com/problems/copy-list-with-random-pointer/description/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><p>方法一：遍历两次。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">copyRandomList</span><span class=\"params\">(self, head: <span class=\"string\">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class=\"line\">    cp = &#123;<span class=\"literal\">None</span>: <span class=\"literal\">None</span>&#125;</span><br><span class=\"line\">    m = n = head</span><br><span class=\"line\">    <span class=\"keyword\">while</span> m:</span><br><span class=\"line\">        cp[m] = Node(m.val, <span class=\"literal\">None</span>, <span class=\"literal\">None</span>)</span><br><span class=\"line\">        m = m.next</span><br><span class=\"line\">    <span class=\"keyword\">while</span> n:</span><br><span class=\"line\">        cp[n].next = cp[n.next]</span><br><span class=\"line\">        cp[n].random = cp[n.random]</span><br><span class=\"line\">        n = n.next</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cp[head]</span><br></pre></td></tr></table></figure>\n<p>Time-O(n), Memory-O(n). 这种方式是相当于把第一次迭代的过程委托给了<code>defaultdict</code>，通过创建一个默认的对象，再去修改它的label值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">copyRandomList</span><span class=\"params\">(self, head: <span class=\"string\">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class=\"line\">    cp = collections.defaultdict(<span class=\"keyword\">lambda</span>: Node(<span class=\"number\">0</span>, <span class=\"literal\">None</span>, <span class=\"literal\">None</span>))</span><br><span class=\"line\">    cp[<span class=\"literal\">None</span>] = <span class=\"literal\">None</span></span><br><span class=\"line\">    h = head</span><br><span class=\"line\">    <span class=\"keyword\">while</span> h:</span><br><span class=\"line\">        cp[h].val = h.val</span><br><span class=\"line\">        cp[h].next = cp[h.next]</span><br><span class=\"line\">        cp[h].random = cp[h.random]</span><br><span class=\"line\">        h = h.next</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cp[head]</span><br></pre></td></tr></table></figure>\n<h3 id=\"36-二叉搜索树与双向链表\"><a href=\"#36-二叉搜索树与双向链表\" class=\"headerlink\" title=\"36.二叉搜索树与双向链表\"></a>36.二叉搜索树与双向链表</h3><h4 id=\"LeetCode有此题，但是不是免费的。\"><a href=\"#LeetCode有此题，但是不是免费的。\" class=\"headerlink\" title=\"LeetCode有此题，但是不是免费的。\"></a>LeetCode有此题，但是不是免费的。</h4><h4 id=\"AcWing传送门-12\"><a href=\"#AcWing传送门-12\" class=\"headerlink\" title=\"AcWing传送门\"></a><a href=\"https://www.acwing.com/problem/content/87/\" target=\"_blank\" rel=\"noopener\">AcWing传送门</a></h4><font color=\"#32CD32\" size=\"3\">方法一：中序遍历，再构造链表。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">convert</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> itertools <span class=\"keyword\">import</span> tee</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> dfs(node.left)</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> node</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> dfs(node.right)</span><br><span class=\"line\"></span><br><span class=\"line\">    a, b = tee(dfs(root))</span><br><span class=\"line\">    ans = next(b, <span class=\"literal\">None</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> f, s <span class=\"keyword\">in</span> zip(a, b):</span><br><span class=\"line\">        f.right = s</span><br><span class=\"line\">        s.left = f</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：分别递归处理左子树和右子树。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">Convert</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">convert_tree</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">None</span>  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.left:</span><br><span class=\"line\">            left = convert_tree(node.left)</span><br><span class=\"line\">            <span class=\"keyword\">while</span> left.right:</span><br><span class=\"line\">                left = left.right</span><br><span class=\"line\">            left.right = node</span><br><span class=\"line\">            node.left = left</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.right:</span><br><span class=\"line\">            right = convert_tree(node.right)</span><br><span class=\"line\">            <span class=\"keyword\">while</span> right.left:</span><br><span class=\"line\">                right = right.left</span><br><span class=\"line\">            right.left = node</span><br><span class=\"line\">            node.right = right</span><br><span class=\"line\">        <span class=\"keyword\">return</span> node</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root</span><br><span class=\"line\">    root = convert_tree(root)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> root.left:</span><br><span class=\"line\">        root = root.left</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：Morris Traversal.</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">Convert</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">    cur = root</span><br><span class=\"line\">    pre = ans = <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> cur:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> cur.left:</span><br><span class=\"line\">            q = cur.left</span><br><span class=\"line\">            <span class=\"keyword\">while</span> q.right:</span><br><span class=\"line\">                q = q.right</span><br><span class=\"line\">            q.right = cur                   <span class=\"comment\"># 补齐右指针</span></span><br><span class=\"line\">            cur.left, cur = <span class=\"literal\">None</span>, cur.left  <span class=\"comment\"># 拆掉左指针</span></span><br><span class=\"line\">        cur.left = pre</span><br><span class=\"line\">        <span class=\"keyword\">if</span> pre <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            ans = cur   <span class=\"comment\"># 这里是为了找到链表的头，只执行一次</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            pre.right = cur</span><br><span class=\"line\">        pre, cur = cur, cur.right</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"37-序列化二叉树\"><a href=\"#37-序列化二叉树\" class=\"headerlink\" title=\"37.序列化二叉树\"></a>37.序列化二叉树</h3><h4 id=\"LeetCode传送门-22\"><a href=\"#LeetCode传送门-22\" class=\"headerlink\" title=\"LeetCode传送门\"></a><a href=\"https://leetcode.com/problems/serialize-and-deserialize-binary-tree/description/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Codec</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">serialize</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">'$'</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> str(root.val) + <span class=\"string\">','</span> + self.serialize(root.left) + <span class=\"string\">','</span> + self.serialize(root.right)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">deserialize</span><span class=\"params\">(self, data)</span>:</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">deserialize_tree</span><span class=\"params\">(nodes)</span>:</span></span><br><span class=\"line\">            val = next(nodes)\t\t<span class=\"comment\"># 这里不会报错的原因是，序列化后必然以`$`结尾的，所以不会出现耗尽的情况</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> val == <span class=\"string\">'$'</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">            root = TreeNode(val)</span><br><span class=\"line\">            root.left = deserialize_tree(nodes)</span><br><span class=\"line\">            root.right = deserialize_tree(nodes)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root     </span><br><span class=\"line\">        nodes = iter(data.split(<span class=\"string\">','</span>))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> deserialize_tree(nodes)</span><br></pre></td></tr></table></figure>\n<h3 id=\"38-字符串的排列\"><a href=\"#38-字符串的排列\" class=\"headerlink\" title=\"38.字符串的排列\"></a>38.字符串的排列</h3><a href=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%95%B0%E7%BB%84%E7%AF%87%EF%BC%89Array/\" title=\"46. Permutations II\">46. Permutations II</a>\n<h4 id=\"LeetCode传送门-23\"><a href=\"#LeetCode传送门-23\" class=\"headerlink\" title=\"LeetCode传送门\"></a><a href=\"https://leetcode.com/problems/permutations-ii/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><p>使用itertools</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">Permutation</span><span class=\"params\">(self, ss)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># write code here</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> itertools <span class=\"keyword\">import</span> permutations</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> ss:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> []</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sorted(list(set([<span class=\"string\">''</span>.join(x) <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> permutations(ss)])))</span><br></pre></td></tr></table></figure>\n<p>这里注意几点：</p>\n<ul>\n<li><p>为什么要判断<code>if not ss</code>，是因为如果<code>ss=&#39;&#39;</code>的时时候，返回了<code>[&#39;&#39;]</code>而不是<code>[]</code>。因为这里返回了一个空的<code>tuple</code>，所以在列表推导式中是有一个元素的。</p>\n <figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt; list(permutations(<span class=\"string\">''</span>, 0))</span></span><br><span class=\"line\">[()]</span><br></pre></td></tr></table></figure></li>\n<li>为什么使用<code>set</code>去重，因为当<code>ss=&#39;aa&#39;</code>的时候，牛客网的测试用例要求返回一个元素，即<code>[&#39;aa&#39;]</code>。</li>\n<li>排序也是为了满足测试用例。</li>\n</ul>\n<p>自己实现。这里拆成两个方法的原因还是因为<code>ss=&#39;&#39;</code>的时候会影响递归循环。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">Permutation</span><span class=\"params\">(self, ss)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> ss:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> []</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.permute(ss)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">permute</span><span class=\"params\">(self, ss)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sorted(list(set([h + p</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, h <span class=\"keyword\">in</span> enumerate(ss)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> self.permute(ss[:i]+ss[i+<span class=\"number\">1</span>:])</span><br><span class=\"line\">    ]))) <span class=\"keyword\">or</span> [<span class=\"string\">\"\"</span>]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：迭代。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">Permutation</span><span class=\"params\">(self, ss)</span>:</span></span><br><span class=\"line\">    ans = [<span class=\"string\">''</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> ss:</span><br><span class=\"line\">        ans = [p[:i] + s + p[i:]</span><br><span class=\"line\">               <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> ans <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range((p+s).index(s)+<span class=\"number\">1</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sorted(ans) <span class=\"keyword\">if</span> ss <span class=\"keyword\">else</span> []</span><br></pre></td></tr></table></figure>\n<h3 id=\"39-数组中出现次数超过一半的数字\"><a href=\"#39-数组中出现次数超过一半的数字\" class=\"headerlink\" title=\"39.数组中出现次数超过一半的数字\"></a>39.数组中出现次数超过一半的数字</h3><h4 id=\"LeetCode传送门-24\"><a href=\"#LeetCode传送门-24\" class=\"headerlink\" title=\"LeetCode传送门\"></a><a href=\"https://leetcode.com/problems/majority-element/description/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><p>方法一：排序. Time-O(nlogn), Space-O(n)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">majority_element</span><span class=\"params\">(nums)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sorted(nums)[len(nums)//<span class=\"number\">2</span>]</span><br></pre></td></tr></table></figure>\n<p>方法二：Counter Time-O(n), Space-O(n)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">majority_element</span><span class=\"params\">(nums)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Counter</span><br><span class=\"line\">    c = Counter(nums)</span><br><span class=\"line\">    <span class=\"comment\"># return max(c.keys(), key=c.get)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> c.most_common(<span class=\"number\">1</span>)[<span class=\"number\">0</span>][<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：Boyer-Moore Voting Algorithm. 书中的算法说的就是这个，这详情请看<a href=\"https://darktiantian.github.io/%E6%B3%A2%E4%B9%89%E5%B0%94%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95%EF%BC%88Boyer-Moore-Voting-Algorithm%EF%BC%89/\" target=\"_blank\" rel=\"noopener\">波义尔摩尔投票</a>。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">majorityElement</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">    count = <span class=\"number\">0</span></span><br><span class=\"line\">    candidate = <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> count == <span class=\"number\">0</span>:</span><br><span class=\"line\">            candidate = num</span><br><span class=\"line\">        count += (<span class=\"number\">1</span> <span class=\"keyword\">if</span> num == candidate <span class=\"keyword\">else</span> <span class=\"number\">-1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> candidate</span><br></pre></td></tr></table></figure>\n<h3 id=\"40-最小的k个数\"><a href=\"#40-最小的k个数\" class=\"headerlink\" title=\"40.最小的k个数\"></a>40.最小的k个数</h3><h4 id=\"相似题目，但是求最大的k个数LeetCode传送门\"><a href=\"#相似题目，但是求最大的k个数LeetCode传送门\" class=\"headerlink\" title=\"相似题目，但是求最大的k个数LeetCode传送门\"></a>相似题目，但是求最大的k个数<a href=\"https://leetcode.com/problems/kth-largest-element-in-an-array/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><h4 id=\"牛客网传送门-4\"><a href=\"#牛客网传送门-4\" class=\"headerlink\" title=\"牛客网传送门\"></a><a href=\"https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&amp;tqId=11182&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&amp;tPage=2\" target=\"_blank\" rel=\"noopener\">牛客网传送门</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">GetLeastNumbers_Solution</span><span class=\"params\">(self, tinput, k)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># write code here</span></span><br><span class=\"line\">    l, r = <span class=\"number\">0</span>, len(tinput)<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> k &gt; len(tinput) <span class=\"keyword\">or</span> k &lt; <span class=\"number\">1</span>: <span class=\"keyword\">return</span> [] <span class=\"comment\"># for passing the damn testcase</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">        pos = self.partition(tinput, l, r)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> pos &lt; k<span class=\"number\">-1</span>:</span><br><span class=\"line\">            l = pos + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> pos &gt; k<span class=\"number\">-1</span>:</span><br><span class=\"line\">            r = pos - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> sorted(tinput[:pos+<span class=\"number\">1</span>])  <span class=\"comment\"># sorted for passing the damn testcase</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">partition</span><span class=\"params\">(self, nums, l, r)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> random <span class=\"keyword\">import</span> randint</span><br><span class=\"line\">    p = randint(l, r)</span><br><span class=\"line\">    nums[r], nums[p] = nums[p], nums[r]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, v <span class=\"keyword\">in</span> enumerate(nums[l:r+<span class=\"number\">1</span>], l):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[i] &lt;= nums[r]:</span><br><span class=\"line\">            nums[l], nums[i] = nums[i], nums[l]</span><br><span class=\"line\">            l += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> l<span class=\"number\">-1</span>  <span class=\"comment\"># the pivot index</span></span><br></pre></td></tr></table></figure>\n<p>使用堆，不改变原数组</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">GetLeastNumbers_Solution</span><span class=\"params\">(self, tinput, k)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">import</span> heapq <span class=\"keyword\">as</span> hq</span><br><span class=\"line\">    <span class=\"keyword\">if</span> k &gt; len(tinput) <span class=\"keyword\">or</span> k &lt;= <span class=\"number\">0</span>: <span class=\"keyword\">return</span> []</span><br><span class=\"line\">    heap = [-x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> tinput[:k]]</span><br><span class=\"line\">    hq.heapify(heap)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> tinput[k:]:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> -heap[<span class=\"number\">0</span>] &gt; num:</span><br><span class=\"line\">            hq.heapreplace(heap, -num)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sorted(-x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> heap)</span><br></pre></td></tr></table></figure>\n<h3 id=\"41-数据流中的中位数\"><a href=\"#41-数据流中的中位数\" class=\"headerlink\" title=\"41.数据流中的中位数\"></a>41.数据流中的中位数</h3><h4 id=\"LeetCode传送门-25\"><a href=\"#LeetCode传送门-25\" class=\"headerlink\" title=\"LeetCode传送门\"></a><a href=\"https://leetcode.com/problems/find-median-from-data-stream/description/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><p>思路：使用两个堆，最大堆存储较小的数据，最小堆存储较大的数据。添加数字时，先添加到最大堆，然后最大堆返回一个最大的数字给最小堆，最后为了平衡，可能需要最小堆还给最大堆一个最小值，以保证最大堆的长度&gt;=最小堆的长度。由于headpq是最小堆，所以使用取反实现最大堆。添加数字：Time-O(logn)，取出中位数：Time-O(1)。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">Adding number <span class=\"number\">41</span></span><br><span class=\"line\">MaxHeap lo: [<span class=\"number\">41</span>]           // MaxHeap stores the largest value at the top (index <span class=\"number\">0</span>)</span><br><span class=\"line\">MinHeap hi: []             // MinHeap stores the smallest value at the top (index <span class=\"number\">0</span>)</span><br><span class=\"line\">Median <span class=\"keyword\">is</span> <span class=\"number\">41</span></span><br><span class=\"line\">=======================</span><br><span class=\"line\">Adding number <span class=\"number\">35</span></span><br><span class=\"line\">MaxHeap lo: [<span class=\"number\">35</span>]</span><br><span class=\"line\">MinHeap hi: [<span class=\"number\">41</span>]</span><br><span class=\"line\">Median <span class=\"keyword\">is</span> <span class=\"number\">38</span></span><br><span class=\"line\">=======================</span><br><span class=\"line\">Adding number <span class=\"number\">62</span></span><br><span class=\"line\">MaxHeap lo: [<span class=\"number\">41</span>, <span class=\"number\">35</span>]</span><br><span class=\"line\">MinHeap hi: [<span class=\"number\">62</span>]</span><br><span class=\"line\">Median <span class=\"keyword\">is</span> <span class=\"number\">41</span></span><br><span class=\"line\">=======================</span><br><span class=\"line\">Adding number <span class=\"number\">4</span></span><br><span class=\"line\">MaxHeap lo: [<span class=\"number\">35</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\">MinHeap hi: [<span class=\"number\">41</span>, <span class=\"number\">62</span>]</span><br><span class=\"line\">Median <span class=\"keyword\">is</span> <span class=\"number\">38</span></span><br><span class=\"line\">=======================</span><br><span class=\"line\">Adding number <span class=\"number\">97</span></span><br><span class=\"line\">MaxHeap lo: [<span class=\"number\">41</span>, <span class=\"number\">35</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\">MinHeap hi: [<span class=\"number\">62</span>, <span class=\"number\">97</span>]</span><br><span class=\"line\">Median <span class=\"keyword\">is</span> <span class=\"number\">41</span></span><br><span class=\"line\">=======================</span><br><span class=\"line\">Adding number <span class=\"number\">108</span></span><br><span class=\"line\">MaxHeap lo: [<span class=\"number\">41</span>, <span class=\"number\">35</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\">MinHeap hi: [<span class=\"number\">62</span>, <span class=\"number\">97</span>, <span class=\"number\">108</span>]</span><br><span class=\"line\">Median <span class=\"keyword\">is</span> <span class=\"number\">51.5</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> heapq <span class=\"keyword\">as</span> hq</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MedianFinder</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.lo, self.hi = [], []  <span class=\"comment\"># lo is max_heap, hi is min_heap</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addNum</span><span class=\"params\">(self, num)</span>:</span></span><br><span class=\"line\">        hq.heappush(self.lo, -num)</span><br><span class=\"line\">        hq.heappush(self.hi, -hq.heappop(self.lo))</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(self.lo) &lt; len(self.hi):</span><br><span class=\"line\">            hq.heappush(self.lo, -hq.heappop(self.hi))       </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findMedian</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(self.lo) == len(self.hi):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (-self.lo[<span class=\"number\">0</span>]+self.hi[<span class=\"number\">0</span>]) / <span class=\"number\">2.0</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> float(-self.lo[<span class=\"number\">0</span>])</span><br></pre></td></tr></table></figure>\n<h3 id=\"42-连续子数组的最大和\"><a href=\"#42-连续子数组的最大和\" class=\"headerlink\" title=\"42.连续子数组的最大和\"></a>42.连续子数组的最大和</h3><h4 id=\"LeetCode传送门-26\"><a href=\"#LeetCode传送门-26\" class=\"headerlink\" title=\"LeetCode传送门\"></a><a href=\"https://leetcode.com/problems/maximum-subarray/description/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><p>方法一：书中的思想。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxSubArray</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">    cp_nums = nums[:]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(nums)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cp_nums[i<span class=\"number\">-1</span>] &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            cp_nums[i] += cp_nums[i<span class=\"number\">-1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(cp_nums)</span><br></pre></td></tr></table></figure>\n<p>方法二：one-liner。注意<code>accumulate</code>是把函数放到后面的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxSubArray</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> itertools <span class=\"keyword\">import</span> accumulate</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(accumulate(nums, <span class=\"keyword\">lambda</span> x, y: x+y <span class=\"keyword\">if</span> x &gt; <span class=\"number\">0</span> <span class=\"keyword\">else</span> y))</span><br></pre></td></tr></table></figure>\n<h3 id=\"43-1-n整数中1出现的次数\"><a href=\"#43-1-n整数中1出现的次数\" class=\"headerlink\" title=\"43.1~n整数中1出现的次数\"></a>43.1~n整数中1出现的次数</h3><h4 id=\"LeetCode传送门-27\"><a href=\"#LeetCode传送门-27\" class=\"headerlink\" title=\"LeetCode传送门\"></a><a href=\"https://leetcode.com/problems/number-of-digit-one/description/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countDigitOne</span><span class=\"params\">(self, n)</span>:</span>    </span><br><span class=\"line\">    countr, i = <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> i &lt;= n:</span><br><span class=\"line\">        divider = i * <span class=\"number\">10</span></span><br><span class=\"line\">        countr += (n // divider) * i + min(max(n % divider - i + <span class=\"number\">1</span>, <span class=\"number\">0</span>), i)</span><br><span class=\"line\">        i *= <span class=\"number\">10</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> countr</span><br></pre></td></tr></table></figure>\n<p>分三种情况讨论比较清晰。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countDigitOne</span><span class=\"params\">(self, n: int)</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"comment\"># xyz b abc</span></span><br><span class=\"line\">    <span class=\"comment\"># (1) xyz * 1000                     if d == 0</span></span><br><span class=\"line\">    <span class=\"comment\"># (2) xyz * 1000 + abc + 1           if d == 1</span></span><br><span class=\"line\">    <span class=\"comment\"># (3) xyz * 1000 + 1000              if d &gt; 1</span></span><br><span class=\"line\">    q, ans, f = n, <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> q &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">        q, cur = divmod(q, <span class=\"number\">10</span>)</span><br><span class=\"line\">        ans += q * f</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cur == <span class=\"number\">1</span>:</span><br><span class=\"line\">            ans += n % f + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> cur &gt; <span class=\"number\">1</span>:</span><br><span class=\"line\">            ans += f</span><br><span class=\"line\">        f *= <span class=\"number\">10</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"45-把数组排成最小的数字\"><a href=\"#45-把数组排成最小的数字\" class=\"headerlink\" title=\"45.把数组排成最小的数字\"></a>45.把数组排成最小的数字</h3><h4 id=\"AcWing传送门-13\"><a href=\"#AcWing传送门-13\" class=\"headerlink\" title=\"AcWing传送门\"></a><a href=\"https://www.acwing.com/problem/content/54/\" target=\"_blank\" rel=\"noopener\">AcWing传送门</a></h4><p>python2的写法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">PrintMinNumber</span><span class=\"params\">(self, numbers)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(sorted(map(str, numbers), </span><br><span class=\"line\">                          <span class=\"keyword\">lambda</span> x, y: cmp(x+y, y+x)))</span><br></pre></td></tr></table></figure>\n<p>匿名函数作为sort的参数，在python2中有这个参数。</p>\n<blockquote>\n<p>cmp specifies a custom comparison function of two arguments (iterable elements) which should return a negative, zero or positive number depending on whether the first argument is considered smaller than, equal to, or larger than the second argument: cmp=lambda x,y: cmp(x.lower(), y.lower()). The default value is None.</p>\n</blockquote>\n<p>作为sort的参数，cmp提供了一个自定义的比较两个元素的方法，如果返回-1表示前者小于后者。python3中取消了这个参数，但是提供了一种key的转换。而内置函数可以通过运算符实现。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">cmp(a, b)</span><br></pre></td></tr></table></figure>\n<p>等同于</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">(a&gt;b) - (a&lt;b)</span><br></pre></td></tr></table></figure>\n<p>所以python3的写法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> functools <span class=\"keyword\">import</span> cmp_to_key</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">PrintMinNumber</span><span class=\"params\">(self, numbers)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># write code here</span></span><br><span class=\"line\">    nums = list(map(str, numbers))</span><br><span class=\"line\">    nums.sort(key=cmp_to_key(<span class=\"keyword\">lambda</span> x, y: ((x+y)&gt;(y+x)) - ((y+x)&gt;(x+y))))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(nums)</span><br></pre></td></tr></table></figure>\n<h3 id=\"46-把数字翻译成字符串\"><a href=\"#46-把数字翻译成字符串\" class=\"headerlink\" title=\"46 把数字翻译成字符串\"></a>46 把数字翻译成字符串</h3><h4 id=\"LeetCode传送门-28\"><a href=\"#LeetCode传送门-28\" class=\"headerlink\" title=\"LeetCode传送门\"></a><a href=\"https://leetcode.com/problems/decode-ways/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numDecodings</span><span class=\"params\">(self, s: str)</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"comment\"># w tells the number of ways</span></span><br><span class=\"line\">    <span class=\"comment\"># v tells the previous number of ways</span></span><br><span class=\"line\">    <span class=\"comment\"># d is the current digit</span></span><br><span class=\"line\">    <span class=\"comment\"># p is the previous digit</span></span><br><span class=\"line\">    v, w, p = <span class=\"number\">0</span>, int(s&gt;<span class=\"string\">''</span>), <span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">        v, w, p = w, int(d&gt;<span class=\"string\">'0'</span>)*w + (<span class=\"number\">9</span>&lt;int(p+d)&lt;<span class=\"number\">27</span>)*v, d</span><br><span class=\"line\">    <span class=\"keyword\">return</span> w</span><br></pre></td></tr></table></figure>\n<h3 id=\"47-礼物的最大价值\"><a href=\"#47-礼物的最大价值\" class=\"headerlink\" title=\"47 礼物的最大价值\"></a>47 礼物的最大价值</h3><h4 id=\"LeetCode传送门。相似题目，求的是最小。\"><a href=\"#LeetCode传送门。相似题目，求的是最小。\" class=\"headerlink\" title=\"LeetCode传送门。相似题目，求的是最小。\"></a><a href=\"https://leetcode.com/problems/minimum-path-sum/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a>。相似题目，求的是最小。</h4><h4 id=\"Acwing传送门这个是原题。\"><a href=\"#Acwing传送门这个是原题。\" class=\"headerlink\" title=\"Acwing传送门这个是原题。\"></a><a href=\"https://www.acwing.com/problem/content/56/\" target=\"_blank\" rel=\"noopener\">Acwing传送门</a>这个是原题。</h4><p>对首行使用初始化，然后消除了i的判断。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_max_value</span><span class=\"params\">(g: <span class=\"string\">'List[List[int]]'</span>)</span> -&gt; int:</span></span><br><span class=\"line\">    R, C = len(g), len(g[<span class=\"number\">0</span>])</span><br><span class=\"line\">    cur = list(itertools.accumulate(g[<span class=\"number\">0</span>]))</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, R):</span><br><span class=\"line\">        tmp = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(C):</span><br><span class=\"line\">            left = tmp[<span class=\"number\">-1</span>] <span class=\"keyword\">if</span> j &gt; <span class=\"number\">0</span> <span class=\"keyword\">else</span> float(<span class=\"string\">'-inf'</span>)</span><br><span class=\"line\">            tmp.append(max(cur[j], left) + g[i][j])</span><br><span class=\"line\">        cur = tmp</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cur[<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"48-最长不含重复字符的子字符串\"><a href=\"#48-最长不含重复字符的子字符串\" class=\"headerlink\" title=\"48.最长不含重复字符的子字符串\"></a>48.最长不含重复字符的子字符串</h3><h4 id=\"LeetCode传送门-29\"><a href=\"#LeetCode传送门-29\" class=\"headerlink\" title=\"LeetCode传送门\"></a><a href=\"https://leetcode.com/problems/longest-substring-without-repeating-characters/description/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><p>方法二：找到重复值时，更新start的值，为什么使用max，因为start有可能大于<code>dic[s[end]]+1</code>，比如当<code>s=&#39;abba&#39;</code>，end走到最后的时候，上一次start因为b做了更新变为了2。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">    ans = start = <span class=\"number\">0</span></span><br><span class=\"line\">    pos = &#123;&#125;    <span class=\"comment\"># last index of element</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> end, c <span class=\"keyword\">in</span> enumerate(s):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> c <span class=\"keyword\">in</span> pos:</span><br><span class=\"line\">            start = max(start, pos[c]+<span class=\"number\">1</span>)</span><br><span class=\"line\">        pos[c] = end</span><br><span class=\"line\">        ans = max(ans, end-start+<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"49-丑数\"><a href=\"#49-丑数\" class=\"headerlink\" title=\"49.丑数\"></a>49.丑数</h3><h4 id=\"LeetCode传送门-30\"><a href=\"#LeetCode传送门-30\" class=\"headerlink\" title=\"LeetCode传送门\"></a><a href=\"https://leetcode.com/problems/ugly-number-ii/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">nthUglyNumber</span><span class=\"params\">(self, n: int)</span> -&gt; int:</span></span><br><span class=\"line\">    q = [<span class=\"number\">1</span>]</span><br><span class=\"line\">    t2 = t3 = t5 = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n<span class=\"number\">-1</span>):</span><br><span class=\"line\">        a2, a3, a5 = q[t2]*<span class=\"number\">2</span>, q[t3]*<span class=\"number\">3</span>, q[t5]*<span class=\"number\">5</span></span><br><span class=\"line\">        to_add = min(a2, a3, a5)</span><br><span class=\"line\">        q.append(to_add)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> a2 == to_add:</span><br><span class=\"line\">            t2 += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> a3 == to_add:</span><br><span class=\"line\">            t3 += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> a5 == to_add:</span><br><span class=\"line\">            t5 += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> q[<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"50-第一个只出现一次的字符\"><a href=\"#50-第一个只出现一次的字符\" class=\"headerlink\" title=\"50.第一个只出现一次的字符\"></a>50.第一个只出现一次的字符</h3><h4 id=\"LeetCode传送门有一点小区别，LeetCode输出索引，书中输出值。\"><a href=\"#LeetCode传送门有一点小区别，LeetCode输出索引，书中输出值。\" class=\"headerlink\" title=\"LeetCode传送门有一点小区别，LeetCode输出索引，书中输出值。\"></a><a href=\"https://leetcode.com/problems/first-unique-character-in-a-string/description/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a>有一点小区别，LeetCode输出索引，书中输出值。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">s &#x3D; &quot;leetcode&quot;</span><br><span class=\"line\">return 0.</span><br><span class=\"line\">s &#x3D; &quot;loveleetcode&quot;,</span><br><span class=\"line\">return 2.</span><br></pre></td></tr></table></figure>\n<p>Time-O(N), Space-O(N)。暂时没发现更快的算法了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">firstUniqChar</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Counter</span><br><span class=\"line\">    c = Counter(s)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, ch <span class=\"keyword\">in</span> enumerate(s):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> c[ch] == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> i</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"51-数组中的逆序对\"><a href=\"#51-数组中的逆序对\" class=\"headerlink\" title=\"51.数组中的逆序对\"></a>51.数组中的逆序对</h3><h4 id=\"牛客网传送门-5\"><a href=\"#牛客网传送门-5\" class=\"headerlink\" title=\"牛客网传送门\"></a><a href=\"https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&amp;tqId=11188&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking\" target=\"_blank\" rel=\"noopener\">牛客网传送门</a></h4><h4 id=\"AcWing传送门-14\"><a href=\"#AcWing传送门-14\" class=\"headerlink\" title=\"AcWing传送门\"></a><a href=\"https://www.acwing.com/problem/content/61/\" target=\"_blank\" rel=\"noopener\">AcWing传送门</a></h4><p>这里使用了双端队列感觉不太合适，因为还要显式地转成list，否则没法对剩余的left或right做切片。也试了将其改为stack，但是stack来回reverse又太麻烦。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">InversePairs</span><span class=\"params\">(self, data)</span>:</span></span><br><span class=\"line\">    self.count = <span class=\"number\">0</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge</span><span class=\"params\">(left, right)</span>:</span></span><br><span class=\"line\">        q = deque()</span><br><span class=\"line\">        l, r = len(left)<span class=\"number\">-1</span>, len(right)<span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> l &gt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> r &gt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> left[l] &gt; right[r]:</span><br><span class=\"line\">                self.count += r + <span class=\"number\">1</span></span><br><span class=\"line\">                q.appendleft(left[l])</span><br><span class=\"line\">                l -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                q.appendleft(right[r])</span><br><span class=\"line\">                r -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"comment\"># q.extendleft(left[l:-1:-1] or right[r:-1:-1])</span></span><br><span class=\"line\">        q = left[:l+<span class=\"number\">1</span>] + right[:r+<span class=\"number\">1</span>] + list(q)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> q</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge_sort</span><span class=\"params\">(ary)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(ary) &lt;= <span class=\"number\">1</span>: <span class=\"keyword\">return</span> ary</span><br><span class=\"line\">        mid = len(ary) // <span class=\"number\">2</span></span><br><span class=\"line\">        left = merge_sort(ary[:mid])</span><br><span class=\"line\">        right = merge_sort(ary[mid:])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> merge(left, right)</span><br><span class=\"line\">    </span><br><span class=\"line\">    merge_sort(data)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.count % <span class=\"number\">1000000007</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"52-两个链表的第一个公共节点\"><a href=\"#52-两个链表的第一个公共节点\" class=\"headerlink\" title=\"52.两个链表的第一个公共节点\"></a>52.两个链表的第一个公共节点</h3><h4 id=\"LeetCode传送门-31\"><a href=\"#LeetCode传送门-31\" class=\"headerlink\" title=\"LeetCode传送门\"></a><a href=\"https://leetcode.com/problems/intersection-of-two-linked-lists/description/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getIntersectionNode</span><span class=\"params\">(self, headA, headB)</span>:</span></span><br><span class=\"line\">    p1, p2 = headA, headB</span><br><span class=\"line\">    <span class=\"keyword\">while</span> p1 <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> p2:</span><br><span class=\"line\">        p1 = p1.next <span class=\"keyword\">if</span> p1 <span class=\"keyword\">else</span> headB</span><br><span class=\"line\">        p2 = p2.next <span class=\"keyword\">if</span> p2 <span class=\"keyword\">else</span> headA</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p1</span><br></pre></td></tr></table></figure>\n<h3 id=\"53-在排序数组中查找数字\"><a href=\"#53-在排序数组中查找数字\" class=\"headerlink\" title=\"53.在排序数组中查找数字\"></a>53.在排序数组中查找数字</h3><p>相似题目，LeetCode是求出数字的索引，书中返回个数。</p>\n<h4 id=\"LeetCode传送门。相似题目，LeetCode要返回两个索引，书中求个数。\"><a href=\"#LeetCode传送门。相似题目，LeetCode要返回两个索引，书中求个数。\" class=\"headerlink\" title=\"LeetCode传送门。相似题目，LeetCode要返回两个索引，书中求个数。\"></a><a href=\"https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a>。相似题目，LeetCode要返回两个索引，书中求个数。</h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums = [<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">8</span>,<span class=\"number\">10</span>], target = <span class=\"number\">8</span></span><br><span class=\"line\">Output: [<span class=\"number\">3</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\">Input: nums = [<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">8</span>,<span class=\"number\">10</span>], target = <span class=\"number\">6</span></span><br><span class=\"line\">Output: [<span class=\"number\">-1</span>,<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<p>方法一：标准库写法。这里不需要target去整个nums中判断。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">searchRange</span><span class=\"params\">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> bisect <span class=\"keyword\">import</span> bisect, bisect_left</span><br><span class=\"line\">    lo = bisect_left(nums, target)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> target <span class=\"keyword\">in</span> nums[lo:lo+<span class=\"number\">1</span>]:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> lo, bisect(nums, target)<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>, <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<p>方法二：自己实现。bisect_right的方式采用+1的形式。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">searchRange</span><span class=\"params\">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">search</span><span class=\"params\">(n)</span>:</span></span><br><span class=\"line\">        lo, hi = <span class=\"number\">0</span>, len(nums)</span><br><span class=\"line\">        <span class=\"keyword\">while</span> lo &lt; hi:</span><br><span class=\"line\">            mid = (lo + hi) // <span class=\"number\">2</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[mid] &gt;= n:</span><br><span class=\"line\">                hi = mid</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                lo = mid + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> lo</span><br><span class=\"line\">    lo = search(target)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> target <span class=\"keyword\">in</span> nums[lo:lo+<span class=\"number\">1</span>]:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> lo, search(target+<span class=\"number\">1</span>)<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>, <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"53-0-n-1中缺失的数字\"><a href=\"#53-0-n-1中缺失的数字\" class=\"headerlink\" title=\"53.0~n-1中缺失的数字\"></a>53.0~n-1中缺失的数字</h3><h4 id=\"LeetCode传送门-32\"><a href=\"#LeetCode传送门-32\" class=\"headerlink\" title=\"LeetCode传送门\"></a><a href=\"https://leetcode.com/problems/missing-number/description/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><p>相似题目，LeetCode是未排序，书中是已排序。所以可以利用排序的特性使时间复杂度小于O(n)。即找出第一个下标与值不相等的元素，再-1就是缺失的元素。</p>\n<h4 id=\"AcWing传送门-15\"><a href=\"#AcWing传送门-15\" class=\"headerlink\" title=\"AcWing传送门\"></a><a href=\"https://www.acwing.com/problem/content/64/\" target=\"_blank\" rel=\"noopener\">AcWing传送门</a></h4><p>方法一：数学公式。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">missingNumber</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">    n = len(nums)</span><br><span class=\"line\">    expected_sum = n*(n+<span class=\"number\">1</span>) // <span class=\"number\">2</span></span><br><span class=\"line\">    actual_sum = sum(nums)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> expected_sum - actual_sum</span><br></pre></td></tr></table></figure>\n<p>方法二：XOR.</p>\n<table>\n<thead>\n<tr>\n<th>index</th>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value</td>\n<td>3</td>\n<td>0</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">missingNumber</span><span class=\"params\">(self, nums: <span class=\"string\">'List[int]'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    missing = len(nums)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, num <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">        missing ^= i ^ num</span><br><span class=\"line\">    <span class=\"keyword\">return</span> missing</span><br></pre></td></tr></table></figure>\n<p>方法三：利用书中已排序的特性。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">missingNumber</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    lo, hi = <span class=\"number\">0</span>, len(nums)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> lo &lt; hi:</span><br><span class=\"line\">        mid = (lo + hi) &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[mid] &gt; mid:</span><br><span class=\"line\">            hi = mid</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            lo = mid + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> lo</span><br></pre></td></tr></table></figure>\n<h3 id=\"53-数组中数值和下标相等的元素\"><a href=\"#53-数组中数值和下标相等的元素\" class=\"headerlink\" title=\"53 数组中数值和下标相等的元素\"></a>53 数组中数值和下标相等的元素</h3><h4 id=\"AcWing传送门-16\"><a href=\"#AcWing传送门-16\" class=\"headerlink\" title=\"AcWing传送门\"></a><a href=\"https://www.acwing.com/problem/content/65/\" target=\"_blank\" rel=\"noopener\">AcWing传送门</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getNumberSameAsIndex</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">    lo, hi = <span class=\"number\">0</span>, len(nums)<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> lo &lt;= hi:</span><br><span class=\"line\">        mid = (lo + hi) &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[mid] &lt; mid:</span><br><span class=\"line\">            lo = mid + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> nums[mid] &gt; mid:</span><br><span class=\"line\">            hi = mid - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"54-二叉搜索树的第k大节点\"><a href=\"#54-二叉搜索树的第k大节点\" class=\"headerlink\" title=\"54.二叉搜索树的第k大节点\"></a>54.二叉搜索树的第k大节点</h3><h4 id=\"AcWing传送门-17\"><a href=\"#AcWing传送门-17\" class=\"headerlink\" title=\"AcWing传送门\"></a><a href=\"https://www.acwing.com/problem/content/66/\" target=\"_blank\" rel=\"noopener\">AcWing传送门</a></h4><p>注意：牛客网上是求第k小节点，这里被坑了一次，然后返回值居然要求返回节点对象，而不是节点值，这里的答案按书中返回。如果是牛客网上需要把节点添加到<code>res</code>中，然后<code>return res[k-1]</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">kth_largest</span><span class=\"params\">(self, root: TreeNode, k: int)</span> -&gt; int:</span></span><br><span class=\"line\">    stack, ans = [], <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> stack <span class=\"keyword\">or</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> root:</span><br><span class=\"line\">            stack.append(root)</span><br><span class=\"line\">            root = root.right</span><br><span class=\"line\">        root = stack.pop()</span><br><span class=\"line\">        k -= <span class=\"number\">1</span></span><br><span class=\"line\">        ans = root</span><br><span class=\"line\">        root = root.left</span><br><span class=\"line\">        <span class=\"keyword\">if</span> k == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法二：生成器写法，无比的清晰。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">kthLargest</span><span class=\"params\">(self, root: TreeNode, k: int)</span> -&gt; int:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">r_inorder</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> r_inorder(node.right)</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> node.val</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> r_inorder(node.left)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> next(islice(r_inorder(root), k<span class=\"number\">-1</span>, <span class=\"literal\">None</span>))</span><br></pre></td></tr></table></figure>\n<h3 id=\"55-二叉树的深度\"><a href=\"#55-二叉树的深度\" class=\"headerlink\" title=\"55.二叉树的深度\"></a>55.二叉树的深度</h3><h4 id=\"LeetCode传送门-33\"><a href=\"#LeetCode传送门-33\" class=\"headerlink\" title=\"LeetCode传送门\"></a><a href=\"https://leetcode.com/problems/maximum-depth-of-binary-tree/description/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">    3</span><br><span class=\"line\">   &#x2F; \\</span><br><span class=\"line\">  9  20</span><br><span class=\"line\">    &#x2F;  \\</span><br><span class=\"line\">   15   7</span><br><span class=\"line\">return 3</span><br></pre></td></tr></table></figure>\n<p>方法一：recursively</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">max_depth</span><span class=\"params\">(root)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\"># return max(max_depth(root.left), max_depth(root.right)) + 1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(map(max_depth, (root.left, root.right))) + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>方法二：iteratively. BFS with deque</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxDepth</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    q = root <span class=\"keyword\">and</span> collections.deque([(root, <span class=\"number\">1</span>)])</span><br><span class=\"line\">    d = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> q:</span><br><span class=\"line\">        node, d = q.popleft()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.right:</span><br><span class=\"line\">            q.append((node.right, d+<span class=\"number\">1</span>))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.left:</span><br><span class=\"line\">            q.append((node.left, d+<span class=\"number\">1</span>))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> d</span><br></pre></td></tr></table></figure>\n<h3 id=\"55-1平衡二叉树\"><a href=\"#55-1平衡二叉树\" class=\"headerlink\" title=\"55.1平衡二叉树\"></a>55.1平衡二叉树</h3><h4 id=\"LeetCode传送门-34\"><a href=\"#LeetCode传送门-34\" class=\"headerlink\" title=\"LeetCode传送门\"></a><a href=\"https://leetcode.com/problems/balanced-binary-tree/description/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><p>方法一：递归+递归。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isBalanced</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.isBalanced(root.left) <span class=\"keyword\">and</span> self.isBalanced(root.right) <span class=\"keyword\">and</span> \\</span><br><span class=\"line\">           abs(self.max_depth(root.left)-self.max_depth(root.right)) &lt;= <span class=\"number\">1</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">max_depth</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(self.max_depth(root.left), self.max_depth(root.right)) + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>方法二：上诉两种方法中都包含了一些无意义的重复遍历。这里采用后序遍历，边遍历边判断，不会重复节点。受此思想启发，添加一种后序遍历二叉树的方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isBalanced</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">    stack, node, last = [], root, <span class=\"literal\">None</span></span><br><span class=\"line\">    depths = collections.defaultdict(int)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> stack <span class=\"keyword\">or</span> node:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            stack.append(node)</span><br><span class=\"line\">            node = node.left</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            node = stack[<span class=\"number\">-1</span>]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node.right <span class=\"keyword\">or</span> last == node.right:</span><br><span class=\"line\">                node = stack.pop()</span><br><span class=\"line\">                left, right  = depths[node.left], depths[node.right]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> abs(left - right) &gt; <span class=\"number\">1</span>: </span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">                depths[node] = <span class=\"number\">1</span> + max(left, right)</span><br><span class=\"line\">                last, node = node, <span class=\"literal\">None</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                node = node.right</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<p>方法三：dfs. 算深度的时候判断左右是否深度超过1. 这里变量不能把self去掉，否则<code>[1,2,2,3,3,null,null,4,4]</code>会错误的返回<code>True</code>而不是<code>False</code>。也可以使用<code>nonlocal</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isBalanced</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\">    self.balanced = <span class=\"literal\">True</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        left = dfs(node.left)</span><br><span class=\"line\">        right = dfs(node.right)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> abs(left-right) &gt; <span class=\"number\">1</span> <span class=\"keyword\">and</span> self.balanced:</span><br><span class=\"line\">            self.balanced = <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(left, right) + <span class=\"number\">1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    dfs(root)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.balanced</span><br></pre></td></tr></table></figure>\n<h3 id=\"56-数组中只出现一次的两个数字。\"><a href=\"#56-数组中只出现一次的两个数字。\" class=\"headerlink\" title=\"56 数组中只出现一次的两个数字。\"></a>56 数组中只出现一次的两个数字。</h3><h4 id=\"找出数组中两个唯一出现一次的元素，其余元素均出现两次。LeetCode传送门\"><a href=\"#找出数组中两个唯一出现一次的元素，其余元素均出现两次。LeetCode传送门\" class=\"headerlink\" title=\"找出数组中两个唯一出现一次的元素，其余元素均出现两次。LeetCode传送门\"></a>找出数组中两个唯一出现一次的元素，其余元素均出现两次。<a href=\"https://leetcode.com/problems/single-number-iii/description/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input:  [1,2,1,3,2,5]</span><br><span class=\"line\">Output: [3,5]</span><br></pre></td></tr></table></figure>\n<p>思想：将这两个元素分到两个组，由于这两个数不相等，所以亦或结果不为0，也就是说二进制中至少有一位1，记为第n位。我们以第n位是否为1，把数组分为两个子数组。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">singleNumbers</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">xor_total</span><span class=\"params\">(ary)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> reduce(xor, ary)</span><br><span class=\"line\"></span><br><span class=\"line\">    total = xor_total(nums)</span><br><span class=\"line\">    mask = total &amp; -total</span><br><span class=\"line\">    n1 = (num <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums <span class=\"keyword\">if</span> num&amp;mask==<span class=\"number\">0</span>)</span><br><span class=\"line\">    n2 = (num <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums <span class=\"keyword\">if</span> num&amp;mask!=<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> xor_total(n1), xor_total(n2)</span><br></pre></td></tr></table></figure>\n<h3 id=\"56-1数组中出现一次的数字，其余元素出现三次。\"><a href=\"#56-1数组中出现一次的数字，其余元素出现三次。\" class=\"headerlink\" title=\"56.1数组中出现一次的数字，其余元素出现三次。\"></a>56.1数组中出现一次的数字，其余元素出现三次。</h3><h4 id=\"LeetCode传送门-35\"><a href=\"#LeetCode传送门-35\" class=\"headerlink\" title=\"LeetCode传送门\"></a><a href=\"https://leetcode.com/problems/single-number-ii/description/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [2,2,3,2]</span><br><span class=\"line\">Output: 3</span><br></pre></td></tr></table></figure>\n<p>方法一：找出单独元素每一位的值。如果把所有数字的二进制每一位加起来，如果某一位可以被3整除，则表示单独元素的该位为0，否则为1。以下使用<code>count</code>来表示每一位<code>1</code>的个数。假设<code>count%3!=0</code>为True，说明该元素<code>i</code>位为1，然后是用<code>|=</code>更新ans在第<code>i</code>个位置的值，这里也可以使用<code>+=</code>，但是效率稍慢。<code>convert</code>的作用是因为python中的int是个对象，且没有最大限制，不是在第32位使用1来表示负数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">singleNumber</span><span class=\"params\">(self, nums, n=<span class=\"number\">3</span>)</span>:</span></span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">32</span>):</span><br><span class=\"line\">        count = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((num &gt;&gt; i) &amp; <span class=\"number\">1</span>):</span><br><span class=\"line\">                count += <span class=\"number\">1</span></span><br><span class=\"line\">        ans |= ((count%n!=<span class=\"number\">0</span>) &lt;&lt; i)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.convert(ans)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">convert</span><span class=\"params\">(self, x)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> x &gt;= <span class=\"number\">2</span>**<span class=\"number\">31</span>:</span><br><span class=\"line\">        x -= <span class=\"number\">2</span>**<span class=\"number\">32</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x</span><br></pre></td></tr></table></figure>\n<p>这里有个状态机的解法，不明觉厉，留坑。<a href=\"https://leetcode.com/problems/single-number-ii/discuss/43294/Challenge-me-thx?page=2\" target=\"_blank\" rel=\"noopener\">讨论1</a>和<a href=\"https://leetcode.com/problems/single-number-ii/discuss/43295/Detailed-explanation-and-generalization-of-the-bitwise-operation-method-for-single-numbers\" target=\"_blank\" rel=\"noopener\">讨论2</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">singleNumber</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">    ones, twos = <span class=\"number\">0</span>, <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(nums)):</span><br><span class=\"line\">        ones = (ones ^ nums[i]) &amp; ~twos</span><br><span class=\"line\">        twos = (twos ^ nums[i]) &amp; ~ones</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ones</span><br></pre></td></tr></table></figure>\n<h3 id=\"57-和为s的数字\"><a href=\"#57-和为s的数字\" class=\"headerlink\" title=\"57.和为s的数字\"></a>57.和为s的数字</h3><h4 id=\"牛客网传送门-6\"><a href=\"#牛客网传送门-6\" class=\"headerlink\" title=\"牛客网传送门\"></a><a href=\"https://www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b?tpId=13&amp;tqId=11195&amp;tPage=3&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking\" target=\"_blank\" rel=\"noopener\">牛客网传送门</a></h4><h4 id=\"AcWing传送门-18\"><a href=\"#AcWing传送门-18\" class=\"headerlink\" title=\"AcWing传送门\"></a><a href=\"https://www.acwing.com/problem/content/71/\" target=\"_blank\" rel=\"noopener\">AcWing传送门</a></h4><p>看牛客网上的描述，如果有多对数字和为s，要求返回乘积最小的一对。乍一看以为牛客网又乱改题，但是仔细一想，如果两个和为s的数，而且是在递增数组中很明显，边缘的数字乘积要小，例如<code>8X8&gt;1X15</code>。所以还是和书中解法一样。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">FindNumbersWithSum</span><span class=\"params\">(self, array, tsum)</span>:</span></span><br><span class=\"line\">    l, r = <span class=\"number\">0</span>, len(array)<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> l &lt; r:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> array[l] + array[r] &lt; tsum:</span><br><span class=\"line\">            l += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> array[l]+array[r] &gt; tsum:</span><br><span class=\"line\">            r -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> array[l], array[r]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> []</span><br></pre></td></tr></table></figure>\n<h3 id=\"57-1-和为s的连续正数序列\"><a href=\"#57-1-和为s的连续正数序列\" class=\"headerlink\" title=\"57_1 和为s的连续正数序列\"></a>57_1 和为s的连续正数序列</h3><h4 id=\"牛客网传送门-7\"><a href=\"#牛客网传送门-7\" class=\"headerlink\" title=\"牛客网传送门\"></a><a href=\"https://www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe?tpId=13&amp;tqId=11194&amp;tPage=3&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking\" target=\"_blank\" rel=\"noopener\">牛客网传送门</a></h4><h4 id=\"AcWing传送门-19\"><a href=\"#AcWing传送门-19\" class=\"headerlink\" title=\"AcWing传送门\"></a><a href=\"https://www.acwing.com/problem/content/72/\" target=\"_blank\" rel=\"noopener\">AcWing传送门</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findContinuousSequence</span><span class=\"params\">(self, tsum)</span>:</span></span><br><span class=\"line\">    end = (tsum + <span class=\"number\">1</span>) // <span class=\"number\">2</span></span><br><span class=\"line\">    lo, hi, cur_sum = <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span></span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> lo &lt; end:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cur_sum &lt; tsum:</span><br><span class=\"line\">            hi += <span class=\"number\">1</span></span><br><span class=\"line\">            cur_sum += hi</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> cur_sum == tsum:</span><br><span class=\"line\">                ans.append(list(range(lo, hi+<span class=\"number\">1</span>)))</span><br><span class=\"line\">            cur_sum -= lo</span><br><span class=\"line\">            lo += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"58-翻转字符串。\"><a href=\"#58-翻转字符串。\" class=\"headerlink\" title=\"58.翻转字符串。\"></a>58.翻转字符串。</h3><h4 id=\"LeetCode传送门-36\"><a href=\"#LeetCode传送门-36\" class=\"headerlink\" title=\"LeetCode传送门\"></a><a href=\"https://leetcode.com/problems/reverse-words-in-a-string/description/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: <span class=\"string\">\"the sky is blue\"</span>,</span><br><span class=\"line\">Output: <span class=\"string\">\"blue is sky the\"</span>.</span><br></pre></td></tr></table></figure>\n<p>方法一：如果面试官是一个Pythoner，那么就让你过了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverse_words</span><span class=\"params\">(s)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">' '</span>.join(reversed(s.split()))</span><br></pre></td></tr></table></figure>\n<p>如果你的面试官是一个只写Java或者C，看见代码就不平衡了，凭啥可以写到一行，非要你实现reverse。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseWords</span><span class=\"params\">(self, s: str)</span> -&gt; str:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hp_reversed</span><span class=\"params\">(s)</span>:</span></span><br><span class=\"line\">        s = list(s)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(s)//<span class=\"number\">2</span>):</span><br><span class=\"line\">            <span class=\"comment\"># s[i], s[-i-1] = s[-i-1], s[i]</span></span><br><span class=\"line\">            s[i], s[~i] = s[~i], s[i]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(s)</span><br><span class=\"line\">    s = hp_reversed(s)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">' '</span>.join(hp_reversed(word) <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> s.split())</span><br></pre></td></tr></table></figure>\n<p>实现<code>split</code>，hp_reverse，</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseWords</span><span class=\"params\">(self, s: str)</span> -&gt; str:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hp_reversed</span><span class=\"params\">(s)</span>:</span></span><br><span class=\"line\">        s = list(s)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(s)//<span class=\"number\">2</span>):</span><br><span class=\"line\">            s[i], s[~i] = s[~i], s[i]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(s)</span><br><span class=\"line\"></span><br><span class=\"line\">    s = hp_reversed(s)</span><br><span class=\"line\">    ans = word = <span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> r, c <span class=\"keyword\">in</span> enumerate(s):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> c != <span class=\"string\">' '</span>:</span><br><span class=\"line\">            word += c</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c== <span class=\"string\">' '</span> <span class=\"keyword\">or</span> r==len(s)<span class=\"number\">-1</span>) <span class=\"keyword\">and</span> word:</span><br><span class=\"line\">            ans += hp_reversed(word) + <span class=\"string\">' '</span></span><br><span class=\"line\">            word = <span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans[:<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"58-1-左旋转字符串\"><a href=\"#58-1-左旋转字符串\" class=\"headerlink\" title=\"58_1 左旋转字符串\"></a>58_1 左旋转字符串</h3><h4 id=\"牛客网传送门-8\"><a href=\"#牛客网传送门-8\" class=\"headerlink\" title=\"牛客网传送门\"></a><a href=\"https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec?tpId=13&amp;tqId=11196&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking\" target=\"_blank\" rel=\"noopener\">牛客网传送门</a></h4><h4 id=\"AcWing传送门-20\"><a href=\"#AcWing传送门-20\" class=\"headerlink\" title=\"AcWing传送门\"></a><a href=\"https://www.acwing.com/problem/content/74/\" target=\"_blank\" rel=\"noopener\">AcWing传送门</a></h4><p>切片，书中的方法个人觉得Python并不适用。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">LeftRotateString</span><span class=\"params\">(self, s, n)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> s:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">''</span></span><br><span class=\"line\">    n = n % len(s)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s[n:] + s[:n]</span><br></pre></td></tr></table></figure>\n<h3 id=\"59-滑动窗口的最大值。\"><a href=\"#59-滑动窗口的最大值。\" class=\"headerlink\" title=\"59.滑动窗口的最大值。\"></a>59.滑动窗口的最大值。</h3><h4 id=\"LeetCode传送门-37\"><a href=\"#LeetCode传送门-37\" class=\"headerlink\" title=\"LeetCode传送门\"></a><a href=\"https://leetcode.com/problems/sliding-window-maximum/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><p>得益于python的切片。Time: O(n*k). k=n-size</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxInWindows</span><span class=\"params\">(self, nums, size)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [max(nums[i:i+size])</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(nums)-size+<span class=\"number\">1</span>) <span class=\"keyword\">if</span> size!=<span class=\"number\">0</span> ]</span><br></pre></td></tr></table></figure>\n<p>方法二：队列保存索引。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxSlidingWindow</span><span class=\"params\">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class=\"line\">    q = collections.deque()</span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, d <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">        <span class=\"keyword\">while</span> q <span class=\"keyword\">and</span> nums[q[<span class=\"number\">-1</span>]] &lt; d:</span><br><span class=\"line\">            q.pop()</span><br><span class=\"line\">        q.append(i)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> q[<span class=\"number\">0</span>] == i-k:</span><br><span class=\"line\">            q.popleft()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i &gt;= k<span class=\"number\">-1</span>:</span><br><span class=\"line\">            ans.append(nums[q[<span class=\"number\">0</span>]])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"60-n个骰子的点数\"><a href=\"#60-n个骰子的点数\" class=\"headerlink\" title=\"60.n个骰子的点数\"></a>60.n个骰子的点数</h3><h4 id=\"AcWing传送门-21\"><a href=\"#AcWing传送门-21\" class=\"headerlink\" title=\"AcWing传送门\"></a><a href=\"https://www.acwing.com/problem/content/76/\" target=\"_blank\" rel=\"noopener\">AcWing传送门</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[[1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1]]</span><br></pre></td></tr></table></figure>\n<p><code>dp[0][j]==1</code>表示第一个骰子和为<code>j+1</code>的次数为1，因为数组下标从0开始。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dice_probability</span><span class=\"params\">(n, val=<span class=\"number\">6</span>)</span>:</span></span><br><span class=\"line\">    dp = [[<span class=\"number\">0</span>]*val*n <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>][:val] = [<span class=\"number\">1</span>] * val  <span class=\"comment\"># 初始化第一个骰子</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n<span class=\"number\">-1</span>):  <span class=\"comment\"># 根据第i个骰子更新第i+1个骰子</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i, len(dp[i+<span class=\"number\">1</span>])):</span><br><span class=\"line\">            <span class=\"comment\"># 第i+1个骰子和为j（实际为j+1，因为数组下标从0开始）的次数，等于第i个</span></span><br><span class=\"line\">            <span class=\"comment\"># 骰子j-1 ~ j-6次数的总和</span></span><br><span class=\"line\">            dp[i+<span class=\"number\">1</span>][j] = sum([dp[i][j-k] <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, val+<span class=\"number\">1</span>)])</span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"comment\"># 整理数据成为dict，key表示和，value表示出现的次数</span></span><br><span class=\"line\">    <span class=\"comment\"># count = &#123;i+1: times for i, times in enumerate(dp[-1])&#125;</span></span><br><span class=\"line\">    <span class=\"comment\"># 计算概率</span></span><br><span class=\"line\">    count = &#123;i+<span class=\"number\">1</span>: round(float(times / (val**n)), <span class=\"number\">5</span>)</span><br><span class=\"line\">             <span class=\"keyword\">for</span> i, times <span class=\"keyword\">in</span> enumerate(dp[<span class=\"number\">-1</span>]) <span class=\"keyword\">if</span> times!=<span class=\"number\">0</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count</span><br></pre></td></tr></table></figure>\n<p>感觉用dict来表示更加明确，没有数组下标从0开始的混淆。按照AcWing中的返回写出一种解法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> defaultdict</span><br><span class=\"line\"><span class=\"keyword\">from</span> itertools <span class=\"keyword\">import</span> repeat</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numberOfDice</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">    last_p = defaultdict(int)</span><br><span class=\"line\">    last_p.update(dict(zip(range(<span class=\"number\">1</span>, <span class=\"number\">7</span>), repeat(<span class=\"number\">1</span>))))</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>, n+<span class=\"number\">1</span>):</span><br><span class=\"line\">        new_p = defaultdict(int)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i, i*<span class=\"number\">6</span>+<span class=\"number\">1</span>):</span><br><span class=\"line\">            new_p[j] = sum(last_p[j-k] <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">7</span>))</span><br><span class=\"line\">        <span class=\"comment\"># print(new_p)</span></span><br><span class=\"line\">        last_p = new_p</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list(last_p.values())</span><br></pre></td></tr></table></figure>\n<h3 id=\"61-扑克牌中的顺子\"><a href=\"#61-扑克牌中的顺子\" class=\"headerlink\" title=\"61.扑克牌中的顺子\"></a>61.扑克牌中的顺子</h3><h4 id=\"牛客网传送门-9\"><a href=\"#牛客网传送门-9\" class=\"headerlink\" title=\"牛客网传送门\"></a><a href=\"https://www.nowcoder.com/practice/762836f4d43d43ca9deb273b3de8e1f4?tpId=13&amp;tqId=11198&amp;tPage=3&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking\" target=\"_blank\" rel=\"noopener\">牛客网传送门</a></h4><h4 id=\"AcWing传送门-22\"><a href=\"#AcWing传送门-22\" class=\"headerlink\" title=\"AcWing传送门\"></a><a href=\"https://www.acwing.com/problem/content/77/\" target=\"_blank\" rel=\"noopener\">AcWing传送门</a></h4><p>开始以为还要用个dict来映射值，后来发现直接传得卡牌的值。思想就是先排序，然后查joker的数量，看剩下牌的差值加起来能不能用已有的joker连起来。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">IsContinuous</span><span class=\"params\">(self, numbers)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> numbers:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    joker_count = numbers.count(<span class=\"number\">0</span>)</span><br><span class=\"line\">    left_cards = sorted(numbers)[joker_count:]</span><br><span class=\"line\">    need_joker = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(left_cards)<span class=\"number\">-1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> left_cards[i+<span class=\"number\">1</span>] == left_cards[i]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        need_joker += (left_cards[i+<span class=\"number\">1</span>]-left_cards[i]<span class=\"number\">-1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> need_joker &lt;= joker_count</span><br></pre></td></tr></table></figure>\n<p>只要没有重复的，并且最大的和最小的差&lt;5就能组成顺子。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isStraight</span><span class=\"params\">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class=\"line\">    cards = [x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> nums <span class=\"keyword\">if</span> x!=<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> len(cards)==len(set(cards)) <span class=\"keyword\">and</span> max(cards)-min(cards)&lt;<span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"62-圆圈中最后剩下的数字\"><a href=\"#62-圆圈中最后剩下的数字\" class=\"headerlink\" title=\"62.圆圈中最后剩下的数字\"></a>62.圆圈中最后剩下的数字</h3><h4 id=\"AcWing传送门-23\"><a href=\"#AcWing传送门-23\" class=\"headerlink\" title=\"AcWing传送门\"></a><a href=\"https://www.acwing.com/problem/content/78/\" target=\"_blank\" rel=\"noopener\">AcWing传送门</a></h4><p>方法一：其实不需要环形链表，使用一个list足矣，每次将其旋转<code>rot</code>位，一开始想将要把第m个数旋转到list首部，然后再<code>pop(0)</code>，后来想到直接可以通过切片取出来，节省了<code>pop(0)</code>的O(n)复杂度。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lastRemaining</span><span class=\"params\">(self, n: int, m: int)</span> -&gt; int:</span></span><br><span class=\"line\">    num = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>, n+<span class=\"number\">1</span>):</span><br><span class=\"line\">        num = (num + m) % i</span><br><span class=\"line\">    <span class=\"keyword\">return</span> num</span><br></pre></td></tr></table></figure>\n<p>方法二：书中的推导过程过于复杂，这里学到了一个稍微简单的推导过程。参考<a href=\"https://blog.oldj.net/2010/05/27/joseph-ring/\" target=\"_blank\" rel=\"noopener\">约瑟夫环问题</a>。</p>\n<p>解析<a href=\"/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98%EF%BC%88Josephus-problem%EF%BC%89/\" title=\"Josephus-problem\">Josephus-problem</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">LastRemaining_Solution</span><span class=\"params\">(self, n, m)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> n&lt;=<span class=\"number\">0</span> <span class=\"keyword\">or</span> m&lt;=<span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    last_num = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>, n+<span class=\"number\">1</span>):</span><br><span class=\"line\">        last_num = (last_num+m) % i</span><br><span class=\"line\">    <span class=\"keyword\">return</span> last_num</span><br></pre></td></tr></table></figure>\n<h3 id=\"63-股票的最大利润\"><a href=\"#63-股票的最大利润\" class=\"headerlink\" title=\"63.股票的最大利润\"></a>63.股票的最大利润</h3><h4 id=\"LeetCode传送门-38\"><a href=\"#LeetCode传送门-38\" class=\"headerlink\" title=\"LeetCode传送门\"></a><a href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><p>方法一：Brute Force.其实就是求最高峰点和前面最低谷点的差。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxProfit</span><span class=\"params\">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    profit, min_buy = <span class=\"number\">0</span>, float(<span class=\"string\">'inf'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> prices:</span><br><span class=\"line\">        min_buy = min(min_buy, p)</span><br><span class=\"line\">        profit = max(profit, p-min_buy)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> profit</span><br></pre></td></tr></table></figure>\n<p>方法二：标准的卡登算法。此题为53.连续数组最大和的变形，如果价格比之前小，则舍弃，否则一起计算连续子数组的和。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxProfit</span><span class=\"params\">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    cur = sofar = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(prices)):</span><br><span class=\"line\">        cur += prices[i] - prices[i<span class=\"number\">-1</span>]</span><br><span class=\"line\">        cur = max(<span class=\"number\">0</span>, cur)</span><br><span class=\"line\">        sofar = max(cur, sofar)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sofar</span><br></pre></td></tr></table></figure>\n<p>方法三：使用标准库的卡登算法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxProfit</span><span class=\"params\">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> itertools <span class=\"keyword\">import</span> tee</span><br><span class=\"line\">    cur = profit = <span class=\"number\">0</span></span><br><span class=\"line\">    a, b = tee(prices)</span><br><span class=\"line\">    next(b, <span class=\"literal\">None</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> before, today <span class=\"keyword\">in</span> zip(a, b):</span><br><span class=\"line\">        cur += today - before</span><br><span class=\"line\">        cur = max(<span class=\"number\">0</span>, cur)</span><br><span class=\"line\">        profit = max(profit, cur)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> profit</span><br></pre></td></tr></table></figure>\n<h3 id=\"64-求1-2-···-n\"><a href=\"#64-求1-2-···-n\" class=\"headerlink\" title=\"64.求1+2+···+n\"></a>64.求1+2+···+n</h3><h4 id=\"AcWing传送门-24\"><a href=\"#AcWing传送门-24\" class=\"headerlink\" title=\"AcWing传送门\"></a><a href=\"https://www.acwing.com/problem/content/80/\" target=\"_blank\" rel=\"noopener\">AcWing传送门</a></h4><p>这题对python不是很友好，感觉<code>and</code>也属于条件判断语句。<code>reduce`</code>sum`之类的属于作弊行为，这里就不贴了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">Sum_Solution</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># write code here</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> n <span class=\"keyword\">and</span> (n+self.Sum_Solution(n<span class=\"number\">-1</span>))</span><br></pre></td></tr></table></figure>\n<h3 id=\"65-不用加减乘除做加法\"><a href=\"#65-不用加减乘除做加法\" class=\"headerlink\" title=\"65.不用加减乘除做加法\"></a>65.不用加减乘除做加法</h3><h4 id=\"LeetCode传送门-39\"><a href=\"#LeetCode传送门-39\" class=\"headerlink\" title=\"LeetCode传送门\"></a><a href=\"https://leetcode.com/problems/sum-of-two-integers/description/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><p>此题由于Python中的int没有长度限制，在负数出现的情况，会导致结果与预期不同。详情见<a href=\"https://darktiantian.github.io/371-Sum-of-Two-Integers-Python/\" target=\"_blank\" rel=\"noopener\">Python负数位运算</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getSum</span><span class=\"params\">(self, a, b)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 32 bits integer max</span></span><br><span class=\"line\">    MAX = <span class=\"number\">0x7FFFFFFF</span>  <span class=\"comment\"># 2**31-1</span></span><br><span class=\"line\">    <span class=\"comment\"># 32 bits interger min  </span></span><br><span class=\"line\">    MIN = <span class=\"number\">0x80000000</span>  <span class=\"comment\"># -2**31</span></span><br><span class=\"line\">    <span class=\"comment\"># mask to get last 32 bits</span></span><br><span class=\"line\">    mask = <span class=\"number\">0xFFFFFFFF</span>  <span class=\"comment\"># 2*32-1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> b != <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"comment\"># ^ get different bits and &amp; gets double 1s, &lt;&lt; moves carry</span></span><br><span class=\"line\">        a, b = (a ^ b) &amp; mask, ((a &amp; b) &lt;&lt; <span class=\"number\">1</span>) &amp; mask</span><br><span class=\"line\">    <span class=\"comment\"># if a is negative, get a's 32 bits complement positive first</span></span><br><span class=\"line\">    <span class=\"comment\"># then get 32-bit positive's Python complement negative</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a <span class=\"keyword\">if</span> a &lt;= MAX <span class=\"keyword\">else</span> ~(a ^ mask)</span><br></pre></td></tr></table></figure>\n<p>或者可以将其转成32位整数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getSum</span><span class=\"params\">(self, a, b)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> b != <span class=\"number\">0</span>:</span><br><span class=\"line\">            a, b = np.int32(a ^ b), np.int32((a &amp; b) &lt;&lt; <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> int(a)</span><br></pre></td></tr></table></figure>\n<h3 id=\"66-构建乘积数组\"><a href=\"#66-构建乘积数组\" class=\"headerlink\" title=\"66 构建乘积数组\"></a>66 构建乘积数组</h3><h4 id=\"LeetCode传送门-40\"><a href=\"#LeetCode传送门-40\" class=\"headerlink\" title=\"LeetCode传送门\"></a><a href=\"https://leetcode.com/problems/product-of-array-except-self/\" target=\"_blank\" rel=\"noopener\">LeetCode传送门</a></h4><p>思路：不能使用除法。如书中所说，以i为分割点，将B拆成C，D两部分，左边是<code>A[0] x A[1] x...x A[i-1]</code>右边则为<code>A[i+1] x ...x A[n-1]</code> ，C[i] = C[i-1] * A[i-1]</p>\n<p>方法一：这里生成器没法直接使用<code>reversed</code>，否则能达到<code>O(1)</code>的空间复杂度。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">constructArr</span><span class=\"params\">(self, a: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    right = list(accumulate([<span class=\"number\">1</span>]+a, mul))        </span><br><span class=\"line\">    left = list(accumulate([<span class=\"number\">1</span>]+a[::<span class=\"number\">-1</span>], mul))[::<span class=\"number\">-1</span>]</span><br><span class=\"line\">    <span class=\"comment\"># right:      1  , 1 , 2 ,  6, 24, 120</span></span><br><span class=\"line\">    <span class=\"comment\"># left:  120, 120, 60, 20,  5,  1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [a*b <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> zip(right, left[<span class=\"number\">1</span>:])]</span><br></pre></td></tr></table></figure>\n<p>方法二：</p>\n<p>不使用标准库的方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">multiply</span><span class=\"params\">(self, A)</span>:</span></span><br><span class=\"line\">    C = [<span class=\"number\">1</span>] <span class=\"comment\"># 第一个元素相当于没有</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(A)<span class=\"number\">-1</span>):</span><br><span class=\"line\">        C.append(C[<span class=\"number\">-1</span>] * A[i])</span><br><span class=\"line\">    D = [<span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(A)<span class=\"number\">-1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">        D.append(D[<span class=\"number\">-1</span>] * A[j])</span><br><span class=\"line\">    D.reverse()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [C[i] * D[i] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(A))]</span><br></pre></td></tr></table></figure>\n<p>方法三：O(n)时间，O(1)空间。</p>\n","categories":["算法"],"tags":["Python","Algorithm","剑指Offer"]},{"title":"LeetCode算法题整理（图篇）Graph","url":"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%9B%BE%E7%AF%87%EF%BC%89Graph/","content":"<h3 id=\"990-Satisfiability-of-Equality-Equations\"><a href=\"#990-Satisfiability-of-Equality-Equations\" class=\"headerlink\" title=\"990. Satisfiability of Equality Equations\"></a>990. Satisfiability of Equality Equations</h3><h4 id=\"满足所有方程式，判断是否存在变量的值满足所有的等式与不等式。原题\"><a href=\"#满足所有方程式，判断是否存在变量的值满足所有的等式与不等式。原题\" class=\"headerlink\" title=\"满足所有方程式，判断是否存在变量的值满足所有的等式与不等式。原题\"></a>满足所有方程式，判断是否存在变量的值满足所有的等式与不等式。<a href=\"https://leetcode.com/problems/satisfiability-of-equality-equations/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>解析：所有的相等的点，在图中是联通的。</p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [&quot;a&#x3D;&#x3D;b&quot;,&quot;b!&#x3D;a&quot;]</span><br><span class=\"line\">Output: false</span><br><span class=\"line\">Explanation: If we assign say, a &#x3D; 1 and b &#x3D; 1, then the first equation is satisfied, but not the second.  There is no way to assign the variables to satisfy both equations.</span><br><span class=\"line\"></span><br><span class=\"line\">Input: [&quot;a&#x3D;&#x3D;b&quot;,&quot;b&#x3D;&#x3D;c&quot;,&quot;a&#x3D;&#x3D;c&quot;]</span><br><span class=\"line\">Output: true</span><br><span class=\"line\"></span><br><span class=\"line\">Input: [&quot;a&#x3D;&#x3D;b&quot;,&quot;b!&#x3D;c&quot;,&quot;c&#x3D;&#x3D;a&quot;]</span><br><span class=\"line\">Output: false</span><br></pre></td></tr></table></figure>\n<p>方法一：set.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">equationsPossible</span><span class=\"params\">(self, equations: <span class=\"string\">'List[str]'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\">    equals = []</span><br><span class=\"line\">    equations.sort(key=operator.itemgetter(<span class=\"number\">1</span>), reverse=<span class=\"literal\">True</span>)</span><br><span class=\"line\">    <span class=\"comment\"># print(equations)</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> x, e, _, y  <span class=\"keyword\">in</span> equations:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> e == <span class=\"string\">'='</span>:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i, eq <span class=\"keyword\">in</span> enumerate(equals):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> x <span class=\"keyword\">in</span> eq <span class=\"keyword\">or</span> y <span class=\"keyword\">in</span> eq:</span><br><span class=\"line\">                    equals[i].update(&#123;x, y&#125;)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                equals.append(&#123;x, y&#125;)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> x == y:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> eq <span class=\"keyword\">in</span> equals:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> x <span class=\"keyword\">in</span> eq <span class=\"keyword\">and</span> y <span class=\"keyword\">in</span> eq:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"comment\"># print(equals)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：union find. 并查集。find方法可以想象成一个链表，返回的是链表末尾key,val相等的元素。同时建立连接关系。如<code>a==b, b==c</code>时<code>fc={&#39;a&#39;: &#39;b&#39;, &#39;b&#39;: &#39;c&#39;, &#39;c&#39;: &#39;c&#39;}</code>比较<code>a!=c</code>时就会最终找到<code>fc[&#39;a&#39;] == &#39;c&#39;</code>；如<code>a==b, c==a时，fc={&#39;a&#39;: &#39;b&#39;, &#39;b&#39;: &#39;b&#39;, &#39;c&#39;: &#39;b&#39;}</code>。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">equationsPossible</span><span class=\"params\">(self, equations: <span class=\"string\">'List[str]'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\">    equations.sort(key=<span class=\"keyword\">lambda</span> e: e[<span class=\"number\">1</span>] == <span class=\"string\">'!'</span>)</span><br><span class=\"line\">    uf = &#123;a: a <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> string.ascii_lowercase&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">find</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> x != uf[x]: </span><br><span class=\"line\">            uf[x] = find(uf[x])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> uf[x]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> a, e, _, b <span class=\"keyword\">in</span> equations:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> e == <span class=\"string\">\"=\"</span>:</span><br><span class=\"line\">            uf[find(a)] = find(b)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> find(a) == find(b):</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"997-Find-the-Town-Judge\"><a href=\"#997-Find-the-Town-Judge\" class=\"headerlink\" title=\"997. Find the Town Judge\"></a>997. Find the Town Judge</h3><h4 id=\"找到小镇审判长。审判长被除自己以外的所有人信任，并且不信任任何人。根据信任列表找出审判长。原题\"><a href=\"#找到小镇审判长。审判长被除自己以外的所有人信任，并且不信任任何人。根据信任列表找出审判长。原题\" class=\"headerlink\" title=\"找到小镇审判长。审判长被除自己以外的所有人信任，并且不信任任何人。根据信任列表找出审判长。原题\"></a>找到小镇审判长。审判长被除自己以外的所有人信任，并且不信任任何人。根据信任列表找出审判长。<a href=\"https://leetcode.com/problems/find-the-town-judge/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: N &#x3D; 4, trust &#x3D; [[1,3],[1,4],[2,3],[2,4],[4,3]]</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Input: N &#x3D; 3, trust &#x3D; [[1,3],[2,3],[3,1]]</span><br><span class=\"line\">Output: -1</span><br><span class=\"line\">Input: N &#x3D; 3, trust &#x3D; [[1,3],[2,3]]</span><br><span class=\"line\">Output: 3</span><br></pre></td></tr></table></figure>\n<p>方法一：brute force.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findJudge</span><span class=\"params\">(self, N: int, trust: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> trust:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> N</span><br><span class=\"line\">    a, b = zip(*trust)           </span><br><span class=\"line\">    candidates = collections.Counter(b)</span><br><span class=\"line\">    villages = set(a)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> c, votes <span class=\"keyword\">in</span> candidates.most_common():</span><br><span class=\"line\">        <span class=\"keyword\">if</span> votes &lt; N - <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> c <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> villages:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> c</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：定向图。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findJudge</span><span class=\"params\">(self, N: int, trust: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    count = [<span class=\"number\">0</span>] * (N + <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, j <span class=\"keyword\">in</span> trust:</span><br><span class=\"line\">        count[i] -= <span class=\"number\">1</span></span><br><span class=\"line\">        count[j] += <span class=\"number\">1</span></span><br><span class=\"line\">        print(count)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, N + <span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> count[i] == N - <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> i</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"133-Clone-Graph\"><a href=\"#133-Clone-Graph\" class=\"headerlink\" title=\"133. Clone Graph\"></a>133. Clone Graph</h3><h4 id=\"深拷贝一个简单环。原题\"><a href=\"#深拷贝一个简单环。原题\" class=\"headerlink\" title=\"深拷贝一个简单环。原题\"></a>深拷贝一个简单环。<a href=\"https://leetcode.com/problems/clone-graph/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><img src=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%9B%BE%E7%AF%87%EF%BC%89Graph/113_sample.png\" class>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">cloneGraph</span><span class=\"params\">(self, node: <span class=\"string\">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class=\"line\">    cp = collections.defaultdict(<span class=\"keyword\">lambda</span>: Node(<span class=\"number\">0</span>, []))</span><br><span class=\"line\">    nodes = [node]</span><br><span class=\"line\">    seen = set()</span><br><span class=\"line\">    <span class=\"keyword\">while</span> nodes:</span><br><span class=\"line\">        n = nodes.pop()</span><br><span class=\"line\">        cp[n].val = n.val</span><br><span class=\"line\">        cp[n].neighbors = [cp[x] <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> n.neighbors]</span><br><span class=\"line\">        nodes.extend(x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> n.neighbors <span class=\"keyword\">if</span> x <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> seen)</span><br><span class=\"line\">        seen.add(n)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cp[node]</span><br></pre></td></tr></table></figure>\n<h3 id=\"1334-Find-the-City-With-the-Smallest-Number-of-Neighbors-at-a-Threshold-Distance\"><a href=\"#1334-Find-the-City-With-the-Smallest-Number-of-Neighbors-at-a-Threshold-Distance\" class=\"headerlink\" title=\"1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance\"></a>1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance</h3><h4 id=\"找到距离范围内邻居最少的城市。原题\"><a href=\"#找到距离范围内邻居最少的城市。原题\" class=\"headerlink\" title=\"找到距离范围内邻居最少的城市。原题\"></a>找到距离范围内邻居最少的城市。<a href=\"https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><img src=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%9B%BE%E7%AF%87%EF%BC%89Graph/1334.png\" class>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 4, edges &#x3D; [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold &#x3D; 4</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: The figure above describes the graph. </span><br><span class=\"line\">The neighboring cities at a distanceThreshold &#x3D; 4 for each city are:</span><br><span class=\"line\">City 0 -&gt; [City 1, City 2] </span><br><span class=\"line\">City 1 -&gt; [City 0, City 2, City 3] </span><br><span class=\"line\">City 2 -&gt; [City 0, City 1, City 3] </span><br><span class=\"line\">City 3 -&gt; [City 1, City 2] </span><br><span class=\"line\">Cities 0 and 3 have 2 neighboring cities at a distanceThreshold &#x3D; 4, but we have to return city 3 since it has the greatest number.</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法一：狄克斯特拉算法。这里没想到用一个堆来维持最小的距离。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findTheCity</span><span class=\"params\">(self, n: int, edges: List[List[int]], distanceThreshold: int)</span> -&gt; int:</span></span><br><span class=\"line\">    g = collections.defaultdict(list)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> u, v, w <span class=\"keyword\">in</span> edges:</span><br><span class=\"line\">        g[u].append((v, w))</span><br><span class=\"line\">        g[v].append((u, w))</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">count_neighbor</span><span class=\"params\">(city)</span>:</span></span><br><span class=\"line\">        heap = [(<span class=\"number\">0</span>, city)]</span><br><span class=\"line\">        dist = &#123;&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> heap:</span><br><span class=\"line\">            cur_w, u = heapq.heappop(heap)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> u <span class=\"keyword\">in</span> dist:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> u != city:</span><br><span class=\"line\">                dist[u] = cur_w</span><br><span class=\"line\">            <span class=\"keyword\">for</span> v, w <span class=\"keyword\">in</span> g[u]:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> v <span class=\"keyword\">in</span> dist:</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> cur_w + w &lt;= distanceThreshold:</span><br><span class=\"line\">                    heapq.heappush(heap, (cur_w+w, v))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> len(dist)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> min(range(n), key=<span class=\"keyword\">lambda</span> x: (count_neighbor(x), -x))</span><br></pre></td></tr></table></figure>\n<p>方法二：弗洛伊德算法，这个时间复杂度为O(N^3)，space: O(N^2)但是代码简单。把每个节点当成中转点k，如果<code>dis[i][j] &gt; dis[i][k] + dis[k][j]</code>说明从k走，i, j距离更短。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findTheCity</span><span class=\"params\">(self, n: int, edges: List[List[int]], maxd: int)</span> -&gt; int:</span></span><br><span class=\"line\">    dis = [[float(<span class=\"string\">'inf'</span>)] * n <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, j, w <span class=\"keyword\">in</span> edges:</span><br><span class=\"line\">        dis[i][j] = dis[j][i] = w</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">        dis[i][i] = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">                dis[i][j] = min(dis[i][j], dis[i][k]+dis[k][j])</span><br><span class=\"line\">    ans = &#123;sum(d&lt;=maxd <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> dis[i]): i <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n)&#125;  <span class=\"comment\"># 这里id大的会将小的覆盖</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans[min(ans)]</span><br></pre></td></tr></table></figure>\n<h3 id=\"1267-Count-Servers-that-Communicate\"><a href=\"#1267-Count-Servers-that-Communicate\" class=\"headerlink\" title=\"1267. Count Servers that Communicate\"></a>1267. Count Servers that Communicate</h3><h4 id=\"找到2个以上的服务器连接个数，服务器可以在一行或是一列算是连接上。原题\"><a href=\"#找到2个以上的服务器连接个数，服务器可以在一行或是一列算是连接上。原题\" class=\"headerlink\" title=\"找到2个以上的服务器连接个数，服务器可以在一行或是一列算是连接上。原题\"></a>找到2个以上的服务器连接个数，服务器可以在一行或是一列算是连接上。<a href=\"https://leetcode.com/problems/count-servers-that-communicate/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: grid &#x3D; [[1,1,0,0],[0,0,1,0],[0,0,1,0],[0,0,0,1]]</span><br><span class=\"line\">Output: 4</span><br><span class=\"line\">Explanation: The two servers in the first row can communicate with each other. The two servers in the third column can communicate with each other. The server at right bottom corner can&#39;t communicate with any other server.</span><br></pre></td></tr></table></figure>\n<p>方法一：和小岛问题不同，这个服务器可以隔空连接，AC时用的dfs方法，效率非常慢。实际上只需要记录横纵左边即可，遍历两次</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countServers</span><span class=\"params\">(self, g: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    X, Y = [<span class=\"number\">0</span>]*<span class=\"number\">300</span>, [<span class=\"number\">0</span>]*<span class=\"number\">300</span></span><br><span class=\"line\">    m, n = len(g), len(g[<span class=\"number\">0</span>])</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            X[i] += g[i][j]</span><br><span class=\"line\">            Y[j] += g[i][j]</span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> g[i][j]==<span class=\"number\">1</span> <span class=\"keyword\">and</span> (X[i]&gt;<span class=\"number\">1</span> <span class=\"keyword\">or</span> Y[j]&gt;<span class=\"number\">1</span>):</span><br><span class=\"line\">                ans += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：行列累计求和，但是只是用来判断而不是累加，然后遍历所有的元素。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countServers</span><span class=\"params\">(self, g: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    X, Y = tuple(map(sum, g)), tuple(map(sum, zip(*g)))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(X[i]+Y[j]&gt;<span class=\"number\">2</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(g)) <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(g[<span class=\"number\">0</span>])) <span class=\"keyword\">if</span> g[i][j])</span><br></pre></td></tr></table></figure>\n<h3 id=\"886-Possible-Bipartition\"><a href=\"#886-Possible-Bipartition\" class=\"headerlink\" title=\"886. Possible Bipartition\"></a>886. Possible Bipartition</h3><h4 id=\"将不喜欢的人放在两组中，根据关系是否能将其分为2组。原题\"><a href=\"#将不喜欢的人放在两组中，根据关系是否能将其分为2组。原题\" class=\"headerlink\" title=\"将不喜欢的人放在两组中，根据关系是否能将其分为2组。原题\"></a>将不喜欢的人放在两组中，根据关系是否能将其分为2组。<a href=\"https://leetcode.com/problems/possible-bipartition/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: N &#x3D; 4, dislikes &#x3D; [[1,2],[1,3],[2,4]]</span><br><span class=\"line\">Output: true</span><br><span class=\"line\">Explanation: group1 [1,4], group2 [2,3]</span><br><span class=\"line\"></span><br><span class=\"line\">Input: N &#x3D; 3, dislikes &#x3D; [[1,2],[1,3],[2,3]]</span><br><span class=\"line\">Output: false</span><br></pre></td></tr></table></figure>\n<p>方法一：dfs。此题想了半个多点才想明白，等同于在一个无向图中，寻找一个奇数边的环。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">possibleBipartition</span><span class=\"params\">(self, N: int, dislikes: List[List[int]])</span> -&gt; bool:</span></span><br><span class=\"line\">    g = [[] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(N+<span class=\"number\">1</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> dislikes:</span><br><span class=\"line\">        g[a].append(b)</span><br><span class=\"line\">        g[b].append(a)</span><br><span class=\"line\"></span><br><span class=\"line\">    seen = set()</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(i, p, p_len)</span>:</span></span><br><span class=\"line\">        seen.add(i)</span><br><span class=\"line\">        p[i] = p_len</span><br><span class=\"line\">        <span class=\"keyword\">for</span> nxt <span class=\"keyword\">in</span> g[i]:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nxt <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> seen:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> dfs(nxt, p, p_len+<span class=\"number\">1</span>):</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> nxt <span class=\"keyword\">in</span> p <span class=\"keyword\">and</span> (p_len-p[nxt])&amp;<span class=\"number\">1</span>==<span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        p.pop(i)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">    p = &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, N+<span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> seen <span class=\"keyword\">and</span> dfs(i, p, <span class=\"number\">0</span>):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<p>方法二：染色思想。0代表红色，1代表蓝色，每次将其不喜欢的人染成另一种颜色。这个代码比较简洁，不过稍微慢了一丢丢，50ms左右。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">possibleBipartition</span><span class=\"params\">(self, N: int, dislikes: List[List[int]])</span> -&gt; bool:</span></span><br><span class=\"line\">    g = [[] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(N+<span class=\"number\">1</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> dislikes:</span><br><span class=\"line\">        g[a].append(b)</span><br><span class=\"line\">        g[b].append(a)</span><br><span class=\"line\">    </span><br><span class=\"line\">    color = &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(i, c=<span class=\"number\">0</span>)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i <span class=\"keyword\">in</span> color:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> color[i]==c</span><br><span class=\"line\">        color[i] = c</span><br><span class=\"line\">        <span class=\"keyword\">return</span> all(dfs(j, c^<span class=\"number\">1</span>) <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> g[i])</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> all(dfs(i) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, N+<span class=\"number\">1</span>) </span><br><span class=\"line\">               <span class=\"keyword\">if</span> i <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> color)</span><br></pre></td></tr></table></figure>\n<h3 id=\"207-Course-Schedule\"><a href=\"#207-Course-Schedule\" class=\"headerlink\" title=\"207. Course Schedule\"></a>207. Course Schedule</h3><h4 id=\"课程调度，课程有依赖关系，问是否能完成所有的课程。原题\"><a href=\"#课程调度，课程有依赖关系，问是否能完成所有的课程。原题\" class=\"headerlink\" title=\"课程调度，课程有依赖关系，问是否能完成所有的课程。原题\"></a>课程调度，课程有依赖关系，问是否能完成所有的课程。<a href=\"https://leetcode.com/problems/course-schedule/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: numCourses &#x3D; 2, prerequisites &#x3D; [[1,0]]</span><br><span class=\"line\">Output: true</span><br><span class=\"line\">Explanation: There are a total of 2 courses to take. </span><br><span class=\"line\">             To take course 1 you should have finished course 0. So it is possible.</span><br></pre></td></tr></table></figure>\n<p>方法一：dfs。注意这里状态要用3中，1表示遍历过，-1表示正在遍历，0表未遍历。这样可以避免重复的遍历。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">canFinish</span><span class=\"params\">(self, n: int, prerequisites: List[List[int]])</span> -&gt; bool:</span></span><br><span class=\"line\">    g = [[] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> prerequisites:</span><br><span class=\"line\">        g[a].append(b)</span><br><span class=\"line\">        </span><br><span class=\"line\">    seen = [<span class=\"number\">0</span>] * n</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(i)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> seen[i] <span class=\"keyword\">in</span> &#123;<span class=\"number\">1</span>, <span class=\"number\">-1</span>&#125;: <span class=\"keyword\">return</span> seen[i]==<span class=\"number\">1</span></span><br><span class=\"line\">        seen[i] = <span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> any(<span class=\"keyword\">not</span> dfs(j) <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> g[i]): <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        seen[i] = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：这个方法优雅一点，来自Lee215. BFS Topological Sorting.</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">canFinish</span><span class=\"params\">(self, n: int, prerequisites: List[List[int]])</span> -&gt; bool:</span></span><br><span class=\"line\">    g = collections.defaultdict(list)</span><br><span class=\"line\">    degree = [<span class=\"number\">0</span>] * n</span><br><span class=\"line\">    <span class=\"keyword\">for</span> u, v <span class=\"keyword\">in</span> prerequisites:</span><br><span class=\"line\">        g[v].append(u)</span><br><span class=\"line\">        degree[u] -= <span class=\"number\">1</span></span><br><span class=\"line\">    bfs = [i <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n) <span class=\"keyword\">if</span> degree[i]==<span class=\"number\">0</span>]    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> bfs:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> g[i]:</span><br><span class=\"line\">            degree[j] += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> degree[j] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                bfs.append(j)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> len(bfs)==n</span><br></pre></td></tr></table></figure>\n<h3 id=\"1462-Course-Schedule-IV\"><a href=\"#1462-Course-Schedule-IV\" class=\"headerlink\" title=\"1462. Course Schedule IV\"></a>1462. Course Schedule IV</h3><h4 id=\"和上题差不多，问题不一样，问的是根据给定的依赖关系，判断两节课是否有依赖。原题\"><a href=\"#和上题差不多，问题不一样，问的是根据给定的依赖关系，判断两节课是否有依赖。原题\" class=\"headerlink\" title=\"和上题差不多，问题不一样，问的是根据给定的依赖关系，判断两节课是否有依赖。原题\"></a>和上题差不多，问题不一样，问的是根据给定的依赖关系，判断两节课是否有依赖。<a href=\"https://leetcode.com/problems/course-schedule-iv/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><font color=\"#32CD32\" size=\"3\">方法一：dfs. 这个方法想了超出比赛时间限制了。但是也没过多久就优化 出来了。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">checkIfPrerequisite</span><span class=\"params\">(self, n: int, prerequisites: List[List[int]], queries: List[List[int]])</span> -&gt; List[bool]:</span></span><br><span class=\"line\">    g = [[] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">    q = [set() <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)]         </span><br><span class=\"line\">    <span class=\"keyword\">for</span> u, v <span class=\"keyword\">in</span> prerequisites:</span><br><span class=\"line\">        g[u].append(v)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(i)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> q[i]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> q[i]</span><br><span class=\"line\">        q[i].update(g[i])</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> g[i]:</span><br><span class=\"line\">            q[i].update(dfs(j))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> q[i]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">        dfs(i)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [b <span class=\"keyword\">in</span> q[a] <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> queries]</span><br></pre></td></tr></table></figure>\n<p>方法二：弗洛伊德算法，和求城市最小距离一样。时间复杂度是O(n3)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">checkIfPrerequisite</span><span class=\"params\">(self, n: int, prerequisites: List[List[int]], queries: List[List[int]])</span> -&gt; List[bool]:</span></span><br><span class=\"line\">    g = [[<span class=\"literal\">False</span>]*n <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> u, v <span class=\"keyword\">in</span> prerequisites:</span><br><span class=\"line\">        g[u][v] = <span class=\"literal\">True</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">                g[i][j] = g[i][j] <span class=\"keyword\">or</span> (g[i][k] <span class=\"keyword\">and</span> g[k][j])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [g[i][j] <span class=\"keyword\">for</span> i, j <span class=\"keyword\">in</span> queries]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：bfs. 拓扑排序。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">checkIfPrerequisite</span><span class=\"params\">(self, n: int, prerequisites: List[List[int]], queries: List[List[int]])</span> -&gt; List[bool]:</span></span><br><span class=\"line\">    g = collections.defaultdict(list)</span><br><span class=\"line\">    degree = [<span class=\"number\">0</span>] * n</span><br><span class=\"line\">    pres = [set() <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> u, v <span class=\"keyword\">in</span> prerequisites:</span><br><span class=\"line\">        g[u].append(v)</span><br><span class=\"line\">        degree[v] -= <span class=\"number\">1</span></span><br><span class=\"line\">        pres[v].add(u)</span><br><span class=\"line\">    bfs = [i <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n) <span class=\"keyword\">if</span> degree[i]==<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> bfs:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> g[i]:</span><br><span class=\"line\">            degree[j] += <span class=\"number\">1</span></span><br><span class=\"line\">            pres[j] |= pres[i]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> degree[j] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                bfs.append(j)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [a <span class=\"keyword\">in</span> pres[b] <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> queries]</span><br></pre></td></tr></table></figure>\n<h3 id=\"1466-Reorder-Routes-to-Make-All-Paths-Lead-to-the-City-Zero\"><a href=\"#1466-Reorder-Routes-to-Make-All-Paths-Lead-to-the-City-Zero\" class=\"headerlink\" title=\"1466. Reorder Routes to Make All Paths Lead to the City Zero\"></a>1466. Reorder Routes to Make All Paths Lead to the City Zero</h3><h4 id=\"有一个有向图，两个节点之间只有一条边，要求所有的边指向0，需要改多少条边的方向。原题\"><a href=\"#有一个有向图，两个节点之间只有一条边，要求所有的边指向0，需要改多少条边的方向。原题\" class=\"headerlink\" title=\"有一个有向图，两个节点之间只有一条边，要求所有的边指向0，需要改多少条边的方向。原题\"></a>有一个有向图，两个节点之间只有一条边，要求所有的边指向0，需要改多少条边的方向。<a href=\"https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 6, connections &#x3D; [[0,1],[1,3],[2,3],[4,0],[4,5]]</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: Change the direction of edges show in red such that each node can reach the node 0 (capital).</span><br></pre></td></tr></table></figure>\n<p>方法一：此题竞赛时未作出。一个效率不是很高的方法。用父节点去重。set记录原始顺序，遍历无向图。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minReorder</span><span class=\"params\">(self, n: int, connections: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    self.ans = <span class=\"number\">0</span></span><br><span class=\"line\">    g = collections.defaultdict(list)</span><br><span class=\"line\">    roads = set()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> u, v <span class=\"keyword\">in</span> connections:</span><br><span class=\"line\">        g[u].append(v)</span><br><span class=\"line\">        g[v].append(u)</span><br><span class=\"line\">        roads.add((u, v))</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(i, parent)</span>:</span></span><br><span class=\"line\">        self.ans += (parent, i) <span class=\"keyword\">in</span> roads</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> g[i]:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> j == parent:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            dfs(j, i)</span><br><span class=\"line\">    </span><br><span class=\"line\">    dfs(<span class=\"number\">0</span>, <span class=\"number\">-1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.ans</span><br></pre></td></tr></table></figure>\n<p>方法二：比赛时想的思路，dfs内容未想出来。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minReorder</span><span class=\"params\">(self, n: int, connections: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    g1 = collections.defaultdict(list)</span><br><span class=\"line\">    g2 = collections.defaultdict(list)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> u, v <span class=\"keyword\">in</span> connections:</span><br><span class=\"line\">        g1[u].append(v)</span><br><span class=\"line\">        g2[v].append(u)</span><br><span class=\"line\">    </span><br><span class=\"line\">    seen = set()</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(i)</span>:</span></span><br><span class=\"line\">        seen.add(i)</span><br><span class=\"line\">        ans = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> g1[i]:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> j <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> seen:</span><br><span class=\"line\">                ans += <span class=\"number\">1</span> + dfs(j)</span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> g2[i]:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> k <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> seen:</span><br><span class=\"line\">                ans += dfs(k)</span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dfs(<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"1210-Minimum-Moves-to-Reach-Target-with-Rotations\"><a href=\"#1210-Minimum-Moves-to-Reach-Target-with-Rotations\" class=\"headerlink\" title=\"1210. Minimum Moves to Reach Target with Rotations\"></a>1210. Minimum Moves to Reach Target with Rotations</h3><h4 id=\"一个占位2格的蛇，从左上走到右下需要最少的步数，可以旋转。原题\"><a href=\"#一个占位2格的蛇，从左上走到右下需要最少的步数，可以旋转。原题\" class=\"headerlink\" title=\"一个占位2格的蛇，从左上走到右下需要最少的步数，可以旋转。原题\"></a>一个占位2格的蛇，从左上走到右下需要最少的步数，可以旋转。<a href=\"https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: grid &#x3D; [[0,0,0,0,0,1],</span><br><span class=\"line\">               [1,1,0,0,1,0],</span><br><span class=\"line\">               [0,0,0,0,1,1],</span><br><span class=\"line\">               [0,0,1,0,1,0],</span><br><span class=\"line\">               [0,1,1,0,0,0],</span><br><span class=\"line\">               [0,1,1,0,0,0]]</span><br><span class=\"line\">Output: 11</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">One possible solution is [right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise, right, down].</span><br></pre></td></tr></table></figure>\n<p>方法一：这题没想到在写完还有10分钟，其实思路很简单，就是拿两个点当成一个点。一个点的bfs就很容易了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minimumMoves</span><span class=\"params\">(self, g: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    n = len(g)</span><br><span class=\"line\">    q = collections.deque([((<span class=\"number\">0</span>, <span class=\"number\">0</span>), (<span class=\"number\">0</span>, <span class=\"number\">1</span>), <span class=\"number\">0</span>)])</span><br><span class=\"line\">    seen = set(((<span class=\"number\">0</span>, <span class=\"number\">0</span>), (<span class=\"number\">0</span>, <span class=\"number\">1</span>)))</span><br><span class=\"line\">    <span class=\"keyword\">while</span> q:</span><br><span class=\"line\">        tail, head, step = q.popleft()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> tail[<span class=\"number\">0</span>] == head[<span class=\"number\">0</span>] == head[<span class=\"number\">1</span>] == n<span class=\"number\">-1</span> <span class=\"keyword\">and</span> tail[<span class=\"number\">1</span>]==n<span class=\"number\">-2</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> step</span><br><span class=\"line\">        <span class=\"keyword\">if</span> tail[<span class=\"number\">0</span>] == head[<span class=\"number\">0</span>] <span class=\"keyword\">and</span> tail[<span class=\"number\">0</span>]!=n<span class=\"number\">-1</span>: <span class=\"comment\"># horizontal</span></span><br><span class=\"line\">            d_tail, d_head = (tail[<span class=\"number\">0</span>]+<span class=\"number\">1</span>, tail[<span class=\"number\">1</span>]), (head[<span class=\"number\">0</span>]+<span class=\"number\">1</span>, head[<span class=\"number\">1</span>])</span><br><span class=\"line\">            <span class=\"keyword\">if</span> g[d_tail[<span class=\"number\">0</span>]][d_tail[<span class=\"number\">1</span>]] == g[d_head[<span class=\"number\">0</span>]][d_head[<span class=\"number\">1</span>]] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tail, d_tail) <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> seen:</span><br><span class=\"line\">                    q.append((tail, d_tail, step+<span class=\"number\">1</span>))</span><br><span class=\"line\">                    seen.add((tail, d_tail))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> tail[<span class=\"number\">1</span>] == head[<span class=\"number\">1</span>] <span class=\"keyword\">and</span> tail[<span class=\"number\">1</span>]!=n<span class=\"number\">-1</span>: <span class=\"comment\"># vertical</span></span><br><span class=\"line\">            r_tail, r_head = (tail[<span class=\"number\">0</span>], tail[<span class=\"number\">1</span>]+<span class=\"number\">1</span>), (head[<span class=\"number\">0</span>], head[<span class=\"number\">1</span>]+<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> g[r_tail[<span class=\"number\">0</span>]][r_tail[<span class=\"number\">1</span>]] == g[r_head[<span class=\"number\">0</span>]][r_head[<span class=\"number\">1</span>]] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tail, r_tail) <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> seen:</span><br><span class=\"line\">                    q.append((tail, r_tail, step+<span class=\"number\">1</span>))</span><br><span class=\"line\">                    seen.add((tail, r_tail))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> head[<span class=\"number\">1</span>] != n<span class=\"number\">-1</span>:</span><br><span class=\"line\">            r_head = head[<span class=\"number\">0</span>], head[<span class=\"number\">1</span>]+<span class=\"number\">1</span></span><br><span class=\"line\">            r_tail = tail[<span class=\"number\">0</span>], tail[<span class=\"number\">1</span>]+<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> g[r_head[<span class=\"number\">0</span>]][r_head[<span class=\"number\">1</span>]] == g[r_tail[<span class=\"number\">0</span>]][r_tail[<span class=\"number\">1</span>]] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (r_tail, r_head) <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> seen:</span><br><span class=\"line\">                    q.append((r_tail, r_head, step+<span class=\"number\">1</span>))                    </span><br><span class=\"line\">                    seen.add((r_tail, r_head))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> head[<span class=\"number\">0</span>] != n<span class=\"number\">-1</span>:</span><br><span class=\"line\">            d_head = head[<span class=\"number\">0</span>]+<span class=\"number\">1</span>, head[<span class=\"number\">1</span>]</span><br><span class=\"line\">            d_tail = tail[<span class=\"number\">0</span>]+<span class=\"number\">1</span>, tail[<span class=\"number\">1</span>]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> g[d_head[<span class=\"number\">0</span>]][d_head[<span class=\"number\">1</span>]] == g[d_tail[<span class=\"number\">0</span>]][d_tail[<span class=\"number\">1</span>]] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (d_tail, d_head) <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> seen:</span><br><span class=\"line\">                    q.append((d_tail, d_head, step+<span class=\"number\">1</span>))</span><br><span class=\"line\">                    seen.add((d_tail, d_head))</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：另一种思路将蛇的横竖状态记录，这样一个点也能表示。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minimumMoves</span><span class=\"params\">(self, g: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    n = len(g)</span><br><span class=\"line\">    q, seen, target = [(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>)], set(), (n<span class=\"number\">-1</span>, n<span class=\"number\">-2</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> r, c, dr, step <span class=\"keyword\">in</span> q:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r, c, dr) == target: <span class=\"keyword\">return</span> step</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r, c, dr) <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> seen:</span><br><span class=\"line\">            seen.add((r, c, dr))</span><br><span class=\"line\">            <span class=\"keyword\">if</span> dr:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> c+<span class=\"number\">1</span>&lt;n <span class=\"keyword\">and</span> g[r][c+<span class=\"number\">1</span>]==g[r+<span class=\"number\">1</span>][c+<span class=\"number\">1</span>]==<span class=\"number\">0</span>:</span><br><span class=\"line\">                    q += [(r, c+<span class=\"number\">1</span>, <span class=\"number\">1</span>, step+<span class=\"number\">1</span>), (r, c, <span class=\"number\">0</span>, step+<span class=\"number\">1</span>)]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> r+<span class=\"number\">2</span>&lt;n <span class=\"keyword\">and</span> g[r+<span class=\"number\">2</span>][c]==<span class=\"number\">0</span>:</span><br><span class=\"line\">                    q += [(r+<span class=\"number\">1</span>, c, <span class=\"number\">1</span>, step+<span class=\"number\">1</span>)]</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> r+<span class=\"number\">1</span>&lt;n <span class=\"keyword\">and</span> g[r+<span class=\"number\">1</span>][c]==g[r+<span class=\"number\">1</span>][c+<span class=\"number\">1</span>]==<span class=\"number\">0</span>:</span><br><span class=\"line\">                    q += [(r+<span class=\"number\">1</span>, c, <span class=\"number\">0</span>, step+<span class=\"number\">1</span>), (r, c, <span class=\"number\">1</span>, step+<span class=\"number\">1</span>)]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> c+<span class=\"number\">2</span>&lt;n <span class=\"keyword\">and</span> g[r][c+<span class=\"number\">2</span>]==<span class=\"number\">0</span>:</span><br><span class=\"line\">                    q += [(r, c+<span class=\"number\">1</span>, <span class=\"number\">0</span>, step+<span class=\"number\">1</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1202-Smallest-String-With-Swaps\"><a href=\"#1202-Smallest-String-With-Swaps\" class=\"headerlink\" title=\"1202. Smallest String With Swaps\"></a>1202. Smallest String With Swaps</h3><h4 id=\"给定一组pairs表明索引对可以互换，求这个字符串能换的最小值时多少，同一对可以进行多次互换。原题\"><a href=\"#给定一组pairs表明索引对可以互换，求这个字符串能换的最小值时多少，同一对可以进行多次互换。原题\" class=\"headerlink\" title=\"给定一组pairs表明索引对可以互换，求这个字符串能换的最小值时多少，同一对可以进行多次互换。原题\"></a>给定一组pairs表明索引对可以互换，求这个字符串能换的最小值时多少，同一对可以进行多次互换。<a href=\"https://leetcode.com/problems/smallest-string-with-swaps/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;dcab&quot;, pairs &#x3D; [[0,3],[1,2]]</span><br><span class=\"line\">Output: &quot;bacd&quot;</span><br><span class=\"line\">Explaination: </span><br><span class=\"line\">Swap s[0] and s[3], s &#x3D; &quot;bcad&quot;</span><br><span class=\"line\">Swap s[1] and s[2], s &#x3D; &quot;bacd&quot;</span><br></pre></td></tr></table></figure>\n<p>方法一：看了几个例子想一想就明白了，实际上是一道连通器的题，将连通的索引单独排序就是最小的值。</p>\n<p>竞赛时ac的方法用的是dfs. 内存用的有点多。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">smallestStringWithSwaps</span><span class=\"params\">(self, s: str, pairs: List[List[int]])</span> -&gt; str:</span></span><br><span class=\"line\">    g = [[] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(len(s))]</span><br><span class=\"line\">    ans = [<span class=\"string\">''</span>] * len(s)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> pairs:</span><br><span class=\"line\">        g[a].append(b)</span><br><span class=\"line\">        g[b].append(a)</span><br><span class=\"line\">    </span><br><span class=\"line\">    seen = [<span class=\"literal\">False</span>] * len(s)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(i, p)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> seen[i]:</span><br><span class=\"line\">            seen[i] = <span class=\"literal\">True</span></span><br><span class=\"line\">            p.append(i)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> g[i]:</span><br><span class=\"line\">                dfs(j, p)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> p</span><br><span class=\"line\">    </span><br><span class=\"line\">    groups = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(s)):</span><br><span class=\"line\">        tmp = dfs(i, [])</span><br><span class=\"line\">        <span class=\"keyword\">if</span> tmp:</span><br><span class=\"line\">            groups.append(tmp)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> idx <span class=\"keyword\">in</span> groups:</span><br><span class=\"line\">        letters = iter(sorted(s[i] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> idx))</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> sorted(idx):</span><br><span class=\"line\">            ans[i] = next(letters)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(ans)</span><br></pre></td></tr></table></figure>\n<p>方法二：做了一点优化。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">smallestStringWithSwaps</span><span class=\"params\">(self, s: str, pairs: List[List[int]])</span> -&gt; str:</span></span><br><span class=\"line\">    g = [[] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(len(s))]</span><br><span class=\"line\">    ans = [<span class=\"string\">''</span>] * len(s)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> pairs:</span><br><span class=\"line\">        g[a].append(b)</span><br><span class=\"line\">        g[b].append(a)</span><br><span class=\"line\">    </span><br><span class=\"line\">    seen = [<span class=\"literal\">False</span>] * len(s)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(i)</span>:</span></span><br><span class=\"line\">        seen[i] = <span class=\"literal\">True</span></span><br><span class=\"line\">        p.append(i)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> g[i]:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> seen[j]:</span><br><span class=\"line\">                dfs(j)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(s)):</span><br><span class=\"line\">        p = []</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> seen[i]:</span><br><span class=\"line\">            dfs(i)</span><br><span class=\"line\">        letters = iter(sorted(s[i] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> p))</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> sorted(p):</span><br><span class=\"line\">            ans[i] = next(letters)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(ans)</span><br></pre></td></tr></table></figure>\n<p>方法三：union-find。这个评论区里看到的方法写得很标准。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">smallestStringWithSwaps</span><span class=\"params\">(self, s: str, pairs: List[List[int]])</span> -&gt; str:</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UF</span>:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">            self.p = list(range(n))</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">union</span><span class=\"params\">(self, x, y)</span>:</span></span><br><span class=\"line\">            self.p[self.find(x)] = self.find(y)</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">find</span><span class=\"params\">(self, x)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> x!=self.p[x]:</span><br><span class=\"line\">                self.p[x] = self.find(self.p[x])</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.p[x]</span><br><span class=\"line\">    uf, res, m = UF(len(s)), [], defaultdict(list)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> pairs:</span><br><span class=\"line\">        uf.union(x, y)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(s)):</span><br><span class=\"line\">        m[uf.find(i)].append(s[i])</span><br><span class=\"line\">    <span class=\"keyword\">for</span> comp_id <span class=\"keyword\">in</span> m.keys(): </span><br><span class=\"line\">        m[comp_id].sort(reverse=<span class=\"literal\">True</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(s)): </span><br><span class=\"line\">        res.append(m[uf.find(i)].pop())</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(res)</span><br></pre></td></tr></table></figure>\n<p>方法四：我自己的Union-Find。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">smallestStringWithSwaps</span><span class=\"params\">(self, s: str, pairs: List[List[int]])</span> -&gt; str:</span></span><br><span class=\"line\">    N = len(s)</span><br><span class=\"line\">    res = [<span class=\"string\">''</span>] * N</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">union</span><span class=\"params\">(x, y)</span>:</span></span><br><span class=\"line\">        uf[find(x)] = find(y)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">find</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> uf[x] != x:</span><br><span class=\"line\">            uf[x] = find(uf[x])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> uf[x]</span><br><span class=\"line\"></span><br><span class=\"line\">    uf = list(range(N))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> u, v <span class=\"keyword\">in</span> pairs:</span><br><span class=\"line\">        union(u, v)</span><br><span class=\"line\"></span><br><span class=\"line\">    g = defaultdict(list)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(N):</span><br><span class=\"line\">        g[find(i)].append(i)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> indexes <span class=\"keyword\">in</span> g.values():</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, c <span class=\"keyword\">in</span> zip(sorted(indexes), sorted(map(s.__getitem__, indexes))):</span><br><span class=\"line\">            res[i] = c</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(res)</span><br></pre></td></tr></table></figure>\n<h3 id=\"787-Cheapest-Flights-Within-K-Stops\"><a href=\"#787-Cheapest-Flights-Within-K-Stops\" class=\"headerlink\" title=\"787. Cheapest Flights Within K Stops\"></a>787. Cheapest Flights Within K Stops</h3><h4 id=\"经过K个站点的最便宜的航班。原题\"><a href=\"#经过K个站点的最便宜的航班。原题\" class=\"headerlink\" title=\"经过K个站点的最便宜的航班。原题\"></a>经过K个站点的最便宜的航班。<a href=\"https://leetcode.com/problems/cheapest-flights-within-k-stops/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：狄克斯特拉算法，只不过多了一个条件，经过K个站点。不需要用seen记录已经去过的点，因为该点可能有更少步数的到达方式。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findCheapestPrice</span><span class=\"params\">(self, n: int, flights: List[List[int]], src: int, dst: int, K: int)</span> -&gt; int:</span></span><br><span class=\"line\">    g = collections.defaultdict(list)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> u, v, w <span class=\"keyword\">in</span> flights:</span><br><span class=\"line\">        g[u].append((v, w))</span><br><span class=\"line\">    </span><br><span class=\"line\">    q = [(<span class=\"number\">0</span>, src, <span class=\"number\">0</span>)]</span><br><span class=\"line\">    heapq.heapify(q)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> q:</span><br><span class=\"line\">        p, city, step = heapq.heappop(q)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> city == dst:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> p</span><br><span class=\"line\">        <span class=\"keyword\">for</span> v, w <span class=\"keyword\">in</span> g[city]:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> step &lt; K+<span class=\"number\">1</span>:</span><br><span class=\"line\">                heapq.heappush(q, (p+w, v, step+<span class=\"number\">1</span>))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"332-Reconstruct-Itinerary\"><a href=\"#332-Reconstruct-Itinerary\" class=\"headerlink\" title=\"332. Reconstruct Itinerary\"></a>332. Reconstruct Itinerary</h3><h4 id=\"重建行程，根据火车票来寻找行程，答案不唯一。原题\"><a href=\"#重建行程，根据火车票来寻找行程，答案不唯一。原题\" class=\"headerlink\" title=\"重建行程，根据火车票来寻找行程，答案不唯一。原题\"></a>重建行程，根据火车票来寻找行程，答案不唯一。<a href=\"https://leetcode.com/problems/reconstruct-itinerary/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [[&quot;MUC&quot;, &quot;LHR&quot;], [&quot;JFK&quot;, &quot;MUC&quot;], [&quot;SFO&quot;, &quot;SJC&quot;], [&quot;LHR&quot;, &quot;SFO&quot;]]</span><br><span class=\"line\">Output: [&quot;JFK&quot;, &quot;MUC&quot;, &quot;LHR&quot;, &quot;SFO&quot;, &quot;SJC&quot;]</span><br></pre></td></tr></table></figure>\n<p>方法一：首次ac的方法，直接修改g。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findItinerary</span><span class=\"params\">(self, tickets: List[List[str]])</span> -&gt; List[str]:</span></span><br><span class=\"line\">    g = collections.defaultdict(list)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> u, v <span class=\"keyword\">in</span> tickets:</span><br><span class=\"line\">        g[u].append(v)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> u <span class=\"keyword\">in</span> g.keys():</span><br><span class=\"line\">        g[u].sort()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(city, p)</span>:</span>  </span><br><span class=\"line\">        <span class=\"comment\"># print(city, p, g)</span></span><br><span class=\"line\">        p.append(city)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> g:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> p</span><br><span class=\"line\">        org = g[city]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, nxt <span class=\"keyword\">in</span> enumerate(g[city]):</span><br><span class=\"line\">            g[city] = g[city][:i] + g[city][i+<span class=\"number\">1</span>:]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> g[city]:</span><br><span class=\"line\">                <span class=\"keyword\">del</span> g[city]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> dfs(nxt, p):</span><br><span class=\"line\">                <span class=\"keyword\">return</span> p</span><br><span class=\"line\">            g[city] = org</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> org:</span><br><span class=\"line\">            <span class=\"keyword\">del</span> g[city]</span><br><span class=\"line\">        p.pop()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dfs(<span class=\"string\">'JFK'</span>, [])</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：用两个倒序可以解决</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findItinerary</span><span class=\"params\">(self, tickets: List[List[str]])</span> -&gt; List[str]:</span></span><br><span class=\"line\">    g = collections.defaultdict(list)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> u, v <span class=\"keyword\">in</span> sorted(tickets, reverse=<span class=\"literal\">True</span>):</span><br><span class=\"line\">        g[u].append(v)</span><br><span class=\"line\">        </span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(city)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> g[city]:</span><br><span class=\"line\">            dfs(g[city].pop())</span><br><span class=\"line\">        ans.append(city)</span><br><span class=\"line\">        </span><br><span class=\"line\">    dfs(<span class=\"string\">'JFK'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans[::<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"1519-Number-of-Nodes-in-the-Sub-Tree-With-the-Same-Label\"><a href=\"#1519-Number-of-Nodes-in-the-Sub-Tree-With-the-Same-Label\" class=\"headerlink\" title=\"1519. Number of Nodes in the Sub-Tree With the Same Label\"></a>1519. Number of Nodes in the Sub-Tree With the Same Label</h3><h4 id=\"有一个数的图，每个节点有个字母，返回每个节点的子树中包含这个字母的总个数。原题\"><a href=\"#有一个数的图，每个节点有个字母，返回每个节点的子树中包含这个字母的总个数。原题\" class=\"headerlink\" title=\"有一个数的图，每个节点有个字母，返回每个节点的子树中包含这个字母的总个数。原题\"></a>有一个数的图，每个节点有个字母，返回每个节点的子树中包含这个字母的总个数。<a href=\"https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：这个题作为竞赛的第二题是在是太恶心了，结束后我想了很长时间才想出来。dfs + counter, 每个节点都有它独立的一个counter。 因为字母不同、</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countSubTrees</span><span class=\"params\">(self, n: int, edges: List[List[int]], labels: str)</span> -&gt; List[int]:</span></span><br><span class=\"line\">    g = collections.defaultdict(list)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> u, v <span class=\"keyword\">in</span> edges:</span><br><span class=\"line\">        g[u].append(v)</span><br><span class=\"line\">        g[v].append(u)</span><br><span class=\"line\"></span><br><span class=\"line\">    seen = [<span class=\"literal\">False</span>] * n</span><br><span class=\"line\">    c = Counter()</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        cur = Counter()</span><br><span class=\"line\">        seen[node] = <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> nxt <span class=\"keyword\">in</span> g[node]:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> seen[nxt]:</span><br><span class=\"line\">                cur += dfs(nxt)</span><br><span class=\"line\">        label = labels[node]</span><br><span class=\"line\">        cur[label] += <span class=\"number\">1</span></span><br><span class=\"line\">        ans[node] = cur[label]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cur</span><br><span class=\"line\">        </span><br><span class=\"line\">    ans = [<span class=\"number\">0</span>] * n</span><br><span class=\"line\">    dfs(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：优化方法一</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countSubTrees</span><span class=\"params\">(self, n: int, edges: List[List[int]], labels: str)</span> -&gt; List[int]:</span></span><br><span class=\"line\">    g = collections.defaultdict(list)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> u, v <span class=\"keyword\">in</span> edges:</span><br><span class=\"line\">        g[u].append(v)</span><br><span class=\"line\">        g[v].append(u)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(node, p)</span>:</span></span><br><span class=\"line\">        cur = Counter(labels[node])</span><br><span class=\"line\">        <span class=\"keyword\">for</span> nxt <span class=\"keyword\">in</span> g[node]:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nxt != p:</span><br><span class=\"line\">                cur += dfs(nxt, node)</span><br><span class=\"line\">        ans[node] = cur[labels[node]]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cur</span><br><span class=\"line\">        </span><br><span class=\"line\">    ans = [<span class=\"number\">0</span>] * n</span><br><span class=\"line\">    dfs(<span class=\"number\">0</span>, <span class=\"number\">-1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"478-Generate-Random-Point-in-a-Circle\"><a href=\"#478-Generate-Random-Point-in-a-Circle\" class=\"headerlink\" title=\"478. Generate Random Point in a Circle\"></a>478. Generate Random Point in a Circle</h3><h4 id=\"在给定圆的范围内随机生成点。原题\"><a href=\"#在给定圆的范围内随机生成点。原题\" class=\"headerlink\" title=\"在给定圆的范围内随机生成点。原题\"></a>在给定圆的范围内随机生成点。<a href=\"https://leetcode.com/problems/generate-random-point-in-a-circle/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：严格来说 这是一道几何题，为什么要将其开方，因为如果没有开方，对于一个圆来说，半径越小的地方点就越密集，因为在该周长上所有的点分布是一样的。开方可以让半径小的点降低分布。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, radius: float, x_center: float, y_center: float)</span>:</span></span><br><span class=\"line\">        self.r = radius</span><br><span class=\"line\">        self.x = x_center</span><br><span class=\"line\">        self.y = y_center</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">randPoint</span><span class=\"params\">(self)</span> -&gt; List[float]:</span></span><br><span class=\"line\">        <span class=\"keyword\">import</span> random</span><br><span class=\"line\">        edge = math.sqrt(random.random()) * self.r</span><br><span class=\"line\">        deg = random.random()*<span class=\"number\">2</span>*math.pi</span><br><span class=\"line\">        x = self.x + edge*math.cos(deg)</span><br><span class=\"line\">        y = self.y + edge*math.sin(deg)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x, y</span><br></pre></td></tr></table></figure>\n<h3 id=\"1559-Detect-Cycles-in-2D-Grid\"><a href=\"#1559-Detect-Cycles-in-2D-Grid\" class=\"headerlink\" title=\"1559. Detect Cycles in 2D Grid\"></a>1559. Detect Cycles in 2D Grid</h3><h4 id=\"2D-矩阵中判断是否有环。原题\"><a href=\"#2D-矩阵中判断是否有环。原题\" class=\"headerlink\" title=\"2D 矩阵中判断是否有环。原题\"></a>2D 矩阵中判断是否有环。<a href=\"https://leetcode.com/problems/detect-cycles-in-2d-grid/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：这个题就差一点没想出来，就是怎么避免重复的路径，那就是需要和前一个点比对。看了这个提示后瞬间就完成了。时间空间待优化。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">containsCycle</span><span class=\"params\">(self, g: List[List[str]])</span> -&gt; bool:</span></span><br><span class=\"line\">    m, n = len(g), len(g[<span class=\"number\">0</span>])</span><br><span class=\"line\">    </span><br><span class=\"line\">    visited = [[<span class=\"literal\">False</span>] * n <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(m)]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">spread</span><span class=\"params\">(x, y, c, a, b)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> visited[x][y]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        visited[x][y] = <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, j <span class=\"keyword\">in</span> ((x<span class=\"number\">-1</span>, y), (x+<span class=\"number\">1</span>, y), (x, y<span class=\"number\">-1</span>), (x, y+<span class=\"number\">1</span>)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=i&lt;m <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=j&lt;n <span class=\"keyword\">and</span> c==g[i][j] <span class=\"keyword\">and</span> (i, j)!=(a, b):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> spread(i, j, c, x, y):</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> visited[i][j] <span class=\"keyword\">and</span> spread(i, j, g[i][j], i, j):</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"310-Minimum-Height-Trees\"><a href=\"#310-Minimum-Height-Trees\" class=\"headerlink\" title=\"310. Minimum Height Trees\"></a>310. Minimum Height Trees</h3><h4 id=\"有一个无向图，0-n-1这些节点，每两个节点只有一条边，找出这种节点，当以节点为根时，组成的树有最小的高度。原题\"><a href=\"#有一个无向图，0-n-1这些节点，每两个节点只有一条边，找出这种节点，当以节点为根时，组成的树有最小的高度。原题\" class=\"headerlink\" title=\"有一个无向图，0~n-1这些节点，每两个节点只有一条边，找出这种节点，当以节点为根时，组成的树有最小的高度。原题\"></a>有一个无向图，0~n-1这些节点，每两个节点只有一条边，找出这种节点，当以节点为根时，组成的树有最小的高度。<a href=\"https://leetcode.com/problems/minimum-height-trees/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 6, edges &#x3D; [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]</span><br><span class=\"line\"></span><br><span class=\"line\">     0  1  2</span><br><span class=\"line\">      \\ | &#x2F;</span><br><span class=\"line\">        3</span><br><span class=\"line\">        |</span><br><span class=\"line\">        4</span><br><span class=\"line\">        |</span><br><span class=\"line\">        5 </span><br><span class=\"line\"></span><br><span class=\"line\">Output: [3, 4]</span><br></pre></td></tr></table></figure>\n<p>方法一：这个解法很棒，评论区的解法，以前看这种题的时候，想到的是bfs，这个解法的核心思想是剪枝。每次将叶子节点剪去。最后剩下的 一个或者2个节点 就是最小高度的根节点。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findMinHeightTrees</span><span class=\"params\">(self, n: int, edges: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">1</span>: <span class=\"keyword\">return</span> [<span class=\"number\">0</span>]</span><br><span class=\"line\">    g = collections.defaultdict(set)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> u, v <span class=\"keyword\">in</span> edges:</span><br><span class=\"line\">        g[u].add(v)</span><br><span class=\"line\">        g[v].add(u)</span><br><span class=\"line\">        </span><br><span class=\"line\">    leaves = [i <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n) <span class=\"keyword\">if</span> len(g[i])==<span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> n &gt; <span class=\"number\">2</span>:</span><br><span class=\"line\">        n -= len(leaves)</span><br><span class=\"line\">        new_leaves = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> leaves:</span><br><span class=\"line\">            j = g[i].pop()</span><br><span class=\"line\">            g[j].remove(i)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(g[j])==<span class=\"number\">1</span>: new_leaves.append(j)</span><br><span class=\"line\">        leaves = new_leaves</span><br><span class=\"line\">    <span class=\"keyword\">return</span> leaves</span><br></pre></td></tr></table></figure>\n<h3 id=\"127-Word-Ladder\"><a href=\"#127-Word-Ladder\" class=\"headerlink\" title=\"127. Word Ladder\"></a>127. Word Ladder</h3><h4 id=\"每次可以改变单词中的一个字母，但必须在wordList中，问最少需要多少次能达到目标单词。原题\"><a href=\"#每次可以改变单词中的一个字母，但必须在wordList中，问最少需要多少次能达到目标单词。原题\" class=\"headerlink\" title=\"每次可以改变单词中的一个字母，但必须在wordList中，问最少需要多少次能达到目标单词。原题\"></a>每次可以改变单词中的一个字母，但必须在wordList中，问最少需要多少次能达到目标单词。<a href=\"https://leetcode.com/problems/word-ladder/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">beginWord &#x3D; &quot;hit&quot;,</span><br><span class=\"line\">endWord &#x3D; &quot;cog&quot;,</span><br><span class=\"line\">wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">Output: 5</span><br><span class=\"line\"></span><br><span class=\"line\">Explanation: As one shortest transformation is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,</span><br><span class=\"line\">return its length 5.</span><br></pre></td></tr></table></figure>\n<p>方法一：BFS很好想，但是要想如何去重，wordList可能非常大，所以不能遍历，因为只有26个字母可以变，所以可以变换完比较。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">ladderLength</span><span class=\"params\">(self, beginWord: str, endWord: str, wordList: List[str])</span> -&gt; int:</span></span><br><span class=\"line\">    q = [(beginWord, <span class=\"number\">1</span>)]</span><br><span class=\"line\">    words_set = set(wordList)</span><br><span class=\"line\">    letters = string.ascii_lowercase</span><br><span class=\"line\">    <span class=\"keyword\">for</span> w, step <span class=\"keyword\">in</span> q:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> w == endWord: <span class=\"keyword\">return</span> step</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(w)):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> letters:</span><br><span class=\"line\">                nw = w[:i] + c + w[i+<span class=\"number\">1</span>:]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> nw <span class=\"keyword\">in</span> words_set:</span><br><span class=\"line\">                    q.append((nw, step+<span class=\"number\">1</span>))</span><br><span class=\"line\">                    words_set.remove(nw)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"547-Friend-Circles\"><a href=\"#547-Friend-Circles\" class=\"headerlink\" title=\"547. Friend Circles\"></a>547. Friend Circles</h3><h4 id=\"朋友圈，一堆人拉帮结伙，朋友关系可以传递。通过二维数组表示i-j两个人是否是朋友。问N个人有多少个帮派。原题\"><a href=\"#朋友圈，一堆人拉帮结伙，朋友关系可以传递。通过二维数组表示i-j两个人是否是朋友。问N个人有多少个帮派。原题\" class=\"headerlink\" title=\"朋友圈，一堆人拉帮结伙，朋友关系可以传递。通过二维数组表示i, j两个人是否是朋友。问N个人有多少个帮派。原题\"></a>朋友圈，一堆人拉帮结伙，朋友关系可以传递。通过二维数组表示i, j两个人是否是朋友。问N个人有多少个帮派。<a href=\"https://leetcode.com/problems/friend-circles/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: </span><br><span class=\"line\">[[1,1,0],</span><br><span class=\"line\"> [1,1,0],</span><br><span class=\"line\"> [0,0,1]]</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation:The 0th and 1st students are direct friends, so they are in a friend circle. </span><br><span class=\"line\">The 2nd student himself is in a friend circle. So return 2.</span><br></pre></td></tr></table></figure>\n<p>方法一：典型的Union-Find。最后结果还要遍历一下，才是最终结果。<code>[[1,0,0,1],[0,1,1,0],[0,1,1,1],[1,0,1,1]]</code>这个case在union之后，是<code>[3,2,3,3]</code>因为2的朋友在1计算之后变成了3。最终点更新了。所以遍历之后是<code>[3,3,3,3]</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findCircleNum</span><span class=\"params\">(self, M: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">union</span><span class=\"params\">(x, y)</span>:</span></span><br><span class=\"line\">        uf[find(x)] = find(y)</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">find</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> x != uf[x]:</span><br><span class=\"line\">            uf[x] = find(uf[x])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> uf[x] </span><br><span class=\"line\">    </span><br><span class=\"line\">    N = len(M)</span><br><span class=\"line\">    uf = list(range(N))</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(N):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(N):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> M[i][j]:</span><br><span class=\"line\">                union(i, j)</span><br><span class=\"line\">                </span><br><span class=\"line\">    <span class=\"keyword\">return</span> len(&#123;find(i) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(N)&#125;)</span><br></pre></td></tr></table></figure>\n<p>方法二：评论中有个dfs 也不错，行列循环分开了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findCircleNum</span><span class=\"params\">(self, M: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    ans, N = <span class=\"number\">0</span>, len(M)</span><br><span class=\"line\">    seen = set()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(i)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j, r <span class=\"keyword\">in</span> enumerate(M[i]):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> r <span class=\"keyword\">and</span> j <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> seen:</span><br><span class=\"line\">                seen.add(j)</span><br><span class=\"line\">                dfs(j)</span><br><span class=\"line\">                </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(N):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> seen:</span><br><span class=\"line\">            ans += <span class=\"number\">1</span></span><br><span class=\"line\">            dfs(i)</span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法三：stefan的科学库和numpy写法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> scipy.sparse</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findCircleNum</span><span class=\"params\">(self, M)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> scipy.sparse.csgraph.connected_components(M)[<span class=\"number\">0</span>]</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findCircleNum</span><span class=\"params\">(self, M)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> len(set(map(tuple, (np.matrix(M, dtype=<span class=\"string\">'bool'</span>)**len(M)).A)))</span><br></pre></td></tr></table></figure>\n<h3 id=\"1584-Min-Cost-to-Connect-All-Points\"><a href=\"#1584-Min-Cost-to-Connect-All-Points\" class=\"headerlink\" title=\"1584. Min Cost to Connect All Points\"></a>1584. Min Cost to Connect All Points</h3><h4 id=\"所有点最小的曼哈顿距离-xi-xj-yi-yj-和为多少。原题\"><a href=\"#所有点最小的曼哈顿距离-xi-xj-yi-yj-和为多少。原题\" class=\"headerlink\" title=\"所有点最小的曼哈顿距离|xi - xj| + |yi - yj|和为多少。原题\"></a>所有点最小的曼哈顿距离|xi - xj| + |yi - yj|和为多少。<a href=\"https://leetcode.com/problems/min-cost-to-connect-all-points/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：贪心法。这题有很多方法，然而比赛时一种也没写出来。首先贪心可以，由于是n^2的复杂度，所以没有敢写。</p>\n<p>毕竟n=1000。评论区的做法，为什么贪心可行，想象一下，最后所有的点相连，每2点只有一条边，而且是最小的边。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minCostConnectPoints</span><span class=\"params\">(self, points: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    n, ans = len(points), <span class=\"number\">0</span></span><br><span class=\"line\">    seen = set()</span><br><span class=\"line\">    dis = [float(<span class=\"string\">'inf'</span>)] * n</span><br><span class=\"line\">    cur = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\"># n-1 edges</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n<span class=\"number\">-1</span>):</span><br><span class=\"line\">        x, y = points[cur]</span><br><span class=\"line\">        seen.add(cur)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j, (nx, ny) <span class=\"keyword\">in</span> enumerate(points):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> j <span class=\"keyword\">in</span> seen: <span class=\"keyword\">continue</span></span><br><span class=\"line\">            dis[j] = min(dis[j], abs(nx-x)+abs(ny-y))</span><br><span class=\"line\">        s, cur = min((d, j) <span class=\"keyword\">for</span> j, d <span class=\"keyword\">in</span> enumerate(dis))</span><br><span class=\"line\">        dis[cur] = float(<span class=\"string\">'inf'</span>)</span><br><span class=\"line\">        ans += s</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法二：最小生成树。这是经典的最小生成树问题，有两种实现的方式，一种是Prim算法。一种是Kruskal算法。比贪心法慢了400ms，花费1580ms，还以为是我实现的问题，结果看评论区中的要2s多。空间则是贪心的5倍多。因为此题需要找到各个边的权重，所以即使是Prim算法，时间复杂度也是O(n^2)。Prim算法是每次以新的顶点找到最小的权重边。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minCostConnectPoints</span><span class=\"params\">(self, p: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">manhattan</span><span class=\"params\">(x, y)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> abs(x[<span class=\"number\">0</span>]-y[<span class=\"number\">0</span>]) + abs(x[<span class=\"number\">1</span>]-y[<span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    ans, n = <span class=\"number\">0</span>, len(p)</span><br><span class=\"line\">    seen = set()</span><br><span class=\"line\">    vertices = [(<span class=\"number\">0</span>, (<span class=\"number\">0</span>, <span class=\"number\">0</span>))]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> len(seen) &lt; n:</span><br><span class=\"line\">        <span class=\"comment\"># print(vertices, seen)</span></span><br><span class=\"line\">        w, (u, v) = heapq.heappop(vertices)            </span><br><span class=\"line\">        <span class=\"keyword\">if</span> v <span class=\"keyword\">in</span> seen: <span class=\"keyword\">continue</span></span><br><span class=\"line\">        ans += w</span><br><span class=\"line\">        seen.add(v)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> j <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> seen <span class=\"keyword\">and</span> j!=v:</span><br><span class=\"line\">                heapq.heappush(vertices, (manhattan(p[j], p[v]), (v, j)))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法三：Kruskal，克鲁斯卡尔算法。原理是Union-Find。按照所有的权重看，每次产生一条边，但不一定和已有的边构成环。理论上来说比Prim算法要慢。实际运行却比prim快了1、200ms。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minCostConnectPoints</span><span class=\"params\">(self, p: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    edges, n, cnt, ans = [], len(p), <span class=\"number\">1</span>, <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">manhattan</span><span class=\"params\">(x, y)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> abs(p[x][<span class=\"number\">0</span>]-p[y][<span class=\"number\">0</span>]) + abs(p[x][<span class=\"number\">1</span>]-p[y][<span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    edges = [(manhattan(i, j), (i, j)) </span><br><span class=\"line\">             <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n) <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i+<span class=\"number\">1</span>, n)]</span><br><span class=\"line\">    heapq.heapify(edges)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">union</span><span class=\"params\">(x, y)</span>:</span></span><br><span class=\"line\">        uf[find(x)] = find(y)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">find</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> x != uf[x]:</span><br><span class=\"line\">            uf[x] = find(uf[x])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> uf[x]</span><br><span class=\"line\"></span><br><span class=\"line\">    uf = list(range(n))</span><br><span class=\"line\">    <span class=\"keyword\">while</span> cnt &lt; n:</span><br><span class=\"line\">        d, (u, v) = heapq.heappop(edges)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> find(u) != find(v):</span><br><span class=\"line\">            ans += d</span><br><span class=\"line\">            cnt += <span class=\"number\">1</span></span><br><span class=\"line\">            union(u, v)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"684-Redundant-Connection\"><a href=\"#684-Redundant-Connection\" class=\"headerlink\" title=\"684. Redundant Connection\"></a>684. Redundant Connection</h3><h4 id=\"多余的边，有一个无向图有N个节点，和N个边，对于一个连通器来说，刚好多了一条边。找到这条多余的边，所有的边给的-u-v-均满足u-lt-v。原题\"><a href=\"#多余的边，有一个无向图有N个节点，和N个边，对于一个连通器来说，刚好多了一条边。找到这条多余的边，所有的边给的-u-v-均满足u-lt-v。原题\" class=\"headerlink\" title=\"多余的边，有一个无向图有N个节点，和N个边，对于一个连通器来说，刚好多了一条边。找到这条多余的边，所有的边给的[u, v]均满足u&lt;v。原题\"></a>多余的边，有一个无向图有N个节点，和N个边，对于一个连通器来说，刚好多了一条边。找到这条多余的边，所有的边给的[u, v]均满足u&lt;v。<a href=\"https://leetcode.com/problems/redundant-connection/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [[1,2], [1,3], [2,3]]</span><br><span class=\"line\">Output: [2,3]</span><br><span class=\"line\">Explanation: The given undirected graph will be like this:</span><br><span class=\"line\">  1</span><br><span class=\"line\"> &#x2F; \\</span><br><span class=\"line\">2 - 3</span><br></pre></td></tr></table></figure>\n<p>方法一：使用传统的Union-Find。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findRedundantConnection</span><span class=\"params\">(self, edges: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">union</span><span class=\"params\">(x, y)</span>:</span></span><br><span class=\"line\">        uf[find(x)] = find(y)</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">find</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> x != uf[x]:</span><br><span class=\"line\">            uf[x] = find(uf[x])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> uf[x]</span><br><span class=\"line\">    </span><br><span class=\"line\">    n = len(edges)</span><br><span class=\"line\">    uf = list(range(n+<span class=\"number\">1</span>))</span><br><span class=\"line\">    <span class=\"keyword\">for</span> u, v <span class=\"keyword\">in</span> edges:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> find(u)==find(v):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> u, v</span><br><span class=\"line\">        union(u, v)</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：stefan. 考虑没用上的条件 <code>u&lt;v</code>。 可以利用字符串的replace。将所有出现的点，替换成最大的。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findRedundantConnection</span><span class=\"params\">(self, edges: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    tree = <span class=\"string\">''</span>.join(map(chr, range(<span class=\"number\">1001</span>)))</span><br><span class=\"line\">    <span class=\"keyword\">for</span> u, v <span class=\"keyword\">in</span> edges:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> tree[u] == tree[v]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> u, v</span><br><span class=\"line\">        tree = tree.replace(tree[u], tree[v])</span><br></pre></td></tr></table></figure>\n<h3 id=\"685-Redundant-Connection-II\"><a href=\"#685-Redundant-Connection-II\" class=\"headerlink\" title=\"685. Redundant Connection II\"></a><a href=\"https://leetcode.com/problems/redundant-connection-ii/\" target=\"_blank\" rel=\"noopener\">685. Redundant Connection II</a></h3><h4 id=\"同684一样，区别在于有向图，也是多出一条边，但这条边是最后一条无用的边。也就是说。删除这条边后，还是一个N个节点的有向图。并且图中只能有一个根节点。\"><a href=\"#同684一样，区别在于有向图，也是多出一条边，但这条边是最后一条无用的边。也就是说。删除这条边后，还是一个N个节点的有向图。并且图中只能有一个根节点。\" class=\"headerlink\" title=\"同684一样，区别在于有向图，也是多出一条边，但这条边是最后一条无用的边。也就是说。删除这条边后，还是一个N个节点的有向图。并且图中只能有一个根节点。\"></a>同684一样，区别在于有向图，也是多出一条边，但这条边是最后一条无用的边。也就是说。删除这条边后，还是一个N个节点的有向图。并且图中只能有一个根节点。</h4><p>方法一：花了不到2小时做出来，感觉方法很笨。因为有这样的例子，<code>[[2,1],[3,1],[4,2],[1,4]]</code>这时不能删除<code>[1,4]</code>，而是要删除<code>[2,1]</code>因为4和3会成为2个根节点。如果我们找到了一个点有两个父节点，那么删除的一定是这两条边中的一条。所以此时我没有将其加入到联通图中；另一种情况，没有两个父节点的点时，就像684一样判断是否联通就好了，最后判断，如果所有节点都联通了，我删除第2次遇见的相同父节点的边就行了，如果没有，那么应该删除第一次的边，这里用了一个pare来记录关系。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findRedundantDirectedConnection</span><span class=\"params\">(self, edges: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">union</span><span class=\"params\">(x, y)</span>:</span></span><br><span class=\"line\">        uf[find(x)] = find(y)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">find</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> x != uf[x]:</span><br><span class=\"line\">            uf[x] = find(uf[x])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> uf[x]</span><br><span class=\"line\">      </span><br><span class=\"line\">    ans, N, pare = <span class=\"literal\">None</span>, len(edges), &#123;&#125;</span><br><span class=\"line\">    uf = list(range(N+<span class=\"number\">1</span>))</span><br><span class=\"line\">    <span class=\"keyword\">for</span> u, v <span class=\"keyword\">in</span> edges:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> v <span class=\"keyword\">in</span> pare:</span><br><span class=\"line\">            ans = (u, v)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> find(u)==find(v) <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> ans:</span><br><span class=\"line\">            ans = (u, v)</span><br><span class=\"line\">        union(u, v)</span><br><span class=\"line\">        pare[v] = u</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans <span class=\"keyword\">if</span> len(set(map(find, range(<span class=\"number\">1</span>, N+<span class=\"number\">1</span>))))==<span class=\"number\">1</span> <span class=\"keyword\">else</span> (pare[ans[<span class=\"number\">1</span>]], ans[<span class=\"number\">1</span>])</span><br></pre></td></tr></table></figure>\n<h3 id=\"743-Network-Delay-Time\"><a href=\"#743-Network-Delay-Time\" class=\"headerlink\" title=\"743. Network Delay Time\"></a>743. Network Delay Time</h3><h4 id=\"网络延迟，有N个网络节点，给出一个加权有向图，问从K点出发，遍历所有点需要多少时间，如果不可能返回-1。原题\"><a href=\"#网络延迟，有N个网络节点，给出一个加权有向图，问从K点出发，遍历所有点需要多少时间，如果不可能返回-1。原题\" class=\"headerlink\" title=\"网络延迟，有N个网络节点，给出一个加权有向图，问从K点出发，遍历所有点需要多少时间，如果不可能返回-1。原题\"></a>网络延迟，有N个网络节点，给出一个加权有向图，问从K点出发，遍历所有点需要多少时间，如果不可能返回-1。<a href=\"https://leetcode.com/problems/network-delay-time/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: times &#x3D; [[2,1,1],[2,3,1],[3,4,1]], N &#x3D; 4, K &#x3D; 2</span><br><span class=\"line\">Output: 2</span><br></pre></td></tr></table></figure>\n<p>方法一：bfs。首次AC，960ms。效率不算很高吧，因为可能遍历到重复的节点更新值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">networkDelayTime</span><span class=\"params\">(self, times, N, K)</span>:</span></span><br><span class=\"line\">    seen, ans = &#123;&#125;, <span class=\"number\">0</span></span><br><span class=\"line\">    g = collections.defaultdict(list)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> u, v , w <span class=\"keyword\">in</span> times:</span><br><span class=\"line\">        g[u].append((v, w))</span><br><span class=\"line\">    q = collections.deque([(K, <span class=\"number\">0</span>)])</span><br><span class=\"line\">    <span class=\"keyword\">while</span> q:</span><br><span class=\"line\">        u, t = q.popleft()</span><br><span class=\"line\">        seen[u] = min(seen.get(u, float(<span class=\"string\">'inf'</span>)), t)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> v, nt <span class=\"keyword\">in</span> g[u]:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> v <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> seen <span class=\"keyword\">or</span> seen[v]&gt;nt+t:</span><br><span class=\"line\">                q.append((v, t+nt))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(seen.values()) <span class=\"keyword\">if</span> len(seen)==N <span class=\"keyword\">else</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：堆实现了一个优先级队列，500ms左右。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">networkDelayTime</span><span class=\"params\">(self, times, N, K)</span>:</span></span><br><span class=\"line\">    seen, t = set(), <span class=\"number\">0</span></span><br><span class=\"line\">    g = collections.defaultdict(list)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> u, v , w <span class=\"keyword\">in</span> times:</span><br><span class=\"line\">        g[u].append((v, w))</span><br><span class=\"line\">    heap = [(<span class=\"number\">0</span>, K)]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> heap:</span><br><span class=\"line\">        t, u = heapq.heappop(heap)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> u <span class=\"keyword\">in</span> seen: <span class=\"keyword\">continue</span></span><br><span class=\"line\">        seen.add(u)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(seen) == N: <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> v, nt <span class=\"keyword\">in</span> g[u]:</span><br><span class=\"line\">            heapq.heappush(heap, (t+nt, v))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t <span class=\"keyword\">if</span> len(seen)==N <span class=\"keyword\">else</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"721-Accounts-Merge\"><a href=\"#721-Accounts-Merge\" class=\"headerlink\" title=\"721. Accounts Merge\"></a><a href=\"https://leetcode.com/problems/accounts-merge/\" target=\"_blank\" rel=\"noopener\">721. Accounts Merge</a></h3><h4 id=\"账号合并，一个人可能有多个账号，将具有相同账号的人合并到一起，返回所有的用户的所有的账号\"><a href=\"#账号合并，一个人可能有多个账号，将具有相同账号的人合并到一起，返回所有的用户的所有的账号\" class=\"headerlink\" title=\"账号合并，一个人可能有多个账号，将具有相同账号的人合并到一起，返回所有的用户的所有的账号\"></a>账号合并，一个人可能有多个账号，将具有相同账号的人合并到一起，返回所有的用户的所有的账号</h4><p>方法一：做的时候想到了union-find，不过以开始的思路用集合暴力也解出来了。只要有一个账号相同，就是一个人。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">accountsMerge</span><span class=\"params\">(self, accounts: List[List[str]])</span> -&gt; List[List[str]]:</span></span><br><span class=\"line\">    users = collections.defaultdict(list)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> name, *mails <span class=\"keyword\">in</span> accounts:</span><br><span class=\"line\">        old_mails = users[name]</span><br><span class=\"line\">        mails = set(mails)</span><br><span class=\"line\">        to_rm = []</span><br><span class=\"line\">        n = len(old_mails)</span><br><span class=\"line\">        j = n - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> j &gt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> old_mails[j] &amp; mails:</span><br><span class=\"line\">                mails |= old_mails[j]</span><br><span class=\"line\">                old_mails.pop(j)</span><br><span class=\"line\">            j -= <span class=\"number\">1</span></span><br><span class=\"line\">        old_mails.append(mails)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[name] + sorted(act_lst) </span><br><span class=\"line\">            <span class=\"keyword\">for</span> name, acts <span class=\"keyword\">in</span> users.items() <span class=\"keyword\">for</span> act_lst <span class=\"keyword\">in</span> acts]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：dfs，需要遍历两次。先记录一下每个邮箱出现的索引，</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">accountsMerge</span><span class=\"params\">(self, accounts: List[List[str]])</span> -&gt; List[List[str]]:</span></span><br><span class=\"line\">    mail_occurs = collections.defaultdict(list)</span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, (_, *mails) <span class=\"keyword\">in</span> enumerate(accounts):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> mail <span class=\"keyword\">in</span> mails:</span><br><span class=\"line\">            mail_occurs[mail].append(i)</span><br><span class=\"line\">    visited = [<span class=\"literal\">False</span>] * len(accounts)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(i, mails)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> visited[i]: <span class=\"keyword\">return</span>             </span><br><span class=\"line\">        visited[i] = <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> other <span class=\"keyword\">in</span> accounts[i][<span class=\"number\">1</span>:]:</span><br><span class=\"line\">            mails.add(other)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> mail_occurs[other]:</span><br><span class=\"line\">                dfs(j, mails)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, (name, *mails) <span class=\"keyword\">in</span> enumerate(accounts):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> visited[i]: <span class=\"keyword\">continue</span></span><br><span class=\"line\">        acts = set()</span><br><span class=\"line\">        dfs(i, acts)</span><br><span class=\"line\">        ans.append([name] + sorted(acts))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：Union-FInd，这里要选出一个标准，不如每个首个出现的账号，将其它账号连到这个账号上。第二步需要遍历一遍，把相同的账号放到一个列表中，遍历过程中记录账号对应的姓名，方便我们构建最终的答案。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">accountsMerge</span><span class=\"params\">(self, accounts: List[List[str]])</span> -&gt; List[List[str]]:</span></span><br><span class=\"line\">    uf = &#123;&#125;</span><br><span class=\"line\">    mail_to_name = &#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">union</span><span class=\"params\">(x, y)</span>:</span></span><br><span class=\"line\">        uf.setdefault(x, x)</span><br><span class=\"line\">        uf.setdefault(y, y)</span><br><span class=\"line\">        uf[find(x)] = find(y)</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">find</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> x != uf[x]:</span><br><span class=\"line\">            uf[x] = find(uf[x])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> uf[x]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> name, *mails <span class=\"keyword\">in</span> accounts:</span><br><span class=\"line\">        first = mails[<span class=\"number\">0</span>]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> mail <span class=\"keyword\">in</span> mails:</span><br><span class=\"line\">            union(mail, first)</span><br><span class=\"line\">            mail_to_name[mail] = name</span><br><span class=\"line\">        </span><br><span class=\"line\">    g = collections.defaultdict(list)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> mail <span class=\"keyword\">in</span> uf.keys():</span><br><span class=\"line\">        g[find(mail)].append(mail)</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[mail_to_name[first]] + sorted(mails) <span class=\"keyword\">for</span> first, mails <span class=\"keyword\">in</span> g.items()]</span><br></pre></td></tr></table></figure>\n<h4 id=\"面试题-17-07-婴儿名字\"><a href=\"#面试题-17-07-婴儿名字\" class=\"headerlink\" title=\"面试题 17.07. 婴儿名字\"></a><a href=\"https://leetcode-cn.com/problems/baby-names-lcci/\" target=\"_blank\" rel=\"noopener\">面试题 17.07. 婴儿名字</a></h4><h4 id=\"找到相同名字的数量，和721一样，也是合并婴儿。names中可能包含synonyms中没有的，synonyms中也可能包含names没有的。\"><a href=\"#找到相同名字的数量，和721一样，也是合并婴儿。names中可能包含synonyms中没有的，synonyms中也可能包含names没有的。\" class=\"headerlink\" title=\"找到相同名字的数量，和721一样，也是合并婴儿。names中可能包含synonyms中没有的，synonyms中也可能包含names没有的。\"></a>找到相同名字的数量，和721一样，也是合并婴儿。names中可能包含synonyms中没有的，synonyms中也可能包含names没有的。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：names &#x3D; [&quot;John(15)&quot;,&quot;Jon(12)&quot;,&quot;Chris(13)&quot;,&quot;Kris(4)&quot;,&quot;Christopher(19)&quot;], synonyms &#x3D; [&quot;(Jon,John)&quot;,&quot;(John,Johnny)&quot;,&quot;(Chris,Kris)&quot;,&quot;(Chris,Christopher)&quot;]</span><br><span class=\"line\">输出：[&quot;John(27)&quot;,&quot;Chris(36)&quot;]</span><br></pre></td></tr></table></figure>\n<p>方法一：Union-Find。改进，这里修改了union方法，将较小的直接作为索引键。因为后续也不需要再使用了。360ms, 35M.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">trulyMostPopular</span><span class=\"params\">(self, names: List[str], synonyms: List[str])</span> -&gt; List[str]:</span></span><br><span class=\"line\">    <span class=\"comment\"># RE_NAME_CNT = re.compile(r'\\w+|\\d+')</span></span><br><span class=\"line\">    <span class=\"comment\"># RE_SAME_NAME = re.compile(r'\\w+')</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">union</span><span class=\"params\">(x, y)</span>:</span></span><br><span class=\"line\">        uf.setdefault(x, x)</span><br><span class=\"line\">        uf.setdefault(y, y)</span><br><span class=\"line\">        ax, ay = find(x), find(y)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ax &lt; ay: ay, ax = ax, ay</span><br><span class=\"line\">        uf[ax] = ay</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">find</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> x != uf[x]:</span><br><span class=\"line\">            uf[x] = find(uf[x])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> uf[x]</span><br><span class=\"line\"></span><br><span class=\"line\">    uf, cnt = &#123;&#125;, &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> person <span class=\"keyword\">in</span> names:</span><br><span class=\"line\">        <span class=\"comment\"># name, c = re.findall(RE_NAME_CNT, person)</span></span><br><span class=\"line\">        <span class=\"comment\"># name, c = re.match(r'(\\w+)\\((\\d+)\\)', person).groups()</span></span><br><span class=\"line\">        name, c = person.strip(<span class=\"string\">')'</span>).split(<span class=\"string\">'('</span>)</span><br><span class=\"line\">        uf.setdefault(name, name)</span><br><span class=\"line\">        cnt[name] = int(c)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> con <span class=\"keyword\">in</span> synonyms:</span><br><span class=\"line\">        <span class=\"comment\"># n1, n2 = re.findall(RE_SAME_NAME, con)</span></span><br><span class=\"line\">        <span class=\"comment\"># n1, n2 = re.match(r'\\((\\w+),(\\w+)\\)', con).groups()</span></span><br><span class=\"line\">        n1, n2 = con.strip(<span class=\"string\">'()'</span>).split(<span class=\"string\">','</span>)</span><br><span class=\"line\">        union(n1, n2)</span><br><span class=\"line\"></span><br><span class=\"line\">    total = collections.defaultdict(int)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> name, c <span class=\"keyword\">in</span> cnt.items():</span><br><span class=\"line\">        total[find(name)] += c</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"string\">f'<span class=\"subst\">&#123;p&#125;</span>(<span class=\"subst\">&#123;t&#125;</span>)'</span> <span class=\"keyword\">for</span> p, t <span class=\"keyword\">in</span> total.items()]</span><br></pre></td></tr></table></figure>\n<p>方法二：dfs 方法。cnt 不能使用defaultdict，因为循环cnt的时候会发生改变报错。因为会存在cnt中没有的key，也就是说不在names中的名字。448ms, 40M.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">trulyMostPopular</span><span class=\"params\">(self, names: List[str], synonyms: List[str])</span> -&gt; List[str]:</span></span><br><span class=\"line\">    cnt, seen, g = &#123;&#125;, defaultdict(int), defaultdict(list)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> person <span class=\"keyword\">in</span> names:</span><br><span class=\"line\">        name, c = person.strip(<span class=\"string\">')'</span>).split(<span class=\"string\">'('</span>)</span><br><span class=\"line\">        cnt[name] = int(c)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> con <span class=\"keyword\">in</span> synonyms:</span><br><span class=\"line\">        n1, n2 = con.strip(<span class=\"string\">'()'</span>).split(<span class=\"string\">','</span>)</span><br><span class=\"line\">        g[n1].append(n2)</span><br><span class=\"line\">        g[n2].append(n1)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(n)</span>:</span></span><br><span class=\"line\">        seen[n], min_name = <span class=\"number\">1</span>, n</span><br><span class=\"line\">        total = cnt.get(n, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> other <span class=\"keyword\">in</span> g[n]:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> seen[other]:</span><br><span class=\"line\">                p, s = dfs(other)</span><br><span class=\"line\">                total += s</span><br><span class=\"line\">                min_name = min(min_name, p)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> min_name, total</span><br><span class=\"line\"></span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> name <span class=\"keyword\">in</span> cnt:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> seen[name]: <span class=\"keyword\">continue</span></span><br><span class=\"line\">        n, s = dfs(name)</span><br><span class=\"line\">        ans.append(<span class=\"string\">'&#123;&#125;(&#123;&#125;)'</span>.format(n, s))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：评论区大神的写法。292ms, 17M，比我的快了好多。它这里的p比我的g要节省空间和时间，我试了更改方法二的这里平均快了40ms和10M的内存。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">trulyMostPopular</span><span class=\"params\">(self, names: List[str], synonyms: List[str])</span> -&gt; List[str]:</span></span><br><span class=\"line\">    p, d, q = &#123;&#125;, &#123;&#125;, collections.defaultdict(int)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> synonyms:</span><br><span class=\"line\">        a, b = s.strip(<span class=\"string\">'()'</span>).split(<span class=\"string\">','</span>)</span><br><span class=\"line\">        pa, pb = p.setdefault(a, [a]), p.setdefault(b, [b])</span><br><span class=\"line\">        pa.extend(pb)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> pb:</span><br><span class=\"line\">            p[c] = pa</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> name <span class=\"keyword\">in</span> p:</span><br><span class=\"line\">        d.setdefault(id(p[name]), min(p[name]))</span><br><span class=\"line\">    <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> names:</span><br><span class=\"line\">        name, count = s.strip(<span class=\"string\">')'</span>).split(<span class=\"string\">'('</span>)</span><br><span class=\"line\">        q[name <span class=\"keyword\">in</span> p <span class=\"keyword\">and</span> d[id(p[name])] <span class=\"keyword\">or</span> name] += int(count)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"string\">f'<span class=\"subst\">&#123;name&#125;</span>(<span class=\"subst\">&#123;count&#125;</span>)'</span> <span class=\"keyword\">for</span> name, count <span class=\"keyword\">in</span> q.items()]</span><br></pre></td></tr></table></figure>\n<h3 id=\"851-Loud-and-Rich\"><a href=\"#851-Loud-and-Rich\" class=\"headerlink\" title=\"851. Loud and Rich\"></a><a href=\"https://leetcode.com/problems/loud-and-rich/\" target=\"_blank\" rel=\"noopener\">851. Loud and Rich</a></h3><h4 id=\"啰里啰嗦一大堆，就是找到比当前人有钱的所有人中最低调的一个，quiet值最小，quiet没有重复值。\"><a href=\"#啰里啰嗦一大堆，就是找到比当前人有钱的所有人中最低调的一个，quiet值最小，quiet没有重复值。\" class=\"headerlink\" title=\"啰里啰嗦一大堆，就是找到比当前人有钱的所有人中最低调的一个，quiet值最小，quiet没有重复值。\"></a>啰里啰嗦一大堆，就是找到比当前人有钱的所有人中最低调的一个，quiet值最小，quiet没有重复值。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: richer &#x3D; [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet &#x3D; [3,2,5,4,6,1,7,0]</span><br><span class=\"line\">Output: [5,5,2,5,4,5,6,7]</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">answer[0] &#x3D; 5.</span><br><span class=\"line\">Person 5 has more money than 3, which has more money than 1, which has more money than 0.</span><br><span class=\"line\">The only person who is quieter (has lower quiet[x]) is person 7, but</span><br><span class=\"line\">it isn&#39;t clear if they have more money than person 0.</span><br></pre></td></tr></table></figure>\n<p>方法一：dfs. 首次AC，算比较简单。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">loudAndRich</span><span class=\"params\">(self, richer: List[List[int]], quiet: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    N = len(quiet)</span><br><span class=\"line\">    rich = collections.defaultdict(list)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> richer:</span><br><span class=\"line\">        rich[b].append(a)</span><br><span class=\"line\">    q_to_p = &#123;q: i <span class=\"keyword\">for</span> i, q <span class=\"keyword\">in</span> enumerate(quiet)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @lru_cache(None)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(i)</span>:</span></span><br><span class=\"line\">        q = quiet[i]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> rich[i]:</span><br><span class=\"line\">            q = min(q, dfs(j))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> q</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [q_to_p[dfs(i)] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(N)]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：Lee的方法，比方法一节省一些空间。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">loudAndRich</span><span class=\"params\">(self, richer: List[List[int]], quiet: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    N = len(quiet)</span><br><span class=\"line\">    rich = collections.defaultdict(list)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> richer:</span><br><span class=\"line\">        rich[b].append(a)</span><br><span class=\"line\">    ans = [<span class=\"number\">-1</span>] * N</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(i)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ans[i] &gt;= <span class=\"number\">0</span>: <span class=\"keyword\">return</span> ans[i]</span><br><span class=\"line\">        ans[i] = i</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> rich[i]:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> quiet[dfs(j)] &lt; quiet[ans[i]]:</span><br><span class=\"line\">                ans[i] = dfs(j)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans[i]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(N):</span><br><span class=\"line\">        dfs(i) </span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"399-Evaluate-Division\"><a href=\"#399-Evaluate-Division\" class=\"headerlink\" title=\"399. Evaluate Division\"></a><a href=\"https://leetcode.com/problems/evaluate-division/\" target=\"_blank\" rel=\"noopener\">399. Evaluate Division</a></h3><h4 id=\"通过已知的除法，计算带有这些变量的除法。\"><a href=\"#通过已知的除法，计算带有这些变量的除法。\" class=\"headerlink\" title=\"通过已知的除法，计算带有这些变量的除法。\"></a>通过已知的除法，计算带有这些变量的除法。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: equations &#x3D; [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;]], values &#x3D; [2.0,3.0], queries &#x3D; [[&quot;a&quot;,&quot;c&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;e&quot;],[&quot;a&quot;,&quot;a&quot;],[&quot;x&quot;,&quot;x&quot;]]</span><br><span class=\"line\">Output: [6.00000,0.50000,-1.00000,1.00000,-1.00000]</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">Given: a &#x2F; b &#x3D; 2.0, b &#x2F; c &#x3D; 3.0</span><br><span class=\"line\">queries are: a &#x2F; c &#x3D; ?, b &#x2F; a &#x3D; ?, a &#x2F; e &#x3D; ?, a &#x2F; a &#x3D; ?, x &#x2F; x &#x3D; ?</span><br><span class=\"line\">return: [6.0, 0.5, -1.0, 1.0, -1.0 ]</span><br></pre></td></tr></table></figure>\n<p>方法一：DFS。这题一开始想的是Union-Find方法，但是实现起来发现有点麻烦。需要注意一个问题，在遍历后未找到目标值时，需要添加-1。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">calcEquation</span><span class=\"params\">(self, equations: List[List[str]], values: List[float], queries: List[List[str]])</span> -&gt; List[float]:</span></span><br><span class=\"line\">    g = defaultdict(list)  </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (u, v), w <span class=\"keyword\">in</span> zip(equations, values):</span><br><span class=\"line\">        g[u].append((v, w))</span><br><span class=\"line\">        g[v].append((u, <span class=\"number\">1</span>/w))</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(i, t, p=<span class=\"number\">1</span>)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == t:</span><br><span class=\"line\">            ans.append(p)</span><br><span class=\"line\">        seen.add(i)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j, w <span class=\"keyword\">in</span> g[i]:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> j <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> seen:</span><br><span class=\"line\">                dfs(j, t, p*w)</span><br><span class=\"line\">    </span><br><span class=\"line\">    ans, seen = [], set()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, (a, b) <span class=\"keyword\">in</span> enumerate(queries):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> g[a] <span class=\"keyword\">and</span> g[b]:</span><br><span class=\"line\">            dfs(a, b)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i == len(ans):</span><br><span class=\"line\">                ans.append(<span class=\"number\">-1</span>)</span><br><span class=\"line\">            seen.clear()</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            ans.append(<span class=\"number\">-1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法二：BFS方法也很优雅。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">calcEquation</span><span class=\"params\">(self, equations: List[List[str]], values: List[float], queries: List[List[str]])</span> -&gt; List[float]:</span></span><br><span class=\"line\">    g = defaultdict(list)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (u, v), w <span class=\"keyword\">in</span> zip(equations, values):</span><br><span class=\"line\">        g[u].append((v, w))</span><br><span class=\"line\">        g[v].append((u, <span class=\"number\">1</span>/w))</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bfs</span><span class=\"params\">(s, e)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> g[s] <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> g[e]: <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        q, seen = [(s, <span class=\"number\">1</span>)], set()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> cur, p <span class=\"keyword\">in</span> q:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> cur == e: <span class=\"keyword\">return</span> p</span><br><span class=\"line\">            seen.add(cur)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> nei, np <span class=\"keyword\">in</span> g[cur]:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> nei <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> seen:</span><br><span class=\"line\">                    q.append((nei, p*np))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (bfs(s, e) <span class=\"keyword\">for</span> s, e <span class=\"keyword\">in</span> queries)</span><br></pre></td></tr></table></figure>\n<p>方法三：Union-Find，自己想了个七八，也是用tuple返回一个比率，最后写着写着给自己绕蒙了，实现起来还是没有另两个方法简单。union方法其实融合了两个功能。然后就是将<code>ratio</code>添加到模板方法中。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">calcEquation</span><span class=\"params\">(self, equations: List[List[str]], values: List[float], queries: List[List[str]])</span> -&gt; List[float]:</span></span><br><span class=\"line\">    uf = &#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">find</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">        p, xr = uf.setdefault(x, (x, <span class=\"number\">1.0</span>))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> x != p:</span><br><span class=\"line\">            r, pr = find(p)</span><br><span class=\"line\">            uf[x] = (r, xr * pr)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> uf[x]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">union</span><span class=\"params\">(x, y, ratio)</span>:</span></span><br><span class=\"line\">        px, xr, py, yr = *find(x), *find(y)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> ratio:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> xr / yr <span class=\"keyword\">if</span> px == py <span class=\"keyword\">else</span> <span class=\"number\">-1.0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> px != py:</span><br><span class=\"line\">            uf[px] = (py, yr/xr*ratio)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (u, v), w <span class=\"keyword\">in</span> zip(equations, values):</span><br><span class=\"line\">        union(u, v, w)</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> [union(x, y, <span class=\"number\">0</span>) <span class=\"keyword\">if</span> x <span class=\"keyword\">in</span> root <span class=\"keyword\">and</span> y <span class=\"keyword\">in</span> root <span class=\"keyword\">else</span> <span class=\"number\">-1.0</span> <span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> queries]</span><br></pre></td></tr></table></figure>\n<p>方法四：Stefan的弗洛伊德算法。这个没有想到。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">calcEquation</span><span class=\"params\">(self, equations: List[List[str]], values: List[float], queries: List[List[str]])</span> -&gt; List[float]:</span></span><br><span class=\"line\">    quot = collections.defaultdict(dict)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (num, den), val <span class=\"keyword\">in</span> zip(equations, values):</span><br><span class=\"line\">        quot[num][num] = quot[den][den] = <span class=\"number\">1</span></span><br><span class=\"line\">        quot[num][den] = val</span><br><span class=\"line\">        quot[den][num] = <span class=\"number\">1</span> / val</span><br><span class=\"line\">    <span class=\"keyword\">for</span> k, i, j <span class=\"keyword\">in</span> itertools.permutations(quot, <span class=\"number\">3</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> k <span class=\"keyword\">in</span> quot[i] <span class=\"keyword\">and</span> j <span class=\"keyword\">in</span> quot[k]:</span><br><span class=\"line\">            quot[i][j] = quot[i][k] * quot[k][j]        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> [quot[num].get(den, <span class=\"number\">-1</span>) <span class=\"keyword\">for</span> num, den <span class=\"keyword\">in</span> queries]</span><br></pre></td></tr></table></figure>\n<h3 id=\"1617-Count-Subtrees-With-Max-Distance-Between-Cities\"><a href=\"#1617-Count-Subtrees-With-Max-Distance-Between-Cities\" class=\"headerlink\" title=\"1617. Count Subtrees With Max Distance Between Cities\"></a><a href=\"https://leetcode.com/problems/count-subtrees-with-max-distance-between-cities/\" target=\"_blank\" rel=\"noopener\">1617. Count Subtrees With Max Distance Between Cities</a></h3><h4 id=\"给你一颗树，求任意子树中节点最大距离1-n-1的分别有多少个。最多有15个节点。\"><a href=\"#给你一颗树，求任意子树中节点最大距离1-n-1的分别有多少个。最多有15个节点。\" class=\"headerlink\" title=\"给你一颗树，求任意子树中节点最大距离1~n-1的分别有多少个。最多有15个节点。\"></a>给你一颗树，求任意子树中节点最大距离1~n-1的分别有多少个。最多有15个节点。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：n &#x3D; 4, edges &#x3D; [[1,2],[2,3],[2,4]]</span><br><span class=\"line\">输出：[3,4,0]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">子树 &#123;1,2&#125;, &#123;2,3&#125; 和 &#123;2,4&#125; 最大距离都是 1 。</span><br><span class=\"line\">子树 &#123;1,2,3&#125;, &#123;1,2,4&#125;, &#123;2,3,4&#125; 和 &#123;1,2,3,4&#125; 最大距离都为 2 。</span><br><span class=\"line\">不存在城市间最大距离为 3 的子树</span><br></pre></td></tr></table></figure>\n<p>方法一：比赛时没有时间做，虽然hard但是比较简单，看了题解后写上了。就是暴力的枚举所有的子树，然后再bfs求最大距离，同时判断一下是否构成了子树（这个组合所有节点都出现了）。这里根据Lee215的竞赛写法做了一些调整。时间复杂度为2**15。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countSubgraphsForEachDiameter</span><span class=\"params\">(self, n: int, edges: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    g = [[] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> u, v <span class=\"keyword\">in</span> edges:</span><br><span class=\"line\">        u, v = u<span class=\"number\">-1</span>, v<span class=\"number\">-1</span></span><br><span class=\"line\">        g[u].append(v)</span><br><span class=\"line\">        g[v].append(u)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">max_d</span><span class=\"params\">(comb)</span>:</span></span><br><span class=\"line\">        ans = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            mask = comb</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"number\">1</span>&lt;&lt;i) &amp; comb:</span><br><span class=\"line\">                bfs = deque([(i, <span class=\"number\">0</span>)])</span><br><span class=\"line\">                d = <span class=\"number\">0</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> bfs:</span><br><span class=\"line\">                    k, d = bfs.popleft()</span><br><span class=\"line\">                    mask ^= (<span class=\"number\">1</span>&lt;&lt;k)  <span class=\"comment\"># 标记k被取出此时为0</span></span><br><span class=\"line\">                    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> g[k]:</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (<span class=\"number\">1</span>&lt;&lt;j) &amp; mask:   <span class=\"comment\"># 为1的是剩下的</span></span><br><span class=\"line\">                            bfs.append((j, d+<span class=\"number\">1</span>))</span><br><span class=\"line\">                <span class=\"keyword\">if</span> mask: <span class=\"keyword\">return</span> <span class=\"number\">0</span>       <span class=\"comment\"># 不是0说明没有构成子树</span></span><br><span class=\"line\">                ans = max(ans, d)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\"></span><br><span class=\"line\">    res = [<span class=\"number\">0</span>] * (n<span class=\"number\">-1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> comb <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>&lt;&lt;n):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> comb &amp; (comb<span class=\"number\">-1</span>) == <span class=\"number\">0</span>: <span class=\"keyword\">continue</span></span><br><span class=\"line\">        d = max_d(comb)</span><br><span class=\"line\">        res[d<span class=\"number\">-1</span>] += d&gt;<span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"1284-Minimum-Number-of-Flips-to-Convert-Binary-Matrix-to-Zero-Matrix\"><a href=\"#1284-Minimum-Number-of-Flips-to-Convert-Binary-Matrix-to-Zero-Matrix\" class=\"headerlink\" title=\"1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix\"></a>1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix</h3><h4 id=\"二维矩阵中，-每次翻拍“十”字，最小步数翻成0-原题\"><a href=\"#二维矩阵中，-每次翻拍“十”字，最小步数翻成0-原题\" class=\"headerlink\" title=\"二维矩阵中， 每次翻拍“十”字，最小步数翻成0.原题\"></a>二维矩阵中， 每次翻拍“十”字，最小步数翻成0.<a href=\"https://leetcode.com/problems/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: mat &#x3D; [[0,0],[0,1]]</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: One possible solution is to flip (1, 0) then (0, 1) and finally (1, 1) as shown.</span><br></pre></td></tr></table></figure>\n<p>方法一：看了答案才做出来，看到提示bfs，但是没有想到可以将这个二维矩阵转成一个二进制是它的数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minFlips</span><span class=\"params\">(self, mat: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    m, n = len(mat), len(mat[<span class=\"number\">0</span>])</span><br><span class=\"line\">    start = sum(cell&lt;&lt;(i*n+j) <span class=\"keyword\">for</span> i, row <span class=\"keyword\">in</span> enumerate(mat) <span class=\"keyword\">for</span> j, cell <span class=\"keyword\">in</span> enumerate(row))</span><br><span class=\"line\">    q = collections.deque([(start, <span class=\"number\">0</span>)])</span><br><span class=\"line\">    seen = &#123;start&#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> q:</span><br><span class=\"line\">        cur, step = q.popleft()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> cur:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> step</span><br><span class=\"line\">        <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(m):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> y <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">                nxt = cur</span><br><span class=\"line\">                <span class=\"keyword\">for</span> i, j <span class=\"keyword\">in</span> ((<span class=\"number\">0</span>, <span class=\"number\">1</span>), (<span class=\"number\">1</span>, <span class=\"number\">0</span>), (<span class=\"number\">-1</span>, <span class=\"number\">0</span>), (<span class=\"number\">0</span>, <span class=\"number\">-1</span>), (<span class=\"number\">0</span>, <span class=\"number\">0</span>)):</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> m &gt; x+i &gt;= <span class=\"number\">0</span> &lt;= y+j &lt; n:</span><br><span class=\"line\">                        nxt ^= <span class=\"number\">1</span> &lt;&lt; ((x+i)*n + y+j) <span class=\"comment\"># 0 ^ 0 = 0, 1 ^ 0 = 1</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> nxt <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> seen:</span><br><span class=\"line\">                    q.append((nxt, step+<span class=\"number\">1</span>))</span><br><span class=\"line\">                    seen.add(nxt)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1293-Shortest-Path-in-a-Grid-with-Obstacles-Elimination\"><a href=\"#1293-Shortest-Path-in-a-Grid-with-Obstacles-Elimination\" class=\"headerlink\" title=\"1293. Shortest Path in a Grid with Obstacles Elimination\"></a>1293. Shortest Path in a Grid with Obstacles Elimination</h3><h4 id=\"最短路径，可以打通障碍k次。原题\"><a href=\"#最短路径，可以打通障碍k次。原题\" class=\"headerlink\" title=\"最短路径，可以打通障碍k次。原题\"></a>最短路径，可以打通障碍k次。<a href=\"https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: </span><br><span class=\"line\">grid &#x3D; </span><br><span class=\"line\">[[0,0,0],</span><br><span class=\"line\"> [1,1,0],</span><br><span class=\"line\"> [0,0,0],</span><br><span class=\"line\"> [0,1,1],</span><br><span class=\"line\"> [0,0,0]], </span><br><span class=\"line\">k &#x3D; 1</span><br><span class=\"line\">Output: 6</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">The shortest path without eliminating any obstacle is 10. </span><br><span class=\"line\">The shortest path with one obstacle elimination at position (3,2) is 6. Such path is (0,0) -&gt; (0,1) -&gt; (0,2) -&gt; (1,2) -&gt; (2,2) -&gt; (3,2) -&gt; (4,2).</span><br></pre></td></tr></table></figure>\n<p>方法一：一开始想到了正确思路，但是想错了最小步骤怎么求，其实不用求，第一个到达的就是最小的步数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">shortestPath</span><span class=\"params\">(self, g: List[List[int]], k: int)</span> -&gt; int:</span></span><br><span class=\"line\">    m, n = len(g), len(g[<span class=\"number\">0</span>])</span><br><span class=\"line\">    q = collections.deque([(<span class=\"number\">0</span>, <span class=\"number\">0</span>, k, <span class=\"number\">0</span>)])</span><br><span class=\"line\">    seen = &#123;(<span class=\"number\">0</span>, <span class=\"number\">0</span>, k)&#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> q:</span><br><span class=\"line\">        x, y, r, s = q.popleft()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> x==m<span class=\"number\">-1</span> <span class=\"keyword\">and</span> y==n<span class=\"number\">-1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s</span><br><span class=\"line\">        <span class=\"comment\"># 如果可以直接直角边走到末尾，那么直接过去，优化快了700ms+.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> r &gt;= m + n - <span class=\"number\">3</span> - x - y:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s + m + n - <span class=\"number\">2</span> - x - y</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, j <span class=\"keyword\">in</span> ((<span class=\"number\">0</span>, <span class=\"number\">1</span>), (<span class=\"number\">1</span>, <span class=\"number\">0</span>), (<span class=\"number\">-1</span>, <span class=\"number\">0</span>), (<span class=\"number\">0</span>, <span class=\"number\">-1</span>)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=x+i&lt;m <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=y+j&lt;n:</span><br><span class=\"line\">                nr = r-(g[x+i][y+j]==<span class=\"number\">1</span>)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (x+i, y+j, nr) <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> seen <span class=\"keyword\">and</span> nr&gt;=<span class=\"number\">0</span>:</span><br><span class=\"line\">                    q.append((x+i, y+j, nr, s+<span class=\"number\">1</span>))</span><br><span class=\"line\">                    seen.add((x+i, y+j, nr))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1298-Maximum-Candies-You-Can-Get-from-Boxes\"><a href=\"#1298-Maximum-Candies-You-Can-Get-from-Boxes\" class=\"headerlink\" title=\"1298. Maximum Candies You Can Get from Boxes\"></a>1298. Maximum Candies You Can Get from Boxes</h3><h4 id=\"最多从盒子中拿到的糖果。从初始的盒子中往外取，盒子能嵌套盒子，盒子如果上锁还需要钥匙打开。原题\"><a href=\"#最多从盒子中拿到的糖果。从初始的盒子中往外取，盒子能嵌套盒子，盒子如果上锁还需要钥匙打开。原题\" class=\"headerlink\" title=\"最多从盒子中拿到的糖果。从初始的盒子中往外取，盒子能嵌套盒子，盒子如果上锁还需要钥匙打开。原题\"></a>最多从盒子中拿到的糖果。从初始的盒子中往外取，盒子能嵌套盒子，盒子如果上锁还需要钥匙打开。<a href=\"https://leetcode.com/problems/maximum-candies-you-can-get-from-boxes/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：有一点没有想到，就是如果前面的盒子被拿出来，但是没有钥匙，知道后面的盒子才获取到钥匙。这种情况需要如何处理？这里参考了lee215的方式。q来表示所有已经打开的盒子，seen表示所有可见的盒子，这样当拿到钥匙时，其实需要做两个操作，如果这个盒子可见，将其放入q，如果盒子没见，将其锁打开（虽不符常理），这样在遇见盒子时可以直接将其添加到队列。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxCandies</span><span class=\"params\">(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    q = collections.deque(b <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> initialBoxes <span class=\"keyword\">if</span> status[b])</span><br><span class=\"line\">    seen = set(initialBoxes)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> q:</span><br><span class=\"line\">        b = q.popleft()</span><br><span class=\"line\">        ans += candies[b]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> new_box <span class=\"keyword\">in</span> containedBoxes[b]:</span><br><span class=\"line\">            seen.add(new_box)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> status[new_box]:</span><br><span class=\"line\">                q.append(new_box)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> key <span class=\"keyword\">in</span> keys[b]:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> status[key] == <span class=\"number\">0</span> <span class=\"keyword\">and</span> key <span class=\"keyword\">in</span> seen:</span><br><span class=\"line\">                q.append(key)</span><br><span class=\"line\">            status[key] = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"1345-Jump-Game-IV\"><a href=\"#1345-Jump-Game-IV\" class=\"headerlink\" title=\"1345. Jump Game IV\"></a>1345. Jump Game IV</h3><h4 id=\"跳到末尾最小步数，可以向前向后或者跳到一样的值。原题\"><a href=\"#跳到末尾最小步数，可以向前向后或者跳到一样的值。原题\" class=\"headerlink\" title=\"跳到末尾最小步数，可以向前向后或者跳到一样的值。原题\"></a>跳到末尾最小步数，可以向前向后或者跳到一样的值。<a href=\"https://leetcode.com/problems/jump-game-iv/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: arr &#x3D; [100,-23,-23,404,100,23,23,23,3,404]</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: You need three jumps from index 0 --&gt; 4 --&gt; 3 --&gt; 9. Note that index 9 is the last index of the array.</span><br></pre></td></tr></table></figure>\n<p>方法一：bfs。需要注意num_seen记录所有的同值，否则会超时。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minJumps</span><span class=\"params\">(self, arr: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    equal = collections.defaultdict(list)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, a <span class=\"keyword\">in</span> enumerate(arr):</span><br><span class=\"line\">        equal[a].append(i)</span><br><span class=\"line\">        </span><br><span class=\"line\">    q = collections.deque([(<span class=\"number\">0</span>, <span class=\"number\">0</span>)])</span><br><span class=\"line\">    pos_seen, num_seen = set(), set()</span><br><span class=\"line\">    <span class=\"keyword\">while</span> q:</span><br><span class=\"line\">        p, s = q.popleft()</span><br><span class=\"line\">        pos_seen.add(p)</span><br><span class=\"line\">        num = arr[p]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> p == len(arr)<span class=\"number\">-1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s</span><br><span class=\"line\">        <span class=\"keyword\">for</span> nxt <span class=\"keyword\">in</span> [p<span class=\"number\">-1</span>, p+<span class=\"number\">1</span>] + equal[num] * (num <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> num_seen):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nxt <span class=\"keyword\">in</span> pos_seen <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> <span class=\"number\">0</span>&lt;=nxt&lt;len(arr): <span class=\"keyword\">continue</span></span><br><span class=\"line\">            q.append((nxt, s+<span class=\"number\">1</span>))</span><br><span class=\"line\">        num_seen.add(num)</span><br></pre></td></tr></table></figure>\n<h3 id=\"1391-Check-if-There-is-a-Valid-Path-in-a-Grid\"><a href=\"#1391-Check-if-There-is-a-Valid-Path-in-a-Grid\" class=\"headerlink\" title=\"1391. Check if There is a Valid Path in a Grid\"></a>1391. Check if There is a Valid Path in a Grid</h3><h4 id=\"判断是否能到达右下点。原题\"><a href=\"#判断是否能到达右下点。原题\" class=\"headerlink\" title=\"判断是否能到达右下点。原题\"></a>判断是否能到达右下点。<a href=\"https://leetcode.com/problems/check-if-there-is-a-valid-path-in-a-grid/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: grid &#x3D; [[2,4,3],[6,5,2]]</span><br><span class=\"line\">Output: true</span><br><span class=\"line\">Explanation: As shown you can start at cell (0, 0) and visit all the cells of the grid to reach (m - 1, n - 1).</span><br></pre></td></tr></table></figure>\n<p>方法一：dfs。需要注意的是<code>(-x, -y) in directions[grid[ni][nj]])</code>是用来判断该块和下一块是否是联通的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hasValidPath</span><span class=\"params\">(self, grid: List[List[int]])</span> -&gt; bool:</span></span><br><span class=\"line\">    directions = &#123;</span><br><span class=\"line\">        <span class=\"number\">1</span>: ((<span class=\"number\">0</span>, <span class=\"number\">1</span>), (<span class=\"number\">0</span>, <span class=\"number\">-1</span>)),</span><br><span class=\"line\">        <span class=\"number\">2</span>: ((<span class=\"number\">1</span>, <span class=\"number\">0</span>), (<span class=\"number\">-1</span>, <span class=\"number\">0</span>)),</span><br><span class=\"line\">        <span class=\"number\">3</span>: ((<span class=\"number\">1</span>, <span class=\"number\">0</span>), (<span class=\"number\">0</span>, <span class=\"number\">-1</span>)),</span><br><span class=\"line\">        <span class=\"number\">4</span>: ((<span class=\"number\">0</span>, <span class=\"number\">1</span>), (<span class=\"number\">1</span>, <span class=\"number\">0</span>)),</span><br><span class=\"line\">        <span class=\"number\">5</span>: ((<span class=\"number\">-1</span>, <span class=\"number\">0</span>), (<span class=\"number\">0</span>, <span class=\"number\">-1</span>)),</span><br><span class=\"line\">        <span class=\"number\">6</span>: ((<span class=\"number\">0</span>, <span class=\"number\">1</span>), (<span class=\"number\">-1</span>, <span class=\"number\">0</span>))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    m, n = len(grid), len(grid[<span class=\"number\">0</span>])</span><br><span class=\"line\">    seen = set()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(i, j)</span>:</span></span><br><span class=\"line\">        seen.add((i, j))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i, j) == (m<span class=\"number\">-1</span>, n<span class=\"number\">-1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        block = grid[i][j]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> directions[block]:</span><br><span class=\"line\">            ni, nj = i+x, j+y</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=ni&lt;m <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=nj&lt;n <span class=\"keyword\">and</span> (ni, nj) <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> seen <span class=\"keyword\">and</span> (</span><br><span class=\"line\">                (-x, -y) <span class=\"keyword\">in</span> directions[grid[ni][nj]]):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> dfs(ni, nj):</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> dfs(<span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"1162-As-Far-from-Land-as-Possible\"><a href=\"#1162-As-Far-from-Land-as-Possible\" class=\"headerlink\" title=\"1162. As Far from Land as Possible\"></a>1162. As Far from Land as Possible</h3><h4 id=\"离陆地最远的点的距离。原题\"><a href=\"#离陆地最远的点的距离。原题\" class=\"headerlink\" title=\"离陆地最远的点的距离。原题\"></a>离陆地最远的点的距离。<a href=\"https://leetcode.com/problems/as-far-from-land-as-possible/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [[1,0,1],[0,0,0],[1,0,1]]</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">The cell (1, 1) is as far as possible from all the land with distance 2.</span><br></pre></td></tr></table></figure>\n<p>方法一：bfs. 此题竞赛时想到了解法，但是出发点有点问题，是从水找陆地，这样的话有很多重复的循环，导致超时。正确的思路是从陆地遍历水。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxDistance</span><span class=\"params\">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    R, C = len(grid), len(grid[<span class=\"number\">0</span>])</span><br><span class=\"line\">    q = collections.deque([(i, j, <span class=\"number\">0</span>) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(R) <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(C)</span><br><span class=\"line\">                           <span class=\"keyword\">if</span> grid[i][j] == <span class=\"number\">1</span>])</span><br><span class=\"line\">    d = <span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> q:</span><br><span class=\"line\">        x, y, d = q.popleft()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> grid[x][y] == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> d</span><br><span class=\"line\">        surrounds = ((x<span class=\"number\">-1</span>, y), (x+<span class=\"number\">1</span>, y), (x, y<span class=\"number\">-1</span>), (x, y+<span class=\"number\">1</span>))</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, j <span class=\"keyword\">in</span> surrounds:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=i&lt;R <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=j&lt;C <span class=\"keyword\">and</span> grid[i][j]==<span class=\"number\">0</span>:</span><br><span class=\"line\">                q.append((i, j, d+<span class=\"number\">1</span>))</span><br><span class=\"line\">                grid[i][j] = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> d <span class=\"keyword\">or</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1091-Shortest-Path-in-Binary-Matrix\"><a href=\"#1091-Shortest-Path-in-Binary-Matrix\" class=\"headerlink\" title=\"1091. Shortest Path in Binary Matrix\"></a>1091. Shortest Path in Binary Matrix</h3><h4 id=\"从左上到右下，只能走0，求最短路径长度，可以斜着走。原题\"><a href=\"#从左上到右下，只能走0，求最短路径长度，可以斜着走。原题\" class=\"headerlink\" title=\"从左上到右下，只能走0，求最短路径长度，可以斜着走。原题\"></a>从左上到右下，只能走0，求最短路径长度，可以斜着走。<a href=\"https://leetcode.com/problems/shortest-path-in-binary-matrix/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：核心思想为，BFS，到终点的深度，使用两个数组。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">shortestPathBinaryMatrix</span><span class=\"params\">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    n = len(grid)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> grid[<span class=\"number\">0</span>][<span class=\"number\">0</span>] == grid[<span class=\"number\">-1</span>][<span class=\"number\">-1</span>] == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">spread</span><span class=\"params\">(i, j)</span>:</span></span><br><span class=\"line\">        di = (<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>)</span><br><span class=\"line\">        dj = (<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> di:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> m <span class=\"keyword\">in</span> dj:</span><br><span class=\"line\">                x, y = i+k, j+m</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=x&lt;n <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=y&lt;n <span class=\"keyword\">and</span> grid[x][y]==<span class=\"number\">0</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">yield</span> x, y</span><br><span class=\"line\">    </span><br><span class=\"line\">    d = <span class=\"number\">0</span></span><br><span class=\"line\">    bfs = [(<span class=\"number\">0</span>, <span class=\"number\">0</span>)]</span><br><span class=\"line\">    seen = set()</span><br><span class=\"line\">    <span class=\"keyword\">while</span> bfs:</span><br><span class=\"line\">        d += <span class=\"number\">1</span></span><br><span class=\"line\">        bfs2 = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (x, y) <span class=\"keyword\">in</span> bfs:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> x==n<span class=\"number\">-1</span> <span class=\"keyword\">and</span> y==n<span class=\"number\">-1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> d</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x, y) <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> seen:</span><br><span class=\"line\">                bfs2.extend([(i, j) <span class=\"keyword\">for</span> i, j <span class=\"keyword\">in</span> spread(x, y)])</span><br><span class=\"line\">                seen.add((x, y))</span><br><span class=\"line\">        bfs = bfs2</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：使用双端队列。为了避免起点为1，所以从-1开始，深度为0.</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">shortestPathBinaryMatrix</span><span class=\"params\">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    n = len(grid)</span><br><span class=\"line\">    q = collections.deque([(<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">0</span>)])</span><br><span class=\"line\">    seen = set()</span><br><span class=\"line\">    <span class=\"keyword\">while</span> q:</span><br><span class=\"line\">        x, y, d = q.popleft()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> x==n<span class=\"number\">-1</span> <span class=\"keyword\">and</span> y==n<span class=\"number\">-1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> d</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, j <span class=\"keyword\">in</span> ((x<span class=\"number\">-1</span>, y<span class=\"number\">-1</span>), (x<span class=\"number\">-1</span>, y), (x<span class=\"number\">-1</span>, y+<span class=\"number\">1</span>), (x, y<span class=\"number\">-1</span>), (x, y+<span class=\"number\">1</span>), (x+<span class=\"number\">1</span>, y<span class=\"number\">-1</span>), (x+<span class=\"number\">1</span>, y), (x+<span class=\"number\">1</span>, y+<span class=\"number\">1</span>)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=i&lt;n <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=j&lt;n <span class=\"keyword\">and</span> grid[i][j]==<span class=\"number\">0</span> <span class=\"keyword\">and</span> (i, j) <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> seen:</span><br><span class=\"line\">                q.append((i, j, d+<span class=\"number\">1</span>))</span><br><span class=\"line\">                seen.add((i, j))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1034-Coloring-A-Border\"><a href=\"#1034-Coloring-A-Border\" class=\"headerlink\" title=\"1034. Coloring A Border\"></a>1034. Coloring A Border</h3><h4 id=\"给边界染色，此题和733-flood-fill很像，区别在于，那个是将所有区域染色，这个是只将边界染色。原题\"><a href=\"#给边界染色，此题和733-flood-fill很像，区别在于，那个是将所有区域染色，这个是只将边界染色。原题\" class=\"headerlink\" title=\"给边界染色，此题和733.flood fill很像，区别在于，那个是将所有区域染色，这个是只将边界染色。原题\"></a>给边界染色，此题和733.flood fill很像，区别在于，那个是将所有区域染色，这个是只将边界染色。<a href=\"https://leetcode.com/problems/coloring-a-border/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：写法稍作修改，将判断移到前面。四个方向只要有一个返回False就说明是边界的点。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">colorBorder</span><span class=\"params\">(self, grid: List[List[int]], r0: int, c0: int, color: int)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(x, y)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x, y) <span class=\"keyword\">in</span> seen:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> (<span class=\"number\">0</span>&lt;=x&lt;R <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=y&lt;C <span class=\"keyword\">and</span> grid[x][y]==grid[r0][c0]):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        seen.add((x, y))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> dfs(x+<span class=\"number\">1</span>, y) + dfs(x<span class=\"number\">-1</span>, y) + dfs(x, y<span class=\"number\">-1</span>) + dfs(x, y+<span class=\"number\">1</span>) &lt; <span class=\"number\">4</span>:</span><br><span class=\"line\">            grid[x][y] = color</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    seen, R, C = set(), len(grid), len(grid[<span class=\"number\">0</span>])</span><br><span class=\"line\">    dfs(r0, c0)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> grid</span><br></pre></td></tr></table></figure>\n<h3 id=\"1031-Number-of-Enclaves\"><a href=\"#1031-Number-of-Enclaves\" class=\"headerlink\" title=\"1031. Number of Enclaves\"></a>1031. Number of Enclaves</h3><h4 id=\"求被困的地点个数。1表示陆地，不能够走到边界的陆地称为被困的陆地。原题\"><a href=\"#求被困的地点个数。1表示陆地，不能够走到边界的陆地称为被困的陆地。原题\" class=\"headerlink\" title=\"求被困的地点个数。1表示陆地，不能够走到边界的陆地称为被困的陆地。原题\"></a>求被困的地点个数。1表示陆地，不能够走到边界的陆地称为被困的陆地。<a href=\"https://leetcode.com/problems/number-of-enclaves/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：简单的DFS</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numEnclaves</span><span class=\"params\">(self, A: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> A:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    R, C = len(A), len(A[<span class=\"number\">0</span>])</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">spread</span><span class=\"params\">(i, j)</span>:</span></span><br><span class=\"line\">        A[i][j] = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> ((i<span class=\"number\">-1</span>, j), (i+<span class=\"number\">1</span>, j), (i, j<span class=\"number\">-1</span>), (i, j+<span class=\"number\">1</span>)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=x&lt;R <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=y&lt;C <span class=\"keyword\">and</span> A[x][y] == <span class=\"number\">1</span>:</span><br><span class=\"line\">                spread(x, y)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(R):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> A[i][<span class=\"number\">0</span>]==<span class=\"number\">1</span>:</span><br><span class=\"line\">            spread(i, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> A[i][C<span class=\"number\">-1</span>] == <span class=\"number\">1</span>:</span><br><span class=\"line\">            spread(i, C<span class=\"number\">-1</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(C):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> A[<span class=\"number\">0</span>][j] == <span class=\"number\">1</span>:</span><br><span class=\"line\">            spread(<span class=\"number\">0</span>, j)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> A[R<span class=\"number\">-1</span>][j] == <span class=\"number\">1</span>:</span><br><span class=\"line\">            spread(R<span class=\"number\">-1</span>, j)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(sum(row) <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> A)</span><br></pre></td></tr></table></figure>\n<h3 id=\"695-Max-Area-of-Island\"><a href=\"#695-Max-Area-of-Island\" class=\"headerlink\" title=\"695. Max Area of Island\"></a>695. Max Area of Island</h3><h4 id=\"最大的岛屿面积。原题\"><a href=\"#最大的岛屿面积。原题\" class=\"headerlink\" title=\"最大的岛屿面积。原题\"></a>最大的岛屿面积。<a href=\"https://leetcode.com/problems/max-area-of-island/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：dfs.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxAreaOfIsland</span><span class=\"params\">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    R, C = len(grid), len(grid[<span class=\"number\">0</span>])</span><br><span class=\"line\">    area, seen = <span class=\"number\">0</span>, set()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">spread</span><span class=\"params\">(i, j)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> (<span class=\"number\">0</span>&lt;=i&lt;R <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=j&lt;C <span class=\"keyword\">and</span> (i, j) <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> seen <span class=\"keyword\">and</span></span><br><span class=\"line\">                grid[i][j]):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        seen.add((i, j))</span><br><span class=\"line\">        surrounds = ((i<span class=\"number\">-1</span>, j), (i+<span class=\"number\">1</span>, j), (i, j<span class=\"number\">-1</span>), (i, j+<span class=\"number\">1</span>))</span><br><span class=\"line\">        <span class=\"comment\"># return 1 + sum(map(lambda x: dfs(*x), surrounds))   </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span> + sum(starmap(dfs, surrounds))</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(spread(i, j) </span><br><span class=\"line\">               <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(R) <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(C))</span><br></pre></td></tr></table></figure>\n<h3 id=\"994-Rotting-Oranges\"><a href=\"#994-Rotting-Oranges\" class=\"headerlink\" title=\"994. Rotting Oranges\"></a>994. Rotting Oranges</h3><h4 id=\"腐烂的橘子，1表示新鲜，2表示腐烂，每分钟腐烂的会传染给四周上下左右的橘子，问所有的橘子腐烂最少需要几分钟。原题\"><a href=\"#腐烂的橘子，1表示新鲜，2表示腐烂，每分钟腐烂的会传染给四周上下左右的橘子，问所有的橘子腐烂最少需要几分钟。原题\" class=\"headerlink\" title=\"腐烂的橘子，1表示新鲜，2表示腐烂，每分钟腐烂的会传染给四周上下左右的橘子，问所有的橘子腐烂最少需要几分钟。原题\"></a>腐烂的橘子，1表示新鲜，2表示腐烂，每分钟腐烂的会传染给四周上下左右的橘子，问所有的橘子腐烂最少需要几分钟。<a href=\"https://leetcode.com/problems/rotting-oranges/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><img src=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%9B%BE%E7%AF%87%EF%BC%89Graph/oranges.png\" class>\n<p>方法一：竞赛时虽然做出来了，但有些点没想出来，其实是BFS，这样一想退出条件就很清楚了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">orangesRotting</span><span class=\"params\">(self, g: <span class=\"string\">'List[List[int]]'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    R, C = len(g), len(g[<span class=\"number\">0</span>])</span><br><span class=\"line\">    rotted = ((x, y, <span class=\"number\">0</span>) <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(R) <span class=\"keyword\">for</span> y <span class=\"keyword\">in</span> range(C) <span class=\"keyword\">if</span> g[x][y]==<span class=\"number\">2</span>)</span><br><span class=\"line\">    q = collections.deque(rotted)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">to_rot</span><span class=\"params\">(x, y)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> ((x<span class=\"number\">-1</span>, y), (x, y<span class=\"number\">-1</span>), (x+<span class=\"number\">1</span>, y), (x, y+<span class=\"number\">1</span>)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=x&lt;R <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=y&lt;C <span class=\"keyword\">and</span> g[x][y]==<span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">yield</span> x, y</span><br><span class=\"line\">    d = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> q:</span><br><span class=\"line\">        r, c, d = q.popleft()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> sr, sc <span class=\"keyword\">in</span> to_rot(r, c):</span><br><span class=\"line\">            g[sr][sc] = <span class=\"number\">2</span></span><br><span class=\"line\">            q.append((sr, sc, d+<span class=\"number\">1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"number\">1</span> <span class=\"keyword\">in</span> sum(g, []):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"733-Flood-Fill\"><a href=\"#733-Flood-Fill\" class=\"headerlink\" title=\"733. Flood Fill\"></a>733. Flood Fill</h3><h4 id=\"“洪水填充”，给定一个二维数组表示一张图片的像素，然后指定一个点和一个颜色，将这个点和上下左右四个点使用新的颜色填充，和这个点原来相同的颜色的点也受到影响，依次扩散，返回新的图片数组。原题\"><a href=\"#“洪水填充”，给定一个二维数组表示一张图片的像素，然后指定一个点和一个颜色，将这个点和上下左右四个点使用新的颜色填充，和这个点原来相同的颜色的点也受到影响，依次扩散，返回新的图片数组。原题\" class=\"headerlink\" title=\"“洪水填充”，给定一个二维数组表示一张图片的像素，然后指定一个点和一个颜色，将这个点和上下左右四个点使用新的颜色填充，和这个点原来相同的颜色的点也受到影响，依次扩散，返回新的图片数组。原题\"></a>“洪水填充”，给定一个二维数组表示一张图片的像素，然后指定一个点和一个颜色，将这个点和上下左右四个点使用新的颜色填充，和这个点原来相同的颜色的点也受到影响，依次扩散，返回新的图片数组。<a href=\"https://leetcode.com/problems/flood-fill/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: </span><br><span class=\"line\">image &#x3D; [[1,1,1],[1,1,0],[1,0,1]]</span><br><span class=\"line\">sr &#x3D; 1, sc &#x3D; 1, newColor &#x3D; 2</span><br><span class=\"line\">Output: [[2,2,2],[2,2,0],[2,0,1]]</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">From the center of the image (with position (sr, sc) &#x3D; (1, 1)), all pixels connected </span><br><span class=\"line\">by a path of the same color as the starting pixel are colored with the new color.</span><br><span class=\"line\">Note the bottom corner is not colored 2, because it is not 4-directionally connected</span><br><span class=\"line\">to the starting pixel.</span><br></pre></td></tr></table></figure>\n<p>方法一：dfs. 需要注意的是，如果目标点与颜色相同，则原图不变。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">floodFill</span><span class=\"params\">(self, image, sr, sc, newColor)</span>:</span></span><br><span class=\"line\">    rows, cols = len(image), len(image[<span class=\"number\">0</span>])</span><br><span class=\"line\">    old_val = image[sr][sc]</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">spread</span><span class=\"params\">(x, y)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> old_val == image[x][y]:</span><br><span class=\"line\">            image[x][y] = newColor</span><br><span class=\"line\">            <span class=\"keyword\">if</span> x<span class=\"number\">-1</span> &gt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">                spread(x<span class=\"number\">-1</span>, y)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> x+<span class=\"number\">1</span> &lt; rows:</span><br><span class=\"line\">                spread(x+<span class=\"number\">1</span>, y)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> y<span class=\"number\">-1</span> &gt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">                spread(x, y<span class=\"number\">-1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> y+<span class=\"number\">1</span> &lt; cols:</span><br><span class=\"line\">                spread(x, y+<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> old_val != newColor:</span><br><span class=\"line\">        spread(sr, sc)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> image</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：上述方法的变形。看起来更优雅。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">floodFill</span><span class=\"params\">(self, image, sr, sc, newColor)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(x, y)</span>:</span></span><br><span class=\"line\">        image[x][y] = newColor</span><br><span class=\"line\">        <span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> ((x<span class=\"number\">-1</span>, y), (x+<span class=\"number\">1</span>, y), (x, y+<span class=\"number\">1</span>), (x, y<span class=\"number\">-1</span>)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=x&lt;rows <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=y&lt;cols <span class=\"keyword\">and</span> image[x][y]==old_val:</span><br><span class=\"line\">                dfs(x, y)</span><br><span class=\"line\">        </span><br><span class=\"line\">    old_val, rows, cols = image[sr][sc], len(image), len(image[<span class=\"number\">0</span>])</span><br><span class=\"line\">    <span class=\"keyword\">if</span> old_val != newColor:</span><br><span class=\"line\">        dfs(sr, sc)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> image</span><br></pre></td></tr></table></figure>\n<h3 id=\"1625-Lexicographically-Smallest-String-After-Applying-Operations\"><a href=\"#1625-Lexicographically-Smallest-String-After-Applying-Operations\" class=\"headerlink\" title=\"1625. Lexicographically Smallest String After Applying Operations\"></a><a href=\"https://leetcode.com/problems/lexicographically-smallest-string-after-applying-operations/\" target=\"_blank\" rel=\"noopener\">1625. Lexicographically Smallest String After Applying Operations</a></h3><h4 id=\"给你一个字符串-s-以及两个整数-a-和-b-。其中，字符串-s-的长度为偶数，且仅由数字-0-到-9-组成。\"><a href=\"#给你一个字符串-s-以及两个整数-a-和-b-。其中，字符串-s-的长度为偶数，且仅由数字-0-到-9-组成。\" class=\"headerlink\" title=\"给你一个字符串 s 以及两个整数 a 和 b 。其中，字符串 s 的长度为偶数，且仅由数字 0 到 9 组成。\"></a>给你一个字符串 s 以及两个整数 a 和 b 。其中，字符串 s 的长度为偶数，且仅由数字 0 到 9 组成。</h4><p>你可以在 s 上按任意顺序多次执行下面两个操作之一：</p>\n<p>累加：将  a 加到 s 中所有下标为奇数的元素上（下标从 0 开始）。数字一旦超过 9 就会变成 0，如此循环往复。例如，s = “3456” 且 a = 5，则执行此操作后 s 变成 “3951”。<br>轮转：将 s 向右轮转 b 位。例如，s = “3456” 且 b = 1，则执行此操作后 s 变成 “6345”。<br>请你返回在 s 上执行上述操作任意次后可以得到的 字典序最小 的字符串。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：s &#x3D; &quot;5525&quot;, a &#x3D; 9, b &#x3D; 2</span><br><span class=\"line\">输出：&quot;2050&quot;</span><br><span class=\"line\">解释：执行操作如下：</span><br><span class=\"line\">初态：&quot;5525&quot;</span><br><span class=\"line\">轮转：&quot;2555&quot;</span><br><span class=\"line\">累加：&quot;2454&quot;</span><br><span class=\"line\">累加：&quot;2353&quot;</span><br><span class=\"line\">轮转：&quot;5323&quot;</span><br><span class=\"line\">累加：&quot;5222&quot;</span><br><span class=\"line\">累加：&quot;5121&quot;</span><br><span class=\"line\">轮转：&quot;2151&quot;</span><br><span class=\"line\">累加：&quot;2050&quot;​​​​​​​​​​​​</span><br><span class=\"line\">无法获得字典序小于 &quot;2050&quot; 的字符串。</span><br></pre></td></tr></table></figure>\n<p>方法一：这题比较难想，作为竞赛第二题一直卡住了，实际没有3题简单。BFS，暴力去做就行，但是比赛时写得有一点问题TLE了。</p>\n<p>但是还是想到一些规律，如果b是偶数时，累加的位数只有奇数位；如果b是奇数，那么通过旋转每一位都可能累加，但是累加和旋转的顺序其实是不想关的，可以单独地操作。时间1700ms。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findLexSmallestString</span><span class=\"params\">(self, s: str, a: int, b: int)</span> -&gt; str:</span></span><br><span class=\"line\">    q, seen, ans = deque([s]), &#123;s&#125;, s</span><br><span class=\"line\">    <span class=\"keyword\">while</span> q:</span><br><span class=\"line\">        cur = q.popleft()</span><br><span class=\"line\">        ans = min(ans, cur)</span><br><span class=\"line\">        nxt = <span class=\"string\">''</span>.join(str(n <span class=\"keyword\">if</span> i&amp;<span class=\"number\">1</span>==<span class=\"number\">0</span> <span class=\"keyword\">else</span> (int(n)+a)%<span class=\"number\">10</span>) <span class=\"keyword\">for</span> i, n <span class=\"keyword\">in</span> enumerate(cur))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> nxt <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> seen:</span><br><span class=\"line\">            seen.add(nxt)</span><br><span class=\"line\">            q.append(nxt)</span><br><span class=\"line\">        rot = nxt[-b:] + nxt[:-b]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> rot <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> seen:</span><br><span class=\"line\">            seen.add(rot)</span><br><span class=\"line\">            q.append(rot)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法二：dfs，也是可以，向BFS那样去重就行了。速度比方法一慢了一点2400ms。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findLexSmallestString</span><span class=\"params\">(self, s: str, a: int, b: int)</span> -&gt; str:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">op_1</span><span class=\"params\">(s)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(str((int(c)+a)%<span class=\"number\">10</span>) <span class=\"keyword\">if</span> i&amp;<span class=\"number\">1</span> <span class=\"keyword\">else</span> c <span class=\"keyword\">for</span> i, c <span class=\"keyword\">in</span> enumerate(s))</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">op_2</span><span class=\"params\">(s)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> s[-b:] + s[:-b]</span><br><span class=\"line\">    </span><br><span class=\"line\">    seen = set()</span><br><span class=\"line\">    stack = [s]</span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"keyword\">while</span> stack:</span><br><span class=\"line\">        s = stack.pop()</span><br><span class=\"line\">        seen.add(s)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ss := op_1(s)) <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> seen: stack.append(ss)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ss := op_2(s)) <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> seen: stack.append(ss)</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> min(seen)</span><br></pre></td></tr></table></figure>\n<h3 id=\"1627-Graph-Connectivity-With-Threshold\"><a href=\"#1627-Graph-Connectivity-With-Threshold\" class=\"headerlink\" title=\"1627. Graph Connectivity With Threshold\"></a><a href=\"https://leetcode-cn.com/problems/graph-connectivity-with-threshold/\" target=\"_blank\" rel=\"noopener\">1627. Graph Connectivity With Threshold</a></h3><h4 id=\"给你1-n个点，如果两个点有一个约数大于Threshold，那么表明两点之间有边。问给你一些点对，判断这两个点是否相连。\"><a href=\"#给你1-n个点，如果两个点有一个约数大于Threshold，那么表明两点之间有边。问给你一些点对，判断这两个点是否相连。\" class=\"headerlink\" title=\"给你1~n个点，如果两个点有一个约数大于Threshold，那么表明两点之间有边。问给你一些点对，判断这两个点是否相连。\"></a>给你1~n个点，如果两个点有一个约数大于Threshold，那么表明两点之间有边。问给你一些点对，判断这两个点是否相连。</h4><p>方法一：简单的并查集问题，比赛可惜没时间做。这题的问题在于如何建图。枚举两个点一定会超时，所以从逆向考虑，枚举所有的约数，将这些点相连。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">areConnected</span><span class=\"params\">(self, n: int, threshold: int, queries: List[List[int]])</span> -&gt; List[bool]:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">union</span><span class=\"params\">(x, y)</span>:</span></span><br><span class=\"line\">        uf[find(x)] = find(y)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">find</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> x != uf[x]:</span><br><span class=\"line\">            uf[x] = find(uf[x])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> uf[x]</span><br><span class=\"line\"></span><br><span class=\"line\">    uf = list(range(<span class=\"number\">0</span>, n+<span class=\"number\">1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> range(threshold+<span class=\"number\">1</span>, n+<span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(d, n+<span class=\"number\">1</span>, d):</span><br><span class=\"line\">            union(j, d)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [find(u)==find(v) <span class=\"keyword\">for</span> u, v <span class=\"keyword\">in</span> queries]</span><br></pre></td></tr></table></figure>\n<h3 id=\"947-Most-Stones-Removed-with-Same-Row-or-Column\"><a href=\"#947-Most-Stones-Removed-with-Same-Row-or-Column\" class=\"headerlink\" title=\"947. Most Stones Removed with Same Row or Column\"></a><a href=\"https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/\" target=\"_blank\" rel=\"noopener\">947. Most Stones Removed with Same Row or Column</a></h3><h4 id=\"最多可以移除多少块石头，每次移除时，下一块找到同行或者同列的进行移除。\"><a href=\"#最多可以移除多少块石头，每次移除时，下一块找到同行或者同列的进行移除。\" class=\"headerlink\" title=\"最多可以移除多少块石头，每次移除时，下一块找到同行或者同列的进行移除。\"></a>最多可以移除多少块石头，每次移除时，下一块找到同行或者同列的进行移除。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: stones &#x3D; [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]</span><br><span class=\"line\">Output: 5</span><br></pre></td></tr></table></figure>\n<p>方法一：Union-Find，并查集方法。从一块石头开始，每次找同行或者同列的作为下一次石头。这些石头连通形成一个集合。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removeStones</span><span class=\"params\">(self, stones: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">union</span><span class=\"params\">(x, y)</span>:</span></span><br><span class=\"line\">        uf[find(x)] = find(y)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">find</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">        uf.setdefault(x, x)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> x != uf[x]:</span><br><span class=\"line\">            uf[x] = find(uf[x])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> uf[x]</span><br><span class=\"line\"></span><br><span class=\"line\">    uf = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> stones:</span><br><span class=\"line\">        union(x, y+<span class=\"number\">10000</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> len(stones) - len(&#123;find(x) <span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> stones&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"1654-Minimum-Jumps-to-Reach-Home\"><a href=\"#1654-Minimum-Jumps-to-Reach-Home\" class=\"headerlink\" title=\"1654. Minimum Jumps to Reach Home\"></a><a href=\"https://leetcode.com/problems/minimum-jumps-to-reach-home/\" target=\"_blank\" rel=\"noopener\">1654. Minimum Jumps to Reach Home</a></h3><h4 id=\"最少需要多少步能到达x，从坐标0点开始，每次可以向右跳a步，或者向左跳b步，但是不能连着两次向左跳。除此之外有些点不可达。\"><a href=\"#最少需要多少步能到达x，从坐标0点开始，每次可以向右跳a步，或者向左跳b步，但是不能连着两次向左跳。除此之外有些点不可达。\" class=\"headerlink\" title=\"最少需要多少步能到达x，从坐标0点开始，每次可以向右跳a步，或者向左跳b步，但是不能连着两次向左跳。除此之外有些点不可达。\"></a>最少需要多少步能到达x，从坐标0点开始，每次可以向右跳<code>a</code>步，或者向左跳<code>b</code>步，但是不能连着两次向左跳。除此之外有些点不可达。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: forbidden &#x3D; [14,4,18,1,15], a &#x3D; 3, b &#x3D; 15, x &#x3D; 9</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: 3 jumps forward (0 -&gt; 3 -&gt; 6 -&gt; 9) will get the bug home.</span><br></pre></td></tr></table></figure>\n<p>方法一：BFS，还是很直观可以想到的，比赛时忽略了<code>forbidden</code>错了一次。需要注意的点如果当前点大于最大范围后，就跳不回来了，这个终止条件。这里用一个<code>bool</code>控制了是否可以回跳。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minimumJumps</span><span class=\"params\">(self, forbidden: List[int], a: int, b: int, x: int)</span> -&gt; int:</span></span><br><span class=\"line\">    f = set(forbidden)</span><br><span class=\"line\">    bfs = [(<span class=\"number\">0</span>, <span class=\"literal\">True</span>, <span class=\"number\">0</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> cur, back, step <span class=\"keyword\">in</span> bfs:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cur == x:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> step</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cur+a &lt;= <span class=\"number\">4000</span> <span class=\"keyword\">and</span> cur+a <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> f:</span><br><span class=\"line\">            bfs.append((cur+a, <span class=\"literal\">True</span>, step+<span class=\"number\">1</span>))</span><br><span class=\"line\">            f.add(cur+a)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> back <span class=\"keyword\">and</span> cur-b&gt;=<span class=\"number\">0</span> <span class=\"keyword\">and</span> cur-b <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> f:</span><br><span class=\"line\">            bfs.append((cur-b, <span class=\"literal\">False</span>, step+<span class=\"number\">1</span>))</span><br><span class=\"line\">            f.add(cur-a)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1203-Sort-Items-by-Groups-Respecting-Dependencies\"><a href=\"#1203-Sort-Items-by-Groups-Respecting-Dependencies\" class=\"headerlink\" title=\"1203. Sort Items by Groups Respecting Dependencies\"></a><a href=\"https://leetcode.com/problems/sort-items-by-groups-respecting-dependencies/\" target=\"_blank\" rel=\"noopener\">1203. Sort Items by Groups Respecting Dependencies</a></h3><h4 id=\"公司共有-n-个项目和-m-个小组，每个项目要不无人接手，要不就由-m-个小组之一负责。group-i-表示第-i-个项目所属的小组，如果这个项目目前无人接手，那么-group-i-就等于-1。（项目和小组都是从零开始编号的）小组可能存在没有接手任何项目的情况。请你帮忙按要求安排这些项目的进度，并返回排序后的项目列表：\"><a href=\"#公司共有-n-个项目和-m-个小组，每个项目要不无人接手，要不就由-m-个小组之一负责。group-i-表示第-i-个项目所属的小组，如果这个项目目前无人接手，那么-group-i-就等于-1。（项目和小组都是从零开始编号的）小组可能存在没有接手任何项目的情况。请你帮忙按要求安排这些项目的进度，并返回排序后的项目列表：\" class=\"headerlink\" title=\"公司共有 n 个项目和  m 个小组，每个项目要不无人接手，要不就由 m 个小组之一负责。group[i] 表示第 i 个项目所属的小组，如果这个项目目前无人接手，那么 group[i] 就等于 -1。（项目和小组都是从零开始编号的）小组可能存在没有接手任何项目的情况。请你帮忙按要求安排这些项目的进度，并返回排序后的项目列表：\"></a>公司共有 n 个项目和  m 个小组，每个项目要不无人接手，要不就由 m 个小组之一负责。group[i] 表示第 i 个项目所属的小组，如果这个项目目前无人接手，那么 group[i] 就等于 -1。（项目和小组都是从零开始编号的）小组可能存在没有接手任何项目的情况。请你帮忙按要求安排这些项目的进度，并返回排序后的项目列表：</h4><ul>\n<li>同一小组的项目，排序后在列表中彼此相邻。</li>\n<li>项目之间存在一定的依赖关系，我们用一个列表 beforeItems 来表示，其中 beforeItems[i] 表示在进行第 i 个项目前（位于第 i 个项目左侧）应该完成的所有项目。</li>\n</ul>\n<h4 id=\"如果存在多个解决方案，只需要返回其中任意一个即可。如果没有合适的解决方案，就请返回一个-空列表-。\"><a href=\"#如果存在多个解决方案，只需要返回其中任意一个即可。如果没有合适的解决方案，就请返回一个-空列表-。\" class=\"headerlink\" title=\"如果存在多个解决方案，只需要返回其中任意一个即可。如果没有合适的解决方案，就请返回一个 空列表 。\"></a>如果存在多个解决方案，只需要返回其中任意一个即可。如果没有合适的解决方案，就请返回一个 空列表 。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 8, m &#x3D; 2, group &#x3D; [-1,-1,1,0,0,1,0,-1], beforeItems &#x3D; [[],[6],[5],[6],[3,6],[],[],[]]</span><br><span class=\"line\">Output: [6,3,4,1,5,2,0,7]</span><br></pre></td></tr></table></figure>\n<p>方法一：拓扑排序，hard题，首先以项目为拓扑排序很容易想到，这里还需要对组间进行拓扑排序。然后再进行一次组内排序。最后合并结果。需要注意的点比较多。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sortItems</span><span class=\"params\">(self, n: int, m: int, group: List[int], beforeItems: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_top_order</span><span class=\"params\">(g, degree)</span>:</span></span><br><span class=\"line\">        bfs = [i <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(g)) <span class=\"keyword\">if</span> degree[i]==<span class=\"number\">0</span>]</span><br><span class=\"line\">        res = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> bfs:</span><br><span class=\"line\">            res.append(i)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> g[i]:</span><br><span class=\"line\">                degree[j] += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> degree[j] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    bfs.append(j)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res <span class=\"keyword\">if</span> len(res)==len(degree) <span class=\"keyword\">else</span> []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 未分配组定义为新组</span></span><br><span class=\"line\">    it = count(m)</span><br><span class=\"line\">    group = [g <span class=\"keyword\">if</span> g!=<span class=\"number\">-1</span> <span class=\"keyword\">else</span> next(it) <span class=\"keyword\">for</span> g <span class=\"keyword\">in</span> group]</span><br><span class=\"line\">    m = next(it)        <span class=\"comment\"># m 增加了</span></span><br><span class=\"line\">    g_graph, p_graph = [[] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(m)], [[] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">    g_degree, p_degree = [<span class=\"number\">0</span>] * m, [<span class=\"number\">0</span>] * n</span><br><span class=\"line\">    <span class=\"keyword\">for</span> u <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> v <span class=\"keyword\">in</span> beforeItems[u]:</span><br><span class=\"line\">            p_degree[u] -= <span class=\"number\">1</span></span><br><span class=\"line\">            p_graph[v].append(u)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> group[u] != group[v]:    <span class=\"comment\"># 只比较不同组</span></span><br><span class=\"line\">                g_degree[group[u]] -= <span class=\"number\">1</span></span><br><span class=\"line\">                g_graph[group[v]].append(group[u])</span><br><span class=\"line\"></span><br><span class=\"line\">    projects = get_top_order(p_graph, p_degree)</span><br><span class=\"line\">    groups = get_top_order(g_graph, g_degree)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> projects <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> groups: <span class=\"keyword\">return</span> []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 组内排序</span></span><br><span class=\"line\">    order_within_group = defaultdict(list)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> projects:</span><br><span class=\"line\">        order_within_group[group[p]].append(p)</span><br><span class=\"line\"></span><br><span class=\"line\">    res = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> g <span class=\"keyword\">in</span> groups:</span><br><span class=\"line\">        res += order_within_group[g]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"803-Bricks-Falling-When-Hit\"><a href=\"#803-Bricks-Falling-When-Hit\" class=\"headerlink\" title=\"803. Bricks Falling When Hit\"></a><a href=\"https://leetcode.com/problems/bricks-falling-when-hit/\" target=\"_blank\" rel=\"noopener\">803. Bricks Falling When Hit</a></h3><h5 id=\"有一个-m-x-n-的二元网格，其中-1-表示砖块，0-表示空白。砖块-稳定（不会掉落）的前提是：\"><a href=\"#有一个-m-x-n-的二元网格，其中-1-表示砖块，0-表示空白。砖块-稳定（不会掉落）的前提是：\" class=\"headerlink\" title=\"有一个 m x n 的二元网格，其中 1 表示砖块，0 表示空白。砖块 稳定（不会掉落）的前提是：\"></a>有一个 m x n 的二元网格，其中 1 表示砖块，0 表示空白。砖块 稳定（不会掉落）的前提是：</h5><h5 id=\"一块砖直接连接到网格的顶部，或者至少有一块相邻（4-个方向之一）砖块-稳定-不会掉落时给你一个数组-hits-，这是需要依次消除砖块的位置。\"><a href=\"#一块砖直接连接到网格的顶部，或者至少有一块相邻（4-个方向之一）砖块-稳定-不会掉落时给你一个数组-hits-，这是需要依次消除砖块的位置。\" class=\"headerlink\" title=\"一块砖直接连接到网格的顶部，或者至少有一块相邻（4 个方向之一）砖块 稳定 不会掉落时给你一个数组 hits ，这是需要依次消除砖块的位置。\"></a>一块砖直接连接到网格的顶部，或者至少有一块相邻（4 个方向之一）砖块 稳定 不会掉落时给你一个数组 hits ，这是需要依次消除砖块的位置。</h5><h5 id=\"每当消除-hits-i-rowi-coli-位置上的砖块时，对应位置的砖块（若存在）会消失，然后其他的砖块可能因为这一消除操作而掉落。一旦砖块掉落，它会立即从网格中消失（即，它不会落在其他稳定的砖块上）。返回一个数组-result-，其中-result-i-表示第-i-次消除操作对应掉落的砖块数目。注意，消除可能指向是没有砖块的空白位置，如果发生这种情况，则没有砖块掉落。\"><a href=\"#每当消除-hits-i-rowi-coli-位置上的砖块时，对应位置的砖块（若存在）会消失，然后其他的砖块可能因为这一消除操作而掉落。一旦砖块掉落，它会立即从网格中消失（即，它不会落在其他稳定的砖块上）。返回一个数组-result-，其中-result-i-表示第-i-次消除操作对应掉落的砖块数目。注意，消除可能指向是没有砖块的空白位置，如果发生这种情况，则没有砖块掉落。\" class=\"headerlink\" title=\"每当消除 hits[i] = (rowi, coli) 位置上的砖块时，对应位置的砖块（若存在）会消失，然后其他的砖块可能因为这一消除操作而掉落。一旦砖块掉落，它会立即从网格中消失（即，它不会落在其他稳定的砖块上）。返回一个数组 result ，其中 result[i] 表示第 i 次消除操作对应掉落的砖块数目。注意，消除可能指向是没有砖块的空白位置，如果发生这种情况，则没有砖块掉落。\"></a>每当消除 hits[i] = (rowi, coli) 位置上的砖块时，对应位置的砖块（若存在）会消失，然后其他的砖块可能因为这一消除操作而掉落。一旦砖块掉落，它会立即从网格中消失（即，它不会落在其他稳定的砖块上）。返回一个数组 result ，其中 result[i] 表示第 i 次消除操作对应掉落的砖块数目。注意，消除可能指向是没有砖块的空白位置，如果发生这种情况，则没有砖块掉落。</h5><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: grid &#x3D; [[1,0,0,0],[1,1,1,0]], hits &#x3D; [[1,0]]</span><br><span class=\"line\">Output: [2]</span><br><span class=\"line\">Explanation: Starting with the grid:</span><br><span class=\"line\">[[1,0,0,0],</span><br><span class=\"line\"> [1,1,1,0]]</span><br><span class=\"line\">We erase the underlined brick at (1,0), resulting in the grid:</span><br><span class=\"line\">[[1,0,0,0],</span><br><span class=\"line\"> [0,1,1,0]]</span><br><span class=\"line\">The two underlined bricks are no longer stable as they are no longer connected to the top nor adjacent to another stable brick, so they will fall. The resulting grid is:</span><br><span class=\"line\">[[1,0,0,0],</span><br><span class=\"line\"> [0,0,0,0]]</span><br><span class=\"line\">Hence the result is [2].</span><br></pre></td></tr></table></figure>\n<p>方法一：逆向思维+dfs。逆向思维还是挺难想的。总共流程可以分为4步。</p>\n<ol>\n<li>按照hits顺序，将砖块敲掉，如果没有，需要敲成-1，为了将其周围的砖块分开。</li>\n<li>对首行每个单元格进行dfs，统计每个点能够挂住的砖块个数，然后将这些砖块标记为2.</li>\n<li>然后按照hits倒序，敲掉的砖块补回来，如果补回来的块能和2的砖块相连，则表示，这些砖块是掉落的。</li>\n<li>统计每次敲击的结果。</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hitBricks</span><span class=\"params\">(self, grid: List[List[int]], hits: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    M, N = len(grid), len(grid[<span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># Connect unconnected bricks and </span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(i, j)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> (<span class=\"number\">0</span>&lt;=i&lt;M <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=j&lt;N) <span class=\"keyword\">or</span> grid[i][j]!=<span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        ret = <span class=\"number\">1</span></span><br><span class=\"line\">        grid[i][j] = <span class=\"number\">2</span></span><br><span class=\"line\">        ret += sum(dfs(x, y) <span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> ((i<span class=\"number\">-1</span>, j), (i+<span class=\"number\">1</span>, j), (i, j<span class=\"number\">-1</span>), (i, j+<span class=\"number\">1</span>)))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># Check whether (i, j) is connected to Not Falling Bricks</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_connected</span><span class=\"params\">(i, j)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> i==<span class=\"number\">0</span> <span class=\"keyword\">or</span> any(<span class=\"number\">0</span>&lt;=x&lt;M <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=y&lt;N <span class=\"keyword\">and</span> grid[x][y]==<span class=\"number\">2</span> </span><br><span class=\"line\">                           <span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> ((i<span class=\"number\">-1</span>, j), (i+<span class=\"number\">1</span>, j), (i, j<span class=\"number\">-1</span>), (i, j+<span class=\"number\">1</span>)))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># Mark whether there is a brick at the each hit</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> hits:</span><br><span class=\"line\">        grid[x][y] -= <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># Get grid after all hits</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(N):</span><br><span class=\"line\">        dfs(<span class=\"number\">0</span>, j)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># Reversely add the block of each hits and get count of newly add bricks</span></span><br><span class=\"line\">    ret = [<span class=\"number\">0</span>] * len(hits)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> k, (i, j) <span class=\"keyword\">in</span> enumerate(reversed(hits)):</span><br><span class=\"line\">        grid[i][j] += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> grid[i][j]==<span class=\"number\">1</span> <span class=\"keyword\">and</span> is_connected(i, j):</span><br><span class=\"line\">            ret[~k] = dfs(i, j) - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret</span><br></pre></td></tr></table></figure>\n<h3 id=\"1766-Tree-of-Coprimes\"><a href=\"#1766-Tree-of-Coprimes\" class=\"headerlink\" title=\"1766. Tree of Coprimes\"></a><a href=\"https://leetcode.com/problems/tree-of-coprimes/\" target=\"_blank\" rel=\"noopener\">1766. Tree of Coprimes</a></h3><h4 id=\"找到每个节点的最小祖先，并且祖先节点和其节点值互质。\"><a href=\"#找到每个节点的最小祖先，并且祖先节点和其节点值互质。\" class=\"headerlink\" title=\"找到每个节点的最小祖先，并且祖先节点和其节点值互质。\"></a>找到每个节点的最小祖先，并且祖先节点和其节点值互质。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [2,3,3,2], edges &#x3D; [[0,1],[1,2],[1,3]]</span><br><span class=\"line\">Output: [-1,0,0,1]</span><br><span class=\"line\">Explanation: In the above figure, each node&#39;s value is in parentheses.</span><br><span class=\"line\">- Node 0 has no coprime ancestors.</span><br><span class=\"line\">- Node 1 has only one ancestor, node 0. Their values are coprime (gcd(2,3) &#x3D;&#x3D; 1).</span><br><span class=\"line\">- Node 2 has two ancestors, nodes 1 and 0. Node 1&#39;s value is not coprime (gcd(3,3) &#x3D;&#x3D; 3), but node 0&#39;s</span><br><span class=\"line\">  value is (gcd(2,3) &#x3D;&#x3D; 1), so node 0 is the closest valid ancestor.</span><br><span class=\"line\">- Node 3 has two ancestors, nodes 1 and 0. It is coprime with node 1 (gcd(3,2) &#x3D;&#x3D; 1), so node 1 is its</span><br><span class=\"line\">  closest valid ancestor.</span><br></pre></td></tr></table></figure>\n<p>方法一：dfs。比赛时没有时间看题。范围比较小节点值在1~50之间，所以可以将每个值互质的节点和深度放到一个列表中。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getCoprimes</span><span class=\"params\">(self, nums: List[int], edges: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    N = len(nums)</span><br><span class=\"line\">    res = [<span class=\"number\">-1</span>] * N</span><br><span class=\"line\">    g = defaultdict(list)</span><br><span class=\"line\">    path = [[] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(<span class=\"number\">51</span>)]  </span><br><span class=\"line\">    seen = set()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> u, v <span class=\"keyword\">in</span> edges:</span><br><span class=\"line\">        g[u].append(v)</span><br><span class=\"line\">        g[v].append(u)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(node, depth)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> node <span class=\"keyword\">in</span> seen: <span class=\"keyword\">return</span></span><br><span class=\"line\">        seen.add(node)</span><br><span class=\"line\">        longest_depth = <span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">51</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> gcd(x, nums[node]) == <span class=\"number\">1</span> <span class=\"keyword\">and</span> len(path[x])&gt;<span class=\"number\">0</span>:</span><br><span class=\"line\">                pnode, pdepth = path[x][<span class=\"number\">-1</span>]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> pdepth &gt; longest_depth:</span><br><span class=\"line\">                    longest_depth = pdepth</span><br><span class=\"line\">                    res[node] = pnode</span><br><span class=\"line\">        path[nums[node]].append((node, depth))</span><br><span class=\"line\">        <span class=\"keyword\">for</span> nei <span class=\"keyword\">in</span> g[node]:</span><br><span class=\"line\">            dfs(nei, depth+<span class=\"number\">1</span>)</span><br><span class=\"line\">        path[nums[node]].pop()</span><br><span class=\"line\"></span><br><span class=\"line\">    dfs(<span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"1368-Minimum-Cost-to-Make-at-Least-One-Valid-Path-in-a-Grid\"><a href=\"#1368-Minimum-Cost-to-Make-at-Least-One-Valid-Path-in-a-Grid\" class=\"headerlink\" title=\"1368. Minimum Cost to Make at Least One Valid Path in a Grid\"></a><a href=\"https://leetcode.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/\" target=\"_blank\" rel=\"noopener\">1368. Minimum Cost to Make at Least One Valid Path in a Grid</a></h3><h4 id=\"修改箭头方向最少次数能够到达右下角的点。\"><a href=\"#修改箭头方向最少次数能够到达右下角的点。\" class=\"headerlink\" title=\"修改箭头方向最少次数能够到达右下角的点。\"></a>修改箭头方向最少次数能够到达右下角的点。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: grid &#x3D; [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: You will start at point (0, 0).</span><br><span class=\"line\">The path to (3, 3) is as follows. (0, 0) --&gt; (0, 1) --&gt; (0, 2) --&gt; (0, 3) change the arrow to down with cost &#x3D; 1 --&gt; (1, 3) --&gt; (1, 2) --&gt; (1, 1) --&gt; (1, 0) change the arrow to down with cost &#x3D; 1 --&gt; (2, 0) --&gt; (2, 1) --&gt; (2, 2) --&gt; (2, 3) change the arrow to down with cost &#x3D; 1 --&gt; (3, 3)</span><br><span class=\"line\">The total cost &#x3D; 3.</span><br></pre></td></tr></table></figure>\n<p>方法一：狄克斯特拉，有点慢，4600ms。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minCost</span><span class=\"params\">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    heap = [(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>)]</span><br><span class=\"line\">    M, N = len(grid), len(grid[<span class=\"number\">0</span>])</span><br><span class=\"line\">    seen = &#123;(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>)&#125;</span><br><span class=\"line\">    d = &#123;<span class=\"number\">1</span>: (<span class=\"number\">0</span>, <span class=\"number\">1</span>), <span class=\"number\">2</span>: (<span class=\"number\">0</span>, <span class=\"number\">-1</span>), <span class=\"number\">3</span>: (<span class=\"number\">1</span>, <span class=\"number\">0</span>), <span class=\"number\">4</span>: (<span class=\"number\">-1</span>, <span class=\"number\">0</span>)&#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">        cost, x, y = heapq.heappop(heap)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> x == M<span class=\"number\">-1</span> <span class=\"keyword\">and</span> y == N<span class=\"number\">-1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> cost</span><br><span class=\"line\">        <span class=\"keyword\">for</span> x0, y0 <span class=\"keyword\">in</span> d.values():</span><br><span class=\"line\">            i = x + x0</span><br><span class=\"line\">            j = y + y0</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=i&lt;M <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=j&lt;N:</span><br><span class=\"line\">                new_cost = cost + (d[grid[x][y]]!=(x0, y0))</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (new_cost, i, j) <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> seen:</span><br><span class=\"line\">                    heapq.heappush(heap, (new_cost, i, j))</span><br><span class=\"line\">                    seen.add((new_cost, i, j))</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：BFS+DFS. @lee215的方法，328ms。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minCost</span><span class=\"params\">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    M, N, k = len(grid), len(grid[<span class=\"number\">0</span>]), <span class=\"number\">0</span></span><br><span class=\"line\">    cost = [[inf] * N <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(M)]</span><br><span class=\"line\">    dire = [(<span class=\"number\">0</span>, <span class=\"number\">1</span>), (<span class=\"number\">0</span>, <span class=\"number\">-1</span>), (<span class=\"number\">1</span>, <span class=\"number\">0</span>), (<span class=\"number\">-1</span>, <span class=\"number\">0</span>)]</span><br><span class=\"line\">    bfs = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(i, j)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> (<span class=\"number\">0</span>&lt;=i&lt;M <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=j&lt;N <span class=\"keyword\">and</span> cost[i][j]==inf): <span class=\"keyword\">return</span></span><br><span class=\"line\">        cost[i][j] = k</span><br><span class=\"line\">        bfs.append((i, j))</span><br><span class=\"line\">        dfs(i+dire[grid[i][j]<span class=\"number\">-1</span>][<span class=\"number\">0</span>], j+dire[grid[i][j]<span class=\"number\">-1</span>][<span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    dfs(<span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> bfs:</span><br><span class=\"line\">        k += <span class=\"number\">1</span></span><br><span class=\"line\">        bfs, bfs2 = [], bfs</span><br><span class=\"line\">        [dfs(x+i, y+j) <span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> bfs2 <span class=\"keyword\">for</span> i, j <span class=\"keyword\">in</span> dire]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> cost[<span class=\"number\">-1</span>][<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"1786-Number-of-Restricted-Paths-From-First-to-Last-Node\"><a href=\"#1786-Number-of-Restricted-Paths-From-First-to-Last-Node\" class=\"headerlink\" title=\"1786. Number of Restricted Paths From First to Last Node\"></a><a href=\"https://leetcode.com/problems/number-of-restricted-paths-from-first-to-last-node/\" target=\"_blank\" rel=\"noopener\">1786. Number of Restricted Paths From First to Last Node</a></h3><h4 id=\"从头节点到尾节点的限制路径是多少个，限制路径指每次节点到尾节点的最短路径要递减。\"><a href=\"#从头节点到尾节点的限制路径是多少个，限制路径指每次节点到尾节点的最短路径要递减。\" class=\"headerlink\" title=\"从头节点到尾节点的限制路径是多少个，限制路径指每次节点到尾节点的最短路径要递减。\"></a>从头节点到尾节点的限制路径是多少个，限制路径指每次节点到尾节点的最短路径要递减。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 5, edges &#x3D; [[1,2,3],[1,3,3],[2,3,1],[1,4,2],[5,2,2],[3,5,1],[5,4,10]]</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: Each circle contains the node number in black and its distanceToLastNode value in blue. The three restricted paths are:</span><br><span class=\"line\">1) 1 --&gt; 2 --&gt; 5</span><br><span class=\"line\">2) 1 --&gt; 2 --&gt; 3 --&gt; 5</span><br><span class=\"line\">3) 1 --&gt; 3 --&gt; 5</span><br></pre></td></tr></table></figure>\n<img src=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%9B%BE%E7%AF%87%EF%BC%89Graph/1786q.png\" class>\n<p>方法一：比赛时差一点做出来，最后一步没有想明白。首先肯定是需要求每个节点到尾节点的最短路径，利用狄克斯特拉算法简单求出。</p>\n<p>然后使用记忆化，本质上是个动态规划来累加路径和。dfs方法没有想出来。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countRestrictedPaths</span><span class=\"params\">(self, n: int, edges: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    MOD = <span class=\"number\">10</span>**<span class=\"number\">9</span> + <span class=\"number\">7</span></span><br><span class=\"line\">    g = defaultdict(list)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> u, v, w <span class=\"keyword\">in</span> edges:</span><br><span class=\"line\">        g[u].append((v, w))</span><br><span class=\"line\">        g[v].append((u, w))</span><br><span class=\"line\"></span><br><span class=\"line\">    dist = [<span class=\"number\">-1</span>] * (n+<span class=\"number\">1</span>)  <span class=\"comment\"># distance</span></span><br><span class=\"line\">    dist[<span class=\"number\">-1</span>] = <span class=\"number\">0</span></span><br><span class=\"line\">    heap = [(w, u) <span class=\"keyword\">for</span> u, w <span class=\"keyword\">in</span> g[n]]</span><br><span class=\"line\">    heapq.heapify(heap)</span><br><span class=\"line\">    cnt = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> cnt &lt; n<span class=\"number\">-1</span>:</span><br><span class=\"line\">        w, u = heapq.heappop(heap)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> dist[u] == <span class=\"number\">-1</span>:</span><br><span class=\"line\">            dist[u] = w</span><br><span class=\"line\">            cnt += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> v, w2 <span class=\"keyword\">in</span> g[u]:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> dist[v]==<span class=\"number\">-1</span>:</span><br><span class=\"line\">                    heapq.heappush(heap, (w+w2, v))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @lru_cache(None)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(i)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == n: <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        ans = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> nei, _ <span class=\"keyword\">in</span> g[i]:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> dist[i] &gt; dist[nei]:</span><br><span class=\"line\">                ans = (ans+dfs(nei)) % MOD</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dfs(<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"331-Verify-Preorder-Serialization-of-a-Binary-Tree\"><a href=\"#331-Verify-Preorder-Serialization-of-a-Binary-Tree\" class=\"headerlink\" title=\"331. Verify Preorder Serialization of a Binary Tree\"></a><a href=\"https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/\" target=\"_blank\" rel=\"noopener\">331. Verify Preorder Serialization of a Binary Tree</a></h3><h4 id=\"判断一个字符串序列是否是前序遍历。\"><a href=\"#判断一个字符串序列是否是前序遍历。\" class=\"headerlink\" title=\"判断一个字符串序列是否是前序遍历。\"></a>判断一个字符串序列是否是前序遍历。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: &quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</span><br><span class=\"line\">Output: true</span><br></pre></td></tr></table></figure>\n<p>方法一：栈。一开始想递归，发现递归并不好找条件return False。这个方法有点像不断地剪枝，当一个叶子节点满足子节点都是<code>#</code>的时候，它也变成<code>#</code>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isValidSerialization</span><span class=\"params\">(self, preorder: str)</span> -&gt; bool:</span></span><br><span class=\"line\">    stack = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> node <span class=\"keyword\">in</span> preorder.split(<span class=\"string\">\",\"</span>):</span><br><span class=\"line\">        stack.append(node)</span><br><span class=\"line\">        <span class=\"keyword\">while</span> len(stack)&gt;=<span class=\"number\">3</span> <span class=\"keyword\">and</span> stack[<span class=\"number\">-1</span>]==stack[<span class=\"number\">-2</span>]==<span class=\"string\">\"#\"</span> <span class=\"keyword\">and</span> stack[<span class=\"number\">-3</span>]!=<span class=\"string\">\"#\"</span>:</span><br><span class=\"line\">            stack.pop()</span><br><span class=\"line\">            stack.pop()</span><br><span class=\"line\">            stack.pop()</span><br><span class=\"line\">            stack.append(<span class=\"string\">\"#\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stack == [<span class=\"string\">\"#\"</span>]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isValidSerialization</span><span class=\"params\">(preorder <span class=\"keyword\">string</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> stack []<span class=\"keyword\">string</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, node := <span class=\"keyword\">range</span> strings.Split(preorder, <span class=\"string\">\",\"</span>) &#123;</span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack, node)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ;<span class=\"built_in\">len</span>(stack)&gt;=<span class=\"number\">3</span> &amp;&amp; stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]==<span class=\"string\">\"#\"</span> &amp;&amp; stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-2</span>]==<span class=\"string\">\"#\"</span> &amp;&amp; stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-3</span>]!=<span class=\"string\">\"#\"</span>; &#123;</span><br><span class=\"line\">            stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-3</span>]</span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack, <span class=\"string\">\"#\"</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(stack)==<span class=\"number\">1</span> &amp;&amp; stack[<span class=\"number\">0</span>]==<span class=\"string\">\"#\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方法二：槽。代码简单，思想不简单。把树中的节点想象成槽，当出现一个非空节点，就需要左右孩子节点2个槽。如果是一个<code>#</code>表示消耗掉一个槽。全程槽的数不能为0，最后才能是0</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isValidSerialization</span><span class=\"params\">(self, preorder: str)</span> -&gt; bool:</span></span><br><span class=\"line\">    slot = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> node <span class=\"keyword\">in</span> preorder.split(<span class=\"string\">\",\"</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> slot == <span class=\"number\">0</span>: <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> node == <span class=\"string\">\"#\"</span>:</span><br><span class=\"line\">            slot -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            slot += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> slot == <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isValidSerialization</span><span class=\"params\">(preorder <span class=\"keyword\">string</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">    slot := <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, node := <span class=\"keyword\">range</span> strings.Split(preorder, <span class=\"string\">\",\"</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> slot == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node == <span class=\"string\">\"#\"</span> &#123;</span><br><span class=\"line\">            slot--</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            slot++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> slot == <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"1857-Largest-Color-Value-in-a-Directed-Graph\"><a href=\"#1857-Largest-Color-Value-in-a-Directed-Graph\" class=\"headerlink\" title=\"1857. Largest Color Value in a Directed Graph\"></a>1857. Largest Color Value in a Directed Graph</h3><h4 id=\"有向图中包含颜色最多的路径，颜色的最大值是多少。\"><a href=\"#有向图中包含颜色最多的路径，颜色的最大值是多少。\" class=\"headerlink\" title=\"有向图中包含颜色最多的路径，颜色的最大值是多少。\"></a>有向图中包含颜色最多的路径，颜色的最大值是多少。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: colors &#x3D; &quot;abaca&quot;, edges &#x3D; [[0,1],[0,2],[2,3],[3,4]]</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: The path 0 -&gt; 2 -&gt; 3 -&gt; 4 contains 3 nodes that are colored &quot;a&quot; (red in the above image).</span><br></pre></td></tr></table></figure>\n<p>方法一：拓扑排序+DP，比较难的一道题。两个都没有想到，首先为什么要拓扑排序，因为对于一个路径来说，从入度为0的点开始，才会让节点越多，颜色才可能最大。<code>dp[i][j]</code>表示以i为终点的路径，j颜色最大有多少个</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">largestPathValue</span><span class=\"params\">(self, colors: str, edges: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    g = defaultdict(list)</span><br><span class=\"line\">    N = len(colors)</span><br><span class=\"line\">    degree = [<span class=\"number\">0</span>] * N</span><br><span class=\"line\">    <span class=\"keyword\">for</span> u, v <span class=\"keyword\">in</span> edges:</span><br><span class=\"line\">        g[u].append(v)</span><br><span class=\"line\">        degree[v] -= <span class=\"number\">1</span></span><br><span class=\"line\">    dp = defaultdict(<span class=\"keyword\">lambda</span>: defaultdict(int))</span><br><span class=\"line\"></span><br><span class=\"line\">    bfs = [i <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(N) <span class=\"keyword\">if</span> degree[i]==<span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    cnt = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> bfs:</span><br><span class=\"line\">        cnt += <span class=\"number\">1</span></span><br><span class=\"line\">        dp[i][colors[i]] += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> g[i]:</span><br><span class=\"line\">            degree[j] += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> string.ascii_lowercase:</span><br><span class=\"line\">                dp[j][c] = max(dp[j][c], dp[i][c])</span><br><span class=\"line\">            <span class=\"keyword\">if</span> degree[j] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                bfs.append(j)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> cnt != N:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(max(dp[i].values()) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(N))</span><br></pre></td></tr></table></figure>\n<h3 id=\"1871-Jump-Game-VII\"><a href=\"#1871-Jump-Game-VII\" class=\"headerlink\" title=\"1871. Jump Game VII\"></a><a href=\"https://leetcode.com/problems/jump-game-vii/\" target=\"_blank\" rel=\"noopener\">1871. Jump Game VII</a></h3><h4 id=\"跳跃游戏，0位首的数组，每次跳跃步伐在mi-ma之间，且只能跳到0的位置，问是否能够跳到最后一个位置。\"><a href=\"#跳跃游戏，0位首的数组，每次跳跃步伐在mi-ma之间，且只能跳到0的位置，问是否能够跳到最后一个位置。\" class=\"headerlink\" title=\"跳跃游戏，0位首的数组，每次跳跃步伐在mi,ma之间，且只能跳到0的位置，问是否能够跳到最后一个位置。\"></a>跳跃游戏，0位首的数组，每次跳跃步伐在mi,ma之间，且只能跳到0的位置，问是否能够跳到最后一个位置。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;011010&quot;, minJump &#x3D; 2, maxJump &#x3D; 3</span><br><span class=\"line\">Output: true</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">In the first step, move from index 0 to index 3. </span><br><span class=\"line\">In the second step, move from index 3 to index 5.</span><br></pre></td></tr></table></figure>\n<p>方法一：比赛期间用了堆+无数次剪枝和TLE勉强通过。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">canReach</span><span class=\"params\">(self, s: str, minJump: int, maxJump: int)</span> -&gt; bool:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> s[<span class=\"number\">-1</span>] != <span class=\"string\">\"0\"</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    max_one, max_zero = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    one, zero = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(s)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> s[i] == <span class=\"string\">\"1\"</span>:</span><br><span class=\"line\">            one += <span class=\"number\">1</span></span><br><span class=\"line\">            zero = <span class=\"number\">0</span></span><br><span class=\"line\">            max_one = max(max_one, one)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            zero += <span class=\"number\">1</span></span><br><span class=\"line\">            one = <span class=\"number\">0</span></span><br><span class=\"line\">            max_zero = max(max_zero, zero)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> max_one &gt;= maxJump:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    N = len(s)</span><br><span class=\"line\">    heap = [<span class=\"number\">0</span>]</span><br><span class=\"line\">    seen = &#123;i <span class=\"keyword\">for</span> i, c <span class=\"keyword\">in</span> enumerate(s) <span class=\"keyword\">if</span> c == <span class=\"string\">'1'</span>&#125;</span><br><span class=\"line\">    seen.add(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> heap:</span><br><span class=\"line\">        i = heapq.heappop(heap)</span><br><span class=\"line\">        i = -i</span><br><span class=\"line\">        <span class=\"comment\"># if i + maxJump &gt;= N-1 and s[-1]==\"0\":</span></span><br><span class=\"line\">        <span class=\"comment\">#     return True</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == N<span class=\"number\">-1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> set(range(i+minJump, min(i+maxJump+<span class=\"number\">1</span>, N))) - seen:</span><br><span class=\"line\">        <span class=\"comment\"># for j, c in enumerate(islice(s, i+minJump, i+maxJump+1), i+minJump):</span></span><br><span class=\"line\">            <span class=\"comment\"># print(j, c)</span></span><br><span class=\"line\">            heapq.heappush(heap, -j)</span><br><span class=\"line\">            seen.add(j)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<p>方法二：bfs。没想到能用bfs。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">canReach</span><span class=\"params\">(self, s: str, minJump: int, maxJump: int)</span> -&gt; bool:</span></span><br><span class=\"line\">    queue = collections.deque([<span class=\"number\">0</span>])</span><br><span class=\"line\">    visited, mx = set([<span class=\"number\">0</span>]), <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> queue:</span><br><span class=\"line\">        i = queue.popleft()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(max(i + minJump, mx + <span class=\"number\">1</span>), min(i + maxJump + <span class=\"number\">1</span>, len(s))):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> s[j] == <span class=\"string\">'0'</span> <span class=\"keyword\">and</span> j <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> visited:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> j == len(s) - <span class=\"number\">1</span>: <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">                queue.append(j)</span><br><span class=\"line\">                visited.add(j)</span><br><span class=\"line\">        <span class=\"comment\"># mx = max(mx, i + maxJump)  # 去重重复的区间判断，对于\"0000000\", 1, 6这种case，没有的话可能会超时</span></span><br><span class=\"line\">        mx = i + maxJump             <span class=\"comment\"># i + maxJump一定会大于mx，因为是拓扑排序</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1905-Count-Sub-Islands\"><a href=\"#1905-Count-Sub-Islands\" class=\"headerlink\" title=\"1905. Count Sub Islands\"></a><a href=\"https://leetcode.com/problems/count-sub-islands/\" target=\"_blank\" rel=\"noopener\">1905. Count Sub Islands</a></h3><h4 id=\"找到图2中子岛屿的个数，如果图2的岛屿都在图一的同一个岛中，那么久叫作子岛屿。\"><a href=\"#找到图2中子岛屿的个数，如果图2的岛屿都在图一的同一个岛中，那么久叫作子岛屿。\" class=\"headerlink\" title=\"找到图2中子岛屿的个数，如果图2的岛屿都在图一的同一个岛中，那么久叫作子岛屿。\"></a>找到图2中子岛屿的个数，如果图2的岛屿都在图一的同一个岛中，那么久叫作子岛屿。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: grid1 &#x3D; [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 &#x3D; [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: In the picture above, the grid on the left is grid1 and the grid on the right is grid2.</span><br><span class=\"line\">The 1s colored red in grid2 are those considered to be part of a sub-island. There are three sub-islands.</span><br></pre></td></tr></table></figure>\n<p>方法一：这题竞赛居然没做出来，想着先把图一的所有岛屿都求出来然后再遍历图2算。其实可以同时进行的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countSubIslands</span><span class=\"params\">(self, g1: List[List[int]], g2: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    M, N = len(g1), len(g1[<span class=\"number\">0</span>])</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(i, j)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> (<span class=\"number\">0</span>&lt;=i&lt;M <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=j&lt;N <span class=\"keyword\">and</span> g2[i][j]==<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"comment\"># 如果越界或者g2[i][j]==0（即不是岛屿，不需要判断），则算作是子岛屿</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        res = g1[i][j]</span><br><span class=\"line\">        g2[i][j] = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> ((i+<span class=\"number\">1</span>, j), (i<span class=\"number\">-1</span>, j), (i, j+<span class=\"number\">1</span>), (i, j<span class=\"number\">-1</span>)):</span><br><span class=\"line\">            res &amp;= dfs(x, y)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(dfs(i, j) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(M) <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(N) <span class=\"keyword\">if</span> g2[i][j])</span><br></pre></td></tr></table></figure>\n<h4 id=\"2092-Find-All-People-With-Secret\"><a href=\"#2092-Find-All-People-With-Secret\" class=\"headerlink\" title=\"2092. Find All People With Secret\"></a><a href=\"https://leetcode.com/problems/find-all-people-with-secret/\" target=\"_blank\" rel=\"noopener\">2092. Find All People With Secret</a></h4><h4 id=\"找到知道秘密的人，一个人可以同时开多个会，而且同一时间点的事件同时发生。\"><a href=\"#找到知道秘密的人，一个人可以同时开多个会，而且同一时间点的事件同时发生。\" class=\"headerlink\" title=\"找到知道秘密的人，一个人可以同时开多个会，而且同一时间点的事件同时发生。\"></a>找到知道秘密的人，一个人可以同时开多个会，而且同一时间点的事件同时发生。</h4><p>方法一：比赛的时候想并查集，但是没有完全想出来。这里是答案的bfs方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findAllPeople</span><span class=\"params\">(self, n: int, meetings: List[List[int]], firstPerson: int)</span> -&gt; List[int]:</span></span><br><span class=\"line\">    can = &#123;<span class=\"number\">0</span>, firstPerson&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, group <span class=\"keyword\">in</span> groupby(sorted(meetings, key=operator.itemgetter(<span class=\"number\">2</span>)), key=operator.itemgetter(<span class=\"number\">2</span>)):</span><br><span class=\"line\">        g = defaultdict(list)</span><br><span class=\"line\">        queue = set()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> x, y, t <span class=\"keyword\">in</span> group:</span><br><span class=\"line\">            g[x].append(y)</span><br><span class=\"line\">            g[y].append(x)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> x <span class=\"keyword\">in</span> can: queue.add(x)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> y <span class=\"keyword\">in</span> can: queue.add(y)</span><br><span class=\"line\">                </span><br><span class=\"line\">        q = deque(queue)</span><br><span class=\"line\">        <span class=\"keyword\">while</span> q:</span><br><span class=\"line\">            x = q.popleft()</span><br><span class=\"line\">            <span class=\"keyword\">for</span> y <span class=\"keyword\">in</span> g[x]:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> y <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> can:</span><br><span class=\"line\">                    q.append(y)</span><br><span class=\"line\">                    can.add(y)</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> list(can)</span><br></pre></td></tr></table></figure>\n<h3 id=\"2097-Valid-Arrangement-of-Pairs\"><a href=\"#2097-Valid-Arrangement-of-Pairs\" class=\"headerlink\" title=\"2097. Valid Arrangement of Pairs\"></a><a href=\"https://leetcode.com/problems/valid-arrangement-of-pairs/\" target=\"_blank\" rel=\"noopener\">2097. Valid Arrangement of Pairs</a></h3><h4 id=\"找到一个有效的首位相连的路径，数组元素表示一条有向边。\"><a href=\"#找到一个有效的首位相连的路径，数组元素表示一条有向边。\" class=\"headerlink\" title=\"找到一个有效的首位相连的路径，数组元素表示一条有向边。\"></a>找到一个有效的首位相连的路径，数组元素表示一条有向边。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: pairs &#x3D; [[5,1],[4,5],[11,9],[9,4]]</span><br><span class=\"line\">Output: [[11,9],[9,4],[4,5],[5,1]]</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">This is a valid arrangement since endi-1 always equals starti.</span><br><span class=\"line\">end0 &#x3D; 9 &#x3D;&#x3D; 9 &#x3D; start1 </span><br><span class=\"line\">end1 &#x3D; 4 &#x3D;&#x3D; 4 &#x3D; start2</span><br><span class=\"line\">end2 &#x3D; 5 &#x3D;&#x3D; 5 &#x3D; start3</span><br></pre></td></tr></table></figure>\n<p>方法一：和332题一样，是求欧拉路径的问题，区别在于要先找到开始的点。比赛的时候没有想出来</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">validArrangement</span><span class=\"params\">(self, pairs: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">    g = defaultdict(list)</span><br><span class=\"line\">    din, dout = defaultdict(int), defaultdict(int)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> s, e <span class=\"keyword\">in</span> pairs:</span><br><span class=\"line\">        g[s].append(e)</span><br><span class=\"line\">        dout[s] += <span class=\"number\">1</span></span><br><span class=\"line\">        din[e] += <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    start = pairs[<span class=\"number\">0</span>][<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> dout:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> dout[p] - din[p] == <span class=\"number\">1</span>:</span><br><span class=\"line\">            start = p  <span class=\"comment\"># 欧拉环的尾</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">    route = []</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(s)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> g[s]:</span><br><span class=\"line\">            dfs(g[s].pop())</span><br><span class=\"line\">        route.append(s)</span><br><span class=\"line\">        </span><br><span class=\"line\">    dfs(start)</span><br><span class=\"line\">    route.reverse()</span><br><span class=\"line\">    <span class=\"comment\"># print(route)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[a, b] <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> zip(route, route[<span class=\"number\">1</span>:])]</span><br></pre></td></tr></table></figure>\n<h3 id=\"2360-Longest-Cycle-in-a-Graph\"><a href=\"#2360-Longest-Cycle-in-a-Graph\" class=\"headerlink\" title=\"2360. Longest Cycle in a Graph\"></a><a href=\"https://leetcode.com/problems/longest-cycle-in-a-graph/\" target=\"_blank\" rel=\"noopener\">2360. Longest Cycle in a Graph</a></h3><h4 id=\"图中的最长环。每个节点最多只有一个出度。\"><a href=\"#图中的最长环。每个节点最多只有一个出度。\" class=\"headerlink\" title=\"图中的最长环。每个节点最多只有一个出度。\"></a>图中的最长环。每个节点最多只有一个出度。</h4>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: edges &#x3D; [3,3,4,2,3]</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: The longest cycle in the graph is the cycle: 2 -&gt; 4 -&gt; 3 -&gt; 2.</span><br><span class=\"line\">The length of this cycle is 3, so 3 is returned.</span><br></pre></td></tr></table></figure>\n<p>方法一：常规方法，拓扑排序+bfs。逐渐删除入度为0的点，最后剩下所有的环。找出最大的环。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestCycle</span><span class=\"params\">(self, edges: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    N = len(edges)</span><br><span class=\"line\">    degree = [<span class=\"number\">0</span>] * N</span><br><span class=\"line\">    <span class=\"keyword\">for</span> u, v <span class=\"keyword\">in</span> enumerate(edges):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> v == <span class=\"number\">-1</span>: <span class=\"keyword\">continue</span></span><br><span class=\"line\">        degree[v] += <span class=\"number\">1</span></span><br><span class=\"line\">    stack = [n <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> range(N) <span class=\"keyword\">if</span> degree[n]==<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> stack:</span><br><span class=\"line\">        u = stack.pop()</span><br><span class=\"line\">        v = edges[u]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> v == <span class=\"number\">-1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        degree[v] -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> degree[v] == <span class=\"number\">0</span>:</span><br><span class=\"line\">            stack.append(v)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 无环，直接返回-1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> max(degree) == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bfs</span><span class=\"params\">(u)</span>:</span></span><br><span class=\"line\">        step = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> u <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> seen:</span><br><span class=\"line\">            step += <span class=\"number\">1</span></span><br><span class=\"line\">            seen.add(u)</span><br><span class=\"line\">            u = edges[u]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> step</span><br><span class=\"line\"></span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    seen = set()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(N):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> degree[i]!=<span class=\"number\">0</span> <span class=\"keyword\">and</span> i <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> seen:</span><br><span class=\"line\">            ans = max(ans, bfs(i))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法二：时钟从0点找没有走过的点，如果有环的话，时差就是环长。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestCycle</span><span class=\"params\">(self, edges: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    time = [<span class=\"number\">0</span>] * len(edges)</span><br><span class=\"line\">    clock, ans = <span class=\"number\">1</span>, <span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> x, t <span class=\"keyword\">in</span> enumerate(time):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> t: </span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        start_time = clock</span><br><span class=\"line\">        <span class=\"keyword\">while</span> x != <span class=\"number\">-1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> time[x]:  <span class=\"comment\"># 重复访问</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> time[x] &gt;= start_time:  <span class=\"comment\"># 找到了一个新的环</span></span><br><span class=\"line\">                    print(x, time[x], start_time)</span><br><span class=\"line\">                    ans = max(ans, clock - time[x])</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            time[x] = clock</span><br><span class=\"line\">            clock += <span class=\"number\">1</span></span><br><span class=\"line\">            x = edges[x]</span><br><span class=\"line\">        <span class=\"comment\"># print(time)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"827-Making-A-Large-Island\"><a href=\"#827-Making-A-Large-Island\" class=\"headerlink\" title=\"827. Making A Large Island\"></a><a href=\"https://leetcode.com/problems/making-a-large-island/\" target=\"_blank\" rel=\"noopener\">827. Making A Large Island</a></h3><h4 id=\"修改一个0变成1，最大的岛屿面积是多少？\"><a href=\"#修改一个0变成1，最大的岛屿面积是多少？\" class=\"headerlink\" title=\"修改一个0变成1，最大的岛屿面积是多少？\"></a>修改一个0变成1，最大的岛屿面积是多少？</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: grid &#x3D; [[1, 0], [0, 1]]</span><br><span class=\"line\">输出: 3</span><br><span class=\"line\">解释: 将一格0变成1，最终连通两个小岛得到面积为 3 的岛屿。</span><br></pre></td></tr></table></figure>\n<p>方法一：首先用独立的编号标记每个岛屿，并记录岛屿面积。然后遍历0的地方，将上下左右的岛屿相连，计算面积。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">largestIsland</span><span class=\"params\">(self, g: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    N = len(g)</span><br><span class=\"line\">    num = <span class=\"number\">2</span></span><br><span class=\"line\">    areas = Counter()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(i, j)</span>:</span></span><br><span class=\"line\">        g[i][j] = num</span><br><span class=\"line\">        area = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> ((i+<span class=\"number\">1</span>, j), (i<span class=\"number\">-1</span>, j), (i, j+<span class=\"number\">1</span>), (i, j<span class=\"number\">-1</span>)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=x&lt;N <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=y&lt;N <span class=\"keyword\">and</span> g[x][y]==<span class=\"number\">1</span>:</span><br><span class=\"line\">                area += dfs(x, y)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> area</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(N):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(N):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> g[i][j] == <span class=\"number\">1</span>:</span><br><span class=\"line\">                area = dfs(i, j)</span><br><span class=\"line\">                areas[num] = area</span><br><span class=\"line\">                num += <span class=\"number\">1</span></span><br><span class=\"line\">    res = max(areas.values(), default=<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(N):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(N):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> g[i][j] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                aroud = set()</span><br><span class=\"line\">                <span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> ((i+<span class=\"number\">1</span>, j), (i<span class=\"number\">-1</span>, j), (i, j+<span class=\"number\">1</span>), (i, j<span class=\"number\">-1</span>)):</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=x&lt;N <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=y&lt;N <span class=\"keyword\">and</span> g[x][y]!=<span class=\"number\">0</span>:</span><br><span class=\"line\">                        aroud.add(g[x][y])</span><br><span class=\"line\">                res = max(res, sum(areas[d] <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> aroud)+<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"934-Shortest-Bridge\"><a href=\"#934-Shortest-Bridge\" class=\"headerlink\" title=\"934. Shortest Bridge\"></a><a href=\"https://leetcode.com/problems/shortest-bridge/\" target=\"_blank\" rel=\"noopener\">934. Shortest Bridge</a></h3><h4 id=\"最短的桥，图中有两个岛屿，求两个岛屿间的最短距离。\"><a href=\"#最短的桥，图中有两个岛屿，求两个岛屿间的最短距离。\" class=\"headerlink\" title=\"最短的桥，图中有两个岛屿，求两个岛屿间的最短距离。\"></a>最短的桥，图中有两个岛屿，求两个岛屿间的最短距离。</h4><p>方法一：首先用dfs将岛屿编号，并保存第一个岛屿的边。然后遍历其边使用bfs去找第二个岛屿。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">shortestBridge</span><span class=\"params\">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    num = <span class=\"number\">2</span></span><br><span class=\"line\">    q = []</span><br><span class=\"line\">    M, N = len(grid), len(grid[<span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(i, j)</span>:</span></span><br><span class=\"line\">        cnt = <span class=\"number\">0</span></span><br><span class=\"line\">        grid[i][j] = num</span><br><span class=\"line\">        <span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> ((i+<span class=\"number\">1</span>, j), (i<span class=\"number\">-1</span>, j), (i, j<span class=\"number\">-1</span>), (i, j+<span class=\"number\">1</span>)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=x&lt;M <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=y&lt;N <span class=\"keyword\">and</span> grid[x][y]==<span class=\"number\">1</span>:</span><br><span class=\"line\">                cnt += <span class=\"number\">1</span></span><br><span class=\"line\">                dfs(x, y)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cnt != <span class=\"number\">4</span> <span class=\"keyword\">and</span> num == <span class=\"number\">2</span>:</span><br><span class=\"line\">            q.append((i, j, <span class=\"number\">0</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(M):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> y <span class=\"keyword\">in</span> range(N):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> grid[x][y] == <span class=\"number\">1</span>:</span><br><span class=\"line\">                dfs(x, y)</span><br><span class=\"line\">                num += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> x, y, s <span class=\"keyword\">in</span> q:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, j <span class=\"keyword\">in</span> ((x+<span class=\"number\">1</span>, y), (x<span class=\"number\">-1</span>, y), (x, y+<span class=\"number\">1</span>), (x, y<span class=\"number\">-1</span>)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=i&lt;M <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=j&lt;N:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> grid[i][j]==<span class=\"number\">0</span>:</span><br><span class=\"line\">                    q.append((i, j, s+<span class=\"number\">1</span>))</span><br><span class=\"line\">                    grid[i][j] = <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">elif</span> grid[i][j]==<span class=\"number\">3</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> s</span><br></pre></td></tr></table></figure>\n<h3 id=\"2477-Minimum-Fuel-Cost-to-Report-to-the-Capital\"><a href=\"#2477-Minimum-Fuel-Cost-to-Report-to-the-Capital\" class=\"headerlink\" title=\"2477. Minimum Fuel Cost to Report to the Capital\"></a><a href=\"https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/\" target=\"_blank\" rel=\"noopener\">2477. Minimum Fuel Cost to Report to the Capital</a></h3><p>给你一棵 <code>n</code> 个节点的树（一个无向、连通、无环图），每个节点表示一个城市，编号从 <code>0</code> 到 <code>n - 1</code> ，且恰好有 <code>n - 1</code> 条路。<code>0</code> 是首都。给你一个二维整数数组 <code>roads</code> ，其中 <code>roads[i] = [ai, bi]</code> ，表示城市 <code>ai</code> 和 <code>bi</code> 之间有一条 <strong>双向路</strong> 。</p>\n<p>每个城市里有一个代表，他们都要去首都参加一个会议。</p>\n<p>每座城市里有一辆车。给你一个整数 <code>seats</code> 表示每辆车里面座位的数目。</p>\n<p>城市里的代表可以选择乘坐所在城市的车，或者乘坐其他城市的车。相邻城市之间一辆车的油耗是一升汽油。</p>\n<p>请你返回到达首都最少需要多少升汽油。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：roads &#x3D; [[0,1],[0,2],[0,3]], seats &#x3D; 5</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：</span><br><span class=\"line\">- 代表 1 直接到达首都，消耗 1 升汽油。</span><br><span class=\"line\">- 代表 2 直接到达首都，消耗 1 升汽油。</span><br><span class=\"line\">- 代表 3 直接到达首都，消耗 1 升汽油。</span><br><span class=\"line\">最少消耗 3 升汽油。</span><br></pre></td></tr></table></figure>\n<p>方法一：这题比赛时竟然没做出来，陷入了思维误区，老想用bfs。实际上需要dfs。首先需要将问题转化。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minimumFuelCost</span><span class=\"params\">(self, roads: List[List[int]], s: int)</span> -&gt; int:</span></span><br><span class=\"line\">    g = defaultdict(list)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> u, v <span class=\"keyword\">in</span> roads:</span><br><span class=\"line\">        g[u].append(v)</span><br><span class=\"line\">        g[v].append(u)</span><br><span class=\"line\"></span><br><span class=\"line\">    res = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 等价于车是无限的，因为每个节点都有车，即使s=1也是足够的</span></span><br><span class=\"line\">    <span class=\"comment\"># 等价于每走一条边，消耗一辆车</span></span><br><span class=\"line\">    <span class=\"comment\"># 求子树节点的大小</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 表示从n到父节点需要多少辆车</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(n, p)</span>:</span></span><br><span class=\"line\">        size = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> g[n]:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> j != p:</span><br><span class=\"line\">                size += dfs(j, n)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n: <span class=\"comment\"># 0节点不需要计算，因为已经停止了</span></span><br><span class=\"line\">            <span class=\"keyword\">nonlocal</span> res</span><br><span class=\"line\">            res += ceil(size / s)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> size</span><br><span class=\"line\"></span><br><span class=\"line\">    dfs(<span class=\"number\">0</span>, <span class=\"number\">-1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n","categories":["算法"],"tags":["LeetCode","Python","Algorithm","Graph"]},{"title":"LeetCode算法题整理（二叉树篇）Tree","url":"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AF%87%EF%BC%89Tree/","content":"<h3 id=\"树的定义\"><a href=\"#树的定义\" class=\"headerlink\" title=\"树的定义\"></a>树的定义</h3><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TreeNode</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, x)</span>:</span></span><br><span class=\"line\">        self.val = x</span><br><span class=\"line\">        self.left = <span class=\"literal\">None</span>    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rangeSumBST</span><span class=\"params\">(self, root: TreeNode, low: int, high: int)</span> -&gt; int:</span></span><br><span class=\"line\">        ans = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> low &lt;= root.val &lt;= high:</span><br><span class=\"line\">                ans += root.val</span><br><span class=\"line\">                ans += self.rangeSumBST(root.left, low, high)</span><br><span class=\"line\">                ans += self.rangeSumBST(root.right, low, high)</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> root.val &lt; low:</span><br><span class=\"line\">                ans += self.rangeSumBST(root.right, low, high)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                ans += self.rangeSumBST(root.left, low, high)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">        self.right = <span class=\"literal\">None</span></span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h3 id=\"144-Binary-Tree-Preorder-Traversal\"><a href=\"#144-Binary-Tree-Preorder-Traversal\" class=\"headerlink\" title=\"144. Binary Tree Preorder Traversal\"></a>144. Binary Tree Preorder Traversal</h3><h4 id=\"二叉树前序遍历\"><a href=\"#二叉树前序遍历\" class=\"headerlink\" title=\"二叉树前序遍历\"></a><a href=\"https://leetcode.com/problems/binary-tree-preorder-traversal/description/\" target=\"_blank\" rel=\"noopener\">二叉树前序遍历</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [1,null,2,3]</span><br><span class=\"line\">   1</span><br><span class=\"line\">    \\</span><br><span class=\"line\">     2</span><br><span class=\"line\">    &#x2F;</span><br><span class=\"line\">   3</span><br><span class=\"line\"></span><br><span class=\"line\">Output: [1,2,3]</span><br></pre></td></tr></table></figure>\n<p>方法一：iteratively</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">preorderTraversal</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'List[int]':</span></span><br><span class=\"line\">    ans, stack = [], root <span class=\"keyword\">and</span> [root]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> stack:</span><br><span class=\"line\">        node = stack.pop()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            ans.append(node.val)</span><br><span class=\"line\">            stack.append(node.right)</span><br><span class=\"line\">            stack.append(node.left)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法二：recursively</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">preorder_traversal</span><span class=\"params\">(root)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> []</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [root.val] + self.preorderTraversal(root.left) + \\</span><br><span class=\"line\">        self.preorderTraversal(root.right)</span><br></pre></td></tr></table></figure>\n<h3 id=\"589-N-ary-Tree-Preorder-Traversal\"><a href=\"#589-N-ary-Tree-Preorder-Traversal\" class=\"headerlink\" title=\"589. N-ary Tree Preorder Traversal\"></a>589. N-ary Tree Preorder Traversal</h3><h4 id=\"N-叉树的前序遍历。N叉树和二叉树有个区别，就是N叉树不需要考虑子节点知否为空，做单独的判断。原题\"><a href=\"#N-叉树的前序遍历。N叉树和二叉树有个区别，就是N叉树不需要考虑子节点知否为空，做单独的判断。原题\" class=\"headerlink\" title=\"N-叉树的前序遍历。N叉树和二叉树有个区别，就是N叉树不需要考虑子节点知否为空，做单独的判断。原题\"></a>N-叉树的前序遍历。N叉树和二叉树有个区别，就是N叉树不需要考虑子节点知否为空，做单独的判断。<a href=\"https://leetcode.com/problems/n-ary-tree-preorder-traversal/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：recursively.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">preorder</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> []</span><br><span class=\"line\">    res = [root.val]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> child <span class=\"keyword\">in</span> root.children:</span><br><span class=\"line\">        res += self.preorder(child)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<p>方法二：iteratively.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">preorder</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">    res, stack = [], root <span class=\"keyword\">and</span> [root]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> stack:</span><br><span class=\"line\">        node = stack.pop()</span><br><span class=\"line\">        res.append(node.val)</span><br><span class=\"line\">        stack.extend(reversed(node.children))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"94-Binary-Tree-Inorder-Traversal\"><a href=\"#94-Binary-Tree-Inorder-Traversal\" class=\"headerlink\" title=\"94. Binary Tree Inorder Traversal\"></a>94. Binary Tree Inorder Traversal</h3><h4 id=\"中序遍历二叉树\"><a href=\"#中序遍历二叉树\" class=\"headerlink\" title=\"中序遍历二叉树\"></a><a href=\"https://leetcode.com/problems/binary-tree-inorder-traversal/description/\" target=\"_blank\" rel=\"noopener\">中序遍历二叉树</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [1,null,2,3]</span><br><span class=\"line\">   1</span><br><span class=\"line\">    \\</span><br><span class=\"line\">     2</span><br><span class=\"line\">    &#x2F;</span><br><span class=\"line\">   3</span><br><span class=\"line\"></span><br><span class=\"line\">Output: [1,3,2]</span><br></pre></td></tr></table></figure>\n<p>方法一：使用栈迭代。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inorderTraversal</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class=\"line\">    stack, ans = [], []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> stack <span class=\"keyword\">or</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> root:</span><br><span class=\"line\">            stack.append(root)</span><br><span class=\"line\">            root = root.left</span><br><span class=\"line\">        root = stack.pop()</span><br><span class=\"line\">        ans.append(root.val)</span><br><span class=\"line\">        root = root.right</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：Morris Traversal.</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inorderTraversal</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class=\"line\">    cur, ans = root, []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> cur:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> cur.left:</span><br><span class=\"line\">            ans.append(cur.val)</span><br><span class=\"line\">            cur = cur.right</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            pre = cur.left</span><br><span class=\"line\">            <span class=\"comment\"># 找到当前节点左子树中最右的右节点</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> pre.right <span class=\"keyword\">and</span> pre.right != cur:</span><br><span class=\"line\">                pre = pre.right</span><br><span class=\"line\">                </span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> pre.right:</span><br><span class=\"line\">                <span class=\"comment\"># 找到最右的节点，连接到根节点</span></span><br><span class=\"line\">                pre.right = cur</span><br><span class=\"line\">                cur = cur.left</span><br><span class=\"line\">            <span class=\"comment\"># 恢复节点</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                pre.right = <span class=\"literal\">None</span></span><br><span class=\"line\">                ans.append(cur.val)</span><br><span class=\"line\">                cur = cur.right</span><br><span class=\"line\">                </span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"145-Binary-Tree-Postorder-Traversal\"><a href=\"#145-Binary-Tree-Postorder-Traversal\" class=\"headerlink\" title=\"145. Binary Tree Postorder Traversal\"></a>145. Binary Tree Postorder Traversal</h3><h4 id=\"后序遍历二叉树\"><a href=\"#后序遍历二叉树\" class=\"headerlink\" title=\"后序遍历二叉树\"></a><a href=\"https://leetcode.com/problems/binary-tree-postorder-traversal/description/\" target=\"_blank\" rel=\"noopener\">后序遍历二叉树</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [1,null,2,3]</span><br><span class=\"line\">   1</span><br><span class=\"line\">    \\</span><br><span class=\"line\">     2</span><br><span class=\"line\">    &#x2F;</span><br><span class=\"line\">   3</span><br><span class=\"line\"></span><br><span class=\"line\">Output: [3,2,1]</span><br></pre></td></tr></table></figure>\n<p>方法一：根右左，再倒序。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">postorder_traversal</span><span class=\"params\">(root)</span>:</span></span><br><span class=\"line\">    res, stack = [], [root]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> stack:</span><br><span class=\"line\">        node = stack.pop()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            res.append(node.val)</span><br><span class=\"line\">            stack.append(node.left)</span><br><span class=\"line\">            stack.append(node.right)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res[::<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<p>方法二：思想: 使用<code>last</code>作为判断是否该节点的右子树完成遍历，如果一个<code>node.right</code>已经刚刚遍历完毕，那么将<code>last==node.right</code>，否则将会寻找<code>node.right</code>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">postorderTraversal</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">    res, stack, node, last = [], [], root, <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> stack <span class=\"keyword\">or</span> node:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            stack.append(node)</span><br><span class=\"line\">            node = node.left</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            node = stack[<span class=\"number\">-1</span>]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node.right <span class=\"keyword\">or</span> last == node.right:</span><br><span class=\"line\">                node = stack.pop()</span><br><span class=\"line\">                res.append(node.val)</span><br><span class=\"line\">                last, node = node, <span class=\"literal\">None</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                node = node.right    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<p>方法三：使用boolean判断一个节点是否被遍历过</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">postorderTraversal</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">    res, stack = [], [(root, <span class=\"literal\">False</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> stack:</span><br><span class=\"line\">        node, visited = stack.pop()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> visited:</span><br><span class=\"line\">                res.append(node.val)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                stack.append((node, <span class=\"literal\">True</span>))</span><br><span class=\"line\">                stack.append((node.right, <span class=\"literal\">False</span>))</span><br><span class=\"line\">                stack.append((node.left, <span class=\"literal\">False</span>))                </span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<p>方法四：dfs.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">postorderTraversal</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'List[int]':</span></span><br><span class=\"line\">    ans = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> </span><br><span class=\"line\">        dfs(node.left)</span><br><span class=\"line\">        dfs(node.right)</span><br><span class=\"line\">        ans.append(node.val)</span><br><span class=\"line\">        </span><br><span class=\"line\">    dfs(root)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"590-N-ary-Tree-Postorder-Traversal\"><a href=\"#590-N-ary-Tree-Postorder-Traversal\" class=\"headerlink\" title=\"590. N-ary Tree Postorder Traversal\"></a>590. N-ary Tree Postorder Traversal</h3><h4 id=\"N-叉树的后序遍历。原题\"><a href=\"#N-叉树的后序遍历。原题\" class=\"headerlink\" title=\"N-叉树的后序遍历。原题\"></a>N-叉树的后序遍历。<a href=\"https://leetcode.com/problems/n-ary-tree-postorder-traversal/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：recursively.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">postorder</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> []</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum([self.postorder(child) <span class=\"keyword\">for</span> child <span class=\"keyword\">in</span> root.children], []) + [root.val]</span><br></pre></td></tr></table></figure>\n<p>方法二：iteratively and reversed.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">postorder</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">    res, stack = [], root <span class=\"keyword\">and</span> [root]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> stack:</span><br><span class=\"line\">        node = stack.pop()</span><br><span class=\"line\">        res.append(node.val)</span><br><span class=\"line\">        stack.extend(node.children)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res[::<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<p>方法三：iteratively and flag.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">postorder</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">    res, stack = [], root <span class=\"keyword\">and</span> [(root, <span class=\"literal\">False</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> stack:</span><br><span class=\"line\">        node, visited = stack.pop()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> visited:</span><br><span class=\"line\">            res.append(node.val)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            stack.append((node, <span class=\"literal\">True</span>))</span><br><span class=\"line\">            stack.extend((n, <span class=\"literal\">False</span>) <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> reversed(node.children))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"100-Same-Tree\"><a href=\"#100-Same-Tree\" class=\"headerlink\" title=\"100. Same Tree\"></a>100. Same Tree</h3><h4 id=\"判断相同的二叉树。原题\"><a href=\"#判断相同的二叉树。原题\" class=\"headerlink\" title=\"判断相同的二叉树。原题\"></a>判断相同的二叉树。<a href=\"https://leetcode.com/problems/same-tree/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input:     1         1</span><br><span class=\"line\">          &#x2F; \\       &#x2F; \\</span><br><span class=\"line\">         2   3     2   3</span><br><span class=\"line\"></span><br><span class=\"line\">        [1,2,3],   [1,2,3]</span><br><span class=\"line\"></span><br><span class=\"line\">Output: true</span><br></pre></td></tr></table></figure>\n<p>方法一：recursively</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isSameTree</span><span class=\"params\">(self, p: <span class=\"string\">'TreeNode'</span>, q: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> p <span class=\"keyword\">and</span> q:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (p.val==q.val <span class=\"keyword\">and</span> self.isSameTree(p.left, q.left) <span class=\"keyword\">and</span> </span><br><span class=\"line\">                self.isSameTree(p.right, q.right))</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p <span class=\"keyword\">is</span> q</span><br></pre></td></tr></table></figure>\n<p>方法二：recursively, tuple</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_same_tree</span><span class=\"params\">(p, q)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">t</span><span class=\"params\">(n)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> n <span class=\"keyword\">and</span> (n.val, t(n.left), t(n.right))  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> t(p) == t(q)</span><br></pre></td></tr></table></figure>\n<p>方法三：iteratively.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isSameTree</span><span class=\"params\">(self, p: <span class=\"string\">'TreeNode'</span>, q: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\">    stack = [(p, q)]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> stack:</span><br><span class=\"line\">        p1, p2 = stack.pop()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> p1 <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> p2:</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> p1 <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> p2:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> p1.val != p2.val:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        stack.append((p1.left, p2.left))</span><br><span class=\"line\">        stack.append((p1.right, p2.right))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"101-Symmetric-Tree\"><a href=\"#101-Symmetric-Tree\" class=\"headerlink\" title=\"101. Symmetric Tree\"></a>101. Symmetric Tree</h3><h4 id=\"判断二叉树是否对称。原题\"><a href=\"#判断二叉树是否对称。原题\" class=\"headerlink\" title=\"判断二叉树是否对称。原题\"></a>判断二叉树是否对称。<a href=\"https://leetcode.com/problems/symmetric-tree/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">    1</span><br><span class=\"line\">   &#x2F; \\</span><br><span class=\"line\">  2   2</span><br><span class=\"line\"> &#x2F; \\ &#x2F; \\</span><br><span class=\"line\">3  4 4  3</span><br></pre></td></tr></table></figure>\n<p>方法一：recursively.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isSymmetric</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">symmetric</span><span class=\"params\">(p1, p2)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> p1 <span class=\"keyword\">and</span> p2:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (p1.val == p2.val <span class=\"keyword\">and</span> symmetric(p1.left, p2.right) <span class=\"keyword\">and</span> </span><br><span class=\"line\">                    symmetric(p1.right, p2.left))</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> p1 <span class=\"keyword\">is</span> p2</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> symmetric(root.left, root.right)</span><br></pre></td></tr></table></figure>\n<p>方法二：iteratively.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isSymmetric</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\">    stack = root <span class=\"keyword\">and</span> [(root.left, root.right)]        </span><br><span class=\"line\">    <span class=\"keyword\">while</span> stack:</span><br><span class=\"line\">        p1, p2 = stack.pop()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> p1 <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> p2: <span class=\"keyword\">continue</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> p1 <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> p2: <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> p1.val != p2.val: <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        stack.append((p1.left, p2.right))</span><br><span class=\"line\">        stack.append((p1.right, p2.left))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"104-Maximum-Depth-of-Binary-Tree\"><a href=\"#104-Maximum-Depth-of-Binary-Tree\" class=\"headerlink\" title=\"104. Maximum Depth of Binary Tree\"></a>104. Maximum Depth of Binary Tree</h3><h4 id=\"二叉树最大深度。原题\"><a href=\"#二叉树最大深度。原题\" class=\"headerlink\" title=\"二叉树最大深度。原题\"></a>二叉树最大深度。<a href=\"https://leetcode.com/problems/maximum-depth-of-binary-tree/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">    3</span><br><span class=\"line\">   &#x2F; \\</span><br><span class=\"line\">  9  20</span><br><span class=\"line\">    &#x2F;  \\</span><br><span class=\"line\">   15   7</span><br><span class=\"line\">return 3</span><br></pre></td></tr></table></figure>\n<p>方法一：recursively</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">max_depth</span><span class=\"params\">(root)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(max_depth(root.left), max_depth(root.right)) + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>方法二：iteratively. BFS with deque</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxDepth</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    q = root <span class=\"keyword\">and</span> collections.deque([(root, <span class=\"number\">1</span>)])</span><br><span class=\"line\">    d = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> q:</span><br><span class=\"line\">        node, d = q.popleft()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.right:</span><br><span class=\"line\">            q.append((node.right, d+<span class=\"number\">1</span>))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.left:</span><br><span class=\"line\">            q.append((node.left, d+<span class=\"number\">1</span>))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> d</span><br></pre></td></tr></table></figure>\n<p>可以参考102分层遍历写法，最后求长度。</p>\n<h3 id=\"559-Maximum-Depth-of-N-ary-Tree\"><a href=\"#559-Maximum-Depth-of-N-ary-Tree\" class=\"headerlink\" title=\"559. Maximum Depth of N-ary Tree\"></a>559. Maximum Depth of N-ary Tree</h3><h4 id=\"N-叉树的最大深度。原题\"><a href=\"#N-叉树的最大深度。原题\" class=\"headerlink\" title=\"N-叉树的最大深度。原题\"></a>N-叉树的最大深度。<a href=\"https://leetcode.com/problems/maximum-depth-of-n-ary-tree/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：BFS with deque.同上题一样。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxDepth</span><span class=\"params\">(self, root: <span class=\"string\">'Node'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    q = root <span class=\"keyword\">and</span> collections.deque([(root, <span class=\"number\">1</span>)])</span><br><span class=\"line\">    d = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> q:</span><br><span class=\"line\">        node, d = q.popleft()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> child <span class=\"keyword\">in</span> node.children:</span><br><span class=\"line\">            q.append((child, d + <span class=\"number\">1</span>))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> d</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：BFS.</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxDepth</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">    q, level = root <span class=\"keyword\">and</span> [root], <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> q:</span><br><span class=\"line\">        q, level = [child <span class=\"keyword\">for</span> node <span class=\"keyword\">in</span> q <span class=\"keyword\">for</span> child <span class=\"keyword\">in</span> node.children], level+<span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> level</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：recursively. </font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxDepth</span><span class=\"params\">(self, root: <span class=\"string\">'Node'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(list(map(self.maxDepth, root.children)) <span class=\"keyword\">or</span> [<span class=\"number\">0</span>]) + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"111-Minimum-Depth-of-Binary-Tree\"><a href=\"#111-Minimum-Depth-of-Binary-Tree\" class=\"headerlink\" title=\"111. Minimum Depth of Binary Tree\"></a>111. Minimum Depth of Binary Tree</h3><h4 id=\"求根节点到叶子节点的最小深度。原题\"><a href=\"#求根节点到叶子节点的最小深度。原题\" class=\"headerlink\" title=\"求根节点到叶子节点的最小深度。原题\"></a>求根节点到叶子节点的最小深度。<a href=\"https://leetcode.com/problems/minimum-depth-of-binary-tree\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：recursively</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minDepth</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> root.left <span class=\"keyword\">and</span> root.right:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> min(self.minDepth(root.left), self.minDepth(root.right)) + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.minDepth(root.left) + self.minDepth(root.right) + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：对上述方法修改，更加Pythonic. 注意一点，Python3中要加list,否则max因为空值报错。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minDepth</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root: <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    d = list(map(self.minDepth, (root.left, root.right)))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span> + (min(d) <span class=\"keyword\">or</span> max(d))</span><br></pre></td></tr></table></figure>\n<p>方法三：迭代法，BFS</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minDepth</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    q = root <span class=\"keyword\">and</span> collections.deque([(root, <span class=\"number\">1</span>)])</span><br><span class=\"line\">    d = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> q:</span><br><span class=\"line\">        node, d = q.popleft()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node.left <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> node.right:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> d</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.left:</span><br><span class=\"line\">            q.append((node.left, d+<span class=\"number\">1</span>))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.right:</span><br><span class=\"line\">            q.append((node.right, d+<span class=\"number\">1</span>))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> d</span><br></pre></td></tr></table></figure>\n<h3 id=\"105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal\"><a href=\"#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal\" class=\"headerlink\" title=\"105. Construct Binary Tree from Preorder and Inorder Traversal\"></a>105. Construct Binary Tree from Preorder and Inorder Traversal</h3><h4 id=\"根据前序遍历和中序遍历重建二叉树。原题\"><a href=\"#根据前序遍历和中序遍历重建二叉树。原题\" class=\"headerlink\" title=\"根据前序遍历和中序遍历重建二叉树。原题\"></a>根据前序遍历和中序遍历重建二叉树。<a href=\"https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">preorder &#x3D; [3,9,20,15,7]</span><br><span class=\"line\">inorder &#x3D; [9,3,15,20,7]</span><br></pre></td></tr></table></figure>\n<p>方法一：切片。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">buildTree</span><span class=\"params\">(preorder, inorder)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> preorder == []:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">    root_val = preorder[<span class=\"number\">0</span>]</span><br><span class=\"line\">    root = TreeNode(root_val)</span><br><span class=\"line\">    cut = inorder.index(root_val)</span><br><span class=\"line\">    root.left = buildTree(preorder[<span class=\"number\">1</span>:cut+<span class=\"number\">1</span>], inorder[:cut])</span><br><span class=\"line\">    root.right = buildTree(preorder[cut+<span class=\"number\">1</span>:], inorder[cut+<span class=\"number\">1</span>:])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：上述方法在极端情况下，如只有左子树的情况，由于index会将时间复杂度上升到O(n²)，而且切片产生了一些不必要的内存。这个方法是setefan大神的方法，pop和<code>reverse</code>是为了增加效率。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">buildTree</span><span class=\"params\">(self, preorder: <span class=\"string\">'List[int]'</span>, inorder: <span class=\"string\">'List[int]'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">build</span><span class=\"params\">(stop)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> inorder <span class=\"keyword\">and</span> inorder[<span class=\"number\">-1</span>] != stop:</span><br><span class=\"line\">            root = TreeNode(preorder.pop())</span><br><span class=\"line\">            root.left = build(root.val)</span><br><span class=\"line\">            inorder.pop()</span><br><span class=\"line\">            root.right = build(stop)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root</span><br><span class=\"line\">    preorder.reverse()</span><br><span class=\"line\">    inorder.reverse()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> build(<span class=\"literal\">None</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal\"><a href=\"#106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal\" class=\"headerlink\" title=\"106. Construct Binary Tree from Inorder and Postorder Traversal\"></a>106. Construct Binary Tree from Inorder and Postorder Traversal</h3><h4 id=\"根据中序遍历和后序遍历重建二叉树。原题\"><a href=\"#根据中序遍历和后序遍历重建二叉树。原题\" class=\"headerlink\" title=\"根据中序遍历和后序遍历重建二叉树。原题\"></a>根据中序遍历和后序遍历重建二叉树。<a href=\"https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：切片、</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">buildTree</span><span class=\"params\">(self, inorder: List[int], postorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> postorder:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">    root_val = postorder[<span class=\"number\">-1</span>]</span><br><span class=\"line\">    root = TreeNode(root_val)</span><br><span class=\"line\">    cut = inorder.index(root_val)</span><br><span class=\"line\">    root.left = self.buildTree(inorder[:cut], postorder[:cut])</span><br><span class=\"line\">    root.right = self.buildTree(inorder[cut+<span class=\"number\">1</span>:], postorder[cut: <span class=\"number\">-1</span>])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：stop pop的方式。甚至都不用reverse</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">buildTree</span><span class=\"params\">(self, inorder: List[int], postorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">build</span><span class=\"params\">(stop)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> inorder <span class=\"keyword\">and</span> inorder[<span class=\"number\">-1</span>]!=stop:</span><br><span class=\"line\">            root = TreeNode(postorder.pop()) </span><br><span class=\"line\">            root.right = build(root.val)</span><br><span class=\"line\">            inorder.pop()</span><br><span class=\"line\">            root.left  = build(stop)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root</span><br><span class=\"line\">         </span><br><span class=\"line\">    <span class=\"keyword\">return</span> build(<span class=\"literal\">None</span>)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">buildTree</span><span class=\"params\">(self, inorder: List[int], postorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">build</span><span class=\"params\">(stop, info=<span class=\"string\">''</span>, lv=<span class=\"number\">0</span>)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> inorder <span class=\"keyword\">and</span> inorder[<span class=\"number\">-1</span>]==stop:</span><br><span class=\"line\">            print(<span class=\"string\">'stop at'</span>, inorder, stop, info)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> </span><br><span class=\"line\">        print(lv*<span class=\"string\">'-&gt;'</span> , inorder, stop, postorder, info)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> inorder <span class=\"keyword\">and</span> inorder[<span class=\"number\">-1</span>]!=stop:</span><br><span class=\"line\">            root = TreeNode(postorder.pop())</span><br><span class=\"line\">            root.right = build(root.val, <span class=\"string\">\"build &#123;&#125;'s right\"</span>.format(root.val), lv+<span class=\"number\">1</span>)</span><br><span class=\"line\">            inorder.pop()</span><br><span class=\"line\">            root.left = build(stop, <span class=\"string\">\"build &#123;&#125;'s left\"</span>.format(root.val), lv+<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> build(<span class=\"literal\">None</span>)</span><br><span class=\"line\">  </span><br><span class=\"line\">[<span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">15</span>, <span class=\"number\">20</span>, <span class=\"number\">7</span>] <span class=\"literal\">None</span> [<span class=\"number\">9</span>, <span class=\"number\">15</span>, <span class=\"number\">7</span>, <span class=\"number\">20</span>, <span class=\"number\">3</span>] </span><br><span class=\"line\">-&gt; [9, 3, 15, 20, 7] 3 [9, 15, 7, 20] build 3's right</span><br><span class=\"line\">-&gt;-&gt; [9, 3, 15, 20, 7] 20 [9, 15, 7] build 20's right</span><br><span class=\"line\">stop at [<span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">15</span>, <span class=\"number\">20</span>, <span class=\"number\">7</span>] <span class=\"number\">7</span> build <span class=\"number\">7</span><span class=\"string\">'s right</span></span><br><span class=\"line\"><span class=\"string\">stop at [9, 3, 15, 20] 20 build 7'</span>s left</span><br><span class=\"line\">-&gt;-&gt; [9, 3, 15] 3 [9, 15] build 20's left</span><br><span class=\"line\">stop at [<span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">15</span>] <span class=\"number\">15</span> build <span class=\"number\">15</span><span class=\"string\">'s right</span></span><br><span class=\"line\"><span class=\"string\">stop at [9, 3] 3 build 15'</span>s left</span><br><span class=\"line\">-&gt; [9] None [9] build 3's left</span><br><span class=\"line\">stop at [<span class=\"number\">9</span>] <span class=\"number\">9</span> build <span class=\"number\">9</span><span class=\"string\">'s right</span></span><br><span class=\"line\"><span class=\"string\">-&gt;-&gt; [] None [] build 9'</span>s left</span><br></pre></td></tr></table></figure>\n<h3 id=\"889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal\"><a href=\"#889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal\" class=\"headerlink\" title=\"889. Construct Binary Tree from Preorder and Postorder Traversal\"></a>889. Construct Binary Tree from Preorder and Postorder Traversal</h3><h4 id=\"根据前序和后序重建二叉树。原题\"><a href=\"#根据前序和后序重建二叉树。原题\" class=\"headerlink\" title=\"根据前序和后序重建二叉树。原题\"></a>根据前序和后序重建二叉树。<a href=\"https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: pre &#x3D; [1,2,4,5,3,6,7], post &#x3D; [4,5,2,6,7,3,1]</span><br><span class=\"line\">Output: [1,2,3,4,5,6,7]</span><br></pre></td></tr></table></figure>\n<p>方法一：index的方式、、</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">constructFromPrePost</span><span class=\"params\">(self, pre: List[int], post: List[int])</span> -&gt; TreeNode:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> post:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">    root = TreeNode(post.pop())</span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(pre) &gt; <span class=\"number\">1</span>:</span><br><span class=\"line\">        cut = post.index(pre[<span class=\"number\">1</span>])</span><br><span class=\"line\">        </span><br><span class=\"line\">        root.left = self.constructFromPrePost(pre[<span class=\"number\">1</span>:cut+<span class=\"number\">2</span>], post[:cut+<span class=\"number\">1</span>])</span><br><span class=\"line\">        root.right = self.constructFromPrePost(pre[cut+<span class=\"number\">2</span>:], post[cut+<span class=\"number\">1</span>:])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：使用index递归 . by@lee215</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    preIndex, posIndex = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">constructFromPrePost</span><span class=\"params\">(self, pre, post)</span>:</span></span><br><span class=\"line\">        root = TreeNode(pre[self.preIndex])</span><br><span class=\"line\">        self.preIndex += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.val != post[self.posIndex]):</span><br><span class=\"line\">            root.left = self.constructFromPrePost(pre, post)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.val != post[self.posIndex]):</span><br><span class=\"line\">            root.right = self.constructFromPrePost(pre, post)</span><br><span class=\"line\">        self.posIndex += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> root</span><br></pre></td></tr></table></figure>\n<h3 id=\"572-Subtree-of-Another-Tree\"><a href=\"#572-Subtree-of-Another-Tree\" class=\"headerlink\" title=\"572. Subtree of Another Tree\"></a>572. Subtree of Another Tree</h3><h4 id=\"判断是否是树的子结构。原题\"><a href=\"#判断是否是树的子结构。原题\" class=\"headerlink\" title=\"判断是否是树的子结构。原题\"></a>判断是否是树的子结构。<a href=\"https://leetcode.com/problems/subtree-of-another-tree/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>思路：这道题是遍历加判断相同树的结合。这里采用前序遍历和递归判断相同树。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isSubtree</span><span class=\"params\">(self, s: <span class=\"string\">'TreeNode'</span>, t: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_same</span><span class=\"params\">(s, t)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> s <span class=\"keyword\">and</span> t:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (s.val==t.val <span class=\"keyword\">and</span> is_same(s.left, t.left) <span class=\"keyword\">and</span> </span><br><span class=\"line\">                    is_same(s.right, t.right))</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s <span class=\"keyword\">is</span> t</span><br><span class=\"line\"></span><br><span class=\"line\">    stack = s <span class=\"keyword\">and</span> [s]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> stack:</span><br><span class=\"line\">        node = stack.pop()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> is_same(node, t):</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">            stack.append(node.right)</span><br><span class=\"line\">            stack.append(node.left)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<p>方法二：生成器写法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"102-Binary-Tree-Level-Order-Traversal\"><a href=\"#102-Binary-Tree-Level-Order-Traversal\" class=\"headerlink\" title=\"102. Binary Tree Level Order Traversal\"></a>102. Binary Tree Level Order Traversal</h3><h4 id=\"分层遍历二叉树。原题\"><a href=\"#分层遍历二叉树。原题\" class=\"headerlink\" title=\"分层遍历二叉树。原题\"></a>分层遍历二叉树。<a href=\"https://leetcode.com/problems/binary-tree-level-order-traversal/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>注意：循环条件要加上root，以防止root is None</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">levelOrder</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'List[List[int]]':</span></span><br><span class=\"line\">    ans, level = [], root <span class=\"keyword\">and</span> [root]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> level:</span><br><span class=\"line\">        ans.append([n.val <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> level])</span><br><span class=\"line\">        level = [k <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> level <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> (n.left, n.right) <span class=\"keyword\">if</span> k]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"103-Binary-Tree-Zigzag-Level-Order-Traversal\"><a href=\"#103-Binary-Tree-Zigzag-Level-Order-Traversal\" class=\"headerlink\" title=\"103. Binary Tree Zigzag Level Order Traversal\"></a>103. Binary Tree Zigzag Level Order Traversal</h3><h4 id=\"之字形打印二叉树。原题\"><a href=\"#之字形打印二叉树。原题\" class=\"headerlink\" title=\"之字形打印二叉树。原题\"></a>之字形打印二叉树。<a href=\"https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">zigzagLevelOrder</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'List[List[int]]':</span></span><br><span class=\"line\">    ans, level, order = [], root <span class=\"keyword\">and</span> [root], <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> level:</span><br><span class=\"line\">        ans.append([n.val <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> level][::order])</span><br><span class=\"line\">        order *= <span class=\"number\">-1</span></span><br><span class=\"line\">        level = [kid <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> level <span class=\"keyword\">for</span> kid <span class=\"keyword\">in</span> (n.left, n.right) <span class=\"keyword\">if</span> kid]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"107-Binary-Tree-Level-Order-Traversal-II\"><a href=\"#107-Binary-Tree-Level-Order-Traversal-II\" class=\"headerlink\" title=\"107. Binary Tree Level Order Traversal II\"></a>107. Binary Tree Level Order Traversal II</h3><h4 id=\"和102题不同的是，从下到上分层打印。原题\"><a href=\"#和102题不同的是，从下到上分层打印。原题\" class=\"headerlink\" title=\"和102题不同的是，从下到上分层打印。原题\"></a>和102题不同的是，从下到上分层打印。<a href=\"https://leetcode.com/problems/binary-tree-level-order-traversal-ii/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><font color=\"#32CD32\" size=\"3\">方法一：将结果倒序输出。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">levelOrderBottom</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">    res, level = [], [root]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> root <span class=\"keyword\">and</span> level:</span><br><span class=\"line\">        res.append([n.val <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> level])</span><br><span class=\"line\">        level = [kid <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> level <span class=\"keyword\">for</span> kid <span class=\"keyword\">in</span> (n.left, n.right) <span class=\"keyword\">if</span> kid]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res[::<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<p>方法二：也可以从前面插入元素。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">levelOrderBottom</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">    res, level = [], [root]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> root <span class=\"keyword\">and</span> level:</span><br><span class=\"line\">        res.insert(<span class=\"number\">0</span>, [n.val <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> level])</span><br><span class=\"line\">        level = [kid <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> level <span class=\"keyword\">for</span> kid <span class=\"keyword\">in</span> (n.left, n.right) <span class=\"keyword\">if</span> kid]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"429-N-ary-Tree-Level-Order-Traversal\"><a href=\"#429-N-ary-Tree-Level-Order-Traversal\" class=\"headerlink\" title=\"429. N-ary Tree Level Order Traversal\"></a>429. N-ary Tree Level Order Traversal</h3><h4 id=\"分层打印N叉树。原题\"><a href=\"#分层打印N叉树。原题\" class=\"headerlink\" title=\"分层打印N叉树。原题\"></a>分层打印N叉树。<a href=\"https://leetcode.com/problems/n-ary-tree-level-order-traversal/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">levelOrder</span><span class=\"params\">(self, root: <span class=\"string\">'Node'</span>)</span> -&gt; 'List[List[int]]':</span></span><br><span class=\"line\">    ans, level = [], root <span class=\"keyword\">and</span> [root]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> level:</span><br><span class=\"line\">        ans.append([n.val <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> level])</span><br><span class=\"line\">        level = [k <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> level <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> n.children <span class=\"keyword\">if</span> k]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"637-Average-of-Levels-in-Binary-Tree\"><a href=\"#637-Average-of-Levels-in-Binary-Tree\" class=\"headerlink\" title=\"637. Average of Levels in Binary Tree\"></a>637. Average of Levels in Binary Tree</h3><h4 id=\"遍历一个二叉树，求每层节点的平均值，按照节点不为空的个数。原题\"><a href=\"#遍历一个二叉树，求每层节点的平均值，按照节点不为空的个数。原题\" class=\"headerlink\" title=\"遍历一个二叉树，求每层节点的平均值，按照节点不为空的个数。原题\"></a>遍历一个二叉树，求每层节点的平均值，按照节点不为空的个数。<a href=\"https://leetcode.com/problems/average-of-levels-in-binary-tree/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">    3</span><br><span class=\"line\">   &#x2F; \\</span><br><span class=\"line\">  9  20</span><br><span class=\"line\">    &#x2F;  \\</span><br><span class=\"line\">   15   7</span><br><span class=\"line\">Output: [3, 14.5, 11]</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">The average value of nodes on level 0 is 3,  on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11].</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">averageOfLevels</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'List[float]':</span></span><br><span class=\"line\">    ans, level = [], root <span class=\"keyword\">and</span> [root]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> level:</span><br><span class=\"line\">        ans.append(sum(n.val <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> level) / len(level))</span><br><span class=\"line\">        level = [k <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> level <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> (n.left, n.right) <span class=\"keyword\">if</span> k]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"515-Find-Largest-Value-in-Each-Tree-Row\"><a href=\"#515-Find-Largest-Value-in-Each-Tree-Row\" class=\"headerlink\" title=\"515. Find Largest Value in Each Tree Row\"></a>515. Find Largest Value in Each Tree Row</h3><h4 id=\"找到树每层的最大值。原题\"><a href=\"#找到树每层的最大值。原题\" class=\"headerlink\" title=\"找到树每层的最大值。原题\"></a>找到树每层的最大值。<a href=\"https://leetcode.com/problems/find-largest-value-in-each-tree-row/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：BFS. 此解法秒。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">largestValues</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class=\"line\">    ans, levels = [], root <span class=\"keyword\">and</span> [root]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> levels:</span><br><span class=\"line\">        ans.append(max(x.val <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> levels))</span><br><span class=\"line\">        levels = [k <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> levels <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> (n.left, n.right) <span class=\"keyword\">if</span> k]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"987-Vertical-Order-Traversal-of-a-Binary-Tree\"><a href=\"#987-Vertical-Order-Traversal-of-a-Binary-Tree\" class=\"headerlink\" title=\"987. Vertical Order Traversal of a Binary Tree\"></a>987. Vertical Order Traversal of a Binary Tree</h3><h4 id=\"垂直遍历二叉树，从左到右，从上到下，如果节点具有相同位置，按照值从小到大。原题\"><a href=\"#垂直遍历二叉树，从左到右，从上到下，如果节点具有相同位置，按照值从小到大。原题\" class=\"headerlink\" title=\"垂直遍历二叉树，从左到右，从上到下，如果节点具有相同位置，按照值从小到大。原题\"></a>垂直遍历二叉树，从左到右，从上到下，如果节点具有相同位置，按照值从小到大。<a href=\"https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><img src=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AF%87%EF%BC%89Tree/tree2.png\" class>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [1,2,3,4,5,6,7]</span><br><span class=\"line\">Output: [[4],[2],[1,5,6],[3],[7]]</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">The node with value 5 and the node with value 6 have the same position according to the given scheme.</span><br><span class=\"line\">However, in the report &quot;[1,5,6]&quot;, the node value of 5 comes first since 5 is smaller than 6.</span><br></pre></td></tr></table></figure>\n<p>方法一：dfs. 通过建立一个<strong>字典数组</strong>，将对应的节点使用深度优先遍历初始化数组。然后按照x, y, val三个优先级进行排序。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">verticalTraversal</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'List[List[int]]':</span></span><br><span class=\"line\">    seen = collections.defaultdict(</span><br><span class=\"line\">        <span class=\"keyword\">lambda</span>: collections.defaultdict(list)</span><br><span class=\"line\">    )</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(node, x=<span class=\"number\">0</span>, y=<span class=\"number\">0</span>)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            seen[x][y].append(node.val)</span><br><span class=\"line\">            dfs(node.left, x<span class=\"number\">-1</span>, y+<span class=\"number\">1</span>)</span><br><span class=\"line\">            dfs(node.right, x+<span class=\"number\">1</span>, y+<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    dfs(root)</span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> sorted(seen):</span><br><span class=\"line\">        inner = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> y <span class=\"keyword\">in</span> sorted(seen[x]):</span><br><span class=\"line\">            inner.extend(sorted(n <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> seen[x][y]))</span><br><span class=\"line\">        ans.append(inner)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"257-Binary-Tree-Paths\"><a href=\"#257-Binary-Tree-Paths\" class=\"headerlink\" title=\"257. Binary Tree Paths\"></a>257. Binary Tree Paths</h3><h4 id=\"打印二叉树从根节点到叶子节点全部路径。原题\"><a href=\"#打印二叉树从根节点到叶子节点全部路径。原题\" class=\"headerlink\" title=\"打印二叉树从根节点到叶子节点全部路径。原题\"></a>打印二叉树从根节点到叶子节点全部路径。<a href=\"https://leetcode.com/problems/binary-tree-paths/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\"></span><br><span class=\"line\">   1</span><br><span class=\"line\"> &#x2F;   \\</span><br><span class=\"line\">2     3</span><br><span class=\"line\"> \\</span><br><span class=\"line\">  5</span><br><span class=\"line\"></span><br><span class=\"line\">Output: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">Explanation: All root-to-leaf paths are: 1-&gt;2-&gt;5, 1-&gt;3</span><br></pre></td></tr></table></figure>\n<p>iteratively。思路：采用前序遍历二叉树，使用tuple保存节点当前路径，如果是叶子节点，则添加到结果中。开始老是想着用<code>&#39;-&gt;&#39;.join()</code>，这样反而麻烦，直接使用字符串保存就好。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">binaryTreePaths</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'List[str]':</span></span><br><span class=\"line\">    ans, stack = [], root <span class=\"keyword\">and</span> [(root, str(root.val))]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> stack:</span><br><span class=\"line\">        n, p = stack.pop()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> n.left <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> n.right:</span><br><span class=\"line\">            ans.append(p)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n.right:</span><br><span class=\"line\">            stack.append((n.right, p+<span class=\"string\">'-&gt;'</span>+str(n.right.val)))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n.left:</span><br><span class=\"line\">            stack.append((n.left, p+<span class=\"string\">'-&gt;'</span>+str(n.left.val)))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\"> 方法二：dfs. </font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">binaryTreePaths</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'List[str]':</span></span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(n, path)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n:</span><br><span class=\"line\">            path.append(str(n.val))</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> n.left <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> n.right:</span><br><span class=\"line\">                ans.append(<span class=\"string\">'-&gt;'</span>.join(path))</span><br><span class=\"line\">            dfs(n.left, path)</span><br><span class=\"line\">            dfs(n.right, path)</span><br><span class=\"line\">            path.pop()</span><br><span class=\"line\">    dfs(root, [])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">recursively。参考了<code>StefanPochmann</code>大神的方法。最开始想到一半，中间那层循环想到了，但没想到用递归。 </font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">binaryTreePaths</span><span class=\"params\">(self, root)</span>:</span> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> []</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [str(root.val) + <span class=\"string\">'-&gt;'</span> + path</span><br><span class=\"line\">            <span class=\"keyword\">for</span> kid <span class=\"keyword\">in</span> (root.left, root.right) <span class=\"keyword\">if</span> kid</span><br><span class=\"line\">            <span class=\"keyword\">for</span> path <span class=\"keyword\">in</span> self.binaryTreePaths(kid)] <span class=\"keyword\">or</span> [str(root.val)]</span><br></pre></td></tr></table></figure>\n<h3 id=\"988-Smallest-String-Starting-From-Leaf\"><a href=\"#988-Smallest-String-Starting-From-Leaf\" class=\"headerlink\" title=\"988. Smallest String Starting From Leaf\"></a>988. Smallest String Starting From Leaf</h3><h4 id=\"求字典顺序最小的路径，路径指叶子节点到根节点的路径。0对应a，1对应b。原题\"><a href=\"#求字典顺序最小的路径，路径指叶子节点到根节点的路径。0对应a，1对应b。原题\" class=\"headerlink\" title=\"求字典顺序最小的路径，路径指叶子节点到根节点的路径。0对应a，1对应b。原题\"></a>求字典顺序最小的路径，路径指叶子节点到根节点的路径。0对应a，1对应b。<a href=\"https://leetcode.com/problems/smallest-string-starting-from-leaf/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [0,1,2,3,4,3,4]</span><br><span class=\"line\">Output: &quot;dba&quot;</span><br></pre></td></tr></table></figure>\n<p>方法一：先列出所有根到叶子的路径，再reverse求最小值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">smallestFromLeaf</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'str':</span></span><br><span class=\"line\">    OFFSET = ord(<span class=\"string\">'a'</span>)</span><br><span class=\"line\">    stack = root <span class=\"keyword\">and</span> [(root, chr(root.val+OFFSET))]</span><br><span class=\"line\">    ans = <span class=\"string\">'~'</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> stack:</span><br><span class=\"line\">        n, p = stack.pop()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> n.left <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> n.right:</span><br><span class=\"line\">            ans = min(ans, p[::<span class=\"number\">-1</span>])</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n.right:</span><br><span class=\"line\">            stack.append((n.right, p+chr(n.right.val+OFFSET)))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n.left:</span><br><span class=\"line\">            stack.append((n.left, p+chr(n.left.val+OFFSET)))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：dfs.  递归计算完左右节点，然后再将根节点pop掉。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">smallestFromLeaf</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'str':</span></span><br><span class=\"line\">    self.ans = <span class=\"string\">'~'</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(node, A)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            A.append(chr(node.val + ord(<span class=\"string\">'a'</span>)))</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node.left <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> node.right:</span><br><span class=\"line\">                self.ans = min(self.ans, <span class=\"string\">''</span>.join(reversed(A)))</span><br><span class=\"line\">            dfs(node.left, A)</span><br><span class=\"line\">            dfs(node.right, A)</span><br><span class=\"line\">            A.pop()</span><br><span class=\"line\">        </span><br><span class=\"line\">    dfs(root, [])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"112-Path-Sum\"><a href=\"#112-Path-Sum\" class=\"headerlink\" title=\"112. Path Sum\"></a>112. Path Sum</h3><h4 id=\"判断是否具有从根节点到叶子节点上的值和为sum。原题\"><a href=\"#判断是否具有从根节点到叶子节点上的值和为sum。原题\" class=\"headerlink\" title=\"判断是否具有从根节点到叶子节点上的值和为sum。原题\"></a>判断是否具有从根节点到叶子节点上的值和为sum。<a href=\"https://leetcode.com/problems/path-sum/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：recursively</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hasPathSum</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>, total: <span class=\"string\">'int'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> (<span class=\"keyword\">not</span> root.left <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> root.right <span class=\"keyword\">and</span> </span><br><span class=\"line\">        root.val==total):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (self.hasPathSum(root.left, total-root.val) <span class=\"keyword\">or</span> </span><br><span class=\"line\">                self.hasPathSum(root.right, total-root.val))</span><br></pre></td></tr></table></figure>\n<p>方法二：iteratively</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hasPathSum</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>, total: <span class=\"string\">'int'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\">    stack = root <span class=\"keyword\">and</span> [(root, total)]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> stack:</span><br><span class=\"line\">        n, t = stack.pop()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> n.left <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> n.right <span class=\"keyword\">and</span> n.val==t:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n.right:</span><br><span class=\"line\">            stack.append((n.right, t-n.val))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n.left:</span><br><span class=\"line\">            stack.append((n.left, t-n.val))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"113-Path-Sum-II\"><a href=\"#113-Path-Sum-II\" class=\"headerlink\" title=\"113. Path Sum II\"></a>113. Path Sum II</h3><h4 id=\"上题的升级版，要求二维数组返回所有路径。原题\"><a href=\"#上题的升级版，要求二维数组返回所有路径。原题\" class=\"headerlink\" title=\"上题的升级版，要求二维数组返回所有路径。原题\"></a>上题的升级版，要求二维数组返回所有路径。<a href=\"https://leetcode.com/problems/path-sum-ii/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sum &#x3D; 22</span><br><span class=\"line\"></span><br><span class=\"line\">      5</span><br><span class=\"line\">     &#x2F; \\</span><br><span class=\"line\">    4   8</span><br><span class=\"line\">   &#x2F;   &#x2F; \\</span><br><span class=\"line\">  11  13  4</span><br><span class=\"line\"> &#x2F;  \\    &#x2F; \\</span><br><span class=\"line\">7    2  5   1</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">   [5,4,11,2],</span><br><span class=\"line\">   [5,8,4,5]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法一：iteratively. 举一反三。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pathSum</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>, total: <span class=\"string\">'int'</span>)</span> -&gt; 'List[List[int]]':</span></span><br><span class=\"line\">    stack = root <span class=\"keyword\">and</span> [(root, [root.val], total)]</span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> stack:</span><br><span class=\"line\">        n, v, t = stack.pop()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> n.left <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> n.right <span class=\"keyword\">and</span> n.val==t:</span><br><span class=\"line\">            ans.append(v)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n.right:</span><br><span class=\"line\">            stack.append((n.right, v+[n.right.val], t-n.val))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n.left:</span><br><span class=\"line\">            stack.append((n.left, v+[n.left.val], t-n.val))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>recursively. 先找出所有路径，再过滤，实际上和257题一样。不过这并没有把这道题的特性涵盖进去。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pathSum</span><span class=\"params\">(self, root, sum_val)</span>:</span></span><br><span class=\"line\">    paths = self.all_paths(root)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [path <span class=\"keyword\">for</span> path <span class=\"keyword\">in</span> paths <span class=\"keyword\">if</span> sum(path)==sum_val]</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">all_paths</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> []</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[root.val]+path</span><br><span class=\"line\">            <span class=\"keyword\">for</span> kid <span class=\"keyword\">in</span> (root.left, root.right) <span class=\"keyword\">if</span> kid</span><br><span class=\"line\">            <span class=\"keyword\">for</span> path <span class=\"keyword\">in</span> self.all_paths(kid)] <span class=\"keyword\">or</span> [[root.val]]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：recursively. </font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pathSum</span><span class=\"params\">(self, root, sum)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> []</span><br><span class=\"line\">    val, *kids = root.val, root.left, root.right</span><br><span class=\"line\">    <span class=\"keyword\">if</span> any(kids):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [[val] + path</span><br><span class=\"line\">                <span class=\"keyword\">for</span> kid <span class=\"keyword\">in</span> kids <span class=\"keyword\">if</span> kid</span><br><span class=\"line\">                <span class=\"keyword\">for</span> path <span class=\"keyword\">in</span> self.pathSum(kid, sum-val)]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[val]] <span class=\"keyword\">if</span> val==sum <span class=\"keyword\">else</span> []</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法四: dfs. 注意找到叶子节点后也要pop()。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pathSum</span><span class=\"params\">(self, root: TreeNode, sum: int)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">    self.ans = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(node, s, p)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node: <span class=\"keyword\">return</span></span><br><span class=\"line\">        p.append(node.val)</span><br><span class=\"line\">        s += node.val</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node.left <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> node.right <span class=\"keyword\">and</span> s==sum:</span><br><span class=\"line\">            self.ans.append(p[:])</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            dfs(node.left, s, p)</span><br><span class=\"line\">            dfs(node.right, s, p)</span><br><span class=\"line\">        p.pop()</span><br><span class=\"line\"></span><br><span class=\"line\">    dfs(root, <span class=\"number\">0</span>, [])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"297-Serialize-and-Deserialize-Binary-Tree\"><a href=\"#297-Serialize-and-Deserialize-Binary-Tree\" class=\"headerlink\" title=\"297. Serialize and Deserialize Binary Tree\"></a>297. Serialize and Deserialize Binary Tree</h3><h4 id=\"序列化反序列化二叉树。原题\"><a href=\"#序列化反序列化二叉树。原题\" class=\"headerlink\" title=\"序列化反序列化二叉树。原题\"></a>序列化反序列化二叉树。<a href=\"https://leetcode.com/problems/serialize-and-deserialize-binary-tree/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Codec</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">serialize</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">'$'</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (str(root.val) + <span class=\"string\">','</span> + self.serialize(root.left) + </span><br><span class=\"line\">                <span class=\"string\">','</span> + self.serialize(root.right))</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">deserialize</span><span class=\"params\">(self, data)</span>:</span></span><br><span class=\"line\">        nodes = data.split(<span class=\"string\">','</span>)[::<span class=\"number\">-1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.deserialize_tree(nodes)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">deserialize_tree</span><span class=\"params\">(self, nodes)</span>:</span></span><br><span class=\"line\">        val = nodes.pop()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> val == <span class=\"string\">'$'</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">        root = TreeNode(val)</span><br><span class=\"line\">        root.left = self.deserialize_tree(nodes)</span><br><span class=\"line\">        root.right = self.deserialize_tree(nodes)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root</span><br></pre></td></tr></table></figure>\n<h3 id=\"110-Balanced-Binary-Tree\"><a href=\"#110-Balanced-Binary-Tree\" class=\"headerlink\" title=\"110. Balanced Binary Tree\"></a>110. Balanced Binary Tree</h3><h4 id=\"判断是否是平衡二叉树。原题\"><a href=\"#判断是否是平衡二叉树。原题\" class=\"headerlink\" title=\"判断是否是平衡二叉树。原题\"></a>判断是否是平衡二叉树。<a href=\"https://leetcode.com/problems/balanced-binary-tree/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：递归+递归。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isBalanced</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.isBalanced(root.left) <span class=\"keyword\">and</span> self.isBalanced(root.right) <span class=\"keyword\">and</span> \\</span><br><span class=\"line\">           abs(self.max_depth(root.left)-self.max_depth(root.right)) &lt;= <span class=\"number\">1</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">max_depth</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(self.max_depth(root.left), self.max_depth(root.right)) + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>方法二：上诉两种方法中都包含了一些无意义的重复遍历。这里采用后序遍历，边遍历边判断，不会重复节点。受此思想启发，添加一种后序遍历二叉树的方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isBalanced</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">    stack, node = [], root</span><br><span class=\"line\">    last, depths = <span class=\"literal\">None</span>, collections.defaultdict(int)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> stack <span class=\"keyword\">or</span> node:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            stack.append(node)</span><br><span class=\"line\">            node = node.left</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            node = stack[<span class=\"number\">-1</span>]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node.right <span class=\"keyword\">or</span> last == node.right:</span><br><span class=\"line\">                node = stack.pop()</span><br><span class=\"line\">                left, right  = depths[node.left], depths[node.right]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> abs(left - right) &gt; <span class=\"number\">1</span>: </span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">                depths[node] = <span class=\"number\">1</span> + max(left, right)</span><br><span class=\"line\">                last, node = node, <span class=\"literal\">None</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                node = node.right</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：dfs. 算深度的时候判断左右是否深度超过1. 这里变量不能把self去掉，否则<code>[1,2,2,3,3,null,null,4,4]</code>会错误的返回<code>True</code>而不是<code>False</code>。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isBalanced</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class=\"line\">    self.balanced = <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> self.balanced:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        left = dfs(node.left)</span><br><span class=\"line\">        right = dfs(node.right)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> abs(left-right) &gt; <span class=\"number\">1</span>:</span><br><span class=\"line\">            self.balanced = <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(left, right) + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    dfs(root)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.balanced</span><br></pre></td></tr></table></figure>\n<h3 id=\"108-Convert-Sorted-Array-to-Binary-Search-Tree\"><a href=\"#108-Convert-Sorted-Array-to-Binary-Search-Tree\" class=\"headerlink\" title=\"108. Convert Sorted Array to Binary Search Tree\"></a>108. Convert Sorted Array to Binary Search Tree</h3><h4 id=\"将有序数组转换成二叉搜索树。原题\"><a href=\"#将有序数组转换成二叉搜索树。原题\" class=\"headerlink\" title=\"将有序数组转换成二叉搜索树。原题\"></a>将有序数组转换成二叉搜索树。<a href=\"https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Given the sorted array: [-10,-3,0,5,9],</span><br><span class=\"line\"></span><br><span class=\"line\">One possible answer is: [0,-3,9,-10,null,5],</span><br><span class=\"line\">      0</span><br><span class=\"line\">     &#x2F; \\</span><br><span class=\"line\">   -3   9</span><br><span class=\"line\">   &#x2F;   &#x2F;</span><br><span class=\"line\"> -10  5</span><br></pre></td></tr></table></figure>\n<p>方法一：答案不唯一，居然一次就通过了。递归的思想还是简单一些的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sortedArrayToBST</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> nums:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">    mid = len(nums) // <span class=\"number\">2</span></span><br><span class=\"line\">    root = TreeNode(nums[mid])</span><br><span class=\"line\">    root.left = self.sortedArrayToBST(nums[:mid])</span><br><span class=\"line\">    root.right = self.sortedArrayToBST(nums[mid+<span class=\"number\">1</span>:])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：不使用切片。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sortedArrayToBST</span><span class=\"params\">(self, nums: <span class=\"string\">'List[int]'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">convert</span><span class=\"params\">(lo, hi)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> lo &gt; hi:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">        mid = (lo+hi) // <span class=\"number\">2</span></span><br><span class=\"line\">        root = TreeNode(nums[mid])</span><br><span class=\"line\">        root.left = convert(lo, mid<span class=\"number\">-1</span>)</span><br><span class=\"line\">        root.right = convert(mid+<span class=\"number\">1</span>, hi)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> convert(<span class=\"number\">0</span>, len(nums)<span class=\"number\">-1</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree\"><a href=\"#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree\" class=\"headerlink\" title=\"235. Lowest Common Ancestor of a Binary Search Tree\"></a>235. Lowest Common Ancestor of a Binary Search Tree</h3><h4 id=\"寻找二叉搜索树的最小公共祖先。原题\"><a href=\"#寻找二叉搜索树的最小公共祖先。原题\" class=\"headerlink\" title=\"寻找二叉搜索树的最小公共祖先。原题\"></a>寻找二叉搜索树的最小公共祖先。<a href=\"https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree\" target=\"_blank\" rel=\"noopener\">原题</a></h4><font color=\"#32CD32\" size=\"3\">方法一：iteratively. </font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lowestCommonAncestor</span><span class=\"params\">(self, root, p, q)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (root.val-p.val) * (root.val-q.val) &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">        root = (root.left, root.right)[root.val &lt; p.val]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br></pre></td></tr></table></figure>\n<p>方法二：recursively.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lowestCommonAncestor</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>, p: <span class=\"string\">'TreeNode'</span>, q: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root.val-p.val) * (root.val-q.val) &lt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.lowestCommonAncestor(</span><br><span class=\"line\">        (root.left, root.right)[root.val &lt; p.val], p, q)</span><br></pre></td></tr></table></figure>\n<h3 id=\"404-Sum-of-Left-Leaves\"><a href=\"#404-Sum-of-Left-Leaves\" class=\"headerlink\" title=\"404. Sum of Left Leaves\"></a>404. Sum of Left Leaves</h3><h4 id=\"求一个二叉树所有左叶子节点的和。原题\"><a href=\"#求一个二叉树所有左叶子节点的和。原题\" class=\"headerlink\" title=\"求一个二叉树所有左叶子节点的和。原题\"></a>求一个二叉树所有左叶子节点的和。<a href=\"https://leetcode.com/problems/sum-of-left-leaves/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><font color=\"#32CD32\" size=\"3\">方法一：iteratively.这里使用了tuple记录是否为左叶子节点。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sumOfLeftLeaves</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    ans, stack = <span class=\"number\">0</span>, root <span class=\"keyword\">and</span> [(root, <span class=\"literal\">False</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> stack:</span><br><span class=\"line\">        n, isleft = stack.pop()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> n.left <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> n.right <span class=\"keyword\">and</span> isleft:</span><br><span class=\"line\">                ans += n.val</span><br><span class=\"line\">            stack.append((n.right, <span class=\"literal\">False</span>))</span><br><span class=\"line\">            stack.append((n.left, <span class=\"literal\">True</span>))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法二：recursively.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sumOfLeftLeaves</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root.left <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> root.left.left <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> root.left.right):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root.left.val + self.sumOfLeftLeaves(root.right)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (self.sumOfLeftLeaves(root.left) + </span><br><span class=\"line\">                self.sumOfLeftLeaves(root.right))</span><br></pre></td></tr></table></figure>\n<h3 id=\"938-Range-Sum-of-BST\"><a href=\"#938-Range-Sum-of-BST\" class=\"headerlink\" title=\"938. Range Sum of BST\"></a>938. Range Sum of BST</h3><h4 id=\"给两个节点的值，求二叉搜索树在这两个值之间的节点和。每个节点的值唯一。原题\"><a href=\"#给两个节点的值，求二叉搜索树在这两个值之间的节点和。每个节点的值唯一。原题\" class=\"headerlink\" title=\"给两个节点的值，求二叉搜索树在这两个值之间的节点和。每个节点的值唯一。原题\"></a>给两个节点的值，求二叉搜索树在这两个值之间的节点和。每个节点的值唯一。<a href=\"https://leetcode.com/contest/weekly-contest-110/problems/range-sum-of-bst/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: root &#x3D; [10,5,15,3,7,null,18], L &#x3D; 7, R &#x3D; 15</span><br><span class=\"line\">Output: 32</span><br><span class=\"line\">Input: root &#x3D; [10,5,15,3,7,13,18,1,null,6], L &#x3D; 6, R &#x3D; 10</span><br><span class=\"line\">Output: 23</span><br></pre></td></tr></table></figure>\n<img src=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AF%87%EF%BC%89Tree/range_sum.png\" class>\n<p>方法一：因为是竞赛题，所以没追求效率，所以这里先前序遍历了一下，再根据条件求和。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rangeSumBST</span><span class=\"params\">(self, root, L, R)</span>:</span></span><br><span class=\"line\">    traverse, stack = [], [root]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> stack:</span><br><span class=\"line\">        node = stack.pop()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            traverse.append(node.val)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.right:</span><br><span class=\"line\">                stack.append(node.right)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.left:</span><br><span class=\"line\">                stack.append(node.left)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum([x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> traverse <span class=\"keyword\">if</span> L &lt;= x &lt;= R])</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：利用二叉搜索树的特性。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rangeSumBST</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>, L: <span class=\"string\">'int'</span>, R: <span class=\"string\">'int'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    ans, stack = <span class=\"number\">0</span>, root <span class=\"keyword\">and</span> [root]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> stack:</span><br><span class=\"line\">        node = stack.pop()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.val &gt; L <span class=\"keyword\">and</span> node.left:</span><br><span class=\"line\">            stack.append(node.left)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.val &lt; R <span class=\"keyword\">and</span> node.right:</span><br><span class=\"line\">            stack.append(node.right)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> L &lt;= node.val &lt;= R:</span><br><span class=\"line\">            ans += node.val</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：递归。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rangeSumBST</span><span class=\"params\">(self, root: TreeNode, low: int, high: int)</span> -&gt; int:</span></span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> low &lt;= root.val &lt;= high:</span><br><span class=\"line\">            ans += root.val</span><br><span class=\"line\">            ans += self.rangeSumBST(root.left, low, high)</span><br><span class=\"line\">            ans += self.rangeSumBST(root.right, low, high)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> root.val &lt; low:</span><br><span class=\"line\">            ans += self.rangeSumBST(root.right, low, high)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            ans += self.rangeSumBST(root.left, low, high)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"530-Minimum-Absolute-Difference-in-BST\"><a href=\"#530-Minimum-Absolute-Difference-in-BST\" class=\"headerlink\" title=\"530. Minimum Absolute Difference in BST\"></a>530. Minimum Absolute Difference in BST</h3><h4 id=\"求二叉搜索树任意两个节点的最小差。原题\"><a href=\"#求二叉搜索树任意两个节点的最小差。原题\" class=\"headerlink\" title=\"求二叉搜索树任意两个节点的最小差。原题\"></a>求二叉搜索树任意两个节点的最小差。<a href=\"https://leetcode.com/problems/minimum-absolute-difference-in-bst/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\"></span><br><span class=\"line\">   1</span><br><span class=\"line\">    \\</span><br><span class=\"line\">     3</span><br><span class=\"line\">    &#x2F;</span><br><span class=\"line\">   2</span><br><span class=\"line\"></span><br><span class=\"line\">Output:</span><br><span class=\"line\">1</span><br><span class=\"line\"></span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getMinimumDifference</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inorder</span><span class=\"params\">(n)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> n:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        <span class=\"keyword\">return</span> inorder(n.left) + [n.val] + inorder(n.right)</span><br><span class=\"line\"></span><br><span class=\"line\">    nums = inorder(root)</span><br><span class=\"line\">    <span class=\"comment\"># return min(nums[i+1]-nums[i] for i in range(len(nums)-1))</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> min(b-a <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> zip(nums, nums[<span class=\"number\">1</span>:]))</span><br></pre></td></tr></table></figure>\n<h3 id=\"783-Minimum-Distance-Between-BST-Nodes\"><a href=\"#783-Minimum-Distance-Between-BST-Nodes\" class=\"headerlink\" title=\"783. Minimum Distance Between BST Nodes\"></a>783. Minimum Distance Between BST Nodes</h3><h4 id=\"二叉搜索树两个节点的最小值。和530是一道题。原题\"><a href=\"#二叉搜索树两个节点的最小值。和530是一道题。原题\" class=\"headerlink\" title=\"二叉搜索树两个节点的最小值。和530是一道题。原题\"></a>二叉搜索树两个节点的最小值。和530是一道题。<a href=\"https://leetcode.com/problems/minimum-distance-between-bst-nodes/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: root &#x3D; [4,2,6,1,3,null,null]</span><br><span class=\"line\">Output: 1</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">Note that root is a TreeNode object, not an array.</span><br><span class=\"line\"></span><br><span class=\"line\">The given tree [4,2,6,1,3,null,null] is represented by the following diagram:</span><br><span class=\"line\"></span><br><span class=\"line\">          4</span><br><span class=\"line\">        &#x2F;   \\</span><br><span class=\"line\">      2      6</span><br><span class=\"line\">     &#x2F; \\    </span><br><span class=\"line\">    1   3  </span><br><span class=\"line\"></span><br><span class=\"line\">while the minimum difference in this tree is 1, it occurs between node 1 and node 2, also between node 3 and node 2.</span><br></pre></td></tr></table></figure>\n<p>方法一：递归 + 生成器， 遍历了两次。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minDiffInBST</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inorder</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        <span class=\"keyword\">return</span> inorder(node.left) + [node.val] + inorder(node.right)</span><br><span class=\"line\">    </span><br><span class=\"line\">    t = inorder(root)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min(t[x]-t[x<span class=\"number\">-1</span>] <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(t)))</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：一次遍历，没有保存整个遍历数组，效率高。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minDiffInBST</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class=\"line\">    ans, last, stack = float(<span class=\"string\">'inf'</span>), float(<span class=\"string\">'-inf'</span>), []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> stack <span class=\"keyword\">or</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> root:</span><br><span class=\"line\">            stack.append(root)</span><br><span class=\"line\">            root = root.left</span><br><span class=\"line\">        root = stack.pop()</span><br><span class=\"line\">        ans, last = min(ans, root.val-last), root.val</span><br><span class=\"line\">        root = root.right</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：一次递归。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    pre = float(<span class=\"string\">'-inf'</span>)</span><br><span class=\"line\">    ans = float(<span class=\"string\">'inf'</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minDiffInBST</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root.left:</span><br><span class=\"line\">            self.minDiffInBST(root.left)</span><br><span class=\"line\">        self.ans = min(self.ans, root.val-self.pre)</span><br><span class=\"line\">        self.pre = root.val</span><br><span class=\"line\">        <span class=\"keyword\">if</span> root.right:</span><br><span class=\"line\">            self.minDiffInBST(root.right)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"538-Convert-BST-to-Greater-Tree\"><a href=\"#538-Convert-BST-to-Greater-Tree\" class=\"headerlink\" title=\"538. Convert BST to Greater Tree\"></a>538. Convert BST to Greater Tree</h3><h4 id=\"二叉搜索树转换。使得节点的值等于所有比它大的节点的和。原题\"><a href=\"#二叉搜索树转换。使得节点的值等于所有比它大的节点的和。原题\" class=\"headerlink\" title=\"二叉搜索树转换。使得节点的值等于所有比它大的节点的和。原题\"></a>二叉搜索树转换。使得节点的值等于所有比它大的节点的和。<a href=\"https://leetcode.com/problems/convert-bst-to-greater-tree/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: The root of a Binary Search Tree like this:</span><br><span class=\"line\">              5</span><br><span class=\"line\">            &#x2F;   \\</span><br><span class=\"line\">           2     13</span><br><span class=\"line\"></span><br><span class=\"line\">Output: The root of a Greater Tree like this:</span><br><span class=\"line\">             18</span><br><span class=\"line\">            &#x2F;   \\</span><br><span class=\"line\">          20     13</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法一：recursively。这里使用了一个变量来保存当前的累加和，然后递归中采用先右后左的方式。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">convertBST</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; TreeNode:</span>   </span><br><span class=\"line\">    self.val = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            dfs(node.right)</span><br><span class=\"line\">            self.val += node.val</span><br><span class=\"line\">            node.val = self.val</span><br><span class=\"line\">            dfs(node.left)</span><br><span class=\"line\"></span><br><span class=\"line\">    dfs(root)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：iteratively。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">convertBST</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; TreeNode:</span>   </span><br><span class=\"line\">    head = root</span><br><span class=\"line\">    stack, val = [], <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> stack <span class=\"keyword\">or</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> root:</span><br><span class=\"line\">            stack.append(root)</span><br><span class=\"line\">            root = root.right</span><br><span class=\"line\">        root = stack.pop()</span><br><span class=\"line\">        val += root.val</span><br><span class=\"line\">        root.val = val</span><br><span class=\"line\">        root = root.left</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：生成器写法。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">convertBST</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; TreeNode:</span>   </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> dfs(node.right)</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> node</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> dfs(node.left)</span><br><span class=\"line\">    val = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> node <span class=\"keyword\">in</span> dfs(root):</span><br><span class=\"line\">        val += node.val</span><br><span class=\"line\">        node.val = val</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br></pre></td></tr></table></figure>\n<h3 id=\"958-Check-Completeness-of-a-Binary-Tree\"><a href=\"#958-Check-Completeness-of-a-Binary-Tree\" class=\"headerlink\" title=\"958. Check Completeness of a Binary Tree\"></a>958. Check Completeness of a Binary Tree</h3><h4 id=\"判断二叉树是否是完整二叉树。完整二叉树为：除了最后一层所有节点不能为空，最后一层节点全部去靠左。原题\"><a href=\"#判断二叉树是否是完整二叉树。完整二叉树为：除了最后一层所有节点不能为空，最后一层节点全部去靠左。原题\" class=\"headerlink\" title=\"判断二叉树是否是完整二叉树。完整二叉树为：除了最后一层所有节点不能为空，最后一层节点全部去靠左。原题\"></a>判断二叉树是否是完整二叉树。完整二叉树为：除了最后一层所有节点不能为空，最后一层节点全部去靠左。<a href=\"https://leetcode.com/problems/check-completeness-of-a-binary-tree/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p><strong>Example 1:</strong></p>\n<p><strong><img src=\"https://assets.leetcode.com/uploads/2018/12/15/complete-binary-tree-1.png\" alt=\"img\"></strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [1,2,3,4,5,6]</span><br><span class=\"line\">Output: true</span><br><span class=\"line\">Explanation: Every level before the last is full (ie. levels with node-values &#123;1&#125; and &#123;2, 3&#125;), and all nodes in the last level (&#123;4, 5, 6&#125;) are as far left as possible.</span><br></pre></td></tr></table></figure>\n<p><strong>Example 2:</strong></p>\n<p><strong><img src=\"https://assets.leetcode.com/uploads/2018/12/15/complete-binary-tree-2.png\" alt=\"img\"></strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [1,2,3,4,5,null,7]</span><br><span class=\"line\">Output: false</span><br><span class=\"line\">Explanation: The node with value 7 isn&#39;t as far left as possible.</span><br></pre></td></tr></table></figure>\n<p>方法一：采用分层遍历的方式，判断每层的节点是否是2**level。最后一层采用切片的方式判断最左原则。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isCompleteTree</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        levels = [root]</span><br><span class=\"line\">        last_full = <span class=\"literal\">True</span></span><br><span class=\"line\">        level = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> levels:</span><br><span class=\"line\">            value_nodes = [n <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> levels <span class=\"keyword\">if</span> n]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> value_nodes != levels[:len(value_nodes)]:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                print(len(levels), <span class=\"number\">2</span>**level)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> len(levels) != <span class=\"number\">2</span>**level:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> last_full:</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">                    last_full = <span class=\"literal\">False</span></span><br><span class=\"line\">                </span><br><span class=\"line\">            levels = [kid <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> levels <span class=\"keyword\">if</span> n <span class=\"keyword\">for</span> kid <span class=\"keyword\">in</span> (n.left, n.right)]</span><br><span class=\"line\">            level += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：Lee神的写法，想明白一件事就是，遇见第一个None时，后面如果再有非None的值就不是玩整树了。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isCompleteTree</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\">    i, bfs = <span class=\"number\">0</span>, [root]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> bfs[i]:</span><br><span class=\"line\">        bfs.append(bfs[i].left)</span><br><span class=\"line\">        bfs.append(bfs[i].right)</span><br><span class=\"line\">        i += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">not</span> any(bfs[i:])</span><br></pre></td></tr></table></figure>\n<h3 id=\"543-Diameter-of-Binary-Tree\"><a href=\"#543-Diameter-of-Binary-Tree\" class=\"headerlink\" title=\"543. Diameter of Binary Tree\"></a>543. Diameter of Binary Tree</h3><h4 id=\"求二叉树的最大直径，即任意两节点的长度。原题\"><a href=\"#求二叉树的最大直径，即任意两节点的长度。原题\" class=\"headerlink\" title=\"求二叉树的最大直径，即任意两节点的长度。原题\"></a>求二叉树的最大直径，即任意两节点的长度。<a href=\"https://leetcode.com/problems/diameter-of-binary-tree/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">          1</span><br><span class=\"line\">         &#x2F; \\</span><br><span class=\"line\">        2   3</span><br><span class=\"line\">       &#x2F; \\     </span><br><span class=\"line\">      4   5    </span><br><span class=\"line\">Return **3**, which is the length of the path [4,2,1,3] or [5,2,1,3].</span><br></pre></td></tr></table></figure>\n<p>方法一： recursively, 使用一个实例变量计算了最大值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">diameterOfBinaryTree</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    self.diameter = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        left = dfs(node.left)</span><br><span class=\"line\">        right = dfs(node.right)</span><br><span class=\"line\">        self.diameter = max(self.diameter, left+right)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(left, right) + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    dfs(root)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.diameter</span><br></pre></td></tr></table></figure>\n<h3 id=\"965-Univalued-Binary-Tree\"><a href=\"#965-Univalued-Binary-Tree\" class=\"headerlink\" title=\"965. Univalued Binary Tree\"></a>965. Univalued Binary Tree</h3><h4 id=\"判断一个二叉树是否所有节点具有相同的值。原题\"><a href=\"#判断一个二叉树是否所有节点具有相同的值。原题\" class=\"headerlink\" title=\"判断一个二叉树是否所有节点具有相同的值。原题\"></a>判断一个二叉树是否所有节点具有相同的值。<a href=\"https://leetcode.com/problems/univalued-binary-tree/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><font color=\"#32CD32\" size=\"3\">方法一：recursively。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isUnivalTree</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">not</span> node <span class=\"keyword\">or</span> root.val==node.val <span class=\"keyword\">and</span> </span><br><span class=\"line\">                dfs(node.left) <span class=\"keyword\">and</span> dfs(node.right))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dfs(root)</span><br></pre></td></tr></table></figure>\n<p>方法二：iteratively.常规写法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isUnivalTree</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\">    r_val, stack = root.val, [root]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> stack:</span><br><span class=\"line\">        n = stack.pop()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> n.val != r_val:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">            stack.append(n.right)</span><br><span class=\"line\">            stack.append(n.left)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<p>方法二：前序遍历，生成器方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isUnivalTree</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bfs</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> node.val</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> bfs(node.left)</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> bfs(node.right)</span><br><span class=\"line\">            </span><br><span class=\"line\">    it = bfs(root)</span><br><span class=\"line\">    root_val = next(it)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> val <span class=\"keyword\">in</span> it:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> val != root_val:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"563-Binary-Tree-Tilt\"><a href=\"#563-Binary-Tree-Tilt\" class=\"headerlink\" title=\"563. Binary Tree Tilt\"></a>563. Binary Tree Tilt</h3><h4 id=\"返回一个二叉树整个树的倾斜度。所有节点倾斜度的总和。节点的倾斜度等于左子树和右子树所有和差的绝对值。原题\"><a href=\"#返回一个二叉树整个树的倾斜度。所有节点倾斜度的总和。节点的倾斜度等于左子树和右子树所有和差的绝对值。原题\" class=\"headerlink\" title=\"返回一个二叉树整个树的倾斜度。所有节点倾斜度的总和。节点的倾斜度等于左子树和右子树所有和差的绝对值。原题\"></a>返回一个二叉树整个树的倾斜度。所有节点倾斜度的总和。节点的倾斜度等于左子树和右子树所有和差的绝对值。<a href=\"https://leetcode.com/problems/binary-tree-tilt/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: </span><br><span class=\"line\">         1</span><br><span class=\"line\">       &#x2F;   \\</span><br><span class=\"line\">      2     3</span><br><span class=\"line\">Output: 1</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">Tilt of node 2 : 0</span><br><span class=\"line\">Tilt of node 3 : 0</span><br><span class=\"line\">Tilt of node 1 : |2-3| &#x3D; 1</span><br><span class=\"line\">Tilt of binary tree : 0 + 0 + 1 &#x3D; 1</span><br></pre></td></tr></table></figure>\n<p>方法一：recursively. 这里用tuple记录了节点总和和倾斜度总和。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findTilt</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">    self.res = <span class=\"number\">0</span></span><br><span class=\"line\">    _, top_res = self.sum_and_diff(root)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.res + top_res</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sum_and_diff</span><span class=\"params\">(self, node)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    l_sum, l_diff = self.sum_and_diff(node.left)</span><br><span class=\"line\">    r_sum, r_diff = self.sum_and_diff(node.right)</span><br><span class=\"line\">    self.res += l_diff + r_diff</span><br><span class=\"line\">    <span class=\"comment\"># print(node.val, node.val+l_sum+r_sum, abs(l_sum-r_sum))</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> node.val+l_sum+r_sum, abs(l_sum-r_sum)</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二: 想了一会后序遍历的迭代法，没想出来，貌似需要维护很多的变量。这里还是优化一下方法一。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findTilt</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">        l_sum, l_diff = dfs(node.left)</span><br><span class=\"line\">        r_sum, r_diff = dfs(node.right)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (node.val + l_sum + r_sum, </span><br><span class=\"line\">                abs(l_sum-r_sum) + l_diff + r_diff)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dfs(root)[<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"606-Construct-String-from-Binary-Tree\"><a href=\"#606-Construct-String-from-Binary-Tree\" class=\"headerlink\" title=\"606. Construct String from Binary Tree\"></a>606. Construct String from Binary Tree</h3><h4 id=\"根据二叉树重建字符串，使用-表示嵌套关系。原题\"><a href=\"#根据二叉树重建字符串，使用-表示嵌套关系。原题\" class=\"headerlink\" title=\"根据二叉树重建字符串，使用()表示嵌套关系。原题\"></a>根据二叉树重建字符串，使用<code>()</code>表示嵌套关系。<a href=\"https://leetcode.com/problems/construct-string-from-binary-tree/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: Binary tree: [1,2,3,4]</span><br><span class=\"line\">       1</span><br><span class=\"line\">     &#x2F;   \\</span><br><span class=\"line\">    2     3</span><br><span class=\"line\">   &#x2F;    </span><br><span class=\"line\">  4     </span><br><span class=\"line\">Output: &quot;1(2(4))(3)&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">Input: Binary tree: [1,2,3,null,4]</span><br><span class=\"line\">       1</span><br><span class=\"line\">     &#x2F;   \\</span><br><span class=\"line\">    2     3</span><br><span class=\"line\">     \\  </span><br><span class=\"line\">      4 </span><br><span class=\"line\">Output: &quot;1(2()(4))(3)&quot;</span><br></pre></td></tr></table></figure>\n<p>方法一：recursively. 左右节点有一点区别，在于如果左节点为空，右节点不为空，要保留左节点的括号。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">tree2str</span><span class=\"params\">(self, t)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> t: <span class=\"keyword\">return</span> <span class=\"string\">''</span></span><br><span class=\"line\">    left = <span class=\"string\">'(&#123;&#125;)'</span>.format(self.tree2str(t.left)) <span class=\"keyword\">if</span> (t.left <span class=\"keyword\">or</span> t.right) <span class=\"keyword\">else</span> <span class=\"string\">''</span></span><br><span class=\"line\">    right = <span class=\"string\">'(&#123;&#125;)'</span>.format(self.tree2str(t.right)) <span class=\"keyword\">if</span> t.right <span class=\"keyword\">else</span> <span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'&#123;&#125;&#123;&#125;&#123;&#125;'</span>.format(t.val, left, right)</span><br></pre></td></tr></table></figure>\n<h3 id=\"617-Merge-Two-Binary-Trees\"><a href=\"#617-Merge-Two-Binary-Trees\" class=\"headerlink\" title=\"617. Merge Two Binary Trees\"></a>617. Merge Two Binary Trees</h3><h4 id=\"合并两个二叉树，相同位置的节点值相加，空节点算0-原题\"><a href=\"#合并两个二叉树，相同位置的节点值相加，空节点算0-原题\" class=\"headerlink\" title=\"合并两个二叉树，相同位置的节点值相加，空节点算0.原题\"></a>合并两个二叉树，相同位置的节点值相加，空节点算0.<a href=\"https://leetcode.com/problems/merge-two-binary-trees/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><font color=\"#32CD32\" size=\"3\">方法一：recursively.</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergeTrees</span><span class=\"params\">(self, t1: TreeNode, t2: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> t1 <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> t2:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">    v1, v2 = t1.val <span class=\"keyword\">if</span> t1 <span class=\"keyword\">else</span> <span class=\"number\">0</span>, t2.val <span class=\"keyword\">if</span> t2 <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br><span class=\"line\">    root = TreeNode(v1+v2)</span><br><span class=\"line\">    root.left = self.mergeTrees(t1.left <span class=\"keyword\">if</span> t1 <span class=\"keyword\">else</span> <span class=\"literal\">None</span>, t2.left <span class=\"keyword\">if</span> t2 <span class=\"keyword\">else</span> <span class=\"literal\">None</span>)</span><br><span class=\"line\">    root.right = self.mergeTrees(t1.right <span class=\"keyword\">if</span> t1 <span class=\"keyword\">else</span> <span class=\"literal\">None</span>, t2.right <span class=\"keyword\">if</span> t2 <span class=\"keyword\">else</span> <span class=\"literal\">None</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br></pre></td></tr></table></figure>\n<p>方法二：iteratively.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergeTrees</span><span class=\"params\">(self, t1, t2)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> t1 <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> t2:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> []</span><br><span class=\"line\">    t = TreeNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">    stack = [(t, t1, t2)]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> stack:</span><br><span class=\"line\">        n, n1, n2 = stack.pop()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n1 <span class=\"keyword\">or</span> n2:</span><br><span class=\"line\">            n.val = (n1.val <span class=\"keyword\">if</span> n1 <span class=\"keyword\">else</span> <span class=\"number\">0</span>) + (n2.val <span class=\"keyword\">if</span> n2 <span class=\"keyword\">else</span> <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (n1 <span class=\"keyword\">and</span> n1.right) <span class=\"keyword\">or</span> (n2 <span class=\"keyword\">and</span> n2.right):</span><br><span class=\"line\">                n.right = TreeNode(<span class=\"literal\">None</span>)</span><br><span class=\"line\">                stack.append((n.right, n1.right <span class=\"keyword\">if</span> n1 <span class=\"keyword\">else</span> <span class=\"literal\">None</span>, n2.right <span class=\"keyword\">if</span> n2 <span class=\"keyword\">else</span> <span class=\"literal\">None</span>))</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (n1 <span class=\"keyword\">and</span> n1.left) <span class=\"keyword\">or</span> (n2 <span class=\"keyword\">and</span> n2.left):</span><br><span class=\"line\">                n.left = TreeNode(<span class=\"literal\">None</span>)</span><br><span class=\"line\">                stack.append((n.left, n1.left <span class=\"keyword\">if</span> n1 <span class=\"keyword\">else</span> <span class=\"literal\">None</span>, n2.left <span class=\"keyword\">if</span> n2 <span class=\"keyword\">else</span> <span class=\"literal\">None</span>))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t</span><br></pre></td></tr></table></figure>\n<h3 id=\"653-Two-Sum-IV-Input-is-a-BST\"><a href=\"#653-Two-Sum-IV-Input-is-a-BST\" class=\"headerlink\" title=\"653. Two Sum IV - Input is a BST\"></a>653. Two Sum IV - Input is a BST</h3><h4 id=\"判断二叉树中是否有两个节点相加为k。原题\"><a href=\"#判断二叉树中是否有两个节点相加为k。原题\" class=\"headerlink\" title=\"判断二叉树中是否有两个节点相加为k。原题\"></a>判断二叉树中是否有两个节点相加为k。<a href=\"https://leetcode.com/problems/two-sum-iv-input-is-a-bst/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: </span><br><span class=\"line\">    5</span><br><span class=\"line\">   &#x2F; \\</span><br><span class=\"line\">  3   6</span><br><span class=\"line\"> &#x2F; \\   \\</span><br><span class=\"line\">2   4   7</span><br><span class=\"line\"></span><br><span class=\"line\">Target &#x3D; 9</span><br><span class=\"line\"></span><br><span class=\"line\">Output: True</span><br></pre></td></tr></table></figure>\n<p>方法一：preorder + set.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findTarget</span><span class=\"params\">(self, root, k)</span>:</span></span><br><span class=\"line\">    seen, stack = set(), root <span class=\"keyword\">and</span> [root]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> stack:</span><br><span class=\"line\">        node = stack.pop()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> k-node.val <span class=\"keyword\">in</span> seen:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">            seen.add(node.val)</span><br><span class=\"line\">            stack.append(node.right)</span><br><span class=\"line\">            stack.append(node.left)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"669-Trim-a-Binary-Search-Tree\"><a href=\"#669-Trim-a-Binary-Search-Tree\" class=\"headerlink\" title=\"669. Trim a Binary Search Tree\"></a>669. Trim a Binary Search Tree</h3><h4 id=\"根据范围修剪二叉搜索树，注意是二叉搜索树，不是普通的二叉树。原题\"><a href=\"#根据范围修剪二叉搜索树，注意是二叉搜索树，不是普通的二叉树。原题\" class=\"headerlink\" title=\"根据范围修剪二叉搜索树，注意是二叉搜索树，不是普通的二叉树。原题\"></a>根据范围修剪二叉搜索树，注意是二叉搜索树，不是普通的二叉树。<a href=\"https://leetcode.com/problems/trim-a-binary-search-tree/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: </span><br><span class=\"line\">    1</span><br><span class=\"line\">   &#x2F; \\</span><br><span class=\"line\">  0   2</span><br><span class=\"line\"></span><br><span class=\"line\">  L &#x3D; 1</span><br><span class=\"line\">  R &#x3D; 2</span><br><span class=\"line\"></span><br><span class=\"line\">Output: </span><br><span class=\"line\">    1</span><br><span class=\"line\">      \\</span><br><span class=\"line\">       2</span><br></pre></td></tr></table></figure>\n<p>方法一：recursively. </p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">trimBST</span><span class=\"params\">(self, root, L, R)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">trim_node</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> node.val &gt; R:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> trim_node(node.left)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> node.val &lt; L:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> trim_node(node.right)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            node.left = trim_node(node.left)</span><br><span class=\"line\">            node.right = trim_node(node.right)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> node</span><br><span class=\"line\">    <span class=\"keyword\">return</span> trim_node(root)</span><br></pre></td></tr></table></figure>\n<h3 id=\"671-Second-Minimum-Node-In-a-Binary-Tree\"><a href=\"#671-Second-Minimum-Node-In-a-Binary-Tree\" class=\"headerlink\" title=\"671. Second Minimum Node In a Binary Tree\"></a>671. Second Minimum Node In a Binary Tree</h3><h4 id=\"找出二叉树中第二小的节点值。左右子节点同时存在或同时不存在，根节点小于等于任意子节点。原题\"><a href=\"#找出二叉树中第二小的节点值。左右子节点同时存在或同时不存在，根节点小于等于任意子节点。原题\" class=\"headerlink\" title=\"找出二叉树中第二小的节点值。左右子节点同时存在或同时不存在，根节点小于等于任意子节点。原题\"></a>找出二叉树中第二小的节点值。左右子节点同时存在或同时不存在，根节点小于等于任意子节点。<a href=\"https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: </span><br><span class=\"line\">    2</span><br><span class=\"line\">   &#x2F; \\</span><br><span class=\"line\">  2   5</span><br><span class=\"line\">     &#x2F; \\</span><br><span class=\"line\">    5   7</span><br><span class=\"line\"></span><br><span class=\"line\">Output: 5</span><br><span class=\"line\">Explanation: The smallest value is 2, the second smallest value is 5.</span><br></pre></td></tr></table></figure>\n<p>方法一：先放到set里. </p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findSecondMinimumValue</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    self.uniques = set()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            self.uniques.add(node.val)</span><br><span class=\"line\">            dfs(node.left)</span><br><span class=\"line\">            dfs(node.right)</span><br><span class=\"line\"></span><br><span class=\"line\">    dfs(root)</span><br><span class=\"line\">    min1, ans = root.val, float(<span class=\"string\">'inf'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> v <span class=\"keyword\">in</span> self.uniques:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> min1 &lt; v &lt; ans:</span><br><span class=\"line\">            ans = v</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans <span class=\"keyword\">if</span> ans &lt; float(<span class=\"string\">'inf'</span>) <span class=\"keyword\">else</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二： iteratively.  </font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findSecondMinimumValue</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">    min1 = root.val <span class=\"keyword\">if</span> root <span class=\"keyword\">else</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    res = float(<span class=\"string\">'inf'</span>)</span><br><span class=\"line\">    stack = root <span class=\"keyword\">and</span> [root]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> stack:</span><br><span class=\"line\">        node = stack.pop()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> min1 &lt; node.val &lt; res:</span><br><span class=\"line\">                res = node.val</span><br><span class=\"line\">            stack.extend([node.right, node.left])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res <span class=\"keyword\">if</span> res &lt; float(<span class=\"string\">'inf'</span>) <span class=\"keyword\">else</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<p>方法三：还没想出来，以上两种都没有利用到一些题中已知条件，我看Solution中给出的及一些Discuss中的答案也忽略了这个条件。想了想无论是哪个顺序遍历，或者深度广度优先，都没能很好的利用这个条件。</p>\n<h3 id=\"687-Longest-Univalue-Path\"><a href=\"#687-Longest-Univalue-Path\" class=\"headerlink\" title=\"687. Longest Univalue Path\"></a>687. Longest Univalue Path</h3><h4 id=\"相同节点最长路径，路径长度按照两个节点之间的边距，也就是节点数-1。原题\"><a href=\"#相同节点最长路径，路径长度按照两个节点之间的边距，也就是节点数-1。原题\" class=\"headerlink\" title=\"相同节点最长路径，路径长度按照两个节点之间的边距，也就是节点数-1。原题\"></a>相同节点最长路径，路径长度按照两个节点之间的边距，也就是节点数-1。<a href=\"https://leetcode.com/problems/longest-univalue-path/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">              5</span><br><span class=\"line\">             &#x2F; \\</span><br><span class=\"line\">            4   5</span><br><span class=\"line\">           &#x2F; \\   \\</span><br><span class=\"line\">          1   1   5</span><br><span class=\"line\">output: 2</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestUnivaluePath</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">    self.res = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">traverse</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        left_len, right_len = traverse(node.left), traverse(node.right)</span><br><span class=\"line\">        left = (left_len+<span class=\"number\">1</span>) <span class=\"keyword\">if</span> node.left <span class=\"keyword\">and</span> node.left.val==node.val <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br><span class=\"line\">        right = (right_len+<span class=\"number\">1</span>) <span class=\"keyword\">if</span> node.right <span class=\"keyword\">and</span> node.right.val==node.val <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br><span class=\"line\">        self.res = max(self.res, left + right)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(left, right)</span><br><span class=\"line\">    traverse(root)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.res</span><br></pre></td></tr></table></figure>\n<h3 id=\"700-Search-in-a-Binary-Search-Tree\"><a href=\"#700-Search-in-a-Binary-Search-Tree\" class=\"headerlink\" title=\"700. Search in a Binary Search Tree\"></a>700. Search in a Binary Search Tree</h3><h4 id=\"在二叉搜索树中搜索节点。原题\"><a href=\"#在二叉搜索树中搜索节点。原题\" class=\"headerlink\" title=\"在二叉搜索树中搜索节点。原题\"></a>在二叉搜索树中搜索节点。<a href=\"https://leetcode.com/problems/search-in-a-binary-search-tree/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Given the tree:</span><br><span class=\"line\">        4</span><br><span class=\"line\">       &#x2F; \\</span><br><span class=\"line\">      2   7</span><br><span class=\"line\">     &#x2F; \\</span><br><span class=\"line\">    1   3</span><br><span class=\"line\"></span><br><span class=\"line\">And the value to search: 2</span><br></pre></td></tr></table></figure>\n<p>方法一：recursively.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">searchBST</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>, val: <span class=\"string\">'int'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> val == root.val:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.searchBST(</span><br><span class=\"line\">            (root.left, root.right)[root.val &lt; val], val)</span><br></pre></td></tr></table></figure>\n<p>方法二：iteratively.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">searchBST</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>, val: <span class=\"string\">'int'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class=\"line\">    node = root</span><br><span class=\"line\">    <span class=\"keyword\">while</span> node <span class=\"keyword\">and</span> node.val != val:</span><br><span class=\"line\">        node = (node.left, node.right)[node.val &lt; val]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node</span><br></pre></td></tr></table></figure>\n<h3 id=\"872-Leaf-Similar-Trees\"><a href=\"#872-Leaf-Similar-Trees\" class=\"headerlink\" title=\"872. Leaf-Similar Trees\"></a>872. Leaf-Similar Trees</h3><h4 id=\"叶子相近的树，只从左到右遍历叶子节点的顺序相同的两棵树。原题\"><a href=\"#叶子相近的树，只从左到右遍历叶子节点的顺序相同的两棵树。原题\" class=\"headerlink\" title=\"叶子相近的树，只从左到右遍历叶子节点的顺序相同的两棵树。原题\"></a>叶子相近的树，只从左到右遍历叶子节点的顺序相同的两棵树。<a href=\"https://leetcode.com/problems/leaf-similar-trees/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：前序遍历+生成器。空间复杂度过高，beats 1%。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">leafSimilar</span><span class=\"params\">(self, root1: <span class=\"string\">'TreeNode'</span>, root2: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">leaves</span><span class=\"params\">(root)</span>:</span></span><br><span class=\"line\">        stack = root <span class=\"keyword\">and</span> [root]</span><br><span class=\"line\">        <span class=\"keyword\">while</span> stack:</span><br><span class=\"line\">            node = stack.pop()</span><br><span class=\"line\">            <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node.right <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> node.left:</span><br><span class=\"line\">                    <span class=\"keyword\">yield</span> node.val</span><br><span class=\"line\">                stack.append(node.right)</span><br><span class=\"line\">                stack.append(node.left)</span><br><span class=\"line\"></span><br><span class=\"line\">    leaves1 = leaves(root1)</span><br><span class=\"line\">    leaves2 = leaves(root2)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> all(</span><br><span class=\"line\">        a==b <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> itertools.zip_longest(leaves1, leaves2))</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：dfs. </font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">leafSimilar</span><span class=\"params\">(self, root1: <span class=\"string\">'TreeNode'</span>, root2: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node.left <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> node.right:</span><br><span class=\"line\">                <span class=\"keyword\">yield</span> node.val</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> dfs(node.left)</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> dfs(node.right)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> all(</span><br><span class=\"line\">        a==b <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> itertools.zip_longest(dfs(root1), dfs(root2)))</span><br></pre></td></tr></table></figure>\n<h3 id=\"897-Increasing-Order-Search-Tree\"><a href=\"#897-Increasing-Order-Search-Tree\" class=\"headerlink\" title=\"897. Increasing Order Search Tree\"></a>897. Increasing Order Search Tree</h3><h4 id=\"根据中序遍历建立一个只有右子树的二叉树。要求在原树上修改。原题\"><a href=\"#根据中序遍历建立一个只有右子树的二叉树。要求在原树上修改。原题\" class=\"headerlink\" title=\"根据中序遍历建立一个只有右子树的二叉树。要求在原树上修改。原题\"></a>根据中序遍历建立一个只有右子树的二叉树。要求在原树上修改。<a href=\"https://leetcode.com/problems/increasing-order-search-tree/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Example 1:</span><br><span class=\"line\">Input: [5,3,6,2,4,null,8,1,null,null,null,7,9]</span><br><span class=\"line\"></span><br><span class=\"line\">       5</span><br><span class=\"line\">      &#x2F; \\</span><br><span class=\"line\">    3    6</span><br><span class=\"line\">   &#x2F; \\    \\</span><br><span class=\"line\">  2   4    8</span><br><span class=\"line\"> &#x2F;        &#x2F; \\ </span><br><span class=\"line\">1        7   9</span><br><span class=\"line\"></span><br><span class=\"line\">Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]</span><br><span class=\"line\"></span><br><span class=\"line\"> 1</span><br><span class=\"line\">  \\</span><br><span class=\"line\">   2</span><br><span class=\"line\">    \\</span><br><span class=\"line\">     3</span><br><span class=\"line\">      \\</span><br><span class=\"line\">       4</span><br></pre></td></tr></table></figure>\n<p>方法一：iteratively.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">increasingBST</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class=\"line\">    ans = head = TreeNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">    stack = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> stack <span class=\"keyword\">or</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> root:</span><br><span class=\"line\">            stack.append(root)</span><br><span class=\"line\">            root = root.left</span><br><span class=\"line\">        root = stack.pop()</span><br><span class=\"line\">        head.right = TreeNode(root.val)</span><br><span class=\"line\">        root, head = root.right, head.right</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans.right</span><br></pre></td></tr></table></figure>\n<p>方法二：生成器。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">increasingBST</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inorder</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> inorder(node.left)</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> node.val</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> inorder(node.right)</span><br><span class=\"line\">            </span><br><span class=\"line\">    ans = head = TreeNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> v <span class=\"keyword\">in</span> inorder(root):</span><br><span class=\"line\">        head.right = TreeNode(v)</span><br><span class=\"line\">        head = head.right</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans.right</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：题中有个要求在原树上修改，所以以上两种方法其实不符合要求，这里使用递归实现。 此答案由lee大神提供，非常巧妙。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">increasingBST</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>, tail=None)</span> -&gt; 'TreeNode':</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root: <span class=\"keyword\">return</span> tail</span><br><span class=\"line\">    res = self.increasingBST(root.left, root)</span><br><span class=\"line\">    root.left = <span class=\"literal\">None</span></span><br><span class=\"line\">    root.right = self.increasingBST(root.right, tail)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"993-Cousins-in-Binary-Tree\"><a href=\"#993-Cousins-in-Binary-Tree\" class=\"headerlink\" title=\"993. Cousins in Binary Tree\"></a>993. Cousins in Binary Tree</h3><h4 id=\"表弟节点指两个节点在同一深度，并且父节点不同。判断两个节点是否是表弟节点。树中节点值唯一。原题\"><a href=\"#表弟节点指两个节点在同一深度，并且父节点不同。判断两个节点是否是表弟节点。树中节点值唯一。原题\" class=\"headerlink\" title=\"表弟节点指两个节点在同一深度，并且父节点不同。判断两个节点是否是表弟节点。树中节点值唯一。原题\"></a>表弟节点指两个节点在同一深度，并且父节点不同。判断两个节点是否是表弟节点。树中节点值唯一。<a href=\"https://leetcode.com/problems/cousins-in-binary-tree/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：用dict记录。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isCousins</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>, x: <span class=\"string\">'int'</span>, y: <span class=\"string\">'int'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\">    parent, depth = &#123;&#125;, &#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(node, par=None)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            parent[node.val] = par</span><br><span class=\"line\">            depth[node.val] = depth[par] + <span class=\"number\">1</span> <span class=\"keyword\">if</span> par <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br><span class=\"line\">            dfs(node.left, node.val)</span><br><span class=\"line\">            dfs(node.right, node.val)</span><br><span class=\"line\">            </span><br><span class=\"line\">    dfs(root)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> depth[x] == depth[y] <span class=\"keyword\">and</span> parent[x] != parent[y]</span><br></pre></td></tr></table></figure>\n<h3 id=\"230-Kth-Smallest-Element-in-a-BST\"><a href=\"#230-Kth-Smallest-Element-in-a-BST\" class=\"headerlink\" title=\"230. Kth Smallest Element in a BST\"></a>230. Kth Smallest Element in a BST</h3><h4 id=\"二叉搜索树的第K小节点值。原题\"><a href=\"#二叉搜索树的第K小节点值。原题\" class=\"headerlink\" title=\"二叉搜索树的第K小节点值。原题\"></a>二叉搜索树的第K小节点值。<a href=\"https://leetcode.com/problems/kth-smallest-element-in-a-bst/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: root &#x3D; [3,1,4,null,2], k &#x3D; 1</span><br><span class=\"line\">   3</span><br><span class=\"line\">  &#x2F; \\</span><br><span class=\"line\"> 1   4</span><br><span class=\"line\">  \\</span><br><span class=\"line\">   2</span><br><span class=\"line\">Output: 1</span><br></pre></td></tr></table></figure>\n<p>方法一：生成器前序遍历。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">kthSmallest</span><span class=\"params\">(self, root: TreeNode, k: int)</span> -&gt; int:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inorder</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> inorder(node.left)</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> node.val</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> inorder(node.right)</span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> inorder(root):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> k == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> n</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            k -= <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>方法二：迭代。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">kthSmallest</span><span class=\"params\">(self, root: TreeNode, k: int)</span> -&gt; int:</span></span><br><span class=\"line\">    stack = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> root <span class=\"keyword\">or</span> stack:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> root:</span><br><span class=\"line\">            stack.append(root)</span><br><span class=\"line\">            root = root.left</span><br><span class=\"line\">        root = stack.pop()</span><br><span class=\"line\">        k -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> k == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root.val</span><br><span class=\"line\">        root = root.right</span><br></pre></td></tr></table></figure>\n<h3 id=\"98-Validate-Binary-Search-Tree\"><a href=\"#98-Validate-Binary-Search-Tree\" class=\"headerlink\" title=\"98. Validate Binary Search Tree\"></a>98. Validate Binary Search Tree</h3><h4 id=\"验证一个树是否是二叉搜索树。原题\"><a href=\"#验证一个树是否是二叉搜索树。原题\" class=\"headerlink\" title=\"验证一个树是否是二叉搜索树。原题\"></a>验证一个树是否是二叉搜索树。<a href=\"https://leetcode.com/problems/validate-binary-search-tree/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">    5</span><br><span class=\"line\">   &#x2F; \\</span><br><span class=\"line\">  1   4</span><br><span class=\"line\">     &#x2F; \\</span><br><span class=\"line\">    3   6</span><br><span class=\"line\">Output: false</span><br><span class=\"line\">Explanation: The input is: [5,1,4,null,null,3,6]. The root node&#39;s value</span><br><span class=\"line\">             is 5 but its right child&#39;s value is 4.</span><br></pre></td></tr></table></figure>\n<p>方法一：中序遍历即可。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isValidBST</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class=\"line\">    stack, last = [], float(<span class=\"string\">'-inf'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> stack <span class=\"keyword\">or</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> root:</span><br><span class=\"line\">            stack.append(root)</span><br><span class=\"line\">            root = root.left</span><br><span class=\"line\">        root = stack.pop()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> root.val &lt;= last:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        last = root.val</span><br><span class=\"line\">        root = root.right</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<p>方法二：整个活。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isValidBST</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inorder</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> inorder(node.left)</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> node.val</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> inorder(node.right)</span><br><span class=\"line\"></span><br><span class=\"line\">    a, b = itertools.tee(inorder(root))</span><br><span class=\"line\">    next(b, <span class=\"literal\">None</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> all(c &lt; d <span class=\"keyword\">for</span> c, d <span class=\"keyword\">in</span> zip(a, b))</span><br></pre></td></tr></table></figure>\n<h3 id=\"109-Convert-Sorted-List-to-Binary-Search-Tree\"><a href=\"#109-Convert-Sorted-List-to-Binary-Search-Tree\" class=\"headerlink\" title=\"109. Convert Sorted List to Binary Search Tree\"></a>109. Convert Sorted List to Binary Search Tree</h3><h4 id=\"将有序链表转成平衡二叉搜索树。原题\"><a href=\"#将有序链表转成平衡二叉搜索树。原题\" class=\"headerlink\" title=\"将有序链表转成平衡二叉搜索树。原题\"></a>将有序链表转成平衡二叉搜索树。<a href=\"https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Given the sorted linked list: [-10,-3,0,5,9],</span><br><span class=\"line\"></span><br><span class=\"line\">One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:</span><br><span class=\"line\"></span><br><span class=\"line\">      0</span><br><span class=\"line\">     &#x2F; \\</span><br><span class=\"line\">   -3   9</span><br><span class=\"line\">   &#x2F;   &#x2F;</span><br><span class=\"line\"> -10  5</span><br></pre></td></tr></table></figure>\n<p>方法一：先遍历链表，再二分递归创建树。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sortedListToBST</span><span class=\"params\">(self, head: ListNode)</span> -&gt; TreeNode:</span></span><br><span class=\"line\">    inorder = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> head:</span><br><span class=\"line\">        inorder.append(head.val)</span><br><span class=\"line\">        head = head.next</span><br><span class=\"line\">    lo, hi = <span class=\"number\">0</span>, len(inorder)<span class=\"number\">-1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">build_tree</span><span class=\"params\">(lo, hi)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> lo &gt; hi:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">        mid = (lo + hi) // <span class=\"number\">2</span></span><br><span class=\"line\">        root = TreeNode(inorder[mid])</span><br><span class=\"line\">        root.left = build_tree(lo, mid<span class=\"number\">-1</span>)</span><br><span class=\"line\">        root.right = build_tree(mid+<span class=\"number\">1</span>, hi)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> build_tree(lo, hi)</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：这个方法很棒。先遍历一遍找到链表的长度；然后递归去构建树，共享一个<code>head</code>可变对象。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sortedListToBST</span><span class=\"params\">(self, head: ListNode)</span> -&gt; TreeNode:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">find_size</span><span class=\"params\">(head)</span>:</span></span><br><span class=\"line\">        h, count = head, <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> h:</span><br><span class=\"line\">            h = h.next</span><br><span class=\"line\">            count += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> count</span><br><span class=\"line\">    lo, hi = <span class=\"number\">0</span>, find_size(head)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">form_bst</span><span class=\"params\">(lo, hi)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">nonlocal</span> head</span><br><span class=\"line\">        <span class=\"keyword\">if</span> lo &gt; hi:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">        mid = (lo + hi) // <span class=\"number\">2</span></span><br><span class=\"line\">        left = form_bst(lo, mid<span class=\"number\">-1</span>)</span><br><span class=\"line\">        root = TreeNode(head.val)</span><br><span class=\"line\">        head = head.next</span><br><span class=\"line\">        root.left = left</span><br><span class=\"line\">        right = form_bst(mid+<span class=\"number\">1</span>, hi)</span><br><span class=\"line\">        root.right = right</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> form_bst(lo, hi<span class=\"number\">-1</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"1008-Construct-Binary-Search-Tree-from-Preorder-Traversal\"><a href=\"#1008-Construct-Binary-Search-Tree-from-Preorder-Traversal\" class=\"headerlink\" title=\"1008. Construct Binary Search Tree from Preorder Traversal\"></a>1008. Construct Binary Search Tree from Preorder Traversal</h3><h4 id=\"根据前序遍历重建二叉搜索树。原题\"><a href=\"#根据前序遍历重建二叉搜索树。原题\" class=\"headerlink\" title=\"根据前序遍历重建二叉搜索树。原题\"></a>根据前序遍历重建二叉搜索树。<a href=\"https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [8,5,1,7,10,12]</span><br><span class=\"line\">Output: [8,5,10,1,7,null,12]</span><br></pre></td></tr></table></figure>\n<p>方法一：recursively.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bstFromPreorder</span><span class=\"params\">(self, preorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> preorder: <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">    root = TreeNode(preorder[<span class=\"number\">0</span>])</span><br><span class=\"line\">    i = bisect.bisect(preorder, root.val)</span><br><span class=\"line\">    root.left = self.bstFromPreorder(preorder[<span class=\"number\">1</span>:i])</span><br><span class=\"line\">    root.right = self.bstFromPreorder(preorder[i:])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br></pre></td></tr></table></figure>\n<h3 id=\"236-Lowest-Common-Ancestor-of-a-Binary-Tree\"><a href=\"#236-Lowest-Common-Ancestor-of-a-Binary-Tree\" class=\"headerlink\" title=\"236. Lowest Common Ancestor of a Binary Tree\"></a>236. Lowest Common Ancestor of a Binary Tree</h3><h4 id=\"二叉树两个节点的最小公共祖先。原题\"><a href=\"#二叉树两个节点的最小公共祖先。原题\" class=\"headerlink\" title=\"二叉树两个节点的最小公共祖先。原题\"></a>二叉树两个节点的最小公共祖先。<a href=\"https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一: 递归，是用mid表示当前节点是否是其中的一个。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lowestCommonAncestor</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>, p: <span class=\"string\">'TreeNode'</span>, q: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class=\"line\">    self.ans = <span class=\"literal\">None</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        left = dfs(node.left)</span><br><span class=\"line\">        right = dfs(node.right)</span><br><span class=\"line\">        mid = node <span class=\"keyword\">in</span> (p, q)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> mid + left + right &gt;= <span class=\"number\">2</span>:</span><br><span class=\"line\">            self.ans = node</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mid <span class=\"keyword\">or</span> left <span class=\"keyword\">or</span> right</span><br><span class=\"line\">    dfs(root)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：递归，思想如果是两个节点中的一个，就返回这个节点。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lowestCommonAncestor</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>, p: <span class=\"string\">'TreeNode'</span>, q: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> root <span class=\"keyword\">in</span> (<span class=\"literal\">None</span>, p, q):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root</span><br><span class=\"line\">    left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class=\"line\">    right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root <span class=\"keyword\">if</span> left <span class=\"keyword\">and</span> right <span class=\"keyword\">else</span> left <span class=\"keyword\">or</span> right</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：参考了257的dfs解法。需要注意的是一定要加<code>list(path)</code>，否则由于可变对象的问题，会导致最后结果为<code>[]</code>。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lowestCommonAncestor</span><span class=\"params\">(self, root: <span class=\"string\">'TreeNode'</span>, p: <span class=\"string\">'TreeNode'</span>, q: <span class=\"string\">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(n, path)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n:</span><br><span class=\"line\">            path.append(n)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> n <span class=\"keyword\">in</span> (p, q):</span><br><span class=\"line\">                ans.append(list(path))   <span class=\"comment\"># must use list, or you will get []</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> len(ans) == <span class=\"number\">2</span>:\t\t <span class=\"comment\"># optimized</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> </span><br><span class=\"line\">            dfs(n.left, path)</span><br><span class=\"line\">            dfs(n.right, path)</span><br><span class=\"line\">            path.pop()</span><br><span class=\"line\">    dfs(root, [])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> next(a <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> list(zip(*ans))[::<span class=\"number\">-1</span>] <span class=\"keyword\">if</span> a==b)</span><br></pre></td></tr></table></figure>\n<h3 id=\"654-Maximum-Binary-Tree\"><a href=\"#654-Maximum-Binary-Tree\" class=\"headerlink\" title=\"654. Maximum Binary Tree\"></a>654. Maximum Binary Tree</h3><h4 id=\"根据数组建立一个树，要求根节点为数组最大的树。原题\"><a href=\"#根据数组建立一个树，要求根节点为数组最大的树。原题\" class=\"headerlink\" title=\"根据数组建立一个树，要求根节点为数组最大的树。原题\"></a>根据数组建立一个树，要求根节点为数组最大的树。<a href=\"https://leetcode.com/problems/maximum-binary-tree/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：此题秒，不过感觉还有更优解，查了一圈没找到。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">constructMaximumBinaryTree</span><span class=\"params\">(self, nums: List[int])</span> -&gt; TreeNode:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> nums:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">    v = max(nums)</span><br><span class=\"line\">    root = TreeNode(v)</span><br><span class=\"line\">    i = nums.index(v)</span><br><span class=\"line\">    root.left = self.constructMaximumBinaryTree(nums[:i])</span><br><span class=\"line\">    root.right = self.constructMaximumBinaryTree(nums[i+<span class=\"number\">1</span>:])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br></pre></td></tr></table></figure>\n<h3 id=\"513-Find-Bottom-Left-Tree-Value\"><a href=\"#513-Find-Bottom-Left-Tree-Value\" class=\"headerlink\" title=\"513. Find Bottom Left Tree Value\"></a>513. Find Bottom Left Tree Value</h3><h4 id=\"寻找二叉树最底层的最左节点。原题\"><a href=\"#寻找二叉树最底层的最左节点。原题\" class=\"headerlink\" title=\"寻找二叉树最底层的最左节点。原题\"></a>寻找二叉树最底层的最左节点。<a href=\"https://leetcode.com/problems/find-bottom-left-tree-value/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：根据分层遍历改编。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findBottomLeftValue</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class=\"line\">    ans, levels = <span class=\"literal\">None</span>, root <span class=\"keyword\">and</span> [root]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> levels:</span><br><span class=\"line\">        ans = levels[<span class=\"number\">0</span>].val</span><br><span class=\"line\">        levels = [k <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> levels <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> (n.left, n.right) <span class=\"keyword\">if</span> k]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法二：双端队列，BFS.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findBottomLeftValue</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class=\"line\">    q = collections.deque([root])</span><br><span class=\"line\">    <span class=\"keyword\">while</span> q:</span><br><span class=\"line\">        node = q.pop()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.right:</span><br><span class=\"line\">            q.appendleft(node.right)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.left:</span><br><span class=\"line\">            q.appendleft(node.left)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node.val</span><br></pre></td></tr></table></figure>\n<p>方法三：循环时改变迭代对象，这种方式个人觉得不好。不过好在是在遍历之前添加到末端。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findBottomLeftValue</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class=\"line\">    queue = [root]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> node <span class=\"keyword\">in</span> queue:</span><br><span class=\"line\">        queue += (x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> (node.right, node.left) <span class=\"keyword\">if</span> x)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node.val</span><br></pre></td></tr></table></figure>\n<h3 id=\"814-Binary-Tree-Pruning\"><a href=\"#814-Binary-Tree-Pruning\" class=\"headerlink\" title=\"814. Binary Tree Pruning\"></a>814. Binary Tree Pruning</h3><h4 id=\"剪掉树中不包含1的子树。原题\"><a href=\"#剪掉树中不包含1的子树。原题\" class=\"headerlink\" title=\"剪掉树中不包含1的子树。原题\"></a>剪掉树中不包含1的子树。<a href=\"https://leetcode.com/problems/binary-tree-pruning/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：递归。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pruneTree</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        left = dfs(node.left)</span><br><span class=\"line\">        right = dfs(node.right)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> left:</span><br><span class=\"line\">            node.left = <span class=\"literal\">None</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> right:</span><br><span class=\"line\">            node.right = <span class=\"literal\">None</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> node.val==<span class=\"number\">0</span> <span class=\"keyword\">and</span> left <span class=\"keyword\">and</span> right</span><br><span class=\"line\">    dfs(root)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br></pre></td></tr></table></figure>\n<h3 id=\"199-Binary-Tree-Right-Side-View\"><a href=\"#199-Binary-Tree-Right-Side-View\" class=\"headerlink\" title=\"199. Binary Tree Right Side View\"></a>199. Binary Tree Right Side View</h3><h4 id=\"二叉树从右向左看时，从上到下的节点。原题\"><a href=\"#二叉树从右向左看时，从上到下的节点。原题\" class=\"headerlink\" title=\"二叉树从右向左看时，从上到下的节点。原题\"></a>二叉树从右向左看时，从上到下的节点。<a href=\"https://leetcode.com/problems/binary-tree-right-side-view/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：和分层遍历思想相同。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rightSideView</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class=\"line\">    ans, levels = [], root <span class=\"keyword\">and</span> [root]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> levels:</span><br><span class=\"line\">        ans.append(levels[<span class=\"number\">-1</span>].val)</span><br><span class=\"line\">        levels = [k <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> levels <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> (n.left, n.right) <span class=\"keyword\">if</span> k]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法二：dfs.  从右到左深度遍历，用一个深度变量控制是否是第一个最右节点。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rightSideView</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(n, depth)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> depth == len(ans):</span><br><span class=\"line\">                ans.append(n.val)</span><br><span class=\"line\">            dfs(n.right, depth+<span class=\"number\">1</span>)</span><br><span class=\"line\">            dfs(n.left, depth+<span class=\"number\">1</span>)</span><br><span class=\"line\">    dfs(root, <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"662-Maximum-Width-of-Binary-Tree\"><a href=\"#662-Maximum-Width-of-Binary-Tree\" class=\"headerlink\" title=\"662. Maximum Width of Binary Tree\"></a>662. Maximum Width of Binary Tree</h3><h4 id=\"二叉树的最大宽度。原题\"><a href=\"#二叉树的最大宽度。原题\" class=\"headerlink\" title=\"二叉树的最大宽度。原题\"></a>二叉树的最大宽度。<a href=\"https://leetcode.com/problems/maximum-width-of-binary-tree/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：常规队列写法。需要注意的是，每层遍历要用最右边的减去最左边的才是宽度。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">widthOfBinaryTree</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class=\"line\">    queue = [(root, <span class=\"number\">0</span>, <span class=\"number\">0</span>)]</span><br><span class=\"line\">    ans = cur_depth = left = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> node, depth, pos <span class=\"keyword\">in</span> queue:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            queue.append((node.left, depth+<span class=\"number\">1</span>, pos*<span class=\"number\">2</span>))</span><br><span class=\"line\">            queue.append((node.right, depth+<span class=\"number\">1</span>, pos*<span class=\"number\">2</span>+<span class=\"number\">1</span>))</span><br><span class=\"line\">            <span class=\"keyword\">if</span> cur_depth != depth:</span><br><span class=\"line\">                cur_depth = depth</span><br><span class=\"line\">                left = pos</span><br><span class=\"line\">            ans = max(pos-left+<span class=\"number\">1</span>, ans)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：按照分层顺序将所有节点编号，从1开始，<code>enumerate其实就是计算2*pos, 2*pos+1</code>。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">widthOfBinaryTree</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class=\"line\">    levels = [(<span class=\"number\">1</span>, root)]</span><br><span class=\"line\">    width = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> levels:</span><br><span class=\"line\">        width = max(levels[<span class=\"number\">-1</span>][<span class=\"number\">0</span>] - levels[<span class=\"number\">0</span>][<span class=\"number\">0</span>] + <span class=\"number\">1</span>, width)</span><br><span class=\"line\">        levels = [k</span><br><span class=\"line\">                  <span class=\"keyword\">for</span> pos, n <span class=\"keyword\">in</span> levels</span><br><span class=\"line\">                  <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> enumerate((n.left, n.right), <span class=\"number\">2</span> * pos)</span><br><span class=\"line\">                  <span class=\"keyword\">if</span> k[<span class=\"number\">1</span>]]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> width</span><br></pre></td></tr></table></figure>\n<h3 id=\"222-Count-Complete-Tree-Nodes\"><a href=\"#222-Count-Complete-Tree-Nodes\" class=\"headerlink\" title=\"222. Count Complete Tree Nodes\"></a>222. Count Complete Tree Nodes</h3><h4 id=\"统计完整树的节点个数。原题\"><a href=\"#统计完整树的节点个数。原题\" class=\"headerlink\" title=\"统计完整树的节点个数。原题\"></a>统计完整树的节点个数。<a href=\"https://leetcode.com/problems/count-complete-tree-nodes/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：二分法。比较左子树的深度和右子树的深度，如果相同则表明左子树为满树，右子树为完整树。如果不同则表明左子树为完整树，右子树为满树。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countNodes</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    left, right = self.depth(root.left), self.depth(root.right)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> left == right:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">2</span> ** left + self.countNodes(root.right)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">2</span> ** right + self.countNodes(root.left)</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">depth</span><span class=\"params\">(self, node)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span> + self.depth(node.left)</span><br></pre></td></tr></table></figure>\n<h3 id=\"1022-Sum-of-Root-To-Leaf-Binary-Numbers\"><a href=\"#1022-Sum-of-Root-To-Leaf-Binary-Numbers\" class=\"headerlink\" title=\"1022. Sum of Root To Leaf Binary Numbers\"></a>1022. Sum of Root To Leaf Binary Numbers</h3><h4 id=\"计算所有根到叶子节点路径二进制数表示的的和。原题\"><a href=\"#计算所有根到叶子节点路径二进制数表示的的和。原题\" class=\"headerlink\" title=\"计算所有根到叶子节点路径二进制数表示的的和。原题\"></a>计算所有根到叶子节点路径二进制数表示的的和。<a href=\"https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [1,0,1,0,1,0,1]</span><br><span class=\"line\">Output: 22</span><br><span class=\"line\">Explanation: (100) + (101) + (110) + (111) &#x3D; 4 + 5 + 6 + 7 &#x3D; 22</span><br></pre></td></tr></table></figure>\n<p>思路和 257.Binary Tree Paths一样。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sumRootToLeaf</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class=\"line\">    self.ans = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(n, path)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n:</span><br><span class=\"line\">            path.append(str(n.val))</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> n.left <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> n.right:</span><br><span class=\"line\">                self.ans += int(<span class=\"string\">''</span>.join(path), <span class=\"number\">2</span>)</span><br><span class=\"line\">            dfs(n.left, path)</span><br><span class=\"line\">            dfs(n.right, path)</span><br><span class=\"line\">            path.pop()</span><br><span class=\"line\">            </span><br><span class=\"line\">    dfs(root, [])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.ans % (<span class=\"number\">10</span>**<span class=\"number\">9</span> + <span class=\"number\">7</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"1026-Maximum-Difference-Between-Node-and-Ancestor\"><a href=\"#1026-Maximum-Difference-Between-Node-and-Ancestor\" class=\"headerlink\" title=\"1026. Maximum Difference Between Node and Ancestor\"></a>1026. Maximum Difference Between Node and Ancestor</h3><h4 id=\"祖先和其子节点的最大差绝对值。原题\"><a href=\"#祖先和其子节点的最大差绝对值。原题\" class=\"headerlink\" title=\"祖先和其子节点的最大差绝对值。原题\"></a>祖先和其子节点的最大差绝对值。<a href=\"https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：周赛时写的dfs.  380ms. 瓶颈在于每次都求一次最大值和最小值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxAncestorDiff</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class=\"line\">    self.ans = float(<span class=\"string\">'-inf'</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(n, p)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> p:</span><br><span class=\"line\">                max_diff = max(abs(max(p)-n.val), abs(min(p)-n.val))</span><br><span class=\"line\">                self.ans = max(self.ans, max_diff)</span><br><span class=\"line\">            p.append(n.val)</span><br><span class=\"line\">            dfs(n.left, p)</span><br><span class=\"line\">            dfs(n.right, p)</span><br><span class=\"line\">            p.pop()</span><br><span class=\"line\">    </span><br><span class=\"line\">    dfs(root, [])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：改良了一下，使用p记录一个当前的最大值和最小值。52ms.</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxAncestorDiff</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class=\"line\">    self.ans = float(<span class=\"string\">'-inf'</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(n, p)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> p:</span><br><span class=\"line\">                mx, mn = p[<span class=\"number\">-1</span>]</span><br><span class=\"line\">                self.ans = max(self.ans, max(mx-n.val, n.val-mn))</span><br><span class=\"line\">                p.append((max(mx, n.val), min(mn, n.val)))</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                p.append((n.val, n.val))</span><br><span class=\"line\">            dfs(n.left, p)</span><br><span class=\"line\">            dfs(n.right, p)</span><br><span class=\"line\">            p.pop() </span><br><span class=\"line\">    dfs(root, [])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"1038-Binary-Search-Tree-to-Greater-Sum-Tree\"><a href=\"#1038-Binary-Search-Tree-to-Greater-Sum-Tree\" class=\"headerlink\" title=\"1038. Binary Search Tree to Greater Sum Tree\"></a>1038. Binary Search Tree to Greater Sum Tree</h3><h4 id=\"二叉搜索树转成一颗规则的树，从右根左的顺序累加节点值。原题\"><a href=\"#二叉搜索树转成一颗规则的树，从右根左的顺序累加节点值。原题\" class=\"headerlink\" title=\"二叉搜索树转成一颗规则的树，从右根左的顺序累加节点值。原题\"></a>二叉搜索树转成一颗规则的树，从右根左的顺序累加节点值。<a href=\"https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：使用栈。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bstToGst</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class=\"line\">    head = root</span><br><span class=\"line\">    stack, total = [], <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> stack <span class=\"keyword\">or</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> root:</span><br><span class=\"line\">            stack.append(root)</span><br><span class=\"line\">            root = root.right</span><br><span class=\"line\">        root = stack.pop()</span><br><span class=\"line\">        total += root.val</span><br><span class=\"line\">        root.val = total</span><br><span class=\"line\">        root = root.left</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head</span><br></pre></td></tr></table></figure>\n<p>方法二：Lee神的递归方式。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    val = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bstToGst</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root.right: self.bstToGst(root.right)</span><br><span class=\"line\">        root.val = self.val = self.val + root.val</span><br><span class=\"line\">        <span class=\"keyword\">if</span> root.left: self.bstToGst(root.left)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root</span><br></pre></td></tr></table></figure>\n<h3 id=\"1080-Insufficient-Nodes-in-Root-to-Leaf-Paths\"><a href=\"#1080-Insufficient-Nodes-in-Root-to-Leaf-Paths\" class=\"headerlink\" title=\"1080. Insufficient Nodes in Root to Leaf Paths\"></a>1080. Insufficient Nodes in Root to Leaf Paths</h3><h4 id=\"计算所有的根到叶子节点的路径，如果路径和小于给定值，则剪掉这个树枝。原题\"><a href=\"#计算所有的根到叶子节点的路径，如果路径和小于给定值，则剪掉这个树枝。原题\" class=\"headerlink\" title=\"计算所有的根到叶子节点的路径，如果路径和小于给定值，则剪掉这个树枝。原题\"></a>计算所有的根到叶子节点的路径，如果路径和小于给定值，则剪掉这个树枝。<a href=\"https://leetcode.com/problems/insufficient-nodes-in-root-to-leaf-paths/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：递归。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sufficientSubset</span><span class=\"params\">(self, root: TreeNode, limit: int)</span> -&gt; TreeNode:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root.left <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> root.right:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root <span class=\"keyword\">if</span> root.val &gt;= limit <span class=\"keyword\">else</span> <span class=\"literal\">None</span></span><br><span class=\"line\">    root.left = self.sufficientSubset(root.left, limit-root.val)</span><br><span class=\"line\">    root.right = self.sufficientSubset(root.right, limit-root.val)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root <span class=\"keyword\">if</span> root.left <span class=\"keyword\">or</span> root.right <span class=\"keyword\">else</span> <span class=\"literal\">None</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1161-Maximum-Level-Sum-of-a-Binary-Tree\"><a href=\"#1161-Maximum-Level-Sum-of-a-Binary-Tree\" class=\"headerlink\" title=\"1161. Maximum Level Sum of a Binary Tree\"></a>1161. Maximum Level Sum of a Binary Tree</h3><h4 id=\"求最节点和最大层的层数。原题\"><a href=\"#求最节点和最大层的层数。原题\" class=\"headerlink\" title=\"求最节点和最大层的层数。原题\"></a>求最节点和最大层的层数。<a href=\"https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：分层遍历</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxLevelSum</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class=\"line\">    lvsum = []</span><br><span class=\"line\">    level = [root]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> level:</span><br><span class=\"line\">        lvsum.append(sum(n.val <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> level))</span><br><span class=\"line\">        level = [k <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> level <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> (n.left, n.right) <span class=\"keyword\">if</span> k]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lvsum.index(max(lvsum)) + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1104-Path-In-Zigzag-Labelled-Binary-Tree\"><a href=\"#1104-Path-In-Zigzag-Labelled-Binary-Tree\" class=\"headerlink\" title=\"1104. Path In Zigzag Labelled Binary Tree\"></a>1104. Path In Zigzag Labelled Binary Tree</h3><h4 id=\"之字形树的目标节点路径。原题\"><a href=\"#之字形树的目标节点路径。原题\" class=\"headerlink\" title=\"之字形树的目标节点路径。原题\"></a>之字形树的目标节点路径。<a href=\"https://leetcode.com/problems/path-in-zigzag-labelled-binary-tree/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：迭代，此题纯粹是数学题，这里先假设非之字形的树，找到规律，然后知道每层的节点数再相减。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pathInZigZagTree</span><span class=\"params\">(self, label: int)</span> -&gt; List[int]:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    n = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"number\">2</span> ** n &lt;= label:</span><br><span class=\"line\">        n += <span class=\"number\">1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span> n &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> label &gt;= <span class=\"number\">1</span>:</span><br><span class=\"line\">        ans.append(label)</span><br><span class=\"line\">        org_lable = label // <span class=\"number\">2</span></span><br><span class=\"line\">        label = <span class=\"number\">2</span>**(n<span class=\"number\">-1</span>)<span class=\"number\">-1</span>-org_lable+<span class=\"number\">2</span>**(n<span class=\"number\">-2</span>)</span><br><span class=\"line\">        n -= <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans[::<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<p>方法二：Lee神的递归。原理一样，层数n是通过查2的幂求的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pathInZigZagTree</span><span class=\"params\">(self, x)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.pathInZigZagTree(<span class=\"number\">3</span> * <span class=\"number\">2</span> ** (len(bin(x)) - <span class=\"number\">4</span>) - <span class=\"number\">1</span> - x / <span class=\"number\">2</span>) + [x] <span class=\"keyword\">if</span> x &gt; <span class=\"number\">1</span> <span class=\"keyword\">else</span> [<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"1110-Delete-Nodes-And-Return-Forest\"><a href=\"#1110-Delete-Nodes-And-Return-Forest\" class=\"headerlink\" title=\"1110. Delete Nodes And Return Forest\"></a>1110. Delete Nodes And Return Forest</h3><h4 id=\"给定一个树，删除指定的一些节点，然后删除的节点的左右子树成为单独的根节点。返回所有的树。原题\"><a href=\"#给定一个树，删除指定的一些节点，然后删除的节点的左右子树成为单独的根节点。返回所有的树。原题\" class=\"headerlink\" title=\"给定一个树，删除指定的一些节点，然后删除的节点的左右子树成为单独的根节点。返回所有的树。原题\"></a>给定一个树，删除指定的一些节点，然后删除的节点的左右子树成为单独的根节点。返回所有的树。<a href=\"https://leetcode.com/problems/delete-nodes-and-return-forest/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: root &#x3D; [1,2,3,4,5,6,7], to_delete &#x3D; [3,5]</span><br><span class=\"line\">Output: [[1,2,null,4],[6],[7]]</span><br></pre></td></tr></table></figure>\n<p>方法一：递归。做着题的时候有个误区：在当前节点被删除后，找到其在父节点对应的位置，然后置为空。实际上应该讲根节点删除的状态保留，在下一层处理。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">delNodes</span><span class=\"params\">(self, root: TreeNode, to_delete: List[int])</span> -&gt; List[TreeNode]:</span></span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    to_del = set(to_delete)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">helper</span><span class=\"params\">(root, is_root)</span>:</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">        is_del = root.val <span class=\"keyword\">in</span> to_del</span><br><span class=\"line\">        root.left = helper(root.left, is_del)</span><br><span class=\"line\">        root.right = helper(root.right, is_del)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> is_del <span class=\"keyword\">and</span> is_root:</span><br><span class=\"line\">            ans.append(root)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span> <span class=\"keyword\">if</span> is_del <span class=\"keyword\">else</span> root</span><br><span class=\"line\">    </span><br><span class=\"line\">    helper(root, <span class=\"literal\">True</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"1123-Lowest-Common-Ancestor-of-Deepest-Leaves\"><a href=\"#1123-Lowest-Common-Ancestor-of-Deepest-Leaves\" class=\"headerlink\" title=\"1123. Lowest Common Ancestor of Deepest Leaves\"></a>1123. Lowest Common Ancestor of Deepest Leaves</h3><h4 id=\"最深的叶子节点的最小公共祖先。原题\"><a href=\"#最深的叶子节点的最小公共祖先。原题\" class=\"headerlink\" title=\"最深的叶子节点的最小公共祖先。原题\"></a>最深的叶子节点的最小公共祖先。<a href=\"https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: root &#x3D; [1,2,3]</span><br><span class=\"line\">Output: [1,2,3]</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">The deepest leaves are the nodes with values 2 and 3.</span><br><span class=\"line\">The lowest common ancestor of these leaves is the node with value 1.</span><br><span class=\"line\">The answer returned is a TreeNode object (not an array) with serialization &quot;[1,2,3]&quot;.</span><br></pre></td></tr></table></figure>\n<p>方法一：Lee神的方法比我的好太多，我借鉴了之前的dfs的方式遍历所有的path，然后再清洗比较。其实直接递归即可。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lcaDeepestLeaves</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">helper</span><span class=\"params\">(root)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>, <span class=\"literal\">None</span></span><br><span class=\"line\">        d1, n1 = helper(root.left)</span><br><span class=\"line\">        d2, n2 = helper(root.right)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> d1 &lt; d2:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> d2 + <span class=\"number\">1</span>, n2</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> d1 &gt; d2:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> d1 + <span class=\"number\">1</span>, n1</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> d1 + <span class=\"number\">1</span>, root</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> helper(root)[<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"1382-Balance-a-Binary-Search-Tree\"><a href=\"#1382-Balance-a-Binary-Search-Tree\" class=\"headerlink\" title=\"1382. Balance a Binary Search Tree\"></a>1382. Balance a Binary Search Tree</h3><h4 id=\"将一个二叉搜索树转为平衡二叉搜索树。原题\"><a href=\"#将一个二叉搜索树转为平衡二叉搜索树。原题\" class=\"headerlink\" title=\"将一个二叉搜索树转为平衡二叉搜索树。原题\"></a>将一个二叉搜索树转为平衡二叉搜索树。<a href=\"https://leetcode.com/problems/balance-a-binary-search-tree/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：想到二叉搜索树首先想到中序遍历，所以一共分为2步，一步是遍历出所有节点，再根据节点重建一个平衡的二叉搜索树。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">balanceBST</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">                <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> dfs(node.left)</span><br><span class=\"line\">                <span class=\"keyword\">yield</span> node.val</span><br><span class=\"line\">                <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> dfs(node.right)</span><br><span class=\"line\">        </span><br><span class=\"line\">        inorder = list(dfs(root))</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">build</span><span class=\"params\">(inorder)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> inorder:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">            n = len(inorder)</span><br><span class=\"line\">            index = n // <span class=\"number\">2</span></span><br><span class=\"line\">            root = TreeNode(inorder[index])</span><br><span class=\"line\">            root.left = build(inorder[:index])</span><br><span class=\"line\">            root.right = build(inorder[index+<span class=\"number\">1</span>:])</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> build(inorder)</span><br></pre></td></tr></table></figure>\n<h3 id=\"1372-Longest-ZigZag-Path-in-a-Binary-Tree\"><a href=\"#1372-Longest-ZigZag-Path-in-a-Binary-Tree\" class=\"headerlink\" title=\"1372. Longest ZigZag Path in a Binary Tree\"></a>1372. Longest ZigZag Path in a Binary Tree</h3><h4 id=\"二叉树中最长的z字形路径。原题\"><a href=\"#二叉树中最长的z字形路径。原题\" class=\"headerlink\" title=\"二叉树中最长的z字形路径。原题\"></a>二叉树中最长的z字形路径。<a href=\"https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：用了不少变量来控制走位。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestZigZag</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class=\"line\">    self.ans = <span class=\"number\">0</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(node, left, right, last_left=True)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            self.ans = max(self.ans, left, right)</span><br><span class=\"line\">            <span class=\"comment\"># if last_left:</span></span><br><span class=\"line\">            <span class=\"comment\">#     dfs(node.right, 0, left+1, False)</span></span><br><span class=\"line\">            <span class=\"comment\">#     dfs(node.left, 1, 0, True)</span></span><br><span class=\"line\">            <span class=\"comment\"># else:</span></span><br><span class=\"line\">            <span class=\"comment\">#     dfs(node.right, 0, 1, False)</span></span><br><span class=\"line\">            <span class=\"comment\">#     dfs(node.left, right+1, 0, True)</span></span><br><span class=\"line\">            dfs(node.right, <span class=\"number\">0</span>, last_left*left+<span class=\"number\">1</span>, <span class=\"literal\">False</span>)</span><br><span class=\"line\">            dfs(node.left, (<span class=\"number\">1</span>-last_left)*right+<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"literal\">True</span>)</span><br><span class=\"line\">            </span><br><span class=\"line\">    dfs(root, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.ans</span><br></pre></td></tr></table></figure>\n<p>方法二：-1的妙用。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestZigZag</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node: <span class=\"keyword\">return</span> (<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>)</span><br><span class=\"line\">        left, right = dfs(node.left), dfs(node.right)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (left[<span class=\"number\">1</span>]+<span class=\"number\">1</span>, right[<span class=\"number\">0</span>]+<span class=\"number\">1</span>, max(left[<span class=\"number\">1</span>]+<span class=\"number\">1</span>, right[<span class=\"number\">0</span>]+<span class=\"number\">1</span>, left[<span class=\"number\">-1</span>], right[<span class=\"number\">-1</span>]))</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> dfs(root)[<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"1367-Linked-List-in-Binary-Tree\"><a href=\"#1367-Linked-List-in-Binary-Tree\" class=\"headerlink\" title=\"1367. Linked List in Binary Tree\"></a>1367. Linked List in Binary Tree</h3><h4 id=\"判断一个链表是否在二叉树的路径中。原题\"><a href=\"#判断一个链表是否在二叉树的路径中。原题\" class=\"headerlink\" title=\"判断一个链表是否在二叉树的路径中。原题\"></a>判断一个链表是否在二叉树的路径中。<a href=\"https://leetcode.com/problems/linked-list-in-binary-tree/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：递归。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isSubPath</span><span class=\"params\">(self, head: ListNode, root: TreeNode)</span> -&gt; bool:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(head, root)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> head: <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root: <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> head.val==root.val <span class=\"keyword\">and</span> (dfs(head.next, root.left) <span class=\"keyword\">or</span> dfs(head.next, root.right))</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> head: <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root: <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dfs(head, root) <span class=\"keyword\">or</span> self.isSubPath(head, root.left) <span class=\"keyword\">or</span> self.isSubPath(head, root.right)</span><br></pre></td></tr></table></figure>\n<h3 id=\"124-Binary-Tree-Maximum-Path-Sum\"><a href=\"#124-Binary-Tree-Maximum-Path-Sum\" class=\"headerlink\" title=\"124. Binary Tree Maximum Path Sum\"></a>124. Binary Tree Maximum Path Sum</h3><h4 id=\"二叉树的最大路径和，可以不经过根节点。原题\"><a href=\"#二叉树的最大路径和，可以不经过根节点。原题\" class=\"headerlink\" title=\"二叉树的最大路径和，可以不经过根节点。原题\"></a>二叉树的最大路径和，可以不经过根节点。<a href=\"https://leetcode.com/problems/binary-tree-maximum-path-sum/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [-10,9,20,null,null,15,7]</span><br><span class=\"line\"></span><br><span class=\"line\">   -10</span><br><span class=\"line\">   &#x2F; \\</span><br><span class=\"line\">  9  20</span><br><span class=\"line\">    &#x2F;  \\</span><br><span class=\"line\">   15   7</span><br><span class=\"line\"></span><br><span class=\"line\">Output: 42</span><br></pre></td></tr></table></figure>\n<p>方法一：递归。开始有一点没想明白，对于任意节点来说，都有左右两条path, 包括根节点。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxPathSum</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    self.ans = float(<span class=\"string\">'-inf'</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxend</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        left = maxend(node.left)</span><br><span class=\"line\">        right = maxend(node.right)</span><br><span class=\"line\">        self.ans = max(self.ans, left+right+node.val)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(node.val + max(left, right), <span class=\"number\">0</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    maxend(root)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"1443-Minimum-Time-to-Collect-All-Apples-in-a-Tree\"><a href=\"#1443-Minimum-Time-to-Collect-All-Apples-in-a-Tree\" class=\"headerlink\" title=\"1443. Minimum Time to Collect All Apples in a Tree\"></a>1443. Minimum Time to Collect All Apples in a Tree</h3><h4 id=\"收集苹果的最小路径。原题\"><a href=\"#收集苹果的最小路径。原题\" class=\"headerlink\" title=\"收集苹果的最小路径。原题\"></a>收集苹果的最小路径。<a href=\"https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 7, edges &#x3D; [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple &#x3D; [false,false,true,false,true,true,false]</span><br><span class=\"line\">Output: 8 </span><br><span class=\"line\">Explanation: The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows.</span><br></pre></td></tr></table></figure>\n<p>方法一：每个苹果的路径都是节点到根的两倍距离。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minTime</span><span class=\"params\">(self, n: int, edges: List[List[int]], hasApple: List[bool])</span> -&gt; int:</span></span><br><span class=\"line\">    t = collections.defaultdict(int)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> edges:</span><br><span class=\"line\">        t[b] = a</span><br><span class=\"line\">        </span><br><span class=\"line\">    used = set()</span><br><span class=\"line\"><span class=\"meta\">    @functools.lru_cache</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> node == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        used.add((node, t[node]))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs(t[node]) + <span class=\"number\">1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    list(map(dfs, (i <span class=\"keyword\">for</span> i, f <span class=\"keyword\">in</span> enumerate(hasApple) <span class=\"keyword\">if</span> f)))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> len(used) * <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1339-Maximum-Product-of-Splitted-Binary-Tree\"><a href=\"#1339-Maximum-Product-of-Splitted-Binary-Tree\" class=\"headerlink\" title=\"1339. Maximum Product of Splitted Binary Tree\"></a>1339. Maximum Product of Splitted Binary Tree</h3><h4 id=\"将一个树砍成两颗树，使两个节点和乘积最大。原题\"><a href=\"#将一个树砍成两颗树，使两个节点和乘积最大。原题\" class=\"headerlink\" title=\"将一个树砍成两颗树，使两个节点和乘积最大。原题\"></a>将一个树砍成两颗树，使两个节点和乘积最大。<a href=\"https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：需要遍历2次，一次求出所有节点和。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxProduct</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class=\"line\">    self.ans = total = <span class=\"number\">0</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">s</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node: <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        left, right = s(node.left), s(node.right)</span><br><span class=\"line\">        self.ans = max(self.ans, (total-left)*left, right*(total-right))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left+right+node.val</span><br><span class=\"line\">    </span><br><span class=\"line\">    total = s(root)</span><br><span class=\"line\">    s(root)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.ans % (<span class=\"number\">10</span>**<span class=\"number\">9</span>+<span class=\"number\">7</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"1315-Sum-of-Nodes-with-Even-Valued-Grandparent\"><a href=\"#1315-Sum-of-Nodes-with-Even-Valued-Grandparent\" class=\"headerlink\" title=\"1315. Sum of Nodes with Even-Valued Grandparent\"></a>1315. Sum of Nodes with Even-Valued Grandparent</h3><h4 id=\"祖父节点为偶数的节点和。原题\"><a href=\"#祖父节点为偶数的节点和。原题\" class=\"headerlink\" title=\"祖父节点为偶数的节点和。原题\"></a>祖父节点为偶数的节点和。<a href=\"https://leetcode.com/problems/sum-of-nodes-with-even-valued-grandparent/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sumEvenGrandparent</span><span class=\"params\">(self, root: TreeNode, p=<span class=\"number\">1</span>, gp=<span class=\"number\">1</span>)</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.sumEvenGrandparent(root.left, root.val, p) + \\</span><br><span class=\"line\">        self.sumEvenGrandparent(root.right, root.val, p) + \\</span><br><span class=\"line\">        root.val * (gp&amp;<span class=\"number\">1</span>==<span class=\"number\">0</span>) <span class=\"keyword\">if</span> root <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1457-Pseudo-Palindromic-Paths-in-a-Binary-Tree\"><a href=\"#1457-Pseudo-Palindromic-Paths-in-a-Binary-Tree\" class=\"headerlink\" title=\"1457. Pseudo-Palindromic Paths in a Binary Tree\"></a>1457. Pseudo-Palindromic Paths in a Binary Tree</h3><h4 id=\"伪回文路径的个数。指排列能够成为回文的路径。原题\"><a href=\"#伪回文路径的个数。指排列能够成为回文的路径。原题\" class=\"headerlink\" title=\"伪回文路径的个数。指排列能够成为回文的路径。原题\"></a>伪回文路径的个数。指排列能够成为回文的路径。<a href=\"https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: root &#x3D; [2,3,1,3,1,null,1]</span><br><span class=\"line\">Output: 2 </span><br><span class=\"line\">Explanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the red path [2,3,3], the green path [2,1,1], and the path [2,3,1]. Among these paths only red path and green path are pseudo-palindromic paths since the red path [2,3,3] can be rearranged in [3,2,3] (palindrome) and the green path [2,1,1] can be rearranged in [1,2,1] (palindrome).</span><br></pre></td></tr></table></figure>\n<p>方法一：竞赛时的答案。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pseudoPalindromicPaths</span> <span class=\"params\">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    c = collections.defaultdict(int)</span><br><span class=\"line\">    self.count = <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(node, odd=True)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            c[node.val] ^= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node.left <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> node.right:</span><br><span class=\"line\">                single = sum(v <span class=\"keyword\">for</span> v <span class=\"keyword\">in</span> c.values() <span class=\"keyword\">if</span> v==<span class=\"number\">1</span>) </span><br><span class=\"line\">                self.count += (single==int(odd))</span><br><span class=\"line\">            dfs(node.left, <span class=\"keyword\">not</span> odd)</span><br><span class=\"line\">            dfs(node.right, <span class=\"keyword\">not</span> odd)</span><br><span class=\"line\">            c[node.val] ^= <span class=\"number\">1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    dfs(root)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.count</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：因为node的值时1~9，所以这里用一个计位器count</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pseudoPalindromicPaths</span> <span class=\"params\">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(node, count=<span class=\"number\">0</span>)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node: <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        count ^= <span class=\"number\">1</span> &lt;&lt; (node.val<span class=\"number\">-1</span>)</span><br><span class=\"line\">        ans = dfs(node.left, count) + dfs(node.right, count)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.left == node.right:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> count &amp; (count<span class=\"number\">-1</span>) == <span class=\"number\">0</span>:</span><br><span class=\"line\">                ans += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> dfs(root)</span><br></pre></td></tr></table></figure>\n<h3 id=\"129-Sum-Root-to-Leaf-Numbers\"><a href=\"#129-Sum-Root-to-Leaf-Numbers\" class=\"headerlink\" title=\"129. Sum Root to Leaf Numbers\"></a>129. Sum Root to Leaf Numbers</h3><h4 id=\"根到叶子节点组成的数字和。原题\"><a href=\"#根到叶子节点组成的数字和。原题\" class=\"headerlink\" title=\"根到叶子节点组成的数字和。原题\"></a>根到叶子节点组成的数字和。<a href=\"https://leetcode.com/problems/sum-root-to-leaf-numbers/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [1,2,3]</span><br><span class=\"line\">    1</span><br><span class=\"line\">   &#x2F; \\</span><br><span class=\"line\">  2   3</span><br><span class=\"line\">Output: 25</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">The root-to-leaf path 1-&gt;2 represents the number 12.</span><br><span class=\"line\">The root-to-leaf path 1-&gt;3 represents the number 13.</span><br><span class=\"line\">Therefore, sum &#x3D; 12 + 13 &#x3D; 25.</span><br></pre></td></tr></table></figure>\n<p>方法一：dfs 写法上迟疑了一下，还是要判断是否为根节点的，避免和累加了2次。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sumNumbers</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class=\"line\">    self.ans = <span class=\"number\">0</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(node, cur)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        cur += node.val</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node.left <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> node.right:</span><br><span class=\"line\">            self.ans += cur</span><br><span class=\"line\">        dfs(node.left, cur*<span class=\"number\">10</span>)</span><br><span class=\"line\">        dfs(node.right, cur*<span class=\"number\">10</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">    dfs(root, <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"114-Flatten-Binary-Tree-to-Linked-List\"><a href=\"#114-Flatten-Binary-Tree-to-Linked-List\" class=\"headerlink\" title=\"114. Flatten Binary Tree to Linked List\"></a>114. Flatten Binary Tree to Linked List</h3><h4 id=\"将一个二叉树变成一个链表，要求在原节点上操作。原题\"><a href=\"#将一个二叉树变成一个链表，要求在原节点上操作。原题\" class=\"headerlink\" title=\"将一个二叉树变成一个链表，要求在原节点上操作。原题\"></a>将一个二叉树变成一个链表，要求在原节点上操作。<a href=\"https://leetcode.com/problems/flatten-binary-tree-to-linked-list/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">    1</span><br><span class=\"line\">   &#x2F; \\</span><br><span class=\"line\">  2   5</span><br><span class=\"line\"> &#x2F; \\   \\</span><br><span class=\"line\">3   4   6</span><br><span class=\"line\"></span><br><span class=\"line\">1</span><br><span class=\"line\"> \\</span><br><span class=\"line\">  2</span><br><span class=\"line\">   \\</span><br><span class=\"line\">    3</span><br><span class=\"line\">     \\</span><br><span class=\"line\">      4</span><br><span class=\"line\">       \\</span><br><span class=\"line\">        5</span><br><span class=\"line\">         \\</span><br><span class=\"line\">          6</span><br></pre></td></tr></table></figure>\n<p>方法一：变成左子树操作直观一点，所以先将它变成左子树，然后再镜像。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">flatten</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(node, p=[], par=None)</span>:</span></span><br><span class=\"line\">        p.append(node)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(p) &gt; <span class=\"number\">1</span>:</span><br><span class=\"line\">            p[<span class=\"number\">-2</span>].left = p[<span class=\"number\">-1</span>]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> par:</span><br><span class=\"line\">                par.right = <span class=\"literal\">None</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.left:</span><br><span class=\"line\">            dfs(node.left, p)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.right:</span><br><span class=\"line\">            dfs(node.right, p, node)</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sym</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            node.left, node.right = node.right, node.left</span><br><span class=\"line\">            sym(node.left)</span><br><span class=\"line\">            sym(node.right)</span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> </span><br><span class=\"line\">    dfs(root)</span><br><span class=\"line\">    sym(root)</span><br></pre></td></tr></table></figure>\n<p>方法二：先把俩节点左右互换。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">flatten</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(node, p=[], par=None)</span>:</span></span><br><span class=\"line\">        node.left, node.right = node.right, node.left</span><br><span class=\"line\">        p.append(node)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(p) &gt; <span class=\"number\">1</span>:</span><br><span class=\"line\">            p[<span class=\"number\">-2</span>].right = p[<span class=\"number\">-1</span>]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> par:</span><br><span class=\"line\">                par.left = <span class=\"literal\">None</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.right:</span><br><span class=\"line\">            dfs(node.right, p)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.left:</span><br><span class=\"line\">            dfs(node.left, p, node</span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> </span><br><span class=\"line\">    dfs(root)</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\"></font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countPairs</span><span class=\"params\">(self, root: TreeNode, distance: int)</span> -&gt; int:</span></span><br><span class=\"line\">    paths = []</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(node, p)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            p.append(node)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node.left <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> node.right:</span><br><span class=\"line\">                paths.append(list(p))</span><br><span class=\"line\">            dfs(node.left, p)</span><br><span class=\"line\">            dfs(node.right, p)</span><br><span class=\"line\">            p.pop()</span><br><span class=\"line\">            </span><br><span class=\"line\">    dfs(root, [])</span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    n = len(paths)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i+<span class=\"number\">1</span>, n):</span><br><span class=\"line\">            p1 = list(paths[i])</span><br><span class=\"line\">            p2 = list(paths[j])</span><br><span class=\"line\">            k = distance + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> k:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> p1[<span class=\"number\">-1</span>] == p2[<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                    ans += <span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> len(p1) &gt;= len(p2):</span><br><span class=\"line\">                    p1.pop()</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    p2.pop()</span><br><span class=\"line\">                k -= <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：后序遍历</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countPairs</span><span class=\"params\">(self, root: TreeNode, distance: int)</span> -&gt; int:</span></span><br><span class=\"line\">    count = <span class=\"number\">0</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">nonlocal</span> count</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node.left <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> node.right:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [<span class=\"number\">1</span>]</span><br><span class=\"line\">        left = dfs(node.left)</span><br><span class=\"line\">        right = dfs(node.right)</span><br><span class=\"line\">        count += sum(l+r&lt;=distance <span class=\"keyword\">for</span> l <span class=\"keyword\">in</span> left <span class=\"keyword\">for</span> r <span class=\"keyword\">in</span> right)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [k+<span class=\"number\">1</span> <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> left+right <span class=\"keyword\">if</span> k+<span class=\"number\">1</span>&lt;distance]</span><br><span class=\"line\">    </span><br><span class=\"line\">    dfs(root)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count</span><br></pre></td></tr></table></figure>\n<h3 id=\"450-Delete-Node-in-a-BST\"><a href=\"#450-Delete-Node-in-a-BST\" class=\"headerlink\" title=\"450. Delete Node in a BST\"></a>450. Delete Node in a BST</h3><h4 id=\"删除二叉搜索树的一个节点。原题\"><a href=\"#删除二叉搜索树的一个节点。原题\" class=\"headerlink\" title=\"删除二叉搜索树的一个节点。原题\"></a>删除二叉搜索树的一个节点。<a href=\"https://leetcode.com/problems/delete-node-in-a-bst/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：递归，好久没做二叉树有点生疏，想了半天。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">deleteNode</span><span class=\"params\">(self, root: TreeNode, key: int)</span> -&gt; TreeNode:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root: <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> root.val &gt; key:</span><br><span class=\"line\">        root.left = self.deleteNode(root.left, key)</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> root.val &lt; key:</span><br><span class=\"line\">        root.right = self.deleteNode(root.right, key)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root.right:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root.left</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> <span class=\"keyword\">not</span> root.left:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root.right</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            cur = root.right</span><br><span class=\"line\">            <span class=\"keyword\">while</span> cur.left:</span><br><span class=\"line\">                cur = cur.left</span><br><span class=\"line\">            cur.left = root.left</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root.right</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br></pre></td></tr></table></figure>\n<h3 id=\"971-Flip-Binary-Tree-To-Match-Preorder-Traversal\"><a href=\"#971-Flip-Binary-Tree-To-Match-Preorder-Traversal\" class=\"headerlink\" title=\"971. Flip Binary Tree To Match Preorder Traversal\"></a>971. Flip Binary Tree To Match Preorder Traversal</h3><h4 id=\"给你一个二叉树和一个前序遍历，判断二叉树否通过互换左右子树来达到前序遍历的顺序，返回这样的节点编号，没有则返回-1。原题\"><a href=\"#给你一个二叉树和一个前序遍历，判断二叉树否通过互换左右子树来达到前序遍历的顺序，返回这样的节点编号，没有则返回-1。原题\" class=\"headerlink\" title=\"给你一个二叉树和一个前序遍历，判断二叉树否通过互换左右子树来达到前序遍历的顺序，返回这样的节点编号，没有则返回-1。原题\"></a>给你一个二叉树和一个前序遍历，判断二叉树否通过互换左右子树来达到前序遍历的顺序，返回这样的节点编号，没有则返回-1。<a href=\"https://leetcode.com/problems/flip-binary-tree-to-match-preorder-traversal/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: root &#x3D; [1,2], voyage &#x3D; [2,1]</span><br><span class=\"line\">Output: [-1]</span><br></pre></td></tr></table></figure>\n<p>方法一：递归。第一次ac的方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">flipMatchVoyage</span><span class=\"params\">(self, root: TreeNode, v: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    v = v[::<span class=\"number\">-1</span>]</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">flip</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        val = node.val <span class=\"keyword\">if</span> node <span class=\"keyword\">else</span> <span class=\"literal\">None</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> val != v[<span class=\"number\">-1</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">nonlocal</span> ans</span><br><span class=\"line\">            ans = [<span class=\"number\">-1</span>]</span><br><span class=\"line\">            <span class=\"keyword\">return</span> </span><br><span class=\"line\">        v.pop()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> v: <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.left <span class=\"keyword\">and</span> node.left.val != v[<span class=\"number\">-1</span>]:</span><br><span class=\"line\">            node.left, node.right = node.right, node.left</span><br><span class=\"line\">            ans.append(node.val)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.left:</span><br><span class=\"line\">            flip(node.left)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.right:</span><br><span class=\"line\">            flip(node.right)</span><br><span class=\"line\">        </span><br><span class=\"line\">    flip(root)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：lee的写法。思路是一样的。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">flipMatchVoyage</span><span class=\"params\">(self, root: TreeNode, v: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    v = v[::<span class=\"number\">-1</span>]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node: <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.val != v[<span class=\"number\">-1</span>]: <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        v.pop()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.left <span class=\"keyword\">and</span> node.left.val != v[<span class=\"number\">-1</span>]:</span><br><span class=\"line\">            node.left, node.right = node.right, node.left</span><br><span class=\"line\">            ans.append(node.val)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs(node.left) <span class=\"keyword\">and</span> dfs(node.right)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans <span class=\"keyword\">if</span> dfs(root) <span class=\"keyword\">else</span> [<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"951-Flip-Equivalent-Binary-Trees\"><a href=\"#951-Flip-Equivalent-Binary-Trees\" class=\"headerlink\" title=\"951. Flip Equivalent Binary Trees\"></a>951. Flip Equivalent Binary Trees</h3><h4 id=\"和971差不多，比较的是两棵树。原题\"><a href=\"#和971差不多，比较的是两棵树。原题\" class=\"headerlink\" title=\"和971差不多，比较的是两棵树。原题\"></a>和971差不多，比较的是两棵树。<a href=\"https://leetcode.com/problems/flip-equivalent-binary-trees/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：第一次提交时少考虑了一个case就是左右节点都相同。这种情况下可翻转也可不翻转。然后想or的关系，担心会超时。好在树的节点并没有很多。而且用时也不高beats了90%。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">flipEquiv</span><span class=\"params\">(self, root1: TreeNode, root2: TreeNode)</span> -&gt; bool:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root1 <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> root2:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root1 <span class=\"keyword\">is</span> root2</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root1.val != root2.val:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    left_1 = root1.left.val <span class=\"keyword\">if</span> root1.left <span class=\"keyword\">else</span> <span class=\"literal\">None</span></span><br><span class=\"line\">    left_2 = root2.left.val <span class=\"keyword\">if</span> root2.left <span class=\"keyword\">else</span> <span class=\"literal\">None</span></span><br><span class=\"line\">    ans = <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> left_1 != left_2:</span><br><span class=\"line\">        root1.left, root1.right = root1.right, root1.left</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        right_1 = root1.right.val <span class=\"keyword\">if</span> root1.right <span class=\"keyword\">else</span> <span class=\"literal\">None</span></span><br><span class=\"line\">        right_2 = root2.right.val <span class=\"keyword\">if</span> root2.right <span class=\"keyword\">else</span> <span class=\"literal\">None</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> left_1 == right_1 == right_2:</span><br><span class=\"line\">            ans |= (self.flipEquiv(root1.left, root2.right) <span class=\"keyword\">and</span></span><br><span class=\"line\">                    self.flipEquiv(root1.right, root2.left))</span><br><span class=\"line\">    ans |= (self.flipEquiv(root1.left, root2.left) <span class=\"keyword\">and</span></span><br><span class=\"line\">            self.flipEquiv(root1.right, root2.right))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法二：理论上来说是方法一快，但是可以忽略不计。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">flipEquiv</span><span class=\"params\">(self, root1: TreeNode, root2: TreeNode)</span> -&gt; bool:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root1 <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> root2:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root1 <span class=\"keyword\">is</span> root2</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (root1.val == root2.val <span class=\"keyword\">and</span></span><br><span class=\"line\">           (self.flipEquiv(root1.left, root2.right) <span class=\"keyword\">and</span></span><br><span class=\"line\">            self.flipEquiv(root1.right, root2.left)) |</span><br><span class=\"line\">           (self.flipEquiv(root1.left, root2.left) <span class=\"keyword\">and</span></span><br><span class=\"line\">            self.flipEquiv(root1.right, root2.right)))</span><br></pre></td></tr></table></figure>\n<h3 id=\"863-All-Nodes-Distance-K-in-Binary-Tree\"><a href=\"#863-All-Nodes-Distance-K-in-Binary-Tree\" class=\"headerlink\" title=\"863. All Nodes Distance K in Binary Tree\"></a>863. All Nodes Distance K in Binary Tree</h3><h4 id=\"找出树中距离目标节点为K的节点值。原题\"><a href=\"#找出树中距离目标节点为K的节点值。原题\" class=\"headerlink\" title=\"找出树中距离目标节点为K的节点值。原题\"></a>找出树中距离目标节点为K的节点值。<a href=\"https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], target &#x3D; 5, K &#x3D; 2</span><br><span class=\"line\"></span><br><span class=\"line\">Output: [7,4,1]</span><br><span class=\"line\"></span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">The nodes that are a distance 2 from the target node (with value 5)</span><br><span class=\"line\">have values 7, 4, and 1.</span><br></pre></td></tr></table></figure>\n<p>方法一：这个方法想了一下，没敢往下细想。先把他变成那种无向图。然后bfs。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">distanceK</span><span class=\"params\">(self, root: TreeNode, target: TreeNode, K: int)</span> -&gt; List[int]:</span></span><br><span class=\"line\">    g = collections.defaultdict(list)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">connect</span><span class=\"params\">(parent, child)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> parent <span class=\"keyword\">and</span> child:</span><br><span class=\"line\">            g[parent.val].append(child.val)</span><br><span class=\"line\">            g[child.val].append(parent.val)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> child.left: connect(child, child.left)  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> child.right: connect(child, child.right)</span><br><span class=\"line\">    </span><br><span class=\"line\">    connect(<span class=\"literal\">None</span>, root)</span><br><span class=\"line\">    bfs = [target.val]</span><br><span class=\"line\">    seen = set(bfs)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(K):</span><br><span class=\"line\">        new_level = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> q_val <span class=\"keyword\">in</span> bfs:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> g[q_val]:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> j <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> seen:</span><br><span class=\"line\">                    new_level.append(j)</span><br><span class=\"line\">        bfs = new_level</span><br><span class=\"line\">        seen |= set(bfs)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bfs</span><br></pre></td></tr></table></figure>\n<h3 id=\"865-Smallest-Subtree-with-all-the-Deepest-Nodes\"><a href=\"#865-Smallest-Subtree-with-all-the-Deepest-Nodes\" class=\"headerlink\" title=\"865. Smallest Subtree with all the Deepest Nodes\"></a>865. Smallest Subtree with all the Deepest Nodes</h3><h4 id=\"带有最深节点的最小子树。也就是求最底层叶子节点的最小公共祖先。原题\"><a href=\"#带有最深节点的最小子树。也就是求最底层叶子节点的最小公共祖先。原题\" class=\"headerlink\" title=\"带有最深节点的最小子树。也就是求最底层叶子节点的最小公共祖先。原题\"></a>带有最深节点的最小子树。也就是求最底层叶子节点的最小公共祖先。<a href=\"https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：用最小公共祖先的求法可以得到。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">subtreeWithAllDeepest</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class=\"line\">    paths = []</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(n, p)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n:</span><br><span class=\"line\">            p.append(n)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> n.left <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> n.right:</span><br><span class=\"line\">                paths.append(list(p))</span><br><span class=\"line\">            dfs(n.left, p)</span><br><span class=\"line\">            dfs(n.right, p)</span><br><span class=\"line\">            p.pop()</span><br><span class=\"line\">    </span><br><span class=\"line\">    dfs(root, [])</span><br><span class=\"line\">    max_len = max(len(p) <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> paths)</span><br><span class=\"line\">    paths = [p <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> paths <span class=\"keyword\">if</span> len(p)==max_len]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> next(nodes[<span class=\"number\">0</span>] <span class=\"keyword\">for</span> nodes <span class=\"keyword\">in</span> list(zip(*paths))[::<span class=\"number\">-1</span>] <span class=\"keyword\">if</span> len(set(nodes))==<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：Lee215的方法。如果对于一个子树节点来说，左边深度&gt;右边则说明我们要找的点在左侧。反之亦然。如果相等，则该节点就是我们要找的节点。返回一个tuple一层层将要找的点递归上去。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">subtreeWithAllDeepest</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">deep</span><span class=\"params\">(root)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root: <span class=\"keyword\">return</span> <span class=\"number\">0</span>, <span class=\"literal\">None</span></span><br><span class=\"line\">        l, r = deep(root.left), deep(root.right)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> l[<span class=\"number\">0</span>] &gt; r[<span class=\"number\">0</span>]: <span class=\"keyword\">return</span> l[<span class=\"number\">0</span>] + <span class=\"number\">1</span>, l[<span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> l[<span class=\"number\">0</span>] &lt; r[<span class=\"number\">0</span>]: <span class=\"keyword\">return</span> r[<span class=\"number\">0</span>] + <span class=\"number\">1</span>, r[<span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">else</span>: <span class=\"keyword\">return</span> l[<span class=\"number\">0</span>] + <span class=\"number\">1</span>, root</span><br><span class=\"line\">    <span class=\"keyword\">return</span> deep(root)[<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"1373-Maximum-Sum-BST-in-Binary-Tree\"><a href=\"#1373-Maximum-Sum-BST-in-Binary-Tree\" class=\"headerlink\" title=\"1373. Maximum Sum BST in Binary Tree\"></a>1373. Maximum Sum BST in Binary Tree</h3><h4 id=\"找到二叉树中，最大的一个二叉搜索子树所有节点的和。原题\"><a href=\"#找到二叉树中，最大的一个二叉搜索子树所有节点的和。原题\" class=\"headerlink\" title=\"找到二叉树中，最大的一个二叉搜索子树所有节点的和。原题\"></a>找到二叉树中，最大的一个二叉搜索子树所有节点的和。<a href=\"https://leetcode.com/problems/maximum-sum-bst-in-binary-tree/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：虽然是个hard题，但是思路很清晰。一个dfs返回时记录这个子树中的最小值，最大值，总和。首次ac的方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxSumBST</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class=\"line\">    self.ans = <span class=\"number\">0</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">helper</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node.left <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> node.right:</span><br><span class=\"line\">            self.ans = max(self.ans, node.val)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> node.val, node.val, node.val</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.left:</span><br><span class=\"line\">            small_left, big_left, total_left = helper(node.left)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            small_left, big_left, total_left = float(<span class=\"string\">'inf'</span>), float(<span class=\"string\">'-inf'</span>), <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.right:</span><br><span class=\"line\">            small_right, big_right, total_right = helper(node.right)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            small_right, big_right, total_right = float(<span class=\"string\">'inf'</span>), float(<span class=\"string\">'-inf'</span>), <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.val &gt; big_left <span class=\"keyword\">and</span> node.val &lt; small_right:</span><br><span class=\"line\">            total = total_left + total_right + node.val</span><br><span class=\"line\">            small = min(small_left, small_right, node.val)</span><br><span class=\"line\">            big = max(big_left, big_right, node.val)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            small, big, total = float(<span class=\"string\">'-inf'</span>), float(<span class=\"string\">'inf'</span>), <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        self.ans = max(self.ans, total)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> small, big, total</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：方法一多了很多多余的比较。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxSumBST</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class=\"line\">    self.ans = <span class=\"number\">0</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">helper</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> float(<span class=\"string\">'inf'</span>), float(<span class=\"string\">'-inf'</span>), <span class=\"number\">0</span></span><br><span class=\"line\">        small_left, big_left, total_left = helper(node.left)</span><br><span class=\"line\">        small_right, big_right, total_right = helper(node.right)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> big_left &lt; node.val &lt; small_right:</span><br><span class=\"line\">            self.ans = max(self.ans, total_left+total_right+node.val)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> min(small_left, node.val), max(big_right, node.val), total_left+total_right+node.val</span><br><span class=\"line\">        <span class=\"keyword\">return</span> float(<span class=\"string\">'-inf'</span>), float(<span class=\"string\">'inf'</span>), <span class=\"number\">0</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    helper(root)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"501-Find-Mode-in-Binary-Search-Tree\"><a href=\"#501-Find-Mode-in-Binary-Search-Tree\" class=\"headerlink\" title=\"501. Find Mode in Binary Search Tree\"></a><a href=\"https://leetcode.com/problems/find-mode-in-binary-search-tree/\" target=\"_blank\" rel=\"noopener\">501. Find Mode in Binary Search Tree</a></h3><h4 id=\"找到二叉搜索树中的众数，可能有多个值。这个树左子树节点是《-当前节点。\"><a href=\"#找到二叉搜索树中的众数，可能有多个值。这个树左子树节点是《-当前节点。\" class=\"headerlink\" title=\"找到二叉搜索树中的众数，可能有多个值。这个树左子树节点是《=当前节点。\"></a>找到二叉搜索树中的众数，可能有多个值。这个树左子树节点是《=当前节点。</h4><p>方法一：中序遍历改的。将所有节点值按序输出就好找了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findMode</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inorder</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> inorder(node.left)</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> node.val</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> inorder(node.right)</span><br><span class=\"line\">            </span><br><span class=\"line\">    prev, ans = <span class=\"literal\">None</span>, []</span><br><span class=\"line\">    cnt = max_cnt = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> inorder(root):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> prev == d:</span><br><span class=\"line\">            cnt += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            cnt = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> cnt &gt; max_cnt:</span><br><span class=\"line\">            ans = [d]</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> cnt == max_cnt:</span><br><span class=\"line\">            ans.append(d)</span><br><span class=\"line\">        max_cnt = max(max_cnt, cnt)</span><br><span class=\"line\">        prev = d</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"968-Binary-Tree-Cameras\"><a href=\"#968-Binary-Tree-Cameras\" class=\"headerlink\" title=\"968. Binary Tree Cameras\"></a><a href=\"https://leetcode.com/problems/binary-tree-cameras/\" target=\"_blank\" rel=\"noopener\">968. Binary Tree Cameras</a></h3><h4 id=\"要对一颗二叉树进行监控，一个摄像头可以监控父节点，自身以及子节点。问最少需要多少个摄像头能监控所有节点。\"><a href=\"#要对一颗二叉树进行监控，一个摄像头可以监控父节点，自身以及子节点。问最少需要多少个摄像头能监控所有节点。\" class=\"headerlink\" title=\"要对一颗二叉树进行监控，一个摄像头可以监控父节点，自身以及子节点。问最少需要多少个摄像头能监控所有节点。\"></a>要对一颗二叉树进行监控，一个摄像头可以监控父节点，自身以及子节点。问最少需要多少个摄像头能监控所有节点。</h4><p>方法一：这题看了题解，实际上有个贪心的解法，通过状态来表示节点是否需要监控。通过后序遍历，子节点的装填判断附近点状态。有时候看到标签上是dp，就被标签上的解法限制住了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minCameraCover</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"comment\"># 0：未被监控；1：已监控，2：摄像头</span></span><br><span class=\"line\">    self.ans = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        left = dfs(node.left)</span><br><span class=\"line\">        right = dfs(node.right)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> left==<span class=\"number\">0</span> <span class=\"keyword\">or</span> right==<span class=\"number\">0</span>:</span><br><span class=\"line\">            self.ans += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> left==<span class=\"number\">1</span> <span class=\"keyword\">and</span> right==<span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> dfs(root) == <span class=\"number\">0</span>:</span><br><span class=\"line\">        self.ans += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"116-Populating-Next-Right-Pointers-in-Each-Node\"><a href=\"#116-Populating-Next-Right-Pointers-in-Each-Node\" class=\"headerlink\" title=\"116. Populating Next Right Pointers in Each Node\"></a><a href=\"https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/\" target=\"_blank\" rel=\"noopener\">116. Populating Next Right Pointers in Each Node</a></h3><h4 id=\"将一个完美二叉树每层的节点相连。完美二叉树是指所有叶子节点在同一层，每个父节点都有两个子节点。\"><a href=\"#将一个完美二叉树每层的节点相连。完美二叉树是指所有叶子节点在同一层，每个父节点都有两个子节点。\" class=\"headerlink\" title=\"将一个完美二叉树每层的节点相连。完美二叉树是指所有叶子节点在同一层，每个父节点都有两个子节点。\"></a>将一个完美二叉树每层的节点相连。完美二叉树是指所有叶子节点在同一层，每个父节点都有两个子节点。</h4><p>方法一：stefan.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">connect</span><span class=\"params\">(self, root: <span class=\"string\">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class=\"line\">    head = root</span><br><span class=\"line\">    <span class=\"keyword\">while</span> root <span class=\"keyword\">and</span> root.left:</span><br><span class=\"line\">        nxt = root.left</span><br><span class=\"line\">        <span class=\"keyword\">while</span> root:</span><br><span class=\"line\">            root.left.next = root.right</span><br><span class=\"line\">            root.right.next = root.next <span class=\"keyword\">and</span> root.next.left</span><br><span class=\"line\">            root = root.next</span><br><span class=\"line\">        root = nxt</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head</span><br></pre></td></tr></table></figure>\n<h3 id=\"117-填充每个节点的下一个右侧节点指针-II\"><a href=\"#117-填充每个节点的下一个右侧节点指针-II\" class=\"headerlink\" title=\"117. 填充每个节点的下一个右侧节点指针 II\"></a><a href=\"https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/\" target=\"_blank\" rel=\"noopener\">117. 填充每个节点的下一个右侧节点指针 II</a></h3><h4 id=\"这题由于要求常数空间复杂度实现，提高了难度。不能使用层序直接做了。对比116题，树不是完美二叉树了。\"><a href=\"#这题由于要求常数空间复杂度实现，提高了难度。不能使用层序直接做了。对比116题，树不是完美二叉树了。\" class=\"headerlink\" title=\"这题由于要求常数空间复杂度实现，提高了难度。不能使用层序直接做了。对比116题，树不是完美二叉树了。\"></a>这题由于要求常数空间复杂度实现，提高了难度。不能使用层序直接做了。对比116题，树不是完美二叉树了。</h4><p>方法一：指针，cur表示当前层游标，head表示下一层头节点，pre则是下一层的游标。逐个将pre的next和cur的左右子节点相连。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">connect</span><span class=\"params\">(self, root: <span class=\"string\">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class=\"line\">    head = root</span><br><span class=\"line\">    <span class=\"keyword\">while</span> head:<span class=\"comment\">#当前层的头节点</span></span><br><span class=\"line\">        cur = head <span class=\"comment\">#当前层处理节点</span></span><br><span class=\"line\">        pre = head = <span class=\"literal\">None</span><span class=\"comment\">#初始化下一层头节点和前置节点</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> cur:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> cur.left:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> pre:<span class=\"comment\">#若尚未找到下一层前置节点，则同步更新下一层头节点和前置节点</span></span><br><span class=\"line\">                    pre = head =cur.left</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:<span class=\"comment\">#已找到下一层前置节点，则将前置节点指向当前子节点，并前移pre</span></span><br><span class=\"line\">                    pre.next = cur.left</span><br><span class=\"line\">                    pre = pre.next</span><br><span class=\"line\">            <span class=\"keyword\">if</span> cur.right:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> pre:</span><br><span class=\"line\">                    pre = head = cur.right</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    pre.next = cur.right</span><br><span class=\"line\">                    pre = pre.next</span><br><span class=\"line\">            cur = cur.next</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br></pre></td></tr></table></figure>\n<h3 id=\"834-Sum-of-Distances-in-Tree-https-leetcode-com-problems-sum-of-distances-in-tree\"><a href=\"#834-Sum-of-Distances-in-Tree-https-leetcode-com-problems-sum-of-distances-in-tree\" class=\"headerlink\" title=\"834. Sum of Distances in Tree](https://leetcode.com/problems/sum-of-distances-in-tree/)\"></a>834. Sum of Distances in Tree](<a href=\"https://leetcode.com/problems/sum-of-distances-in-tree/\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/sum-of-distances-in-tree/</a>)</h3><h4 id=\"给定一个无向、连通的树。树中有-N-个标记为-0…N-1-的节点以及-N-1-条边-。返回一个表示节点-i-与其他所有节点距离之和的列表-ans。\"><a href=\"#给定一个无向、连通的树。树中有-N-个标记为-0…N-1-的节点以及-N-1-条边-。返回一个表示节点-i-与其他所有节点距离之和的列表-ans。\" class=\"headerlink\" title=\"给定一个无向、连通的树。树中有 N 个标记为 0…N-1 的节点以及 N-1 条边 。返回一个表示节点 i 与其他所有节点距离之和的列表 ans。\"></a>给定一个无向、连通的树。树中有 N 个标记为 0…N-1 的节点以及 N-1 条边 。返回一个表示节点 i 与其他所有节点距离之和的列表 ans。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: N &#x3D; 6, edges &#x3D; [[0,1],[0,2],[2,3],[2,4],[2,5]]</span><br><span class=\"line\">输出: [8,12,6,10,10,10]</span><br><span class=\"line\">解释: </span><br><span class=\"line\">如下为给定的树的示意图：</span><br><span class=\"line\">  0</span><br><span class=\"line\"> &#x2F; \\</span><br><span class=\"line\">1   2</span><br><span class=\"line\">   &#x2F;|\\</span><br><span class=\"line\">  3 4 5</span><br></pre></td></tr></table></figure>\n<p>方法一：dfs. @lee215的方法。 属实是一道hard题，看了题解才明白。对于任意节点，可以从O(n)获取所有的距离之和。但是如果每个节点都做一遍dfs，O(n^2)明显会超时。这样思考，当根节点在无向图中移动时，比如从0到2，那么与移动方向相同的节点，所有节点距离都少了1；与之反向的节点距离都+1。那么如果知道了2节点的子树（包含2节点）一共有多少个节点，就知道了距离是如何变化的。还需要明白一件事，res[root] = res[child] + count[child]<code>。比如以0位父节点，在0的右子树部分距离和为</code>res[2] + count[2]<code>，count表示2子树有多少个节点。因为对于2中所有的节点到2的距离都包含在了</code>res[2]`中，那么需要计算到0的距离，就是所有的节点再+1。我们以0位根节点，在通过0算其他的距离和。知道了这些规律，先进行一次后序遍历更新更新res[0]和count。然后进行先序遍历更新0的各个子节点的距离和。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sumOfDistancesInTree</span><span class=\"params\">(self, N: int, edges: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    tree = defaultdict(set)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> u, v <span class=\"keyword\">in</span> edges:</span><br><span class=\"line\">        tree[u].add(v)</span><br><span class=\"line\">        tree[v].add(u)</span><br><span class=\"line\">    res = [<span class=\"number\">0</span>] * N</span><br><span class=\"line\">    count = [<span class=\"number\">1</span>] * N</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(root, pre)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> tree[root]:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i != pre:</span><br><span class=\"line\">                dfs(i, root)</span><br><span class=\"line\">                count[root] += count[i]</span><br><span class=\"line\">                res[root] += res[i] + count[i]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs2</span><span class=\"params\">(root, pre)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> tree[root]:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i != pre:</span><br><span class=\"line\">                res[i] = res[root] - count[i] + N - count[i]</span><br><span class=\"line\">                dfs2(i, root)</span><br><span class=\"line\"></span><br><span class=\"line\">    dfs(<span class=\"number\">0</span>, <span class=\"number\">-1</span>)</span><br><span class=\"line\">    dfs2(<span class=\"number\">0</span>, <span class=\"number\">-1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"655-Print-Binary-Tree\"><a href=\"#655-Print-Binary-Tree\" class=\"headerlink\" title=\"655. Print Binary Tree\"></a><a href=\"https://leetcode.com/problems/print-binary-tree/\" target=\"_blank\" rel=\"noopener\">655. Print Binary Tree</a></h3><h4 id=\"打印二叉树。\"><a href=\"#打印二叉树。\" class=\"headerlink\" title=\"打印二叉树。\"></a>打印二叉树。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">     1</span><br><span class=\"line\">    &#x2F; \\</span><br><span class=\"line\">   2   3</span><br><span class=\"line\">    \\</span><br><span class=\"line\">     4</span><br><span class=\"line\">Output:</span><br><span class=\"line\">[[&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;1&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;],</span><br><span class=\"line\"> [&quot;&quot;, &quot;2&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;3&quot;, &quot;&quot;],</span><br><span class=\"line\"> [&quot;&quot;, &quot;&quot;, &quot;4&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;]]</span><br></pre></td></tr></table></figure>\n<p>方法一：iterative. </p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">printTree</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; List[List[str]]:</span></span><br><span class=\"line\">    level, ans, d = [root], [], <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> any(level):</span><br><span class=\"line\">        ans.append([str(n.val) <span class=\"keyword\">if</span> n <span class=\"keyword\">else</span> <span class=\"string\">''</span> <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> level])</span><br><span class=\"line\">        tmp = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> level:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> n: tmp.extend([<span class=\"literal\">None</span>, <span class=\"literal\">None</span>])</span><br><span class=\"line\">            <span class=\"keyword\">else</span>: tmp.extend([n.left, n.right])</span><br><span class=\"line\">        level = tmp</span><br><span class=\"line\">        d += <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    m = n = <span class=\"number\">2</span> ** d - <span class=\"number\">1</span></span><br><span class=\"line\">    res = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> layer <span class=\"keyword\">in</span> ans:</span><br><span class=\"line\">        tmp = [<span class=\"string\">''</span>] * n</span><br><span class=\"line\">        it = iter(layer)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(m//<span class=\"number\">2</span>, n, m+<span class=\"number\">1</span>):</span><br><span class=\"line\">            tmp[j] = next(it)</span><br><span class=\"line\">        res.append(tmp)</span><br><span class=\"line\">        m //= <span class=\"number\">2</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<p>方法二：递归法也很清晰。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">printTree</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; List[List[str]]:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_height</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span> <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node <span class=\"keyword\">else</span> <span class=\"number\">1</span> + max(get_height(node.left), get_height(node.right))</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">update_output</span><span class=\"params\">(i, lo, hi, node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node: <span class=\"keyword\">return</span></span><br><span class=\"line\">        mid = (lo + hi) // <span class=\"number\">2</span></span><br><span class=\"line\">        ans[i][mid] = str(node.val)</span><br><span class=\"line\">        update_output(i+<span class=\"number\">1</span>, lo, mid<span class=\"number\">-1</span>, node.left)</span><br><span class=\"line\">        update_output(i+<span class=\"number\">1</span>, mid+<span class=\"number\">1</span>, hi, node.right)</span><br><span class=\"line\">    </span><br><span class=\"line\">    h = get_height(root)</span><br><span class=\"line\">    w = <span class=\"number\">2</span> ** h - <span class=\"number\">1</span></span><br><span class=\"line\">    ans = [[<span class=\"string\">''</span>] * w <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(h)]</span><br><span class=\"line\">    lo, hi = <span class=\"number\">0</span>, w - <span class=\"number\">1</span></span><br><span class=\"line\">    update_output(<span class=\"number\">0</span>, lo, hi, root)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法三：自己写得方法，逐层遍历，逐层更新。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">printTree</span><span class=\"params\">(self, root: Optional[TreeNode])</span> -&gt; List[List[str]]:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fat</span><span class=\"params\">(row)</span>:</span></span><br><span class=\"line\">        new_row = [<span class=\"string\">\"\"</span>]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> n, e <span class=\"keyword\">in</span> zip(row, repeat(<span class=\"string\">\"\"</span>)):</span><br><span class=\"line\">            new_row.extend([n, e])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> new_row</span><br><span class=\"line\"></span><br><span class=\"line\">    level = [(root, <span class=\"number\">0</span>)] <span class=\"comment\"># 节点, 父节点横坐标, 以root为原点</span></span><br><span class=\"line\">    res = [[str(root.val)]]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">        level = [(k, xk) <span class=\"keyword\">for</span> (n, x2) <span class=\"keyword\">in</span> level </span><br><span class=\"line\">                 <span class=\"keyword\">for</span> (k, xk) <span class=\"keyword\">in</span> ((n.left, x2*<span class=\"number\">2</span><span class=\"number\">-1</span>), (n.right, x2*<span class=\"number\">2</span>+<span class=\"number\">1</span>))</span><br><span class=\"line\">                 <span class=\"keyword\">if</span> k]</span><br><span class=\"line\">        <span class=\"comment\"># print(level)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> level:</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> res:</span><br><span class=\"line\">            row[::] = fat(row)</span><br><span class=\"line\">        N = len(res[<span class=\"number\">-1</span>])</span><br><span class=\"line\">        new_row = [<span class=\"string\">\"\"</span>] * N</span><br><span class=\"line\">        <span class=\"keyword\">for</span> n, px <span class=\"keyword\">in</span> level:</span><br><span class=\"line\">            new_row[px + N//<span class=\"number\">2</span>] = str(n.val)</span><br><span class=\"line\">        res.append(new_row)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"307-Range-Sum-Query-Mutable\"><a href=\"#307-Range-Sum-Query-Mutable\" class=\"headerlink\" title=\"307. Range Sum Query - Mutable\"></a><a href=\"https://leetcode.com/problems/range-sum-query-mutable/\" target=\"_blank\" rel=\"noopener\">307. Range Sum Query - Mutable</a></h3><h4 id=\"可变区间查询。\"><a href=\"#可变区间查询。\" class=\"headerlink\" title=\"可变区间查询。\"></a>可变区间查询。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Given nums &#x3D; [1, 3, 5]</span><br><span class=\"line\"></span><br><span class=\"line\">sumRange(0, 2) -&gt; 9</span><br><span class=\"line\">update(1, 2)</span><br><span class=\"line\">sumRange(0, 2) -&gt; 8</span><br></pre></td></tr></table></figure>\n<p>方法一：标准的线段树。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, start, end, val=<span class=\"number\">0</span>)</span>:</span></span><br><span class=\"line\">        self.start = start</span><br><span class=\"line\">        self.end = end</span><br><span class=\"line\">        self.val = val</span><br><span class=\"line\">        self.left = <span class=\"literal\">None</span></span><br><span class=\"line\">        self.right = <span class=\"literal\">None</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NumArray</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, nums: List[int])</span>:</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">build_tree</span><span class=\"params\">(lo, hi)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> lo &gt; hi:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> </span><br><span class=\"line\">            <span class=\"keyword\">if</span> lo == hi:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> Node(lo, hi, nums[lo])</span><br><span class=\"line\">            mid = (lo + hi) &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">            root = Node(lo, hi)</span><br><span class=\"line\">            root.left = build_tree(lo, mid)</span><br><span class=\"line\">            root.right = build_tree(mid+<span class=\"number\">1</span>, hi)</span><br><span class=\"line\">            root.val = root.left.val + root.right.val</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root</span><br><span class=\"line\">        self.root = build_tree(<span class=\"number\">0</span>, len(nums)<span class=\"number\">-1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">update</span><span class=\"params\">(self, i: int, val: int)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">update_val</span><span class=\"params\">(root, i, val)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> root.start == root.end:</span><br><span class=\"line\">                root.val = val</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            mid = (root.start + root.end) &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> i &lt;= mid:</span><br><span class=\"line\">                update_val(root.left, i, val)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                update_val(root.right, i, val)</span><br><span class=\"line\">            root.val = root.left.val + root.right.val</span><br><span class=\"line\">        </span><br><span class=\"line\">        update_val(self.root, i, val)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sumRange</span><span class=\"params\">(self, i: int, j: int)</span> -&gt; int:</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sum_range</span><span class=\"params\">(root, i, j)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> root.start==i <span class=\"keyword\">and</span> root.end==j:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> root.val</span><br><span class=\"line\">            </span><br><span class=\"line\">            mid = (root.start + root.end) &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> j &lt;= mid:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> sum_range(root.left, i, j)</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> i &gt;= mid+<span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> sum_range(root.right, i, j)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> sum_range(root.left, i, mid) + sum_range(root.right, mid+<span class=\"number\">1</span>, j)</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum_range(self.root, i, j)</span><br></pre></td></tr></table></figure>\n<h3 id=\"652-Find-Duplicate-Subtrees\"><a href=\"#652-Find-Duplicate-Subtrees\" class=\"headerlink\" title=\"652. Find Duplicate Subtrees\"></a><a href=\"https://leetcode.com/problems/find-duplicate-subtrees/\" target=\"_blank\" rel=\"noopener\">652. Find Duplicate Subtrees</a></h3><h4 id=\"找到重复的子树结构，相同子树返回任意节点。\"><a href=\"#找到重复的子树结构，相同子树返回任意节点。\" class=\"headerlink\" title=\"找到重复的子树结构，相同子树返回任意节点。\"></a>找到重复的子树结构，相同子树返回任意节点。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: root &#x3D; [1,2,3,4,null,2,4,null,null,4]</span><br><span class=\"line\">Output: [[2,4],[4]]</span><br></pre></td></tr></table></figure>\n<p>方法一：序列化+哈希。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findDuplicateSubtrees</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; List[TreeNode]:</span></span><br><span class=\"line\">    g = &#123;&#125;</span><br><span class=\"line\">    res = &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">'#'</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            left = dfs(node.left)</span><br><span class=\"line\">            right = dfs(node.right)</span><br><span class=\"line\">            cur = left + <span class=\"string\">','</span> + right + <span class=\"string\">','</span> + str(node.val)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> cur <span class=\"keyword\">in</span> g:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> cur <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> res:</span><br><span class=\"line\">                    res[cur] = node</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                g[cur] = node</span><br><span class=\"line\">            <span class=\"keyword\">return</span> cur</span><br><span class=\"line\"></span><br><span class=\"line\">    dfs(root)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list(res.values())</span><br></pre></td></tr></table></figure>\n<p>方法二：使用三元组，这里的defaultdict写法很独特。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findDuplicateSubtrees</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; List[TreeNode]:</span></span><br><span class=\"line\">    trees = defaultdict()</span><br><span class=\"line\">    trees.default_factory = trees.__len__</span><br><span class=\"line\">    c = Counter()</span><br><span class=\"line\">    res = []</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            uid = trees[(node.val, dfs(node.left), dfs(node.right))]    </span><br><span class=\"line\">            c[uid] += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> c[uid] == <span class=\"number\">2</span>:</span><br><span class=\"line\">                res.append(node)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> uid</span><br><span class=\"line\">    dfs(root)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"1028-Recover-a-Tree-From-Preorder-Traversal\"><a href=\"#1028-Recover-a-Tree-From-Preorder-Traversal\" class=\"headerlink\" title=\"1028. Recover a Tree From Preorder Traversal\"></a><a href=\"https://leetcode.com/problems/recover-a-tree-from-preorder-traversal/\" target=\"_blank\" rel=\"noopener\">1028. Recover a Tree From Preorder Traversal</a></h3><h4 id=\"通过前序遍历重建二叉树。\"><a href=\"#通过前序遍历重建二叉树。\" class=\"headerlink\" title=\"通过前序遍历重建二叉树。\"></a>通过前序遍历重建二叉树。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: S &#x3D; &quot;1-2--3--4-5--6--7&quot;</span><br><span class=\"line\">Output: [1,2,5,3,4,6,7]</span><br></pre></td></tr></table></figure>\n<p>方法一：迭代。使用一个栈来辅助。当栈长度大于深度时，将子节点出栈。然后优先安装左子节点。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">recoverFromPreorder</span><span class=\"params\">(self, S: str)</span> -&gt; TreeNode:</span></span><br><span class=\"line\">    stack, i, n = [], <span class=\"number\">0</span>, len(S)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> i &lt; n:</span><br><span class=\"line\">        lv, val = <span class=\"number\">0</span>, <span class=\"string\">''</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i&lt;n <span class=\"keyword\">and</span> S[i]==<span class=\"string\">'-'</span>:</span><br><span class=\"line\">            lv, i = lv+<span class=\"number\">1</span>, i+<span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i&lt;n <span class=\"keyword\">and</span> S[i]!=<span class=\"string\">'-'</span>:</span><br><span class=\"line\">            val, i = val+S[i], i+<span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> len(stack) &gt; lv:</span><br><span class=\"line\">            stack.pop()</span><br><span class=\"line\">        node = TreeNode(val)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> stack <span class=\"keyword\">and</span> stack[<span class=\"number\">-1</span>].left <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            stack[<span class=\"number\">-1</span>].left = node</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> stack:</span><br><span class=\"line\">            stack[<span class=\"number\">-1</span>].right = node</span><br><span class=\"line\">        stack.append(node)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stack[<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n","categories":["算法"],"tags":["LeetCode","Python","Algorithm","Math"]},{"title":"LeetCode算法题整理（动态规划篇）Danymic Programming","url":"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AF%87%EF%BC%89Danymic-Programming/","content":"<h3 id=\"70-Climbing-Stairs\"><a href=\"#70-Climbing-Stairs\" class=\"headerlink\" title=\"70. Climbing Stairs\"></a>70. Climbing Stairs</h3><h4 id=\"爬楼梯，一次可以爬一阶或两阶楼梯，爬上n阶楼梯有多少种方法？原题\"><a href=\"#爬楼梯，一次可以爬一阶或两阶楼梯，爬上n阶楼梯有多少种方法？原题\" class=\"headerlink\" title=\"爬楼梯，一次可以爬一阶或两阶楼梯，爬上n阶楼梯有多少种方法？原题\"></a>爬楼梯，一次可以爬一阶或两阶楼梯，爬上n阶楼梯有多少种方法？<a href=\"https://leetcode.com/problems/climbing-stairs/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><a id=\"more\"></a>\n<p>斐波那契问题</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fibonacci</span><span class=\"params\">(n)</span>:</span></span><br><span class=\"line\">    a = b = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n<span class=\"number\">-1</span>):</span><br><span class=\"line\">        a, b = b, a+b</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b</span><br></pre></td></tr></table></figure>\n<h3 id=\"746-Min-Cost-Climbing-Stairs\"><a href=\"#746-Min-Cost-Climbing-Stairs\" class=\"headerlink\" title=\"746. Min Cost Climbing Stairs\"></a>746. Min Cost Climbing Stairs</h3><h4 id=\"楼梯上每层写了到达该层的卡路里，求上到顶层消耗的最小卡路里。原题\"><a href=\"#楼梯上每层写了到达该层的卡路里，求上到顶层消耗的最小卡路里。原题\" class=\"headerlink\" title=\"楼梯上每层写了到达该层的卡路里，求上到顶层消耗的最小卡路里。原题\"></a>楼梯上每层写了到达该层的卡路里，求上到顶层消耗的最小卡路里。<a href=\"https://leetcode.com/problems/min-cost-climbing-stairs/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: cost &#x3D; [10, 15, 20]</span><br><span class=\"line\">Output: 15</span><br><span class=\"line\">Explanation: Cheapest is start on cost[1], pay that cost and go to the top.</span><br><span class=\"line\"></span><br><span class=\"line\">Input: cost &#x3D; [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</span><br><span class=\"line\">Output: 6</span><br><span class=\"line\">Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].</span><br></pre></td></tr></table></figure>\n<p>方法一：the final cost <code>f[i]</code> to climb the staircase from some step <code>i</code>is <code>f[i] = cost[i] + min(f[i+1], f[i+2])</code>。到达一层有两种选择，一种是上一层，一种是上两层。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minCostClimbingStairs</span><span class=\"params\">(self, cost: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    f1 = f2 = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> reversed(cost):</span><br><span class=\"line\">        f1, f2 = min(f1, f2) + x, f1</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min(f1, f2)</span><br></pre></td></tr></table></figure>\n<h3 id=\"121-Best-Time-to-Buy-and-Sell-Stock\"><a href=\"#121-Best-Time-to-Buy-and-Sell-Stock\" class=\"headerlink\" title=\"121. Best Time to Buy and Sell Stock\"></a>121. Best Time to Buy and Sell Stock</h3><h4 id=\"买入卖出最大收益。原题\"><a href=\"#买入卖出最大收益。原题\" class=\"headerlink\" title=\"买入卖出最大收益。原题\"></a>买入卖出最大收益。<a href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [7,1,5,3,6,4]</span><br><span class=\"line\">Output: 5</span><br><span class=\"line\">Explanation: Buy on day 2 (price &#x3D; 1) and sell on day 5 (price &#x3D; 6), profit &#x3D; 6-1 &#x3D; 5.</span><br><span class=\"line\">             Not 7-1 &#x3D; 6, as selling price needs to be larger than buying price.</span><br></pre></td></tr></table></figure>\n<p>方法一：Brute Force.其实就是求最高峰点和前面最低谷点的差。</p>\n<img src=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AF%87%EF%BC%89Danymic-Programming/121_profit_graph.png\" class>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxProfit</span><span class=\"params\">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    ans, min_buy = <span class=\"number\">0</span>, float(<span class=\"string\">'inf'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> price <span class=\"keyword\">in</span> prices:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> price &lt; min_buy:</span><br><span class=\"line\">            min_buy = price</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> price-min_buy &gt; ans:</span><br><span class=\"line\">            ans = price - min_buy</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：标准的卡登算法。此题为53.连续数组最大和的变形，如果价格比之前小，则舍弃，否则一起计算连续子数组的和。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxProfit</span><span class=\"params\">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    cur = sofar = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(prices)):</span><br><span class=\"line\">        cur += prices[i] - prices[i<span class=\"number\">-1</span>]</span><br><span class=\"line\">        cur = max(<span class=\"number\">0</span>, cur)</span><br><span class=\"line\">        sofar = max(cur, sofar)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sofar</span><br></pre></td></tr></table></figure>\n<h3 id=\"122-Best-Time-to-Buy-and-Sell-Stock-II\"><a href=\"#122-Best-Time-to-Buy-and-Sell-Stock-II\" class=\"headerlink\" title=\"122. Best Time to Buy and Sell Stock II\"></a>122. Best Time to Buy and Sell Stock II</h3><h4 id=\"买入卖出，允许多次交易。原题\"><a href=\"#买入卖出，允许多次交易。原题\" class=\"headerlink\" title=\"买入卖出，允许多次交易。原题\"></a>买入卖出，允许多次交易。<a href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [7,1,5,3,6,4]</span><br><span class=\"line\">Output: 7</span><br><span class=\"line\">Explanation: Buy on day 2 (price &#x3D; 1) and sell on day 3 (price &#x3D; 5), profit &#x3D; 5-1 &#x3D; 4.</span><br><span class=\"line\">             Then buy on day 4 (price &#x3D; 3) and sell on day 5 (price &#x3D; 6), profit &#x3D; 6-3 &#x3D; 3.</span><br></pre></td></tr></table></figure>\n<p>思路：比较每两天的价格，如果是涨价了，那就把收益计算进去，否则不出手交易。</p>\n<img src=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AF%87%EF%BC%89Danymic-Programming/122_maxprofit.png\" class>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">max_profit</span><span class=\"params\">(prices)</span>:</span></span><br><span class=\"line\">    profit = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(prices)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> prices[i] &gt; prices[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">            profit += prices[i] - prices[i<span class=\"number\">-1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> profit</span><br></pre></td></tr></table></figure>\n<p>方法二：pairwise.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxProfit</span><span class=\"params\">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    t, y = itertools.tee(prices)</span><br><span class=\"line\">    next(t, <span class=\"literal\">None</span>)</span><br><span class=\"line\">    profit = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> p1, p2 <span class=\"keyword\">in</span> zip(t, y):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> p1 &gt; p2:</span><br><span class=\"line\">            profit += p1-p2</span><br><span class=\"line\">    <span class=\"keyword\">return</span> profit</span><br></pre></td></tr></table></figure>\n<h3 id=\"714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee\"><a href=\"#714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee\" class=\"headerlink\" title=\"714. Best Time to Buy and Sell Stock with Transaction Fee\"></a><a href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/\" target=\"_blank\" rel=\"noopener\">714. Best Time to Buy and Sell Stock with Transaction Fee</a></h3><h4 id=\"和122比较像，区别在于每次交易时有一定的手续费。\"><a href=\"#和122比较像，区别在于每次交易时有一定的手续费。\" class=\"headerlink\" title=\"和122比较像，区别在于每次交易时有一定的手续费。\"></a>和122比较像，区别在于每次交易时有一定的手续费。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: prices &#x3D; [1, 3, 2, 8, 4, 9], fee &#x3D; 2</span><br><span class=\"line\">Output: 8</span><br><span class=\"line\">Explanation: The maximum profit can be achieved by:</span><br><span class=\"line\">Buying at prices[0] &#x3D; 1Selling at prices[3] &#x3D; 8</span><br><span class=\"line\">Buying at prices[4] &#x3D; 4Selling at prices[5] &#x3D; 9</span><br><span class=\"line\">The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) &#x3D; 8.</span><br></pre></td></tr></table></figure>\n<p>方法一：dp。和抢房子有点像。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxProfit</span><span class=\"params\">(self, prices: List[int], fee: int)</span> -&gt; int:</span></span><br><span class=\"line\">    hold, unhold = -inf, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, price <span class=\"keyword\">in</span> enumerate(prices):</span><br><span class=\"line\">        unhold, hold = max(unhold, hold+price-fee), max(hold, unhold-price)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unhold</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：想到了贪心方法，但没写出具体代码，思路是这样的，把交易费和买入价算到一起。买了之后肯定回去卖。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxProfit</span><span class=\"params\">(self, prices: List[int], fee: int)</span> -&gt; int:</span></span><br><span class=\"line\">    profit = <span class=\"number\">0</span></span><br><span class=\"line\">    buy = prices[<span class=\"number\">0</span>] + fee</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(prices)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> prices[i] + fee &lt; buy:</span><br><span class=\"line\">            buy = prices[i] + fee</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> prices[i] &gt; buy:</span><br><span class=\"line\">            profit += prices[i] - buy</span><br><span class=\"line\">            buy = prices[i]  <span class=\"comment\"># 这里不能+buy，因为连续升高的股价，只需要卖一次即可</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> profit</span><br></pre></td></tr></table></figure>\n<h3 id=\"Best-Time-to-Buy-and-Sell-Stock-III\"><a href=\"#Best-Time-to-Buy-and-Sell-Stock-III\" class=\"headerlink\" title=\"Best Time to Buy and Sell Stock III\"></a>Best Time to Buy and Sell Stock III</h3><h4 id=\"最多允许交易两次。原题\"><a href=\"#最多允许交易两次。原题\" class=\"headerlink\" title=\"最多允许交易两次。原题\"></a>最多允许交易两次。<a href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>先从左到右按照一次交易计算每天的利润。然后按照从右到左，判断如果进行第二次交易，最大的利润。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxProfit</span><span class=\"params\">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    min_buy = float(<span class=\"string\">'inf'</span>)</span><br><span class=\"line\">    profits = []</span><br><span class=\"line\">    max_profit = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> prices:</span><br><span class=\"line\">        min_buy = min(min_buy, p)</span><br><span class=\"line\">        max_profit = max(max_profit, p-min_buy)</span><br><span class=\"line\">        profits.append(max_profit)</span><br><span class=\"line\">    </span><br><span class=\"line\">    max_profit = <span class=\"number\">0</span></span><br><span class=\"line\">    total_profit = <span class=\"number\">0</span></span><br><span class=\"line\">    max_sell = float(<span class=\"string\">'-inf'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(prices)<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">        max_sell = max(max_sell, prices[i])</span><br><span class=\"line\">        max_profit = max(max_profit, max_sell-prices[i])</span><br><span class=\"line\">        total_profit = max(total_profit, max_profit+profits[i])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> total_profit</span><br></pre></td></tr></table></figure>\n<h3 id=\"188-Best-Time-to-Buy-and-Sell-Stock-IV\"><a href=\"#188-Best-Time-to-Buy-and-Sell-Stock-IV\" class=\"headerlink\" title=\"188. Best Time to Buy and Sell Stock IV\"></a><a href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/\" target=\"_blank\" rel=\"noopener\">188. Best Time to Buy and Sell Stock IV</a></h3><h4 id=\"最多允许交易K次。\"><a href=\"#最多允许交易K次。\" class=\"headerlink\" title=\"最多允许交易K次。\"></a>最多允许交易K次。</h4><p>方法一：三维dp数组。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxProfit</span><span class=\"params\">(self, k: int, prices: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    N = len(prices)</span><br><span class=\"line\">    <span class=\"comment\"># dp[i][j][0]表示prices[:i]进行j次交易后最后是卖出的最大利润</span></span><br><span class=\"line\">    <span class=\"comment\"># dp[i][j][1]表示prices[:i]进行j次交易后最后是买入的最大利润</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> k &gt;= N//<span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum(b-a <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> zip(prices, prices[<span class=\"number\">1</span>:]) <span class=\"keyword\">if</span> b&gt;a)</span><br><span class=\"line\">    dp = [[[<span class=\"number\">0</span>, <span class=\"number\">0</span>] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(k+<span class=\"number\">1</span>)] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(N)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, k+<span class=\"number\">1</span>):</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][j][<span class=\"number\">0</span>] = <span class=\"number\">0</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][j][<span class=\"number\">1</span>] = -prices[<span class=\"number\">0</span>]  <span class=\"comment\"># 以第一天的股票价格买入方便后续处理数据</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, p <span class=\"keyword\">in</span> enumerate(prices[<span class=\"number\">1</span>:], <span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, k+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"comment\"># 假设买入时增加一次交易</span></span><br><span class=\"line\">            dp[i][j][<span class=\"number\">0</span>] = max(dp[i<span class=\"number\">-1</span>][j][<span class=\"number\">1</span>]+p, dp[i<span class=\"number\">-1</span>][j][<span class=\"number\">0</span>])</span><br><span class=\"line\">            dp[i][j][<span class=\"number\">1</span>] = max(dp[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>][<span class=\"number\">0</span>]-p, dp[i<span class=\"number\">-1</span>][j][<span class=\"number\">1</span>])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[<span class=\"number\">-1</span>][<span class=\"number\">-1</span>][<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown\"><a href=\"#309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown\" class=\"headerlink\" title=\"309. Best Time to Buy and Sell Stock with Cooldown\"></a>309. Best Time to Buy and Sell Stock with Cooldown</h3><h4 id=\"每次买卖股票后有一天的冷却期什么也不能干。原题\"><a href=\"#每次买卖股票后有一天的冷却期什么也不能干。原题\" class=\"headerlink\" title=\"每次买卖股票后有一天的冷却期什么也不能干。原题\"></a>每次买卖股票后有一天的冷却期什么也不能干。<a href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：3个状态，5中状态转换。 </p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxProfit</span><span class=\"params\">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"comment\"># hold -&gt; do_nothing -&gt; hold</span></span><br><span class=\"line\">    <span class=\"comment\"># hold -&gt; sell -&gt; not_hold_cd</span></span><br><span class=\"line\">    <span class=\"comment\"># not_hold -&gt; do_nothing -&gt; not_hold</span></span><br><span class=\"line\">    <span class=\"comment\"># not_hold -&gt; buy -&gt; hold</span></span><br><span class=\"line\">    <span class=\"comment\"># not_hold_cd -&gt; do_nothing -&gt; not_hold</span></span><br><span class=\"line\">    not_hold, hold, not_hold_cd = <span class=\"number\">0</span>, float(<span class=\"string\">'-inf'</span>), float(<span class=\"string\">'-inf'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> price <span class=\"keyword\">in</span> prices:</span><br><span class=\"line\">        hold, not_hold, not_hold_cd = max(hold, not_hold-price), max(not_hold, not_hold_cd), hold+price</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(not_hold, not_hold_cd)</span><br></pre></td></tr></table></figure>\n<h4 id=\"LCP-19-秋叶收藏集\"><a href=\"#LCP-19-秋叶收藏集\" class=\"headerlink\" title=\"LCP 19. 秋叶收藏集\"></a><a href=\"https://leetcode-cn.com/problems/UlBDOe/\" target=\"_blank\" rel=\"noopener\">LCP 19. 秋叶收藏集</a></h4><h4 id=\"杯赛里的题，说将字符串替换成r-y-r-的形式，最少需要多少步。原题\"><a href=\"#杯赛里的题，说将字符串替换成r-y-r-的形式，最少需要多少步。原题\" class=\"headerlink\" title=\"杯赛里的题，说将字符串替换成r*y*r*的形式，最少需要多少步。原题\"></a>杯赛里的题，说将字符串替换成<code>r*y*r*</code>的形式，最少需要多少步。<a href=\"https://leetcode-cn.com/problems/UlBDOe/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：和309非常相似，记录3种状态。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minimumOperations</span><span class=\"params\">(self, leaves: str)</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"comment\"># r 代表当前位置是 r* 型的替换次数</span></span><br><span class=\"line\">    <span class=\"comment\"># ry 代表当前位置是 r*y* 型的替换次数</span></span><br><span class=\"line\">    <span class=\"comment\"># ryr 分别代表当前位置是 r*y*r* 型的替换次数</span></span><br><span class=\"line\">    r, ry, ryr = int(leaves[<span class=\"number\">0</span>] == <span class=\"string\">'y'</span>), float(<span class=\"string\">'inf'</span>), float(<span class=\"string\">'inf'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(leaves)):</span><br><span class=\"line\">        x = int(leaves[i] == <span class=\"string\">'y'</span>)</span><br><span class=\"line\">        r, ry, ryr = r+x, min(r, ry)+(<span class=\"number\">1</span>-x), min(ry, ryr)+x</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ryr</span><br></pre></td></tr></table></figure>\n<h3 id=\"198-House-Robber\"><a href=\"#198-House-Robber\" class=\"headerlink\" title=\"198. House Robber\"></a>198. House Robber</h3><h4 id=\"抢劫房子问题。不能连续抢劫两个挨着的房间。原题\"><a href=\"#抢劫房子问题。不能连续抢劫两个挨着的房间。原题\" class=\"headerlink\" title=\"抢劫房子问题。不能连续抢劫两个挨着的房间。原题\"></a>抢劫房子问题。不能连续抢劫两个挨着的房间。<a href=\"https://leetcode.com/problems/house-robber\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [2,7,9,3,1]</span><br><span class=\"line\">Output: 12</span><br><span class=\"line\">Explanation: Rob house 1 (money &#x3D; 2), rob house 3 (money &#x3D; 9) and rob house 5 (money &#x3D; 1).</span><br><span class=\"line\">             Total amount you can rob &#x3D; 2 + 9 + 1 &#x3D; 12.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">f(0) &#x3D; nums[0]</span><br><span class=\"line\">f(1) &#x3D; max(num[0], num[1])</span><br><span class=\"line\">f(k) &#x3D; max( f(k-2) + nums[k], f(k-1) )</span><br></pre></td></tr></table></figure>\n<p><del>方法一：递归，超时。</del></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rob</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> nums:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(nums) &lt;= <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(nums[<span class=\"number\">0</span>]+self.rob(nums[<span class=\"number\">2</span>:]), </span><br><span class=\"line\">               self.rob(nums[<span class=\"number\">1</span>:]))</span><br></pre></td></tr></table></figure>\n<p>方法二：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rob</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">    last, now = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        last, now = now, max(last+num, now)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> now</span><br></pre></td></tr></table></figure>\n<h3 id=\"213-House-Robber-II\"><a href=\"#213-House-Robber-II\" class=\"headerlink\" title=\"213. House Robber II\"></a>213. House Robber II</h3><h4 id=\"与上题不同的是，所有的房子连成一个环。原题\"><a href=\"#与上题不同的是，所有的房子连成一个环。原题\" class=\"headerlink\" title=\"与上题不同的是，所有的房子连成一个环。原题\"></a>与上题不同的是，所有的房子连成一个环。<a href=\"https://leetcode.com/problems/house-robber-ii/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">nput: [2,3,2]</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: You cannot rob house 1 (money &#x3D; 2) and then rob house 3 (money &#x3D; 2),</span><br><span class=\"line\">             because they are adjacent houses.</span><br></pre></td></tr></table></figure>\n<p>方法一：注意nums长度为1的情况。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rob</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">robber</span><span class=\"params\">(nums)</span>:</span></span><br><span class=\"line\">        last = now = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">            last, now = now, max(last+num, now)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> now</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(robber(nums[:<span class=\"number\">-1</span>]), robber(nums[len(nums)!=<span class=\"number\">1</span>:]))</span><br></pre></td></tr></table></figure>\n<h3 id=\"303-Range-Sum-Query-Immutable\"><a href=\"#303-Range-Sum-Query-Immutable\" class=\"headerlink\" title=\"303. Range Sum Query - Immutable\"></a>303. Range Sum Query - Immutable</h3><h4 id=\"给定一个数组，计算索引i-j之间的和。原题\"><a href=\"#给定一个数组，计算索引i-j之间的和。原题\" class=\"headerlink\" title=\"给定一个数组，计算索引i, j之间的和。原题\"></a>给定一个数组，计算索引<code>i, j</code>之间的和。<a href=\"https://leetcode.com/problems/range-sum-query-immutable/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Given nums &#x3D; [-2, 0, 3, -5, 2, -1]</span><br><span class=\"line\"></span><br><span class=\"line\">sumRange(0, 2) -&gt; 1</span><br><span class=\"line\">sumRange(2, 5) -&gt; -1</span><br><span class=\"line\">sumRange(0, 5) -&gt; -3</span><br></pre></td></tr></table></figure>\n<p>思路：如果单纯采用切片计算，效率过低，题中要求sumRange调用多次。所以这里采用动态规划。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NumArray</span>:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># self.sum_item = [0]</span></span><br><span class=\"line\">        <span class=\"comment\"># for num in nums:</span></span><br><span class=\"line\">        <span class=\"comment\">#     self.sum_item.append(self.sum_item[-1] + num)</span></span><br><span class=\"line\">        <span class=\"keyword\">from</span> itertools <span class=\"keyword\">import</span> accumulate</span><br><span class=\"line\">        <span class=\"keyword\">from</span> operator <span class=\"keyword\">import</span> add</span><br><span class=\"line\">        self.sum_item = list(accumulate(nums, add))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sumRange</span><span class=\"params\">(self, i, j)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># return self.sum_item[j+1] - self.sum_item[i] </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.sum_item[j] - self.sum_item[i<span class=\"number\">-1</span>] <span class=\"keyword\">if</span> i &gt; <span class=\"number\">0</span> <span class=\"keyword\">else</span> self.sum_item[j]</span><br></pre></td></tr></table></figure>\n<h3 id=\"91-Decode-Ways\"><a href=\"#91-Decode-Ways\" class=\"headerlink\" title=\"91. Decode Ways\"></a>91. Decode Ways</h3><h4 id=\"将数字翻译成字母有多少种方式。原题\"><a href=\"#将数字翻译成字母有多少种方式。原题\" class=\"headerlink\" title=\"将数字翻译成字母有多少种方式。原题\"></a>将数字翻译成字母有多少种方式。<a href=\"https://leetcode.com/problems/decode-ways/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: &quot;226&quot;</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: It could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6).</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numDecodings</span><span class=\"params\">(self, s: str)</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"comment\"># w tells the number of ways</span></span><br><span class=\"line\">    <span class=\"comment\"># v tells the previous number of ways</span></span><br><span class=\"line\">    <span class=\"comment\"># d is the current digit</span></span><br><span class=\"line\">    <span class=\"comment\"># p is the previous digit</span></span><br><span class=\"line\">    v, w, p = <span class=\"number\">0</span>, int(s&gt;<span class=\"string\">''</span>), <span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">        v, w, p = w, int(d&gt;<span class=\"string\">'0'</span>)*w + (<span class=\"number\">9</span>&lt;int(p+d)&lt;<span class=\"number\">27</span>)*v, d</span><br><span class=\"line\">    <span class=\"keyword\">return</span> w</span><br></pre></td></tr></table></figure>\n<h3 id=\"62-Unique-Paths\"><a href=\"#62-Unique-Paths\" class=\"headerlink\" title=\"62. Unique Paths\"></a>62. Unique Paths</h3><h4 id=\"一个矩阵中，从左上走到右下有多少种不同走法，每次只能向右或向下移动。原题\"><a href=\"#一个矩阵中，从左上走到右下有多少种不同走法，每次只能向右或向下移动。原题\" class=\"headerlink\" title=\"一个矩阵中，从左上走到右下有多少种不同走法，每次只能向右或向下移动。原题\"></a>一个矩阵中，从左上走到右下有多少种不同走法，每次只能向右或向下移动。<a href=\"https://leetcode.com/problems/unique-paths/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><img src=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AF%87%EF%BC%89Danymic-Programming/robot_maze.png\" class>\n<p>方法一：构建二维矩阵。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">uniquePaths</span><span class=\"params\">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class=\"line\">    g = [[<span class=\"number\">0</span>] * m <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(m):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i==<span class=\"number\">0</span> <span class=\"keyword\">or</span> j==<span class=\"number\">0</span>:</span><br><span class=\"line\">                g[i][j] = <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                g[i][j] = g[i<span class=\"number\">-1</span>][j] + g[i][j<span class=\"number\">-1</span>]</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> g[<span class=\"number\">-1</span>][<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：二维数组时没有必要的，仔细观察发现每层都是累计的关系，<code>accumulate</code>为此而生。</font>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[1,  1,  1,   1,   1,   1,   1]</span><br><span class=\"line\">[1,  2,  3,   4,   5,   6,   7]</span><br><span class=\"line\">[1,  3,  6,  10,  15,  21,  28]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">uniquePaths</span><span class=\"params\">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class=\"line\">    row = [<span class=\"number\">1</span>] * m</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n<span class=\"number\">-1</span>):</span><br><span class=\"line\">        row = itertools.accumulate(row)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list(row)[<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"63-Unique-Paths-II\"><a href=\"#63-Unique-Paths-II\" class=\"headerlink\" title=\"63. Unique Paths II\"></a>63. Unique Paths II</h3><h4 id=\"和62一样，不同的是中间加了障碍1。原题\"><a href=\"#和62一样，不同的是中间加了障碍1。原题\" class=\"headerlink\" title=\"和62一样，不同的是中间加了障碍1。原题\"></a>和62一样，不同的是中间加了障碍<code>1</code>。<a href=\"https://leetcode.com/problems/unique-paths-ii/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [0,0,0],</span><br><span class=\"line\">  [0,1,0],</span><br><span class=\"line\">  [0,0,0]</span><br><span class=\"line\">]</span><br><span class=\"line\">Output: 2</span><br></pre></td></tr></table></figure>\n<p>方法一：首次AC的方法，这里采用先遍历一次记录障碍，然后初始化首行和首列，最后再求解的过程。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">uniquePathsWithObstacles</span><span class=\"params\">(self, g: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    R, C = len(g), len(g[<span class=\"number\">0</span>])</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(R):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(C):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> g[i][j] == <span class=\"number\">1</span>:</span><br><span class=\"line\">                g[i][j] = <span class=\"number\">-1</span></span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(R):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> g[i][<span class=\"number\">0</span>] != <span class=\"number\">-1</span>:</span><br><span class=\"line\">            g[i][<span class=\"number\">0</span>] = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(C):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> g[<span class=\"number\">0</span>][j] != <span class=\"number\">-1</span>:</span><br><span class=\"line\">            g[<span class=\"number\">0</span>][j] = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, R):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, C):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> g[i][j] == <span class=\"number\">-1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                up = g[i<span class=\"number\">-1</span>][j] <span class=\"keyword\">if</span> g[i<span class=\"number\">-1</span>][j]!=<span class=\"number\">-1</span> <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br><span class=\"line\">                left = g[i][j<span class=\"number\">-1</span>] <span class=\"keyword\">if</span> g[i][j<span class=\"number\">-1</span>]!=<span class=\"number\">-1</span> <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br><span class=\"line\">                g[i][j] = up + left</span><br><span class=\"line\">                </span><br><span class=\"line\">    <span class=\"comment\"># print(g)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> g[<span class=\"number\">-1</span>][<span class=\"number\">-1</span>] <span class=\"keyword\">if</span> g[<span class=\"number\">-1</span>][<span class=\"number\">-1</span>] != <span class=\"number\">-1</span> <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<p>方法二：想错了一件事情，我根本不需要去单独的设置障碍值，在遍历的时候就可以根据0来判断。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">uniquePathsWithObstacles</span><span class=\"params\">(self, g: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    R, C = len(g), len(g[<span class=\"number\">0</span>])</span><br><span class=\"line\">    <span class=\"keyword\">if</span> g[<span class=\"number\">0</span>][<span class=\"number\">0</span>] == <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    g[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, C):</span><br><span class=\"line\">        g[<span class=\"number\">0</span>][i] = int(g[<span class=\"number\">0</span>][i<span class=\"number\">-1</span>]==<span class=\"number\">1</span> <span class=\"keyword\">and</span> g[<span class=\"number\">0</span>][i]==<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, R):</span><br><span class=\"line\">        g[j][<span class=\"number\">0</span>] = int(g[j<span class=\"number\">-1</span>][<span class=\"number\">0</span>]==<span class=\"number\">1</span> <span class=\"keyword\">and</span> g[j][<span class=\"number\">0</span>]==<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, R):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, C):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> g[i][j] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                g[i][j] = g[i<span class=\"number\">-1</span>][j] + g[i][j<span class=\"number\">-1</span>]</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                g[i][j] = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> g[<span class=\"number\">-1</span>][<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"120-Triangle\"><a href=\"#120-Triangle\" class=\"headerlink\" title=\"120. Triangle\"></a>120. Triangle</h3><h4 id=\"三角形从上到下最小路径。原题\"><a href=\"#三角形从上到下最小路径。原题\" class=\"headerlink\" title=\"三角形从上到下最小路径。原题\"></a>三角形从上到下最小路径。<a href=\"https://leetcode.com/problems/triangle/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">     [2],</span><br><span class=\"line\">    [3,4],</span><br><span class=\"line\">   [6,5,7],</span><br><span class=\"line\">  [4,1,8,3]</span><br><span class=\"line\">]</span><br><span class=\"line\">i.e., 2 + 3 + 5 + 1 &#x3D; 11</span><br></pre></td></tr></table></figure>\n<p>方法一：我这里使用了一个嵌套的字典保存每一行的累计最小值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minimumTotal</span><span class=\"params\">(self, t: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> t:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> defaultdict</span><br><span class=\"line\">    dp = defaultdict(<span class=\"keyword\">lambda</span>: defaultdict(<span class=\"keyword\">lambda</span>: float(<span class=\"string\">'inf'</span>)))</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = t[<span class=\"number\">0</span>][<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, row <span class=\"keyword\">in</span> enumerate(t[<span class=\"number\">1</span>:], <span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j, num <span class=\"keyword\">in</span> enumerate(row):</span><br><span class=\"line\">            dp[i][j] = min(dp[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>], dp[i<span class=\"number\">-1</span>][j]) + t[i][j]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min(dp[len(t)<span class=\"number\">-1</span>].values())</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：在原数组上修改，空间复杂度O(1). </font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minimumTotal</span><span class=\"params\">(self, t: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(t)<span class=\"number\">-2</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i+<span class=\"number\">1</span>):</span><br><span class=\"line\">            t[i][j] += min(t[i+<span class=\"number\">1</span>][j], t[i+<span class=\"number\">1</span>][j+<span class=\"number\">1</span>])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t[<span class=\"number\">0</span>][<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：错位相加大法。空间复杂度O(n)</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minimumTotal</span><span class=\"params\">(self, t: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">combine_rows</span><span class=\"params\">(lower_row, upper_row)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> [upper + min(lower_left, lower_right)</span><br><span class=\"line\">                <span class=\"keyword\">for</span> upper, lower_left, lower_right <span class=\"keyword\">in</span> </span><br><span class=\"line\">                zip(upper_row, lower_row, islice(lower_row, <span class=\"number\">1</span>, <span class=\"literal\">None</span>))]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> reduce(combine_rows, reversed(t))[<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n<p>方法四：我按照方法三实现了一个纯的生成器版本。<code>iter</code>是防止t中只有一行的情况。这里我不确定是否将空间复杂度降低到了O(1)。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minimumTotal</span><span class=\"params\">(self, t: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">combine_rows</span><span class=\"params\">(lower_row, upper_row)</span>:</span></span><br><span class=\"line\">        lower_row, lower_row_nxt = tee(lower_row)</span><br><span class=\"line\">        next(lower_row_nxt, <span class=\"literal\">None</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (upper + min(lower_left, lower_right)</span><br><span class=\"line\">                <span class=\"keyword\">for</span> upper, lower_left, lower_right <span class=\"keyword\">in</span> </span><br><span class=\"line\">                zip(upper_row, lower_row, lower_row_nxt))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> next(iter(reduce(combine_rows, reversed(t))))</span><br></pre></td></tr></table></figure>\n<h3 id=\"931-Minimum-Falling-Path-Sum\"><a href=\"#931-Minimum-Falling-Path-Sum\" class=\"headerlink\" title=\"931. Minimum Falling Path Sum\"></a>931. Minimum Falling Path Sum</h3><h4 id=\"和120相似，不过形状变成了矩形。原题\"><a href=\"#和120相似，不过形状变成了矩形。原题\" class=\"headerlink\" title=\"和120相似，不过形状变成了矩形。原题\"></a>和120相似，不过形状变成了矩形。<a href=\"https://leetcode.com/problems/minimum-falling-path-sum/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class=\"line\">Output: 12</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">The possible falling paths are:</span><br></pre></td></tr></table></figure>\n<p>方法一：常规写法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minFallingPathSum</span><span class=\"params\">(self, A: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    R, C = len(A), len(A[<span class=\"number\">0</span>])</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(R<span class=\"number\">-2</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(C):</span><br><span class=\"line\">            path = slice(max(<span class=\"number\">0</span>, j<span class=\"number\">-1</span>), min(C, j+<span class=\"number\">2</span>))</span><br><span class=\"line\">            A[i][j] += min(A[i+<span class=\"number\">1</span>][path])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min(A[<span class=\"number\">0</span>])</span><br></pre></td></tr></table></figure>\n<p>方法二：错位计算的方式，这个比120三角形的要复杂一点。需要填充无穷大来使生效。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minFallingPathSum</span><span class=\"params\">(self, A: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> functools <span class=\"keyword\">import</span> reduce</span><br><span class=\"line\">    padding = [float(<span class=\"string\">'inf'</span>)]</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">combine_rows</span><span class=\"params\">(lower_row, upper_row)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> [upper + min(lower_left, lower_mid, lower_right)</span><br><span class=\"line\">                <span class=\"keyword\">for</span> upper, lower_left, lower_mid, lower_right <span class=\"keyword\">in</span></span><br><span class=\"line\">                zip(upper_row, lower_row[<span class=\"number\">1</span>:]+padding, lower_row, padding+lower_row[:<span class=\"number\">-1</span>])]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min(reduce(combine_rows, A[::<span class=\"number\">-1</span>]))</span><br></pre></td></tr></table></figure>\n<h3 id=\"1289-Minimum-Falling-Path-Sum-II\"><a href=\"#1289-Minimum-Falling-Path-Sum-II\" class=\"headerlink\" title=\"1289. Minimum Falling Path Sum II\"></a>1289. Minimum Falling Path Sum II</h3><h4 id=\"上题变形，每行找到非自己那列的元素。原题\"><a href=\"#上题变形，每行找到非自己那列的元素。原题\" class=\"headerlink\" title=\"上题变形，每行找到非自己那列的元素。原题\"></a>上题变形，每行找到非自己那列的元素。<a href=\"https://leetcode.com/problems/minimum-falling-path-sum-ii/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：用堆记录2个最小的值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minFallingPathSum</span><span class=\"params\">(self, arr: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    m, n = len(arr), len(arr[<span class=\"number\">0</span>])</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, m):</span><br><span class=\"line\">        r = heapq.nsmallest(<span class=\"number\">2</span>, arr[i<span class=\"number\">-1</span>])</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            arr[i][j] += r[<span class=\"number\">1</span>] <span class=\"keyword\">if</span> arr[i<span class=\"number\">-1</span>][j]==r[<span class=\"number\">0</span>] <span class=\"keyword\">else</span> r[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min(arr[<span class=\"number\">-1</span>])</span><br></pre></td></tr></table></figure>\n<h3 id=\"279-Perfect-Squares\"><a href=\"#279-Perfect-Squares\" class=\"headerlink\" title=\"279. Perfect Squares\"></a>279. Perfect Squares</h3><h4 id=\"完美平方，找出n的最少的能被几个平方数相加。原题\"><a href=\"#完美平方，找出n的最少的能被几个平方数相加。原题\" class=\"headerlink\" title=\"完美平方，找出n的最少的能被几个平方数相加。原题\"></a>完美平方，找出n的最少的能被几个平方数相加。<a href=\"https://leetcode.com/problems/perfect-squares/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 13</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: 13 &#x3D; 4 + 9.</span><br></pre></td></tr></table></figure>\n<p><code>f(n)表示n最少的个数。f(n)=min(f(n-1²), f(n-2²)...f(0)) + 1</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    _dp = [<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numSquares</span><span class=\"params\">(self, n: int)</span> -&gt; int:</span></span><br><span class=\"line\">        dp = self._dp</span><br><span class=\"line\">        <span class=\"keyword\">while</span> len(dp) &lt;= n:</span><br><span class=\"line\">            <span class=\"comment\"># dp.append(min(dp[len(dp)-i*i] for i in range(1, int(len(dp)**0.5+1))) + 1)</span></span><br><span class=\"line\">            dp.append(min(dp[-i*i] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, int(len(dp)**<span class=\"number\">0.5</span>+<span class=\"number\">1</span>))) + <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n]</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-Longest-Palindromic-Substring\"><a href=\"#5-Longest-Palindromic-Substring\" class=\"headerlink\" title=\"5. Longest Palindromic Substring\"></a>5. Longest Palindromic Substring</h3><h4 id=\"最长回文子字符串。原题\"><a href=\"#最长回文子字符串。原题\" class=\"headerlink\" title=\"最长回文子字符串。原题\"></a>最长回文子字符串。<a href=\"https://leetcode.com/problems/longest-palindromic-substring/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: &quot;babad&quot;</span><br><span class=\"line\">Output: &quot;bab&quot;</span><br><span class=\"line\">Note: &quot;aba&quot; is also a valid answer.</span><br></pre></td></tr></table></figure>\n<p>方法一：O(n²)的方法。非常低效的一个做法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(self, s: str)</span> -&gt; str:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">helper</span><span class=\"params\">(i, j)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &gt;=<span class=\"number\">0</span> <span class=\"keyword\">and</span> j &lt; len(s) <span class=\"keyword\">and</span> s[i]==s[j]:</span><br><span class=\"line\">            i -= <span class=\"number\">1</span></span><br><span class=\"line\">            j += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> s[i+<span class=\"number\">1</span>:j]  <span class=\"comment\"># 因为i, j是不相等的。</span></span><br><span class=\"line\">    <span class=\"comment\"># ans = ''</span></span><br><span class=\"line\">    <span class=\"comment\"># for i, c in enumerate(s):</span></span><br><span class=\"line\">    <span class=\"comment\">#     tmp = helper(i, i)</span></span><br><span class=\"line\">    <span class=\"comment\">#     if len(tmp) &gt; len(ans):</span></span><br><span class=\"line\">    <span class=\"comment\">#         ans = tmp</span></span><br><span class=\"line\">    <span class=\"comment\">#     tmp = helper(i, i+1)</span></span><br><span class=\"line\">    <span class=\"comment\">#     if len(tmp) &gt; len(ans):</span></span><br><span class=\"line\">    <span class=\"comment\">#         ans = tmp</span></span><br><span class=\"line\">    <span class=\"comment\"># return ans</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> s <span class=\"keyword\">and</span> max((a <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(s)) </span><br><span class=\"line\">                      <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> (helper(i, i), helper(i, i+<span class=\"number\">1</span>))), key=len) <span class=\"keyword\">or</span> <span class=\"string\">''</span></span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：这个方法很好。从前到后遍历字符，一种是奇数长度的回文串，是增加两个长度，另一种是偶数长度的回文串，是增加一个长度。每次从当前字符向前做切片，并根据当前的最大长度控制切片长度。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(self, s: str)</span> -&gt; str:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> s:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">''</span></span><br><span class=\"line\">    maxLen = <span class=\"number\">1</span></span><br><span class=\"line\">    start = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(s)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i-maxLen&gt;=<span class=\"number\">1</span> <span class=\"keyword\">and</span> s[i-maxLen<span class=\"number\">-1</span>:i+<span class=\"number\">1</span>]==s[i-maxLen<span class=\"number\">-1</span>:i+<span class=\"number\">1</span>][::<span class=\"number\">-1</span>]:</span><br><span class=\"line\">            start = i - maxLen - <span class=\"number\">1</span></span><br><span class=\"line\">            maxLen += <span class=\"number\">2</span></span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i-maxLen&gt;=<span class=\"number\">0</span> <span class=\"keyword\">and</span> s[i-maxLen:i+<span class=\"number\">1</span>]==s[i-maxLen:i+<span class=\"number\">1</span>][::<span class=\"number\">-1</span>]:</span><br><span class=\"line\">            <span class=\"comment\"># print(s[i-maxLen:i+1], s[i-maxLen:i+1][::-1])</span></span><br><span class=\"line\">            start = i - maxLen</span><br><span class=\"line\">            maxLen += <span class=\"number\">1</span> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> s[start:start+maxLen]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：马拉车算法。Time: O(n). </font>\n\n<p><a href=\"https://segmentfault.com/a/1190000003914228\" target=\"_blank\" rel=\"noopener\">算法详解。</a>这里是把一些情况做了整合。整个代码非常优雅。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(self, s: str)</span> -&gt; str:</span></span><br><span class=\"line\">    <span class=\"comment\"># Transform S into T.</span></span><br><span class=\"line\">    <span class=\"comment\"># For example, S = \"abba\", T = \"^#a#b#b#a#$\".</span></span><br><span class=\"line\">    <span class=\"comment\"># ^ and $ signs are sentinels appended to each end to avoid bounds checking</span></span><br><span class=\"line\">    T = <span class=\"string\">'#'</span>.join(<span class=\"string\">'^&#123;&#125;$'</span>.format(s))</span><br><span class=\"line\">    n = len(T)</span><br><span class=\"line\">    P = [<span class=\"number\">0</span>] * n</span><br><span class=\"line\">    C = R = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range (<span class=\"number\">1</span>, n<span class=\"number\">-1</span>):</span><br><span class=\"line\">        P[i] = (R &gt; i) <span class=\"keyword\">and</span> min(R - i, P[<span class=\"number\">2</span>*C - i]) <span class=\"comment\"># equals to i' = C - (i-C)</span></span><br><span class=\"line\">        <span class=\"comment\"># Attempt to expand palindrome centered at i</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> T[i + <span class=\"number\">1</span> + P[i]] == T[i - <span class=\"number\">1</span> - P[i]]:</span><br><span class=\"line\">            P[i] += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># If palindrome centered at i expand past R,</span></span><br><span class=\"line\">        <span class=\"comment\"># adjust center based on expanded palindrome.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i + P[i] &gt; R:</span><br><span class=\"line\">            C, R = i, i + P[i]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># Find the maximum element in P.</span></span><br><span class=\"line\">    maxLen, centerIndex = max((n, i) <span class=\"keyword\">for</span> i, n <span class=\"keyword\">in</span> enumerate(P))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s[(centerIndex  - maxLen)//<span class=\"number\">2</span>: (centerIndex  + maxLen)//<span class=\"number\">2</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"1024-Video-Stitching\"><a href=\"#1024-Video-Stitching\" class=\"headerlink\" title=\"1024. Video Stitching\"></a>1024. Video Stitching</h3><h4 id=\"影片剪辑，给定n组影片段，求能够拼出0-T完整影片所使用的最小段数。原题\"><a href=\"#影片剪辑，给定n组影片段，求能够拼出0-T完整影片所使用的最小段数。原题\" class=\"headerlink\" title=\"影片剪辑，给定n组影片段，求能够拼出0~T完整影片所使用的最小段数。原题\"></a>影片剪辑，给定n组影片段，求能够拼出0~T完整影片所使用的最小段数。<a href=\"https://leetcode.com/problems/video-stitching/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: clips &#x3D; [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T &#x3D; 10</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">We take the clips [0,2], [8,10], [1,9]; a total of 3 clips.</span><br><span class=\"line\">Then, we can reconstruct the sporting event as follows:</span><br><span class=\"line\">We cut [1,9] into segments [1,2] + [2,8] + [8,9].</span><br><span class=\"line\">Now we have segments [0,2] + [2,8] + [8,10] which cover the sporting event [0, 10].</span><br></pre></td></tr></table></figure>\n<p>方法一：此题竞赛时没有完成，想了字典的方法，老是纠结于怎么消除题中的<code>[1, 5]</code>段，其实根本没必要，迭代的时候维护两个变量，一个是已经能组成的最大时长，另一个是当前可以延长到的最大时长。看了Lee神的答案。有个地方比较难理解，假设输入是<code>[[0,2], [1,9],[4,6]],  T=9</code>。按照逻辑如果全执行完，cnt应该=3。但是一旦<code>end2</code>覆盖了答案就及时break掉了，所以不会再累加。如果T10，那么即使cnt为3也会返回-1。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">videoStitching</span><span class=\"params\">(self, clips: List[List[int]], T: int)</span> -&gt; int:</span></span><br><span class=\"line\">    end, end2, cnt = <span class=\"number\">-1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>   <span class=\"comment\"># end 表示上一段最后截止点，end2表示当前可以最大延伸的最远地点。</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> s, e <span class=\"keyword\">in</span> sorted(clips):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> end2 &gt;= T <span class=\"keyword\">or</span> s &gt; end2:   <span class=\"comment\"># 完成或者接不上了</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> end &lt; s &lt;= end2:       <span class=\"comment\"># 续1s</span></span><br><span class=\"line\">            cnt += <span class=\"number\">1</span></span><br><span class=\"line\">            end = end2</span><br><span class=\"line\">        end2 = max(end2, e)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cnt <span class=\"keyword\">if</span> end2 &gt;= T <span class=\"keyword\">else</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1048-Longest-String-Chain\"><a href=\"#1048-Longest-String-Chain\" class=\"headerlink\" title=\"1048. Longest String Chain\"></a>1048. Longest String Chain</h3><h4 id=\"每个字符添加任意一个字符，可以组成一个字符串链。原题\"><a href=\"#每个字符添加任意一个字符，可以组成一个字符串链。原题\" class=\"headerlink\" title=\"每个字符添加任意一个字符，可以组成一个字符串链。原题\"></a>每个字符添加任意一个字符，可以组成一个字符串链。<a href=\"https://leetcode.com/problems/longest-string-chain/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestStrChain</span><span class=\"params\">(self, words: List[str])</span> -&gt; int:</span></span><br><span class=\"line\">    words2 = &#123;i:set() <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">17</span>)&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> words:</span><br><span class=\"line\">        words2[len(word)].add(word)</span><br><span class=\"line\">    dp = collections.defaultdict(<span class=\"keyword\">lambda</span> : <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>, <span class=\"number\">17</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> words2[k]:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(k):</span><br><span class=\"line\">                prev = w[:i] + w[i+<span class=\"number\">1</span>:]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> prev <span class=\"keyword\">in</span> words2[k<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                    <span class=\"comment\"># dp[w] = max(dp[w], dp[prev]+1)</span></span><br><span class=\"line\">                    dp[w] = dp[prev] + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(dp.values() <span class=\"keyword\">or</span> [<span class=\"number\">1</span>])</span><br></pre></td></tr></table></figure>\n<h3 id=\"1143-Longest-Common-Subsequence\"><a href=\"#1143-Longest-Common-Subsequence\" class=\"headerlink\" title=\"1143. Longest Common Subsequence\"></a>1143. Longest Common Subsequence</h3><h4 id=\"最长公共子串的长度。原题\"><a href=\"#最长公共子串的长度。原题\" class=\"headerlink\" title=\"最长公共子串的长度。原题\"></a>最长公共子串的长度。<a href=\"https://leetcode.com/problems/longest-common-subsequence/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot; </span><br><span class=\"line\">Output: 3  </span><br><span class=\"line\">Explanation: The longest common subsequence is &quot;ace&quot; and its length is 3.</span><br></pre></td></tr></table></figure>\n<p>方法一：递归</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> functools</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestCommonSubsequence</span><span class=\"params\">(self, text1: str, text2: str)</span> -&gt; int:</span></span><br><span class=\"line\"><span class=\"meta\">        @functools.lru_cache(None)</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">helper</span><span class=\"params\">(i,j)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> i&lt;<span class=\"number\">0</span> <span class=\"keyword\">or</span> j&lt;<span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> text1[i]==text2[j]:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> helper(i<span class=\"number\">-1</span>,j<span class=\"number\">-1</span>)+<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> max(helper(i<span class=\"number\">-1</span>,j),helper(i,j<span class=\"number\">-1</span>))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> helper(len(text1)<span class=\"number\">-1</span>,len(text2)<span class=\"number\">-1</span>)</span><br></pre></td></tr></table></figure>\n<p>方法二：迭代。dp(i,j) means the longest common subsequence of text1[:i] and text2[:j].</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestCommonSubsequence</span><span class=\"params\">(self, text1: str, text2: str)</span> -&gt; int:</span></span><br><span class=\"line\">    n1, n2 = len(text1), len(text2)</span><br><span class=\"line\">    dp = [[<span class=\"number\">0</span>]*(n2+<span class=\"number\">1</span>) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n1+<span class=\"number\">1</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n1):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n2):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> text1[i] == text2[j]:</span><br><span class=\"line\">                dp[i+<span class=\"number\">1</span>][j+<span class=\"number\">1</span>] = dp[i][j] + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                dp[i+<span class=\"number\">1</span>][j+<span class=\"number\">1</span>] = max(dp[i][j+<span class=\"number\">1</span>], dp[i+<span class=\"number\">1</span>][j])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[<span class=\"number\">-1</span>][<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"583-Delete-Operation-for-Two-Strings\"><a href=\"#583-Delete-Operation-for-Two-Strings\" class=\"headerlink\" title=\"583. Delete Operation for Two Strings\"></a>583. Delete Operation for Two Strings</h3><h4 id=\"最少删除多少次可以让两个字符串相等。原题\"><a href=\"#最少删除多少次可以让两个字符串相等。原题\" class=\"headerlink\" title=\"最少删除多少次可以让两个字符串相等。原题\"></a>最少删除多少次可以让两个字符串相等。<a href=\"https://leetcode.com/problems/delete-operation-for-two-strings/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: &quot;sea&quot;, &quot;eat&quot;</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: You need one step to make &quot;sea&quot; to &quot;ea&quot; and another step to make &quot;eat&quot; to &quot;ea&quot;.</span><br></pre></td></tr></table></figure>\n<p>方法一：dp。这题一上来就发现和1143. Longest Common Subsequence一样。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minDistance</span><span class=\"params\">(self, word1: str, word2: str)</span> -&gt; int:</span></span><br><span class=\"line\">    n1, n2 = len(word1), len(word2)</span><br><span class=\"line\">    dp = [[<span class=\"number\">0</span>]*(n2+<span class=\"number\">1</span>) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n1+<span class=\"number\">1</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n1):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n2):</span><br><span class=\"line\">            dp[i+<span class=\"number\">1</span>][j+<span class=\"number\">1</span>] = max(dp[i][j+<span class=\"number\">1</span>], dp[i+<span class=\"number\">1</span>][j], dp[i][j]+(word1[i]==word2[j]))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n1+n2-dp[<span class=\"number\">-1</span>][<span class=\"number\">-1</span>]*<span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"712-Minimum-ASCII-Delete-Sum-for-Two-Strings\"><a href=\"#712-Minimum-ASCII-Delete-Sum-for-Two-Strings\" class=\"headerlink\" title=\"712. Minimum ASCII Delete Sum for Two Strings\"></a><a href=\"https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/\" target=\"_blank\" rel=\"noopener\">712. Minimum ASCII Delete Sum for Two Strings</a></h3><h4 id=\"删除最小的ascii码的字符，使剩下的两个字符串相等。\"><a href=\"#删除最小的ascii码的字符，使剩下的两个字符串相等。\" class=\"headerlink\" title=\"删除最小的ascii码的字符，使剩下的两个字符串相等。\"></a>删除最小的ascii码的字符，使剩下的两个字符串相等。</h4><p>方法一：同583.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minimumDeleteSum</span><span class=\"params\">(self, s1: str, s2: str)</span> -&gt; int:</span></span><br><span class=\"line\">    n1, n2 = len(s1), len(s2)</span><br><span class=\"line\">    dp = [[<span class=\"number\">0</span>] * (n2+<span class=\"number\">1</span>) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n1+<span class=\"number\">1</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n1):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n2):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> s1[i]==s2[j]:</span><br><span class=\"line\">                dp[i+<span class=\"number\">1</span>][j+<span class=\"number\">1</span>] = dp[i][j] + ord(s1[i])</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                dp[i+<span class=\"number\">1</span>][j+<span class=\"number\">1</span>] = max(dp[i+<span class=\"number\">1</span>][j], dp[i][j+<span class=\"number\">1</span>])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(map(ord, s1+s2)) - dp[<span class=\"number\">-1</span>][<span class=\"number\">-1</span>]*<span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1312-Minimum-Insertion-Steps-to-Make-a-String-Palindrome\"><a href=\"#1312-Minimum-Insertion-Steps-to-Make-a-String-Palindrome\" class=\"headerlink\" title=\"1312. Minimum Insertion Steps to Make a String Palindrome\"></a>1312. Minimum Insertion Steps to Make a String Palindrome</h3><h4 id=\"将一个字符串变为回文串，最小插入字母步数。原题\"><a href=\"#将一个字符串变为回文串，最小插入字母步数。原题\" class=\"headerlink\" title=\"将一个字符串变为回文串，最小插入字母步数。原题\"></a>将一个字符串变为回文串，最小插入字母步数。<a href=\"https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;zzazz&quot;</span><br><span class=\"line\">Output: 0</span><br><span class=\"line\">Explanation: The string &quot;zzazz&quot; is already palindrome we don&#39;t need any insertions.</span><br><span class=\"line\">Input: s &#x3D; &quot;leetcode&quot;</span><br><span class=\"line\">Output: 5</span><br><span class=\"line\">Explanation: Inserting 5 characters the string becomes &quot;leetcodocteel&quot;.</span><br></pre></td></tr></table></figure>\n<p>方法一：和1134，Longest Common Subsequence一样，当这个字符串和他倒序的公共子串越多，需要添加的字母就越少。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minInsertions</span><span class=\"params\">(self, s: str)</span> -&gt; int:</span></span><br><span class=\"line\">    n = len(s)</span><br><span class=\"line\">    dp = [[<span class=\"number\">0</span>] * (n+<span class=\"number\">1</span>) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n+<span class=\"number\">1</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            dp[i+<span class=\"number\">1</span>][j+<span class=\"number\">1</span>] = dp[i][j] + <span class=\"number\">1</span> <span class=\"keyword\">if</span> s[i] == s[~j] <span class=\"keyword\">else</span> max(dp[i+<span class=\"number\">1</span>][j], dp[i][j+<span class=\"number\">1</span>])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n - dp[n][n]</span><br></pre></td></tr></table></figure>\n<h3 id=\"221-Maximal-Square\"><a href=\"#221-Maximal-Square\" class=\"headerlink\" title=\"221. Maximal Square\"></a>221. Maximal Square</h3><h4 id=\"最大的正方形岛屿面积。原题\"><a href=\"#最大的正方形岛屿面积。原题\" class=\"headerlink\" title=\"最大的正方形岛屿面积。原题\"></a>最大的正方形岛屿面积。<a href=\"https://leetcode.com/problems/maximal-square/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: </span><br><span class=\"line\"></span><br><span class=\"line\">1 0 1 0 0</span><br><span class=\"line\">1 0 1 1 1</span><br><span class=\"line\">1 1 1 1 1</span><br><span class=\"line\">1 0 0 1 0</span><br><span class=\"line\"></span><br><span class=\"line\">Output: 4</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法一：此题看似和最大岛屿面积相似，但解法完全不同。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maximalSquare</span><span class=\"params\">(self, g: List[List[str]])</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> g: <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    M, N = len(g), len(g[<span class=\"number\">0</span>])</span><br><span class=\"line\">    dp = [[<span class=\"number\">0</span>] * (N+<span class=\"number\">1</span>) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(M+<span class=\"number\">1</span>)]</span><br><span class=\"line\">    max_side = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, M+<span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, N+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> g[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>] == <span class=\"string\">'1'</span>:</span><br><span class=\"line\">                dp[i][j] = min(dp[i<span class=\"number\">-1</span>][j], dp[i][j<span class=\"number\">-1</span>], dp[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>]) + <span class=\"number\">1</span></span><br><span class=\"line\">                max_side = max(max_side, dp[i][j])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max_side ** <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：采用位运算。从评论区学到的写法，非常屌。假设从有h行数组，将这些数组表示的二进制数按位与，最大的连续的1的长度就是能组成最大正方形的宽度。由于查1的运算变成了位运算，所以时间复杂度和上述方法是一样的。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maximalSquare</span><span class=\"params\">(self, g: List[List[str]])</span> -&gt; int:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">count_serial_one</span><span class=\"params\">(d)</span>:</span></span><br><span class=\"line\">        count = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> d:</span><br><span class=\"line\">            d = d &amp; (d&lt;&lt;<span class=\"number\">1</span>)</span><br><span class=\"line\">            count += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> count</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> g: <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    nums = [int(<span class=\"string\">''</span>.join(row), <span class=\"number\">2</span>) <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> g]</span><br><span class=\"line\">    M = len(g)</span><br><span class=\"line\">    size = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(M):</span><br><span class=\"line\">        cur_num = nums[i]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i, M):</span><br><span class=\"line\">            cur_num = cur_num &amp; nums[j]</span><br><span class=\"line\">            w = count_serial_one(cur_num)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> w &lt; j-i+<span class=\"number\">1</span>: <span class=\"keyword\">break</span>  <span class=\"comment\"># 优化。因为w会越来越小，高会越来越大。</span></span><br><span class=\"line\">            size = max(size, min(w, j-i+<span class=\"number\">1</span>))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> size ** <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1340-Jump-Game-V\"><a href=\"#1340-Jump-Game-V\" class=\"headerlink\" title=\"1340. Jump Game V\"></a>1340. Jump Game V</h3><h4 id=\"跳跃游戏，可以向左右d范围内矮的地方跳下。原题\"><a href=\"#跳跃游戏，可以向左右d范围内矮的地方跳下。原题\" class=\"headerlink\" title=\"跳跃游戏，可以向左右d范围内矮的地方跳下。原题\"></a>跳跃游戏，可以向左右d范围内矮的地方跳下。<a href=\"https://leetcode.com/problems/jump-game-v/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: arr &#x3D; [6,4,14,6,8,13,9,7,10,6,12], d &#x3D; 2</span><br><span class=\"line\">Output: 4</span><br><span class=\"line\">Explanation: You can start at index 10. You can jump 10 --&gt; 8 --&gt; 6 --&gt; 7 as shown.</span><br><span class=\"line\">Note that if you start at index 6 you can only jump to index 7. You cannot jump to index 5 because 13 &gt; 9. You cannot jump to index 4 because index 5 is between index 4 and 6 and 13 &gt; 9.</span><br><span class=\"line\">Similarly You cannot jump from index 3 to index 2 or index 1.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxJumps</span><span class=\"params\">(self, arr: List[int], d: int)</span> -&gt; int:</span></span><br><span class=\"line\">    n = len(arr)</span><br><span class=\"line\">    ans = [<span class=\"number\">0</span>] * n</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">jump</span><span class=\"params\">(i)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ans[i]: <span class=\"keyword\">return</span> ans[i]</span><br><span class=\"line\">        ans[i] = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> di <span class=\"keyword\">in</span> (<span class=\"number\">-1</span>, <span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i+di, i+d*di+di, di):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> (<span class=\"number\">0</span>&lt;=j&lt;n <span class=\"keyword\">and</span> arr[j]&lt;arr[i]): <span class=\"keyword\">break</span></span><br><span class=\"line\">                ans[i] = max(ans[i], jump(j)+<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans[i]</span><br></pre></td></tr></table></figure>\n<h3 id=\"1301-Number-of-Paths-with-Max-Score\"><a href=\"#1301-Number-of-Paths-with-Max-Score\" class=\"headerlink\" title=\"1301. Number of Paths with Max Score\"></a>1301. Number of Paths with Max Score</h3><h4 id=\"左上到右下，最大值，路径中存在障碍，并且需要返回路径的个数。原题\"><a href=\"#左上到右下，最大值，路径中存在障碍，并且需要返回路径的个数。原题\" class=\"headerlink\" title=\"左上到右下，最大值，路径中存在障碍，并且需要返回路径的个数。原题\"></a>左上到右下，最大值，路径中存在障碍，并且需要返回路径的个数。<a href=\"https://leetcode.com/problems/number-of-paths-with-max-score/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: board &#x3D; [&quot;E23&quot;,&quot;2X2&quot;,&quot;12S&quot;]</span><br><span class=\"line\">Output: [7,1]</span><br></pre></td></tr></table></figure>\n<p>方法一：初次AC的方法。此题与剑指offer中礼物的最大值有点像，多了一个障碍，多了一种走法，多返回一个数量。这种解法对于带有障碍的问题来说 不太适合。但是速度上比方法二快了一点。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pathsWithMaxScore</span><span class=\"params\">(self, board: List[str])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    R, C = len(board), len(board[<span class=\"number\">0</span>])</span><br><span class=\"line\">    board[<span class=\"number\">0</span>] = <span class=\"string\">'0'</span> + board[<span class=\"number\">0</span>][<span class=\"number\">1</span>:]</span><br><span class=\"line\">    board[<span class=\"number\">-1</span>] = board[<span class=\"number\">-1</span>][:<span class=\"number\">-1</span>] + <span class=\"string\">'0'</span></span><br><span class=\"line\">    b = [[float(<span class=\"string\">'-inf'</span>) <span class=\"keyword\">if</span> d==<span class=\"string\">'X'</span> <span class=\"keyword\">else</span> int(d) <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> row] <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> board]</span><br><span class=\"line\">    ways = [[<span class=\"number\">0</span>] * C <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(R)]</span><br><span class=\"line\">    first_row = list(itertools.takewhile(<span class=\"keyword\">lambda</span> x: x&gt;=<span class=\"number\">0</span>, ways[<span class=\"number\">0</span>]))</span><br><span class=\"line\">    ways[<span class=\"number\">0</span>] = len(first_row) * [<span class=\"number\">1</span>] + (C-len(first_row)) * [<span class=\"number\">0</span>]</span><br><span class=\"line\">    cur = list(itertools.accumulate(b[<span class=\"number\">0</span>]))</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, R):</span><br><span class=\"line\">        tmp = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(C):</span><br><span class=\"line\">            left = tmp[<span class=\"number\">-1</span>] <span class=\"keyword\">if</span> j&gt;<span class=\"number\">0</span> <span class=\"keyword\">else</span> float(<span class=\"string\">'-inf'</span>)</span><br><span class=\"line\">            dia = cur[j<span class=\"number\">-1</span>] <span class=\"keyword\">if</span> j&gt;<span class=\"number\">0</span> <span class=\"keyword\">else</span> float(<span class=\"string\">'-inf'</span>)</span><br><span class=\"line\">            max_pre = max(cur[j], dia, left)</span><br><span class=\"line\">            tmp.append(max_pre + b[i][j])</span><br><span class=\"line\">            left_way = ways[i][j<span class=\"number\">-1</span>] <span class=\"keyword\">if</span> j&gt;<span class=\"number\">0</span> <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br><span class=\"line\">            up_way = ways[i<span class=\"number\">-1</span>][j]</span><br><span class=\"line\">            dia_way = ways[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>] <span class=\"keyword\">if</span> i&gt;<span class=\"number\">0</span> <span class=\"keyword\">and</span> j&gt;<span class=\"number\">0</span> <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> max_pre != float(<span class=\"string\">'-inf'</span>) <span class=\"keyword\">and</span> b[i][j]!=float(<span class=\"string\">'-inf'</span>):</span><br><span class=\"line\">                ways[i][j] += up_way * (cur[j]==max_pre)</span><br><span class=\"line\">                ways[i][j] += left_way * (left==max_pre)</span><br><span class=\"line\">                ways[i][j] += dia_way * (dia==max_pre)</span><br><span class=\"line\">        cur = tmp</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (cur[<span class=\"number\">-1</span>] <span class=\"keyword\">if</span> cur[<span class=\"number\">-1</span>]!=float(<span class=\"string\">'-inf'</span>) <span class=\"keyword\">else</span> <span class=\"number\">0</span>, </span><br><span class=\"line\">            ways[<span class=\"number\">-1</span>][<span class=\"number\">-1</span>] % (<span class=\"number\">10</span>**<span class=\"number\">9</span>+<span class=\"number\">7</span>))</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：优化。构造一个<code>+1</code>的dp。lee215的解法。3个方向的延伸放到了循环中，同时记录最大的路径个数。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pathsWithMaxScore</span><span class=\"params\">(self, board: List[str])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    n, mod = len(board), <span class=\"number\">10</span>**<span class=\"number\">9</span>+<span class=\"number\">7</span></span><br><span class=\"line\">    dp = [[[float(<span class=\"string\">'-inf'</span>), <span class=\"number\">0</span>] <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n+<span class=\"number\">1</span>)] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n+<span class=\"number\">1</span>)]</span><br><span class=\"line\">    dp[n<span class=\"number\">-1</span>][n<span class=\"number\">-1</span>] = [<span class=\"number\">0</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(n)[::<span class=\"number\">-1</span>]:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> y <span class=\"keyword\">in</span> range(n)[::<span class=\"number\">-1</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> board[x][y] <span class=\"keyword\">in</span> <span class=\"string\">'XS'</span>: <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> i, j <span class=\"keyword\">in</span> ((<span class=\"number\">0</span>, <span class=\"number\">1</span>), (<span class=\"number\">1</span>, <span class=\"number\">0</span>), (<span class=\"number\">1</span>, <span class=\"number\">1</span>)):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> dp[x][y][<span class=\"number\">0</span>] &lt; dp[x+i][y+j][<span class=\"number\">0</span>]:</span><br><span class=\"line\">                    dp[x][y] = [dp[x+i][y+j][<span class=\"number\">0</span>], <span class=\"number\">0</span>]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> dp[x][y][<span class=\"number\">0</span>] == dp[x+i][y+j][<span class=\"number\">0</span>]:</span><br><span class=\"line\">                    dp[x][y][<span class=\"number\">1</span>] += dp[x+i][y+j][<span class=\"number\">1</span>]</span><br><span class=\"line\">            dp[x][y][<span class=\"number\">0</span>] += int(board[x][y]) <span class=\"keyword\">if</span> x <span class=\"keyword\">or</span> y <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>][<span class=\"number\">0</span>] <span class=\"keyword\">if</span> dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>][<span class=\"number\">1</span>] <span class=\"keyword\">else</span> <span class=\"number\">0</span>, dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>][<span class=\"number\">1</span>] % mod]</span><br></pre></td></tr></table></figure>\n<h3 id=\"1277-Count-Square-Submatrices-with-All-Ones\"><a href=\"#1277-Count-Square-Submatrices-with-All-Ones\" class=\"headerlink\" title=\"1277. Count Square Submatrices with All Ones\"></a>1277. Count Square Submatrices with All Ones</h3><h4 id=\"矩阵中最多有多少个1构成的正方形。原题\"><a href=\"#矩阵中最多有多少个1构成的正方形。原题\" class=\"headerlink\" title=\"矩阵中最多有多少个1构成的正方形。原题\"></a>矩阵中最多有多少个1构成的正方形。<a href=\"https://leetcode.com/problems/count-square-submatrices-with-all-ones/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: matrix &#x3D;</span><br><span class=\"line\">[</span><br><span class=\"line\">  [0,1,1,1],</span><br><span class=\"line\">  [1,1,1,1],</span><br><span class=\"line\">  [0,1,1,1]</span><br><span class=\"line\">]</span><br><span class=\"line\">Output: 15</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">There are 10 squares of side 1.</span><br><span class=\"line\">There are 4 squares of side 2.</span><br><span class=\"line\">There is  1 square of side 3.</span><br><span class=\"line\">Total number of squares &#x3D; 10 + 4 + 1 &#x3D; 15.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countSquares</span><span class=\"params\">(self, mat: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    m, n = len(mat), len(mat[<span class=\"number\">0</span>])</span><br><span class=\"line\">    <span class=\"comment\"># dp[i][j] 表示以i, j为右下点时，正方形的个数。</span></span><br><span class=\"line\">    dp = [[<span class=\"number\">0</span>] * (n) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> mat[i][j] == <span class=\"number\">1</span>:</span><br><span class=\"line\">                dp[i][j] = min(dp[i<span class=\"number\">-1</span>][j], dp[i][j<span class=\"number\">-1</span>], dp[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>]) + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(map(sum, dp))</span><br></pre></td></tr></table></figure>\n<h3 id=\"1269-Number-of-Ways-to-Stay-in-the-Same-Place-After-Some-Steps\"><a href=\"#1269-Number-of-Ways-to-Stay-in-the-Same-Place-After-Some-Steps\" class=\"headerlink\" title=\"1269. Number of Ways to Stay in the Same Place After Some Steps\"></a>1269. Number of Ways to Stay in the Same Place After Some Steps</h3><h4 id=\"回到原点的走法一共有多少种，一次只能向右，向左或者停留，要求始终保持在数组范围。原题\"><a href=\"#回到原点的走法一共有多少种，一次只能向右，向左或者停留，要求始终保持在数组范围。原题\" class=\"headerlink\" title=\"回到原点的走法一共有多少种，一次只能向右，向左或者停留，要求始终保持在数组范围。原题\"></a>回到原点的走法一共有多少种，一次只能向右，向左或者停留，要求始终保持在数组范围。<a href=\"https://leetcode.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: steps &#x3D; 3, arrLen &#x3D; 2</span><br><span class=\"line\">Output: 4</span><br><span class=\"line\">Explanation: There are 4 differents ways to stay at index 0 after 3 steps.</span><br><span class=\"line\">Right, Left, Stay</span><br><span class=\"line\">Stay, Right, Left</span><br><span class=\"line\">Right, Stay, Left</span><br><span class=\"line\">Stay, Stay, Stay</span><br></pre></td></tr></table></figure>\n<p>方法一：找到状态转移方程，<code>dp[p][s] = dp[p-1][s-1] + dp[p][s-1] + dp[p+1, s-1]</code>p代表位置，s代表步数。首部添加0方便求和。注意<code>t+3</code>这个范围。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numWays</span><span class=\"params\">(self, steps: int, n: int)</span> -&gt; int:</span></span><br><span class=\"line\">    mod = <span class=\"number\">10</span>**<span class=\"number\">9</span> + <span class=\"number\">7</span></span><br><span class=\"line\">    A = [<span class=\"number\">0</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> range(steps):</span><br><span class=\"line\">        A[<span class=\"number\">1</span>:] = [sum(A[i - <span class=\"number\">1</span>:i + <span class=\"number\">2</span>]) % mod <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, min(n + <span class=\"number\">1</span>, t + <span class=\"number\">3</span>))]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> A[<span class=\"number\">1</span>] % mod</span><br></pre></td></tr></table></figure>\n<h3 id=\"338-Counting-Bits\"><a href=\"#338-Counting-Bits\" class=\"headerlink\" title=\"338. Counting Bits\"></a>338. Counting Bits</h3><h4 id=\"返回从0到num的数中，每个数二进制中含有1的个数。原题\"><a href=\"#返回从0到num的数中，每个数二进制中含有1的个数。原题\" class=\"headerlink\" title=\"返回从0到num的数中，每个数二进制中含有1的个数。原题\"></a>返回从0到num的数中，每个数二进制中含有1的个数。<a href=\"https://leetcode.com/problems/counting-bits/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: 5</span><br><span class=\"line\">Output: [0,1,1,2,1,2]</span><br></pre></td></tr></table></figure>\n<p>方法一：此解法用了191的暴力解法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countBits</span><span class=\"params\">(self, num: int)</span> -&gt; List[int]:</span></span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">count</span><span class=\"params\">(a)</span>:</span></span><br><span class=\"line\">        c = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> a != <span class=\"number\">0</span>:</span><br><span class=\"line\">            a &amp;= a<span class=\"number\">-1</span></span><br><span class=\"line\">            c += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> c</span><br><span class=\"line\">    <span class=\"keyword\">return</span> map(count, range(<span class=\"number\">0</span>, num+<span class=\"number\">1</span>))</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：dp 。<code>dp[i]=dp[i//2]+i&amp;1</code></font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countBits</span><span class=\"params\">(self, num: int)</span> -&gt; List[int]:</span></span><br><span class=\"line\">    dp = [<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, num+<span class=\"number\">1</span>):</span><br><span class=\"line\">        dp.append(dp[i&gt;&gt;<span class=\"number\">1</span>] + (i&amp;<span class=\"number\">1</span>))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp</span><br></pre></td></tr></table></figure>\n<h3 id=\"1262-Greatest-Sum-Divisible-by-Three\"><a href=\"#1262-Greatest-Sum-Divisible-by-Three\" class=\"headerlink\" title=\"1262. Greatest Sum Divisible by Three\"></a>1262. Greatest Sum Divisible by Three</h3><h4 id=\"最多的元素和能被3整除。原题\"><a href=\"#最多的元素和能被3整除。原题\" class=\"headerlink\" title=\"最多的元素和能被3整除。原题\"></a>最多的元素和能被3整除。<a href=\"https://leetcode.com/problems/greatest-sum-divisible-by-three/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [3,6,5,1,8]</span><br><span class=\"line\">Output: 18</span><br><span class=\"line\">Explanation: Pick numbers 3, 6, 1 and 8 their sum is 18 (maximum sum divisible by 3).</span><br></pre></td></tr></table></figure>\n<p>方法一：数学方法，累加所有的数，和可能有三种情况：</p>\n<ul>\n<li>余 0 ，刚好整除。</li>\n<li>余1， 需要减去一个余1的数，或者两个余2的数。</li>\n<li>余2，减去一个余2的数，或者两个余1的数。</li>\n</ul>\n<p>需要注意数字是否够用。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxSumDivThree</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    total = sum(nums)</span><br><span class=\"line\">    mod_1 = [n <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> nums <span class=\"keyword\">if</span> n%<span class=\"number\">3</span>==<span class=\"number\">1</span>]</span><br><span class=\"line\">    mod_2 = [n <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> nums <span class=\"keyword\">if</span> n%<span class=\"number\">3</span>==<span class=\"number\">2</span>]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> total % <span class=\"number\">3</span> == <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> total - min(min(mod_1), sum(heapq.nsmallest(<span class=\"number\">2</span>, mod_2) <span class=\"keyword\">if</span> len(mod_2)&gt;=<span class=\"number\">2</span> <span class=\"keyword\">else</span> [float(<span class=\"string\">'inf'</span>)]))</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> total % <span class=\"number\">3</span> == <span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> total - min(min(mod_2), sum(heapq.nsmallest(<span class=\"number\">2</span>, mod_1) <span class=\"keyword\">if</span> len(mod_1)&gt;=<span class=\"number\">2</span> <span class=\"keyword\">else</span> [float(<span class=\"string\">'inf'</span>)]))</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> total</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：dp. </font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxSumDivThree</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"comment\"># dp[pos][mod]</span></span><br><span class=\"line\">    <span class=\"comment\"># # 0  1  2</span></span><br><span class=\"line\">    <span class=\"comment\"># 0 3  0  0</span></span><br><span class=\"line\">    <span class=\"comment\"># 1 9  0  0 </span></span><br><span class=\"line\">    <span class=\"comment\"># 2 9  0  14</span></span><br><span class=\"line\">    <span class=\"comment\"># 3 15 10 14</span></span><br><span class=\"line\">    <span class=\"comment\"># 4 18 22 23</span></span><br><span class=\"line\">    dp = [<span class=\"number\">0</span>] * <span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> dp[:]:</span><br><span class=\"line\">            dp[(j+a) % <span class=\"number\">3</span>] = max(dp[(j+a) % <span class=\"number\">3</span>], j+a)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"72-Edit-Distance\"><a href=\"#72-Edit-Distance\" class=\"headerlink\" title=\"72. Edit Distance\"></a>72. Edit Distance</h3><h4 id=\"两个单词，将a变成b的最小步数，可以添加、删除，替换一个字母。原题\"><a href=\"#两个单词，将a变成b的最小步数，可以添加、删除，替换一个字母。原题\" class=\"headerlink\" title=\"两个单词，将a变成b的最小步数，可以添加、删除，替换一个字母。原题\"></a>两个单词，将a变成b的最小步数，可以添加、删除，替换一个字母。<a href=\"https://leetcode.com/problems/edit-distance/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">horse -&gt; rorse (replace &#39;h&#39; with &#39;r&#39;)</span><br><span class=\"line\">rorse -&gt; rose (remove &#39;r&#39;)</span><br><span class=\"line\">rose -&gt; ros (remove &#39;e&#39;)</span><br></pre></td></tr></table></figure>\n<p>方法一：真是后悔没早点做这个题，这题解法下有一个方法将dp的问题从记忆化搜索的递归到实现的过程讲解的非常详细。<a href=\"https://leetcode.com/problems/edit-distance/discuss/159295/Python-solutions-and-intuition\" target=\"_blank\" rel=\"noopener\">这里</a>从这样的一个递归开始演变。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minDistance</span><span class=\"params\">(self, word1, word2)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"Naive recursive solution\"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> word1 <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> word2:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> word1:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> len(word2)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> word2:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> len(word1)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> word1[<span class=\"number\">0</span>] == word2[<span class=\"number\">0</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.minDistance(word1[<span class=\"number\">1</span>:], word2[<span class=\"number\">1</span>:])</span><br><span class=\"line\">        insert = <span class=\"number\">1</span> + self.minDistance(word1, word2[<span class=\"number\">1</span>:])</span><br><span class=\"line\">        delete = <span class=\"number\">1</span> + self.minDistance(word1[<span class=\"number\">1</span>:], word2)</span><br><span class=\"line\">        replace = <span class=\"number\">1</span> + self.minDistance(word1[<span class=\"number\">1</span>:], word2[<span class=\"number\">1</span>:])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> min(insert, replace, delete)</span><br></pre></td></tr></table></figure>\n<p>到最终的形态。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minDistance</span><span class=\"params\">(self, word1: str, word2: str)</span> -&gt; int:</span></span><br><span class=\"line\">    m, n = len(word1), len(word2)</span><br><span class=\"line\">    dp = [[<span class=\"number\">0</span>] * (n+<span class=\"number\">1</span>) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(m+<span class=\"number\">1</span>)]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m+<span class=\"number\">1</span>):</span><br><span class=\"line\">        dp[i][<span class=\"number\">0</span>] = i</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n+<span class=\"number\">1</span>):</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][j] = j</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> word1[i] == word2[j]:</span><br><span class=\"line\">                dp[i+<span class=\"number\">1</span>][j+<span class=\"number\">1</span>] = dp[i][j]</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                dp[i+<span class=\"number\">1</span>][j+<span class=\"number\">1</span>] = min(dp[i+<span class=\"number\">1</span>][j], dp[i][j+<span class=\"number\">1</span>], dp[i][j]) + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[<span class=\"number\">-1</span>][<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"322-Coin-Change\"><a href=\"#322-Coin-Change\" class=\"headerlink\" title=\"322. Coin Change\"></a>322. Coin Change</h3><h4 id=\"找零问题，给你几种面值的硬币，不限制每种硬币的个数，问组成多少钱最少需要几个硬币。原题\"><a href=\"#找零问题，给你几种面值的硬币，不限制每种硬币的个数，问组成多少钱最少需要几个硬币。原题\" class=\"headerlink\" title=\"找零问题，给你几种面值的硬币，不限制每种硬币的个数，问组成多少钱最少需要几个硬币。原题\"></a>找零问题，给你几种面值的硬币，不限制每种硬币的个数，问组成多少钱最少需要几个硬币。<a href=\"https://leetcode.com/problems/coin-change/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: coins &#x3D; [1, 2, 5], amount &#x3D; 11</span><br><span class=\"line\">Output: 3 </span><br><span class=\"line\">Explanation: 11 &#x3D; 5 + 5 + 1</span><br></pre></td></tr></table></figure>\n<p>方法一：自己想的方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">coinChange</span><span class=\"params\">(self, coins: List[int], amount: int)</span> -&gt; int:</span></span><br><span class=\"line\">    dp = [<span class=\"number\">0</span>] + [float(<span class=\"string\">'inf'</span>)] * amount</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, amount+<span class=\"number\">1</span>):</span><br><span class=\"line\">        dp[i] = min(dp[i-coin]+<span class=\"number\">1</span> <span class=\"keyword\">if</span> i&gt;=coin <span class=\"keyword\">else</span> float(<span class=\"string\">'inf'</span>) <span class=\"keyword\">for</span> coin <span class=\"keyword\">in</span> coins)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[<span class=\"number\">-1</span>] <span class=\"keyword\">if</span> dp[<span class=\"number\">-1</span>]!=float(<span class=\"string\">'inf'</span>) <span class=\"keyword\">else</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"518-Coin-Change-2\"><a href=\"#518-Coin-Change-2\" class=\"headerlink\" title=\"518. Coin Change 2\"></a>518. Coin Change 2</h3><h4 id=\"找钱问题，给你几种面值的硬币，不限制每种硬币的个数，问组成多少钱有多少种方法。原题\"><a href=\"#找钱问题，给你几种面值的硬币，不限制每种硬币的个数，问组成多少钱有多少种方法。原题\" class=\"headerlink\" title=\"找钱问题，给你几种面值的硬币，不限制每种硬币的个数，问组成多少钱有多少种方法。原题\"></a>找钱问题，给你几种面值的硬币，不限制每种硬币的个数，问组成多少钱有多少种方法。<a href=\"https://leetcode.com/problems/coin-change-2/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: amount &#x3D; 5, coins &#x3D; [1, 2, 5]</span><br><span class=\"line\">Output: 4</span><br><span class=\"line\">Explanation: there are four ways to make up the amount:</span><br><span class=\"line\">5&#x3D;5</span><br><span class=\"line\">5&#x3D;2+2+1</span><br><span class=\"line\">5&#x3D;2+1+1+1</span><br><span class=\"line\">5&#x3D;1+1+1+1+1</span><br></pre></td></tr></table></figure>\n<p>方法一：背包问题，看了答案。</p>\n<p><code>dp[i - 1][j]</code>: 完全不用当前硬币组成j有多少种组合<br><code>dp[i][j - coins[i - 1]]</code> :使用<strong>至少一个</strong>当前硬币（与上面一条是互斥事件）组成组成j有多少组合。for循环不能写反了，比如1+5和5+1同样能组成6，被算了两次。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">change</span><span class=\"params\">(self, amount: int, coins: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    dp = [<span class=\"number\">0</span>] * (amount + <span class=\"number\">1</span>)</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> coins:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, amount + <span class=\"number\">1</span>):</span><br><span class=\"line\">           <span class=\"keyword\">if</span> j &gt;= i:</span><br><span class=\"line\">               dp[j] += dp[j - i]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[amount]</span><br></pre></td></tr></table></figure>\n<h3 id=\"1220-Count-Vowels-Permutation\"><a href=\"#1220-Count-Vowels-Permutation\" class=\"headerlink\" title=\"1220. Count Vowels Permutation\"></a>1220. Count Vowels Permutation</h3><h4 id=\"元音字母的全排列，根据指定规则的，求全排列的个数。原题\"><a href=\"#元音字母的全排列，根据指定规则的，求全排列的个数。原题\" class=\"headerlink\" title=\"元音字母的全排列，根据指定规则的，求全排列的个数。原题\"></a>元音字母的全排列，根据指定规则的，求全排列的个数。<a href=\"https://leetcode.com/problems/count-vowels-permutation/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 2</span><br><span class=\"line\">Output: 10</span><br><span class=\"line\">Explanation: All possible strings are: &quot;ae&quot;, &quot;ea&quot;, &quot;ei&quot;, &quot;ia&quot;, &quot;ie&quot;, &quot;io&quot;, &quot;iu&quot;, &quot;oi&quot;, &quot;ou&quot; and &quot;ua&quot;.</span><br></pre></td></tr></table></figure>\n<p>方法一：没想到居然做出来了。dp分别代表了以这些字母开头的个数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countVowelPermutation</span><span class=\"params\">(self, n: int)</span> -&gt; int:</span></span><br><span class=\"line\">    dp = [<span class=\"number\">1</span>] * <span class=\"number\">5</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n<span class=\"number\">-1</span>):</span><br><span class=\"line\">        tmp = [[<span class=\"number\">0</span>] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(<span class=\"number\">5</span>)]</span><br><span class=\"line\">        tmp[<span class=\"number\">0</span>] = dp[<span class=\"number\">1</span>]</span><br><span class=\"line\">        tmp[<span class=\"number\">1</span>] = dp[<span class=\"number\">0</span>] + dp[<span class=\"number\">2</span>]</span><br><span class=\"line\">        tmp[<span class=\"number\">2</span>] = dp[<span class=\"number\">0</span>] + dp[<span class=\"number\">1</span>] + dp[<span class=\"number\">3</span>] + dp[<span class=\"number\">4</span>]</span><br><span class=\"line\">        tmp[<span class=\"number\">3</span>] = dp[<span class=\"number\">2</span>] + dp[<span class=\"number\">4</span>]</span><br><span class=\"line\">        tmp[<span class=\"number\">4</span>] = dp[<span class=\"number\">0</span>]</span><br><span class=\"line\">        dp = tmp</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(dp) % (<span class=\"number\">10</span>**<span class=\"number\">9</span>+<span class=\"number\">7</span>)</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：一整得有点复杂了。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countVowelPermutation</span><span class=\"params\">(self, n: int)</span> -&gt; int:</span></span><br><span class=\"line\">    a = e = i = o = u = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n<span class=\"number\">-1</span>):</span><br><span class=\"line\">        a, e, i, o, u = e, a+i, a+e+o+u, i+u, a</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a+e+i+o+u) % (<span class=\"number\">10</span>**<span class=\"number\">9</span>+<span class=\"number\">7</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"368-Largest-Divisible-Subset\"><a href=\"#368-Largest-Divisible-Subset\" class=\"headerlink\" title=\"368. Largest Divisible Subset\"></a>368. Largest Divisible Subset</h3><h4 id=\"最大的整除子集。原题\"><a href=\"#最大的整除子集。原题\" class=\"headerlink\" title=\"最大的整除子集。原题\"></a>最大的整除子集。<a href=\"https://leetcode.com/problems/largest-divisible-subset/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [1,2,3]</span><br><span class=\"line\">Output: [1,2] (of course, [1,3] will also be ok)</span><br></pre></td></tr></table></figure>\n<p>方法一：stefan的解法。自己没想出来。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">largestDivisibleSubset</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    S = &#123;<span class=\"number\">-1</span>: set()&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> sorted(nums):</span><br><span class=\"line\">        S[x] = max((S[d] <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> S <span class=\"keyword\">if</span> x % d == <span class=\"number\">0</span>), key=len) | &#123;x&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list(max(S.values(), key=len))</span><br></pre></td></tr></table></figure>\n<h3 id=\"5456-Kth-Ancestor-of-a-Tree-Node\"><a href=\"#5456-Kth-Ancestor-of-a-Tree-Node\" class=\"headerlink\" title=\"5456. Kth Ancestor of a Tree Node\"></a>5456. Kth Ancestor of a Tree Node</h3><h4 id=\"找出一个树节点的k个祖先。原题\"><a href=\"#找出一个树节点的k个祖先。原题\" class=\"headerlink\" title=\"找出一个树节点的k个祖先。原题\"></a>找出一个树节点的k个祖先。<a href=\"https://leetcode.com/problems/kth-ancestor-of-a-tree-node/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">[&quot;TreeAncestor&quot;,&quot;getKthAncestor&quot;,&quot;getKthAncestor&quot;,&quot;getKthAncestor&quot;]</span><br><span class=\"line\">[[7,[-1,0,0,1,1,2,2]],[3,1],[5,2],[6,3]]</span><br><span class=\"line\"></span><br><span class=\"line\">Output:</span><br><span class=\"line\">[null,1,0,-1]</span><br><span class=\"line\"></span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">TreeAncestor treeAncestor &#x3D; new TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2]);</span><br><span class=\"line\"></span><br><span class=\"line\">treeAncestor.getKthAncestor(3, 1);  &#x2F;&#x2F; returns 1 which is the parent of 3</span><br><span class=\"line\">treeAncestor.getKthAncestor(5, 2);  &#x2F;&#x2F; returns 0 which is the grandparent of 5</span><br><span class=\"line\">treeAncestor.getKthAncestor(6, 3);  &#x2F;&#x2F; returns -1 because there is no such ancestor</span><br></pre></td></tr></table></figure>\n<p>方法一：这道题没有做出来，Lee的答案。用的倍增法，binary lifting.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TreeAncestor</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    step = <span class=\"number\">15</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, n, A)</span>:</span></span><br><span class=\"line\">        A = dict(enumerate(A))</span><br><span class=\"line\">        jump = [A]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> range(self.step):</span><br><span class=\"line\">            B = &#123;&#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> A:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> A[i] <span class=\"keyword\">in</span> A:</span><br><span class=\"line\">                    B[i] = A[A[i]]</span><br><span class=\"line\">            jump.append(B)</span><br><span class=\"line\">            A = B</span><br><span class=\"line\">        self.jump = jump</span><br><span class=\"line\">        print(jump)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getKthAncestor</span><span class=\"params\">(self, x: int, k: int)</span> -&gt; int:</span></span><br><span class=\"line\">        step = self.step</span><br><span class=\"line\">        <span class=\"keyword\">while</span> k &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> x &gt; <span class=\"number\">-1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> k &gt;= <span class=\"number\">1</span> &lt;&lt; step:</span><br><span class=\"line\">                x = self.jump[step].get(x, <span class=\"number\">-1</span>)</span><br><span class=\"line\">                k -= <span class=\"number\">1</span> &lt;&lt; step</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                step -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> x</span><br></pre></td></tr></table></figure>\n<h3 id=\"1477-Find-Two-Non-overlapping-Sub-arrays-Each-With-Target-Sum\"><a href=\"#1477-Find-Two-Non-overlapping-Sub-arrays-Each-With-Target-Sum\" class=\"headerlink\" title=\"1477. Find Two Non-overlapping Sub-arrays Each With Target Sum\"></a>1477. Find Two Non-overlapping Sub-arrays Each With Target Sum</h3><h4 id=\"找到数组中等于目标值的两个不重叠子数组的最小长度和。原题\"><a href=\"#找到数组中等于目标值的两个不重叠子数组的最小长度和。原题\" class=\"headerlink\" title=\"找到数组中等于目标值的两个不重叠子数组的最小长度和。原题\"></a>找到数组中等于目标值的两个不重叠子数组的最小长度和。<a href=\"https://leetcode.com/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: arr &#x3D; [3,2,2,4,3], target &#x3D; 3</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: Only two sub-arrays have sum &#x3D; 3 ([3] and [3]). The sum of their lengths is 2.</span><br></pre></td></tr></table></figure>\n<p>方法一：看了提示后使用了前后遍历法做出来的。其实有一次遍历的方式。这个方法看了挺长时间，才明白，实际上记录了一个以end为结尾的前面的所有元素最好的长度是多少。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minSumOfLengths</span><span class=\"params\">(self, arr: List[int], target: int)</span> -&gt; int:</span></span><br><span class=\"line\">    prefix = &#123;<span class=\"number\">0</span>: <span class=\"number\">-1</span>&#125;</span><br><span class=\"line\">    best_till = [math.inf] * len(arr)</span><br><span class=\"line\">    ans = best = math.inf</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, curr <span class=\"keyword\">in</span> enumerate(itertools.accumulate(arr)):</span><br><span class=\"line\">        <span class=\"comment\"># print(i, curr)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> curr - target <span class=\"keyword\">in</span> prefix:</span><br><span class=\"line\">            end = prefix[curr - target]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> end &gt; <span class=\"number\">-1</span>:</span><br><span class=\"line\">                ans = min(ans, i - end + best_till[end])</span><br><span class=\"line\">            best = min(best, i - end)</span><br><span class=\"line\">            <span class=\"comment\"># print('\\t', best, i-end, best_till, ans)</span></span><br><span class=\"line\">        best_till[i] = best</span><br><span class=\"line\">        prefix[curr] = i</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span> <span class=\"keyword\">if</span> ans == math.inf <span class=\"keyword\">else</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"494-Target-Sum\"><a href=\"#494-Target-Sum\" class=\"headerlink\" title=\"494. Target Sum\"></a>494. Target Sum</h3><h4 id=\"给你一组数，用-或-连接起来最后等于target，问有多少种填法。原题\"><a href=\"#给你一组数，用-或-连接起来最后等于target，问有多少种填法。原题\" class=\"headerlink\" title=\"给你一组数，用+或-连接起来最后等于target，问有多少种填法。原题\"></a>给你一组数，用+或-连接起来最后等于target，问有多少种填法。<a href=\"https://leetcode.com/problems/target-sum/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums is [1, 1, 1, 1, 1], S is 3. </span><br><span class=\"line\">Output: 5</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\"></span><br><span class=\"line\">-1+1+1+1+1 &#x3D; 3</span><br><span class=\"line\">+1-1+1+1+1 &#x3D; 3</span><br><span class=\"line\">+1+1-1+1+1 &#x3D; 3</span><br><span class=\"line\">+1+1+1-1+1 &#x3D; 3</span><br><span class=\"line\">+1+1+1+1-1 &#x3D; 3</span><br></pre></td></tr></table></figure>\n<p>方法一：记忆化搜索。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findTargetSumWays</span><span class=\"params\">(self, nums: List[int], S: int)</span> -&gt; int:</span></span><br><span class=\"line\">    n = len(nums)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @lru_cache(None)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(i, total)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == n:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> total==S</span><br><span class=\"line\">        ans = dfs(i+<span class=\"number\">1</span>, total+nums[i]) + dfs(i+<span class=\"number\">1</span>, total-nums[i])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dfs(<span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"174-Dungeon-Game\"><a href=\"#174-Dungeon-Game\" class=\"headerlink\" title=\"174. Dungeon Game\"></a>174. Dungeon Game</h3><h4 id=\"地牢游戏，从左上走到右下，每次只能像右或者向下，格子里会扣血和加血，问最少需要多少血，全程保持血量为1以上。原题\"><a href=\"#地牢游戏，从左上走到右下，每次只能像右或者向下，格子里会扣血和加血，问最少需要多少血，全程保持血量为1以上。原题\" class=\"headerlink\" title=\"地牢游戏，从左上走到右下，每次只能像右或者向下，格子里会扣血和加血，问最少需要多少血，全程保持血量为1以上。原题\"></a>地牢游戏，从左上走到右下，每次只能像右或者向下，格子里会扣血和加血，问最少需要多少血，全程保持血量为1以上。<a href=\"https://leetcode.com/problems/dungeon-game/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：这道题曾经面试某公司的时候做过，只是那道题还要求返回路径，当时做的时候以为做对了。再次遇见此题时想了一晚上发现想简单了。一开始想保留两个变量，一个是最少血量，一个是累加和。然后根据最少血量判断选择走哪条路，结果一个case证明了想法是错的。还是评论区找的写法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">calculateMinimumHP</span><span class=\"params\">(self, dungeon: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    R, C = len(dungeon), len(dungeon[<span class=\"number\">0</span>])</span><br><span class=\"line\">    dp = [[<span class=\"number\">0</span>] * C <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(R)] </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(R<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(C<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i == R<span class=\"number\">-1</span> <span class=\"keyword\">and</span> j == C<span class=\"number\">-1</span>:</span><br><span class=\"line\">                dp[i][j] = max(<span class=\"number\">1</span>, <span class=\"number\">1</span> - dungeon[i][j])</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> i == R<span class=\"number\">-1</span>:</span><br><span class=\"line\">                dp[i][j] = max(<span class=\"number\">1</span>, dp[i][j+<span class=\"number\">1</span>] - dungeon[i][j])</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> j == C<span class=\"number\">-1</span>:</span><br><span class=\"line\">                dp[i][j] = max(<span class=\"number\">1</span>, dp[i+<span class=\"number\">1</span>][j] - dungeon[i][j])</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                dp[i][j] = max(<span class=\"number\">1</span>, min(dp[i+<span class=\"number\">1</span>][j], dp[i][j+<span class=\"number\">1</span>]) - dungeon[i][j])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"96-Unique-Binary-Search-Trees\"><a href=\"#96-Unique-Binary-Search-Trees\" class=\"headerlink\" title=\"96. Unique Binary Search Trees\"></a>96. Unique Binary Search Trees</h3><h4 id=\"不重复的二叉搜索树，1-n节点。原题\"><a href=\"#不重复的二叉搜索树，1-n节点。原题\" class=\"headerlink\" title=\"不重复的二叉搜索树，1~n节点。原题\"></a>不重复的二叉搜索树，1~n节点。<a href=\"https://leetcode.com/problems/unique-binary-search-trees/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: 3</span><br><span class=\"line\">Output: 5</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">Given n &#x3D; 3, there are a total of 5 unique BST&#39;s:</span><br><span class=\"line\"></span><br><span class=\"line\">   1         3     3      2      1</span><br><span class=\"line\">    \\       &#x2F;     &#x2F;      &#x2F; \\      \\</span><br><span class=\"line\">     3     2     1      1   3      2</span><br><span class=\"line\">    &#x2F;     &#x2F;       \\                 \\</span><br><span class=\"line\">   2     1         2                 3</span><br></pre></td></tr></table></figure>\n<p>方法一：这题看了答案，状态转移方程式这样的G(n)表示n个节点能组成的二叉搜索树节点个数。F(i, n)表示有n个节点时，以i为root的个数。<code>G(n) = F(1, n) + F(2, n) + ... + F(n, n).</code> <code>F(3, 7)=G(2)*G(4)</code>即<code>F(i, n) = G(i-1) * G(n-i)</code>, 所以最后<code>G(n) = G(0) * G(n-1) + G(1) * G(n-2) + … + G(n-1) * G(0)</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numTrees</span><span class=\"params\">(self, n: int)</span> -&gt; int:</span></span><br><span class=\"line\">    G = [<span class=\"number\">0</span>] * (n+<span class=\"number\">1</span>)</span><br><span class=\"line\">    G[<span class=\"number\">0</span>] = G[<span class=\"number\">1</span>] = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>, n+<span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, i+<span class=\"number\">1</span>):</span><br><span class=\"line\">            G[i] += G[j<span class=\"number\">-1</span>]*G[i-j]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> G[n]</span><br></pre></td></tr></table></figure>\n<h3 id=\"95-Unique-Binary-Search-Trees-II\"><a href=\"#95-Unique-Binary-Search-Trees-II\" class=\"headerlink\" title=\"95. Unique Binary Search Trees II\"></a>95. Unique Binary Search Trees II</h3><h4 id=\"这题和96一样，要求将所有的树找出来。原题\"><a href=\"#这题和96一样，要求将所有的树找出来。原题\" class=\"headerlink\" title=\"这题和96一样，要求将所有的树找出来。原题\"></a>这题和96一样，要求将所有的树找出来。<a href=\"https://leetcode.com/problems/unique-binary-search-trees-ii/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：第一次AC的方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">generateTrees</span><span class=\"params\">(self, n: int)</span> -&gt; List[TreeNode]:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    memo = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">build</span><span class=\"params\">(lo, hi)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lo, hi) <span class=\"keyword\">in</span> memo: <span class=\"keyword\">return</span> memo[(lo, hi)]</span><br><span class=\"line\">        ans = []</span><br><span class=\"line\">        <span class=\"keyword\">if</span> lo &gt; hi:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [<span class=\"literal\">None</span>]</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> lo == hi:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [TreeNode(lo)]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(lo, hi+<span class=\"number\">1</span>):</span><br><span class=\"line\">            root = TreeNode(i)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> left <span class=\"keyword\">in</span> build(lo, i<span class=\"number\">-1</span>):</span><br><span class=\"line\">                root.left = left</span><br><span class=\"line\">                <span class=\"keyword\">for</span> right <span class=\"keyword\">in</span> build(i+<span class=\"number\">1</span>, hi):</span><br><span class=\"line\">                    root.right = right</span><br><span class=\"line\">                    ans.append(copy.deepcopy(root))</span><br><span class=\"line\">        memo[(lo, hi)] = ans</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> build(<span class=\"number\">1</span>, n) <span class=\"keyword\">if</span> n&gt;<span class=\"number\">0</span> <span class=\"keyword\">else</span> []</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法二：看了stefan的答案，更正一下自己的方法，lo-hi是没必要的，之前因为先考虑这个因素，没有删掉。deepcopy可以写成别的形式，在内循环生成root节点，而不是在外层生成一个再去拷贝。记忆化搜索也是没有必要的。用时比原来快了3倍。\"><a href=\"#方法二：看了stefan的答案，更正一下自己的方法，lo-hi是没必要的，之前因为先考虑这个因素，没有删掉。deepcopy可以写成别的形式，在内循环生成root节点，而不是在外层生成一个再去拷贝。记忆化搜索也是没有必要的。用时比原来快了3倍。\" class=\"headerlink\" title=\"方法二：看了stefan的答案，更正一下自己的方法，lo==hi是没必要的，之前因为先考虑这个因素，没有删掉。deepcopy可以写成别的形式，在内循环生成root节点，而不是在外层生成一个再去拷贝。记忆化搜索也是没有必要的。用时比原来快了3倍。\"></a><font color=\"#32CD32\" size=\"3\">方法二：看了stefan的答案，更正一下自己的方法，<code>lo==hi</code>是没必要的，之前因为先考虑这个因素，没有删掉。deepcopy可以写成别的形式，在内循环生成root节点，而不是在外层生成一个再去拷贝。记忆化搜索也是没有必要的。用时比原来快了3倍。</font></h3><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">generateTrees</span><span class=\"params\">(self, n: int)</span> -&gt; List[TreeNode]:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">build</span><span class=\"params\">(lo, hi)</span>:</span></span><br><span class=\"line\">        ans = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(lo, hi+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> left <span class=\"keyword\">in</span> build(lo, i<span class=\"number\">-1</span>):</span><br><span class=\"line\">                <span class=\"keyword\">for</span> right <span class=\"keyword\">in</span> build(i+<span class=\"number\">1</span>, hi):</span><br><span class=\"line\">                    root = TreeNode(i)</span><br><span class=\"line\">                    root.left = left</span><br><span class=\"line\">                    root.right = right</span><br><span class=\"line\">                    ans.append(root)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans <span class=\"keyword\">or</span> [<span class=\"literal\">None</span>]</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> build(<span class=\"number\">1</span>, n) <span class=\"keyword\">if</span> n&gt;<span class=\"number\">0</span> <span class=\"keyword\">else</span> []</span><br></pre></td></tr></table></figure>\n<h3 id=\"337-House-Robber-III\"><a href=\"#337-House-Robber-III\" class=\"headerlink\" title=\"337. House Robber III\"></a>337. House Robber III</h3><h4 id=\"抢劫房子，房子是二叉树结构，不能抢两个挨着的节点，问最多可以抢多少。原题\"><a href=\"#抢劫房子，房子是二叉树结构，不能抢两个挨着的节点，问最多可以抢多少。原题\" class=\"headerlink\" title=\"抢劫房子，房子是二叉树结构，不能抢两个挨着的节点，问最多可以抢多少。原题\"></a>抢劫房子，房子是二叉树结构，不能抢两个挨着的节点，问最多可以抢多少。<a href=\"https://leetcode.com/problems/house-robber-iii/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：看了讨论区才解出来。对于一个节点来说，只有两种case：抢与不抢。将这个条件利用起来代入到递归判断中</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rob</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">        left, right = dfs(node.left), dfs(node.right)</span><br><span class=\"line\">        not_rob = max(left) + max(right)</span><br><span class=\"line\">        robbed = node.val + left[<span class=\"number\">0</span>] + right[<span class=\"number\">0</span>]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> not_rob, robbed</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(dfs(root))</span><br></pre></td></tr></table></figure>\n<h3 id=\"1504-Count-Submatrices-With-All-Ones\"><a href=\"#1504-Count-Submatrices-With-All-Ones\" class=\"headerlink\" title=\"1504. Count Submatrices With All Ones\"></a>1504. Count Submatrices With All Ones</h3><h4 id=\"查找有多少个由1组成的子矩阵。原题\"><a href=\"#查找有多少个由1组成的子矩阵。原题\" class=\"headerlink\" title=\"查找有多少个由1组成的子矩阵。原题\"></a>查找有多少个由1组成的子矩阵。<a href=\"https://leetcode.com/problems/count-submatrices-with-all-ones/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: mat &#x3D; [[1,0,1],</span><br><span class=\"line\">              [1,1,0],</span><br><span class=\"line\">              [1,1,0]]</span><br><span class=\"line\">Output: 13</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">There are 6 rectangles of side 1x1.</span><br><span class=\"line\">There are 2 rectangles of side 1x2.</span><br><span class=\"line\">There are 3 rectangles of side 2x1.</span><br><span class=\"line\">There is 1 rectangle of side 2x2. </span><br><span class=\"line\">There is 1 rectangle of side 3x1.</span><br><span class=\"line\">Total number of rectangles &#x3D; 6 + 2 + 3 + 1 + 1 &#x3D; 13.</span><br></pre></td></tr></table></figure>\n<p>方法一：竞赛时未做出来，有道类似的题是求正方形的，所以思路被限制了，找到一个状态转移方程，但是case1跑不过，未注意变量的范围，其实O(MMN)的时间复杂度也是允许的。从1D扩展的2D，然后h表示当前列k的top到down是否都是1。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numSubmat</span><span class=\"params\">(self, mat: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    R, C = len(mat), len(mat[<span class=\"number\">0</span>])</span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">count_row</span><span class=\"params\">(a)</span>:</span></span><br><span class=\"line\">        ans = l = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> a:</span><br><span class=\"line\">            l = <span class=\"number\">0</span> <span class=\"keyword\">if</span> num==<span class=\"number\">0</span> <span class=\"keyword\">else</span> l+<span class=\"number\">1</span></span><br><span class=\"line\">            ans += l</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> top <span class=\"keyword\">in</span> range(R):</span><br><span class=\"line\">        h = [<span class=\"number\">1</span>] * C</span><br><span class=\"line\">        <span class=\"keyword\">for</span> bottom <span class=\"keyword\">in</span> range(top, R):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(C):</span><br><span class=\"line\">                h[k] &amp;= mat[bottom][k]</span><br><span class=\"line\">            ans += count_row(h)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"1140-Stone-Game-II\"><a href=\"#1140-Stone-Game-II\" class=\"headerlink\" title=\"1140. Stone Game II\"></a>1140. Stone Game II</h3><h4 id=\"和1不一样，这回的规则是这样的，每次拿前m-lt-x-lt-2m个堆，问最后Alex可以拿多少最多。原题\"><a href=\"#和1不一样，这回的规则是这样的，每次拿前m-lt-x-lt-2m个堆，问最后Alex可以拿多少最多。原题\" class=\"headerlink\" title=\"和1不一样，这回的规则是这样的，每次拿前m &lt;= x &lt;= 2m个堆，问最后Alex可以拿多少最多。原题\"></a>和1不一样，这回的规则是这样的，每次拿前m &lt;= x &lt;= 2m个堆，问最后Alex可以拿多少最多。<a href=\"https://leetcode.com/problems/stone-game-ii/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: piles &#x3D; [2,7,9,4,4]</span><br><span class=\"line\">Output: 10</span><br><span class=\"line\">Explanation:  If Alex takes one pile at the beginning, Lee takes two piles, then Alex takes 2 piles again. Alex can get 2 + 4 + 4 &#x3D; 10 piles in total. If Alex takes two piles at the beginning, then Lee can take all three piles left. In this case, Alex get 2 + 7 &#x3D; 9 piles in total. So we return 10 since it&#39;s larger.</span><br></pre></td></tr></table></figure>\n<p>方法一：没做出来，Lee的答案看了半天，退出条件开始很难想出来。就是如果能够全拿，就退出。转移方程式这样的，A变成了一个从后累加的数组，当前的人拿<code>i</code>~<code>i+x</code>另外的人就是<code>dp[i+x, max(m, x)]</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">stoneGameII</span><span class=\"params\">(self, A: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    N = len(A)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(N - <span class=\"number\">2</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">        A[i] += A[i + <span class=\"number\">1</span>]</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">from</span> functools <span class=\"keyword\">import</span> lru_cache</span><br><span class=\"line\"><span class=\"meta\">    @lru_cache(None)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dp</span><span class=\"params\">(i, m)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i + <span class=\"number\">2</span> * m &gt;= N: <span class=\"keyword\">return</span> A[i]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> A[i] - min(dp(i + x, max(m, x)) <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">2</span> * m + <span class=\"number\">1</span>))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp(<span class=\"number\">0</span>, <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"1510-Stone-Game-IV\"><a href=\"#1510-Stone-Game-IV\" class=\"headerlink\" title=\"1510. Stone Game IV\"></a><a href=\"https://leetcode.com/problems/stone-game-iv/\" target=\"_blank\" rel=\"noopener\">1510. Stone Game IV</a></h3><h4 id=\"这次是有n堆石头，每次可以拿平方数堆，如果谁拿不了了，谁就输了。\"><a href=\"#这次是有n堆石头，每次可以拿平方数堆，如果谁拿不了了，谁就输了。\" class=\"headerlink\" title=\"这次是有n堆石头，每次可以拿平方数堆，如果谁拿不了了，谁就输了。\"></a>这次是有n堆石头，每次可以拿平方数堆，如果谁拿不了了，谁就输了。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 7</span><br><span class=\"line\">Output: false</span><br><span class=\"line\">Explanation: Alice can&#39;t win the game if Bob plays optimally.</span><br><span class=\"line\">If Alice starts removing 4 stones, Bob will remove 1 stone then Alice should remove only 1 stone and finally Bob removes the last one (7 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; 0). </span><br><span class=\"line\">If Alice starts removing 1 stone, Bob will remove 4 stones then Alice only can remove 1 stone and finally Bob removes the last one (7 -&gt; 6 -&gt; 2 -&gt; 1 -&gt; 0).</span><br></pre></td></tr></table></figure>\n<p>方法一：递归+记忆化，这里注意要从大到小遍历，开始写反了超时了一次。这里发现<code>j*j</code>比<code>j**2</code>快130ms，不明原因。240ms。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">winnerSquareGame</span><span class=\"params\">(self, n: int)</span> -&gt; bool:</span></span><br><span class=\"line\"><span class=\"meta\">\t\t@lru_cache(None)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dp</span><span class=\"params\">(i)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">not</span> all(dp(i-j*j) <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(int(sqrt(i)), <span class=\"number\">0</span>, <span class=\"number\">-1</span>))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp(n)</span><br></pre></td></tr></table></figure>\n<p>方法二：迭代。Lee的迭代用了1000ms，这次没我写得好。我稍微改了一下，使它降到了700ms，不过还是很慢。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">winnerSquareGame</span><span class=\"params\">(self, n: int)</span> -&gt; bool:</span></span><br><span class=\"line\">    dp = [<span class=\"literal\">False</span>] * (n + <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n + <span class=\"number\">1</span>):</span><br><span class=\"line\">        dp[i] = <span class=\"keyword\">not</span> all(dp[i - k * k] <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(int(sqrt(i)), <span class=\"number\">0</span>, <span class=\"number\">-1</span>))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"1686-Stone-Game-VI\"><a href=\"#1686-Stone-Game-VI\" class=\"headerlink\" title=\"1686. Stone Game VI\"></a><a href=\"https://leetcode.com/problems/stone-game-vi/\" target=\"_blank\" rel=\"noopener\">1686. Stone Game VI</a></h3><h4 id=\"两人从任意位置拿石头，每个石头对于两个人的价值不一样。两人都按最优方式拿，最后1表示Alice赢，0表示平局。\"><a href=\"#两人从任意位置拿石头，每个石头对于两个人的价值不一样。两人都按最优方式拿，最后1表示Alice赢，0表示平局。\" class=\"headerlink\" title=\"两人从任意位置拿石头，每个石头对于两个人的价值不一样。两人都按最优方式拿，最后1表示Alice赢，0表示平局。\"></a>两人从任意位置拿石头，每个石头对于两个人的价值不一样。两人都按最优方式拿，最后1表示Alice赢，0表示平局。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: aliceValues &#x3D; [2,4,3], bobValues &#x3D; [1,6,7]</span><br><span class=\"line\">Output: -1</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">Regardless of how Alice plays, Bob will be able to have more points than Alice.</span><br><span class=\"line\">For example, if Alice takes stone 1, Bob can take stone 2, and Alice takes stone 0, Alice will have 6 points to Bob&#39;s 7.</span><br><span class=\"line\">Bob wins.</span><br></pre></td></tr></table></figure>\n<p>方法一：比赛时想出来了，里面有个贪心的思想，对于一个石头来说，每个人都优先拿对于两个人价值都高的，所以这里是以累加为条件作为排序。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">stoneGameVI</span><span class=\"params\">(self, aliceValues: List[int], bobValues: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    values = sorted(zip(aliceValues, bobValues), key=<span class=\"keyword\">lambda</span> x: x[<span class=\"number\">0</span>]+x[<span class=\"number\">1</span>], reverse=<span class=\"literal\">True</span>)</span><br><span class=\"line\">    a = sum(v[<span class=\"number\">0</span>] <span class=\"keyword\">for</span> v <span class=\"keyword\">in</span> values[::<span class=\"number\">2</span>])</span><br><span class=\"line\">    b = sum(v[<span class=\"number\">-1</span>] <span class=\"keyword\">for</span> v <span class=\"keyword\">in</span> values[<span class=\"number\">1</span>::<span class=\"number\">2</span>])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">-1</span>)[(a&gt;b)-(a&lt;b)]</span><br></pre></td></tr></table></figure>\n<h3 id=\"1524-Number-of-Sub-arrays-With-Odd-Sum\"><a href=\"#1524-Number-of-Sub-arrays-With-Odd-Sum\" class=\"headerlink\" title=\"1524. Number of Sub-arrays With Odd Sum\"></a>1524. Number of Sub-arrays With Odd Sum</h3><h4 id=\"求一个数组的和为奇数的子数组的个数。原题\"><a href=\"#求一个数组的和为奇数的子数组的个数。原题\" class=\"headerlink\" title=\"求一个数组的和为奇数的子数组的个数。原题\"></a>求一个数组的和为奇数的子数组的个数。<a href=\"https://leetcode.com/problems/number-of-sub-arrays-with-odd-sum/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: arr &#x3D; [1,3,5]</span><br><span class=\"line\">Output: 4</span><br><span class=\"line\">Explanation: All sub-arrays are [[1],[1,3],[1,3,5],[3],[3,5],[5]]</span><br><span class=\"line\">All sub-arrays sum are [1,4,9,3,8,5].</span><br><span class=\"line\">Odd sums are [1,9,3,5] so the answer is 4.</span><br></pre></td></tr></table></figure>\n<p>方法一：这题作为竞赛2题没做上，导致周赛排名降了不少。odd表示前i个数包含i的子数组奇数的个数。even则是偶数个数。那么当i+1为偶数时，even+1，奇数不变；当i+1为奇数时，even=odd，even=odd+1</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numOfSubarrays</span><span class=\"params\">(self, arr: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    ans = odd = even = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> arr:</span><br><span class=\"line\">        even += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> x % <span class=\"number\">2</span>:</span><br><span class=\"line\">            odd, even = even, odd</span><br><span class=\"line\">        ans = (ans + odd) % (<span class=\"number\">10</span>**<span class=\"number\">9</span>+<span class=\"number\">7</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"139-Word-Break\"><a href=\"#139-Word-Break\" class=\"headerlink\" title=\"139. Word Break\"></a>139. Word Break</h3><h4 id=\"问s是否能拆成words里的单词，单词可以重复使用。原题\"><a href=\"#问s是否能拆成words里的单词，单词可以重复使用。原题\" class=\"headerlink\" title=\"问s是否能拆成words里的单词，单词可以重复使用。原题\"></a>问s是否能拆成words里的单词，单词可以重复使用。<a href=\"https://leetcode.com/problems/word-break/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;applepenapple&quot;, wordDict &#x3D; [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class=\"line\">Output: true</span><br><span class=\"line\">Explanation: Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;.</span><br><span class=\"line\">             Note that you are allowed to reuse a dictionary word.</span><br></pre></td></tr></table></figure>\n<p>方法一：还是想不到dp的解法。此题需要逆向思维。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wordBreak</span><span class=\"params\">(self, s: str, words: List[str])</span> -&gt; bool:</span></span><br><span class=\"line\">    dp = [<span class=\"literal\">True</span>] + [<span class=\"literal\">False</span>] * len(s)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(s)+<span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> words:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> s[:i].endswith(w):</span><br><span class=\"line\">                dp[i] |= dp[i-len(w)]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<p>方法二：递归倒是想到了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wordBreak</span><span class=\"params\">(self, s: str, wordDict: List[str])</span> -&gt; bool:</span></span><br><span class=\"line\">    word_set = set(wordDict)</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">    @lru_cache(None)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(w)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> w:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> word_set:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> w.startswith(word) <span class=\"keyword\">and</span> dfs(w[len(word):]):</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> dfs(s)</span><br></pre></td></tr></table></figure>\n<h3 id=\"140-Word-Break-II\"><a href=\"#140-Word-Break-II\" class=\"headerlink\" title=\"140. Word Break II\"></a>140. Word Break II</h3><h4 id=\"和上题一样，不过要求返回所有拆分的结果。原题\"><a href=\"#和上题一样，不过要求返回所有拆分的结果。原题\" class=\"headerlink\" title=\"和上题一样，不过要求返回所有拆分的结果。原题\"></a>和上题一样，不过要求返回所有拆分的结果。<a href=\"https://leetcode.com/problems/word-break-ii/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">s &#x3D; &quot;catsanddog&quot;</span><br><span class=\"line\">wordDict &#x3D; [&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;]</span><br><span class=\"line\">Output:</span><br><span class=\"line\">[</span><br><span class=\"line\">  &quot;cats and dog&quot;,</span><br><span class=\"line\">  &quot;cat sand dog&quot;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>方法一：回溯法，这里有个case会超时，所以判断了一下s是否有单独的字符出现。这个方法不太好，LC的例子有点弱，我将用例修改为<code>&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;\n[&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;,&quot;aaaaa&quot;,&quot;aaaaaa&quot;,&quot;aaaaaaa&quot;,&quot;aaaaaaaa&quot;,&quot;aaaaaaaaa&quot;,&quot;aaaaaaaaaa&quot;]</code>超出内存限制了。好叭，方法二也没过了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wordBreak</span><span class=\"params\">(self, s: str, words: List[str])</span> -&gt; List[str]:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    words = set(words)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> set(s)-set(c <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> words <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> w):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> []</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtrack</span><span class=\"params\">(s, p)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> s:</span><br><span class=\"line\">            ans.append(<span class=\"string\">' '</span>.join(p))</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(s)+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> s[:i] <span class=\"keyword\">in</span> words:</span><br><span class=\"line\">                backtrack(s[i:], p+[s[:i]])</span><br><span class=\"line\">    </span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    backtrack(s, [])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：记忆化搜索。需要用索引作key来完成。不能用s是因为，s可能是前后有重复值。 </font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wordBreak</span><span class=\"params\">(self, s: str, words: List[str])</span> -&gt; List[str]:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    words = set(words)</span><br><span class=\"line\">    memo = &#123;len(s): [<span class=\"string\">''</span>]&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sentences</span><span class=\"params\">(i)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> memo:</span><br><span class=\"line\">            memo[i] = [s[i:j] + (tail <span class=\"keyword\">and</span> <span class=\"string\">' '</span> + tail)</span><br><span class=\"line\">                       <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i+<span class=\"number\">1</span>, len(s)+<span class=\"number\">1</span>)</span><br><span class=\"line\">                       <span class=\"keyword\">if</span> s[i:j] <span class=\"keyword\">in</span> words</span><br><span class=\"line\">                       <span class=\"keyword\">for</span> tail <span class=\"keyword\">in</span> sentences(j)]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> memo[i]</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> sentences(<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"1416-Restore-The-Array\"><a href=\"#1416-Restore-The-Array\" class=\"headerlink\" title=\"1416. Restore The Array\"></a>1416. Restore The Array</h3><h4 id=\"字符串s是有1-k个数非0开头组成的，问有多少种组成的方式。原题\"><a href=\"#字符串s是有1-k个数非0开头组成的，问有多少种组成的方式。原题\" class=\"headerlink\" title=\"字符串s是有1~k个数非0开头组成的，问有多少种组成的方式。原题\"></a>字符串s是有1~k个数非0开头组成的，问有多少种组成的方式。<a href=\"https://leetcode.com/problems/restore-the-array/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;1000&quot;, k &#x3D; 10000</span><br><span class=\"line\">Output: 1</span><br><span class=\"line\">Explanation: The only possible array is [1000]</span><br><span class=\"line\"></span><br><span class=\"line\">Input: s &#x3D; &quot;1000&quot;, k &#x3D; 10</span><br><span class=\"line\">Output: 0</span><br><span class=\"line\">Explanation: There cannot be an array that was printed this way and has all integer &gt;&#x3D; 1 and &lt;&#x3D; 10.</span><br><span class=\"line\"></span><br><span class=\"line\">Input: s &#x3D; &quot;1317&quot;, k &#x3D; 2000</span><br><span class=\"line\">Output: 8</span><br><span class=\"line\">Explanation: Possible arrays are [1317],[131,7],[13,17],[1,317],[13,1,7],[1,31,7],[1,3,17],[1,3,1,7]</span><br></pre></td></tr></table></figure>\n<p>方法一：首次ac的方法。第10行如果不取余，时间慢了一倍，空间多了好几倍。这个思路和Word Break有点像，dp[i]表示s[:i]总共的组成方式。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numberOfArrays</span><span class=\"params\">(self, s: str, k: int)</span> -&gt; int:</span></span><br><span class=\"line\">    mod = <span class=\"number\">10</span> ** <span class=\"number\">9</span> + <span class=\"number\">7</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    dp = [<span class=\"number\">0</span>] * (len(s) + <span class=\"number\">1</span>)</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(s)+<span class=\"number\">1</span>):</span><br><span class=\"line\">        j = i<span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> j&gt;=<span class=\"number\">0</span> <span class=\"keyword\">and</span> len(s[j:i])&lt;=len(str(k)) <span class=\"keyword\">and</span> int(s[j:i]) &lt;= k:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> s[j] != <span class=\"string\">'0'</span>:</span><br><span class=\"line\">                dp[i] += dp[j] % mod</span><br><span class=\"line\">            j -= <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[<span class=\"number\">-1</span>] % mod</span><br></pre></td></tr></table></figure>\n<p>方法二：针对方法一优化，while循环看着有点乱。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numberOfArrays</span><span class=\"params\">(self, s: str, k: int)</span> -&gt; int:</span></span><br><span class=\"line\">    mod = <span class=\"number\">10</span> ** <span class=\"number\">9</span> + <span class=\"number\">7</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    k_len = len(str(k))</span><br><span class=\"line\">    dp = [<span class=\"number\">0</span>] * (len(s) + <span class=\"number\">1</span>)</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(s)+<span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(max(<span class=\"number\">0</span>, i-k_len), i):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> s[j] != <span class=\"string\">'0'</span> <span class=\"keyword\">and</span> int(s[j:i]) &lt;=k:</span><br><span class=\"line\">                dp[i] += dp[j] % mod</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[<span class=\"number\">-1</span>] % mod</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：用dp[i]表示[i:]总共的组成数量，从后向前计算，这样有一个好处，可以用数值来判断而不是字符串。此方法在时间上比上述快了一倍。为此作了很多实验，时间的消耗正是在s的反复切片中。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numberOfArrays</span><span class=\"params\">(self, s: str, k: int)</span> -&gt; int:</span></span><br><span class=\"line\">    mod = <span class=\"number\">10</span> ** <span class=\"number\">9</span> + <span class=\"number\">7</span></span><br><span class=\"line\">    n = len(s)</span><br><span class=\"line\">    s = [*map(int, s)] + [math.inf]      </span><br><span class=\"line\">    dp = [<span class=\"number\">0</span>] * n + [<span class=\"number\">1</span>]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">        num = s[i]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i+<span class=\"number\">1</span>, n+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"number\">1</span> &lt;= num &lt;= k:</span><br><span class=\"line\">                dp[i] = (dp[i] + dp[j]) % mod</span><br><span class=\"line\">                num = <span class=\"number\">10</span> * num + s[j]</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"1537-Get-the-Maximum-Score\"><a href=\"#1537-Get-the-Maximum-Score\" class=\"headerlink\" title=\"1537. Get the Maximum Score\"></a>1537. Get the Maximum Score</h3><h4 id=\"两个不重复数字的数组，从某个数组从左向右找一条路径，使值最大，如果和另一个数组有重复的数字则可以跳到另一个数组上。原题\"><a href=\"#两个不重复数字的数组，从某个数组从左向右找一条路径，使值最大，如果和另一个数组有重复的数字则可以跳到另一个数组上。原题\" class=\"headerlink\" title=\"两个不重复数字的数组，从某个数组从左向右找一条路径，使值最大，如果和另一个数组有重复的数字则可以跳到另一个数组上。原题\"></a>两个不重复数字的数组，从某个数组从左向右找一条路径，使值最大，如果和另一个数组有重复的数字则可以跳到另一个数组上。<a href=\"https://leetcode.com/problems/get-the-maximum-score/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：竞赛时没有时间想，不过做起来比第3题简单。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxSum</span><span class=\"params\">(self, nums1: List[int], nums2: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_cross</span><span class=\"params\">(arr1, arr2)</span>:</span></span><br><span class=\"line\">        a = [<span class=\"number\">0</span>]</span><br><span class=\"line\">        p = <span class=\"literal\">False</span></span><br><span class=\"line\">        s2 = set(arr2)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> arr1:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> p:</span><br><span class=\"line\">                a.append(a.pop()+n)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                a.append(n)</span><br><span class=\"line\">            p = n <span class=\"keyword\">in</span> s2</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a</span><br><span class=\"line\"></span><br><span class=\"line\">    a1, a2 = get_cross(nums1, nums2), get_cross(nums2, nums1)</span><br><span class=\"line\">        </span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> itertools.zip_longest(a1, a2, fillvalue=<span class=\"number\">0</span>):</span><br><span class=\"line\">        ans = (ans + max(a, b)) % (<span class=\"number\">10</span>**<span class=\"number\">9</span>+<span class=\"number\">7</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：忽略了一个条件，两个数组时有序的，所以可以使用双指针，O(1)的空间来实现。by@lee215. </font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxSum</span><span class=\"params\">(self, A: List[int], B: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    i, j, n, m = <span class=\"number\">0</span>, <span class=\"number\">0</span>, len(A), len(B)</span><br><span class=\"line\">    a, b, mod = <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">10</span>**<span class=\"number\">9</span>+<span class=\"number\">7</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> i&lt;n <span class=\"keyword\">or</span> j&lt;m:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i&lt;n <span class=\"keyword\">and</span> (j==m <span class=\"keyword\">or</span> A[i]&lt;B[j]):</span><br><span class=\"line\">            a += A[i]</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> j&lt;m <span class=\"keyword\">and</span> (i==n <span class=\"keyword\">or</span> A[i]&gt;B[j]):</span><br><span class=\"line\">            b += B[j]</span><br><span class=\"line\">            j += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            a = b = max(a, b) + A[i]</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">            j += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(a, b) % mod</span><br></pre></td></tr></table></figure>\n<h3 id=\"1553-Minimum-Number-of-Days-to-Eat-N-Oranges\"><a href=\"#1553-Minimum-Number-of-Days-to-Eat-N-Oranges\" class=\"headerlink\" title=\"1553. Minimum Number of Days to Eat N Oranges\"></a>1553. Minimum Number of Days to Eat N Oranges</h3><h4 id=\"每天可以吃一个橙子；或者被2整除时吃一半；或者被3整除时吃3分之2。问最少几天可以吃完原题\"><a href=\"#每天可以吃一个橙子；或者被2整除时吃一半；或者被3整除时吃3分之2。问最少几天可以吃完原题\" class=\"headerlink\" title=\"每天可以吃一个橙子；或者被2整除时吃一半；或者被3整除时吃3分之2。问最少几天可以吃完原题\"></a>每天可以吃一个橙子；或者被2整除时吃一半；或者被3整除时吃3分之2。问最少几天可以吃完<a href=\"https://leetcode.com/problems/minimum-number-of-days-to-eat-n-oranges/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 10</span><br><span class=\"line\">Output: 4</span><br><span class=\"line\">Explanation: You have 10 oranges.</span><br><span class=\"line\">Day 1: Eat 1 orange,  10 - 1 &#x3D; 9.  </span><br><span class=\"line\">Day 2: Eat 6 oranges, 9 - 2*(9&#x2F;3) &#x3D; 9 - 6 &#x3D; 3. (Since 9 is divisible by 3)</span><br><span class=\"line\">Day 3: Eat 2 oranges, 3 - 2*(3&#x2F;3) &#x3D; 3 - 2 &#x3D; 1. </span><br><span class=\"line\">Day 4: Eat the last orange  1 - 1  &#x3D; 0.</span><br><span class=\"line\">You need at least 4 days to eat the 10 oranges.</span><br></pre></td></tr></table></figure>\n<p>方法一：比赛时未做出来，想初始化一个2*10**9的数组，结果内存溢出。而且取余也没想出来。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\"><span class=\"meta\">    @functools.lru_cache()</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minDays</span><span class=\"params\">(self, n: int)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &lt;= <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> n</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span> + min(self.minDays(n//<span class=\"number\">2</span>)+n%<span class=\"number\">2</span>, self.minDays(n//<span class=\"number\">3</span>)+n%<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n<p>方法二：bfs，这个方法完全没有想到，就是将3种吃法放到队列中去。这种时间效率比方法一低很多。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minDays</span><span class=\"params\">(self, n: int)</span> -&gt; int:</span></span><br><span class=\"line\">    q = collections.deque([(n, <span class=\"number\">0</span>)]) </span><br><span class=\"line\">    seen = set()</span><br><span class=\"line\">    <span class=\"keyword\">while</span> q:</span><br><span class=\"line\">        cur, step = q.popleft()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cur == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> step</span><br><span class=\"line\">        seen.add(cur)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cur<span class=\"number\">-1</span> <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> seen: q.append((cur<span class=\"number\">-1</span>, step+<span class=\"number\">1</span>))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cur&amp;<span class=\"number\">1</span>==<span class=\"number\">0</span> <span class=\"keyword\">and</span> cur//<span class=\"number\">2</span> <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> seen:     </span><br><span class=\"line\">            q.append((cur//<span class=\"number\">2</span>, step+<span class=\"number\">1</span>))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cur%<span class=\"number\">3</span>==<span class=\"number\">0</span> <span class=\"keyword\">and</span> cur//<span class=\"number\">3</span> <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> seen:</span><br><span class=\"line\">            q.append((cur//<span class=\"number\">3</span>, step+<span class=\"number\">1</span>))</span><br></pre></td></tr></table></figure>\n<h3 id=\"801-Minimum-Swaps-To-Make-Sequences-Increasing\"><a href=\"#801-Minimum-Swaps-To-Make-Sequences-Increasing\" class=\"headerlink\" title=\"801. Minimum Swaps To Make Sequences Increasing\"></a>801. Minimum Swaps To Make Sequences Increasing</h3><h4 id=\"最少多少次对应位置的交换可以使两个数组都严格地单调递增。原题\"><a href=\"#最少多少次对应位置的交换可以使两个数组都严格地单调递增。原题\" class=\"headerlink\" title=\"最少多少次对应位置的交换可以使两个数组都严格地单调递增。原题\"></a>最少多少次对应位置的交换可以使两个数组都严格地单调递增。<a href=\"https://leetcode.com/problems/minimum-swaps-to-make-sequences-increasing/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Example:</span><br><span class=\"line\">Input: A &#x3D; [1,3,5,4], B &#x3D; [1,2,3,7]</span><br><span class=\"line\">Output: 1</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">Swap A[3] and B[3].  Then the sequences are:</span><br><span class=\"line\">A &#x3D; [1, 3, 5, 7] and B &#x3D; [1, 2, 3, 4]</span><br><span class=\"line\">which are both strictly increasing.</span><br></pre></td></tr></table></figure>\n<p>方法一：在提交错一次get新case后做了出来。首次AC的方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minSwap</span><span class=\"params\">(self, A: List[int], B: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    last_swap = last_not_swap = <span class=\"number\">0</span></span><br><span class=\"line\">    A = [float(<span class=\"string\">'-inf'</span>)] + A</span><br><span class=\"line\">    B = [float(<span class=\"string\">'-inf'</span>)] + B</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(A)):</span><br><span class=\"line\">        cur_swap = cur_not_swap = float(<span class=\"string\">'inf'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> A[i] &gt; A[i<span class=\"number\">-1</span>] <span class=\"keyword\">and</span> B[i] &gt; B[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">            cur_swap = last_swap + <span class=\"number\">1</span></span><br><span class=\"line\">            cur_not_swap = last_not_swap</span><br><span class=\"line\">        <span class=\"keyword\">if</span> A[i] &gt; B[i<span class=\"number\">-1</span>] <span class=\"keyword\">and</span> B[i] &gt; A[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">            cur_swap = min(cur_swap, last_not_swap+<span class=\"number\">1</span>)</span><br><span class=\"line\">            cur_not_swap = min(cur_not_swap, last_swap)</span><br><span class=\"line\">        last_swap, last_not_swap = cur_swap, cur_not_swap</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min(last_swap, last_not_swap)</span><br></pre></td></tr></table></figure>\n<p>方法二：看了lee的答案，改了一下初始化的值，补负无穷是没必要的</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minSwap</span><span class=\"params\">(self, A: List[int], B: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    last_swap, last_not_swap = <span class=\"number\">1</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(A)):</span><br><span class=\"line\">        cur_swap = cur_not_swap = len(A)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> A[i] &gt; A[i<span class=\"number\">-1</span>] <span class=\"keyword\">and</span> B[i] &gt; B[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">            cur_swap = last_swap + <span class=\"number\">1</span></span><br><span class=\"line\">            cur_not_swap = last_not_swap</span><br><span class=\"line\">        <span class=\"keyword\">if</span> A[i] &gt; B[i<span class=\"number\">-1</span>] <span class=\"keyword\">and</span> B[i] &gt; A[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">            cur_swap = min(cur_swap, last_not_swap+<span class=\"number\">1</span>)</span><br><span class=\"line\">            cur_not_swap = min(cur_not_swap, last_swap)</span><br><span class=\"line\">        last_swap, last_not_swap = cur_swap, cur_not_swap</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min(last_swap, last_not_swap)</span><br></pre></td></tr></table></figure>\n<h3 id=\"837-New-21-Game\"><a href=\"#837-New-21-Game\" class=\"headerlink\" title=\"837. New 21 Game\"></a>837. New 21 Game</h3><h4 id=\"新的21点游戏，有个W面的骰子，少于K的时候要一直掷骰子，直到和超过K，问最后结果小于等于N的概率。原题\"><a href=\"#新的21点游戏，有个W面的骰子，少于K的时候要一直掷骰子，直到和超过K，问最后结果小于等于N的概率。原题\" class=\"headerlink\" title=\"新的21点游戏，有个W面的骰子，少于K的时候要一直掷骰子，直到和超过K，问最后结果小于等于N的概率。原题\"></a>新的21点游戏，有个W面的骰子，少于K的时候要一直掷骰子，直到和超过K，问最后结果小于等于N的概率。<a href=\"https://leetcode.com/problems/new-21-game/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: N &#x3D; 6, K &#x3D; 1, W &#x3D; 10</span><br><span class=\"line\">Output: 0.60000</span><br><span class=\"line\">Explanation:  Alice gets a single card, then stops.</span><br><span class=\"line\">In 6 out of W &#x3D; 10 possibilities, she is at or below N &#x3D; 6 points.</span><br><span class=\"line\"></span><br><span class=\"line\">Input: N &#x3D; 21, K &#x3D; 17, W &#x3D; 10</span><br><span class=\"line\">Output: 0.73278</span><br></pre></td></tr></table></figure>\n<font color=\"#FF0000\" size=\"3\"><strong>方法一：超时，这道题让我联想到剑指offer中的骰子题，但是不太一样，所以这个方法和那个有点类似，但是超时了。此题的时间要求很高</strong>。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">new21Game</span><span class=\"params\">(self, N: int, K: int, W: int)</span> -&gt; float:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> K == <span class=\"number\">0</span>: <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    last_p = collections.defaultdict(int)</span><br><span class=\"line\">    last_p[<span class=\"number\">0</span>] = <span class=\"number\">1</span></span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(K):</span><br><span class=\"line\">        new_p = collections.defaultdict(int)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i+<span class=\"number\">1</span>, N+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> j &gt;= K:</span><br><span class=\"line\">                ans += sum(last_p[j-m] <span class=\"keyword\">for</span> m <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, W+<span class=\"number\">1</span>) <span class=\"keyword\">if</span> j-m&lt;K) / W</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                new_p[j] = sum(last_p[j-m] <span class=\"keyword\">for</span> m <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, W+<span class=\"number\">1</span>) <span class=\"keyword\">if</span> j-m&lt;K) / W</span><br><span class=\"line\"></span><br><span class=\"line\">        last_p = new_p</span><br><span class=\"line\">        <span class=\"comment\"># print(i, last_p)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：这是Lee的答案，这题也是Lee贡献的，想了半天才想明白。想通了原理就不难理解，方法一就是没转过来弯。<code>p(K) = p(K-1) / W + p(K-2) / W + p(K-3) / W + ... p(K-W) / W</code> ，然后<code>Wsum</code>其实就是<code>p(K-1)+p(K-2)+...p(K-W)</code>，想象成一个W长度的滑动窗口，然后<code>i&lt;K</code>是因为如果i达到了K，就已经截止了，所以概率不再累加了。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">new21Game</span><span class=\"params\">(self, N: int, K: int, W: int)</span> -&gt; float:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> fractions <span class=\"keyword\">import</span> Fraction</span><br><span class=\"line\">    <span class=\"keyword\">if</span> K == <span class=\"number\">0</span> <span class=\"keyword\">or</span> N &gt;= K + W: <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    dp = [<span class=\"number\">1.0</span>] + [<span class=\"number\">0.0</span>] * N</span><br><span class=\"line\">    Wsum = <span class=\"number\">1.0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, N + <span class=\"number\">1</span>):</span><br><span class=\"line\">        dp[i] = Wsum / W</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i &lt; K: Wsum += dp[i]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i - W &gt;= <span class=\"number\">0</span>: Wsum -= dp[i - W]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(dp[K:])</span><br></pre></td></tr></table></figure>\n<h3 id=\"808-Soup-Servings\"><a href=\"#808-Soup-Servings\" class=\"headerlink\" title=\"808. Soup Servings\"></a>808. Soup Servings</h3><h4 id=\"有两种汤，有四种上法，如果一种汤不够，那都全都上了。问A汤先卖完的概率加上一起卖完的概率的一半，和是多少。原题\"><a href=\"#有两种汤，有四种上法，如果一种汤不够，那都全都上了。问A汤先卖完的概率加上一起卖完的概率的一半，和是多少。原题\" class=\"headerlink\" title=\"有两种汤，有四种上法，如果一种汤不够，那都全都上了。问A汤先卖完的概率加上一起卖完的概率的一半，和是多少。原题\"></a>有两种汤，有四种上法，如果一种汤不够，那都全都上了。问A汤先卖完的概率加上一起卖完的概率的一半，和是多少。<a href=\"https://leetcode.com/problems/soup-servings/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Example:</span><br><span class=\"line\">Input: N &#x3D; 50</span><br><span class=\"line\">Output: 0.625</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">If we choose the first two operations, A will become empty first. For the third operation, A and B will become empty at the same time. For the fourth operation, B will become empty first. So the total probability of A becoming empty first plus half the probability that A and B become empty at the same time, is 0.25 * (1 + 1 + 0.5 + 0) &#x3D; 0.625.</span><br></pre></td></tr></table></figure>\n<font color=\"#FF0000\" size=\"3\"><strong>方法一：递归，爆栈了，因为N最大为10^9。</strong></font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">soupServings</span><span class=\"params\">(self, N: int)</span> -&gt; float:</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">    @functools.lru_cache()</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_p</span><span class=\"params\">(a, b)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> a &lt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> b &lt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">1</span>, <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> b &lt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">        a_0 = two_0 = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, <span class=\"number\">100</span>, <span class=\"number\">25</span>):</span><br><span class=\"line\">            p1, p2 = get_p(a<span class=\"number\">-100</span>+i, b-i)</span><br><span class=\"line\">            a_0 += p1 / <span class=\"number\">4</span></span><br><span class=\"line\">            two_0 += p2 / <span class=\"number\">4</span></span><br><span class=\"line\">        <span class=\"comment\"># print(a, b, a_0, ' - ', two_0)</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> a_0, two_0</span><br><span class=\"line\">    </span><br><span class=\"line\">    p1, p2 = get_p(N, N)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p1 + <span class=\"number\">0.5</span>*p2</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：Lee的方法。同时为0的情况，可以直接将概率减半，因为后序不会再此概率上再做计算。但就这样的话还是无法解决爆栈的问题。然后寻找规律，A汤4种情况平均下来，消耗地比B多，那么N越大，B先卖完的概率就越小，结果就越大。答案在5位小数精度内都算正确，所以找到一个阈值，概率变为1。然后对于25ml这个条件，可以将其看作一勺单位，这样计算起来比较简单。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    memo = &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">soupServings</span><span class=\"params\">(self, N)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> N &gt; <span class=\"number\">4800</span>: <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(a, b)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a, b) <span class=\"keyword\">in</span> self.memo: <span class=\"keyword\">return</span> self.memo[a, b]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> a &lt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> b &lt;= <span class=\"number\">0</span>: <span class=\"keyword\">return</span> <span class=\"number\">0.5</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> a &lt;= <span class=\"number\">0</span>: <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> b &lt;= <span class=\"number\">0</span>: <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">            self.memo[(a, b)] = <span class=\"number\">0.25</span> * (f(a - <span class=\"number\">4</span>, b) + f(a - <span class=\"number\">3</span>, b - <span class=\"number\">1</span>) + f(a - <span class=\"number\">2</span>, b - <span class=\"number\">2</span>) + f(a - <span class=\"number\">1</span>, b - <span class=\"number\">3</span>))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.memo[(a, b)]</span><br><span class=\"line\">        N = math.ceil(N / <span class=\"number\">25.0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f(N, N)</span><br></pre></td></tr></table></figure>\n<h3 id=\"983-Minimum-Cost-For-Tickets\"><a href=\"#983-Minimum-Cost-For-Tickets\" class=\"headerlink\" title=\"983. Minimum Cost For Tickets\"></a>983. Minimum Cost For Tickets</h3><h4 id=\"最小花费的票钱，有三种通票，分别能旅行1，7，30天，对应三种价格，要在一年中的旅行日花费最少，需要多少钱。原题\"><a href=\"#最小花费的票钱，有三种通票，分别能旅行1，7，30天，对应三种价格，要在一年中的旅行日花费最少，需要多少钱。原题\" class=\"headerlink\" title=\"最小花费的票钱，有三种通票，分别能旅行1，7，30天，对应三种价格，要在一年中的旅行日花费最少，需要多少钱。原题\"></a>最小花费的票钱，有三种通票，分别能旅行1，7，30天，对应三种价格，要在一年中的旅行日花费最少，需要多少钱。<a href=\"https://leetcode.com/problems/minimum-cost-for-tickets/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: days &#x3D; [1,4,6,7,8,20], costs &#x3D; [2,7,15]</span><br><span class=\"line\">Output: 11</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">For example, here is one way to buy passes that lets you travel your travel plan:</span><br><span class=\"line\">On day 1, you bought a 1-day pass for costs[0] &#x3D; $2, which covered day 1.</span><br><span class=\"line\">On day 3, you bought a 7-day pass for costs[1] &#x3D; $7, which covered days 3, 4, ..., 9.</span><br><span class=\"line\">On day 20, you bought a 1-day pass for costs[0] &#x3D; $2, which covered day 20.</span><br><span class=\"line\">In total you spent $11 and covered all the days of your travel.</span><br></pre></td></tr></table></figure>\n<p>方法一：想了一会儿就做出来了，需要注意如果不是旅行日，要等于前一天的花费。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mincostTickets</span><span class=\"params\">(self, days: List[int], costs: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    dp = [<span class=\"number\">0</span>] + [float(<span class=\"string\">'inf'</span>)] * days[<span class=\"number\">-1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, days[<span class=\"number\">-1</span>]+<span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> set(days):</span><br><span class=\"line\">            dp[i] = dp[i<span class=\"number\">-1</span>]</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        dp[i] = min((dp[i-d] <span class=\"keyword\">if</span> i-d&gt;=<span class=\"number\">0</span> <span class=\"keyword\">else</span> <span class=\"number\">0</span>) + cost <span class=\"keyword\">for</span> d, cost <span class=\"keyword\">in</span> zip([<span class=\"number\">1</span>, <span class=\"number\">7</span>, <span class=\"number\">30</span>], costs))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"473-Matchsticks-to-Square\"><a href=\"#473-Matchsticks-to-Square\" class=\"headerlink\" title=\"473. Matchsticks to Square\"></a>473. Matchsticks to Square</h3><h4 id=\"将长度列表的火柴棍拼成正方形。不能折断某个火柴，但可以连接。原题\"><a href=\"#将长度列表的火柴棍拼成正方形。不能折断某个火柴，但可以连接。原题\" class=\"headerlink\" title=\"将长度列表的火柴棍拼成正方形。不能折断某个火柴，但可以连接。原题\"></a>将长度列表的火柴棍拼成正方形。不能折断某个火柴，但可以连接。<a href=\"https://leetcode.com/problems/matchsticks-to-square/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [1,1,2,2,2]</span><br><span class=\"line\">Output: true</span><br><span class=\"line\"></span><br><span class=\"line\">Explanation: You can form a square with length 2, one side of the square came two sticks with length 1.</span><br><span class=\"line\"></span><br><span class=\"line\">Input: [3,3,3,3,4]</span><br><span class=\"line\">Output: false</span><br><span class=\"line\"></span><br><span class=\"line\">Explanation: You cannot find a way to form a square with all the matchsticks.</span><br></pre></td></tr></table></figure>\n<p>方法一：dfs ，效率不是很高。sort很重要，如果优先拿的不是最大的，那么将会超时。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">makesquare</span><span class=\"params\">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(nums)&lt;<span class=\"number\">4</span> <span class=\"keyword\">or</span> sum(nums) % <span class=\"number\">4</span>: <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    target = sum(nums) // <span class=\"number\">4</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> max(nums) &gt; target: <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    nums.sort()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(edges)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># if all(d==target for d in edges): return True</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> nums: <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        cur = nums.pop()</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> edges[i] + cur &lt;= target:</span><br><span class=\"line\">                edges[i] += cur</span><br><span class=\"line\">                <span class=\"keyword\">if</span> dfs(edges): <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">                edges[i] -= cur</span><br><span class=\"line\">        nums.append(cur)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> dfs([<span class=\"number\">0</span>]*<span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：bitmask+ dp。这个方法研究了很长时间，忽略了<code>A[bit]&gt;cur</code>下的break，让我对输出疑惑了很久，mask是一个N长度的都是1的二进制数，每次从右到左数第[i]位设为0 表示A[i]已经使用了，cur表示当前边剩下的长度，如果为0，表示一个边已经准备好，重新再设为T。原答案用的A排序是正序，我改成了倒序，又快了一倍，但是感觉这个跟cases是密切相关的，这个方法非常快，最快仅用40ms。比方法一快得多。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">makesquare</span><span class=\"params\">(self, A: List[int])</span> -&gt; bool:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(A) &lt; <span class=\"number\">4</span> <span class=\"keyword\">or</span> sum(A) % <span class=\"number\">4</span> <span class=\"keyword\">or</span> max(A) &gt; sum(A) / <span class=\"number\">4</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">    T = sum(A) // <span class=\"number\">4</span></span><br><span class=\"line\">    N = len(A)</span><br><span class=\"line\">    A.sort(reverse=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    memo = &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dp</span><span class=\"params\">(mask, cur = T)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># print(format(mask, 'b').rjust(N, '0'), cur)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mask, cur) <span class=\"keyword\">in</span> memo:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> memo[mask, cur]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> mask == <span class=\"number\">0</span>: <span class=\"keyword\">return</span> cur == <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> cur == <span class=\"number\">0</span>: <span class=\"keyword\">return</span> dp(mask, T)</span><br><span class=\"line\"></span><br><span class=\"line\">        ans = <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> bit <span class=\"keyword\">in</span> range(N):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> mask &amp; (<span class=\"number\">1</span> &lt;&lt; bit):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> A[bit] &gt; cur:</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">                <span class=\"comment\"># print('\\t', format(mask, 'b').rjust(N, '0'), cur, bit)</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> dp(mask ^ (<span class=\"number\">1</span> &lt;&lt; bit), cur - A[bit]):</span><br><span class=\"line\">                    ans = <span class=\"literal\">True</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">        memo[mask, cur] = ans</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">    </span><br><span class=\"line\">    ans = dp(<span class=\"number\">2</span>**N - <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"799-Champagne-Tower\"><a href=\"#799-Champagne-Tower\" class=\"headerlink\" title=\"799. Champagne Tower\"></a>799. Champagne Tower</h3><h4 id=\"这题蛮有意思，说一个香槟塔，从塔尖倒酒，倒指定杯数的酒，然后问第几行第几个杯子是有多少酒。原题\"><a href=\"#这题蛮有意思，说一个香槟塔，从塔尖倒酒，倒指定杯数的酒，然后问第几行第几个杯子是有多少酒。原题\" class=\"headerlink\" title=\"这题蛮有意思，说一个香槟塔，从塔尖倒酒，倒指定杯数的酒，然后问第几行第几个杯子是有多少酒。原题 \"></a>这题蛮有意思，说一个香槟塔，从塔尖倒酒，倒指定杯数的酒，然后问第几行第几个杯子是有多少酒。<a href=\"https://leetcode.com/problems/champagne-tower/\" target=\"_blank\" rel=\"noopener\">原题 </a></h4><p>方法一：想象每行前后多两个空杯，方便计算。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">champagneTower</span><span class=\"params\">(self, poured: int, query_row: int, query_glass: int)</span> -&gt; float:</span></span><br><span class=\"line\">    row = [poured]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> r <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, query_row+<span class=\"number\">1</span>):</span><br><span class=\"line\">        tmp_row = [<span class=\"number\">0</span>] + row + [<span class=\"number\">0</span>]</span><br><span class=\"line\">        a, b = itertools.tee(iter(tmp_row))</span><br><span class=\"line\">        next(b, <span class=\"literal\">None</span>)</span><br><span class=\"line\">        row = [max((l<span class=\"number\">-1</span>)*<span class=\"number\">0.5</span>, <span class=\"number\">0</span>) + max((r<span class=\"number\">-1</span>)*<span class=\"number\">0.5</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">               <span class=\"keyword\">for</span> l, r <span class=\"keyword\">in</span> zip(a, b)]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min(row[query_glass], <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n<p>方法二：Lee的方法和我的差不多，但是空间上比较小。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">champagneTower</span><span class=\"params\">(self, poured: int, query_row: int, query_glass: int)</span> -&gt; float:</span></span><br><span class=\"line\">    res = [poured] + [<span class=\"number\">0</span>] * query_row</span><br><span class=\"line\">    <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, query_row + <span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(row, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">            res[i] = max(res[i] - <span class=\"number\">1</span>, <span class=\"number\">0</span>) / <span class=\"number\">2.0</span> + max(res[i - <span class=\"number\">1</span>] - <span class=\"number\">1</span>, <span class=\"number\">0</span>) / <span class=\"number\">2.0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> min(res[query_glass], <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"486-Predict-the-Winner\"><a href=\"#486-Predict-the-Winner\" class=\"headerlink\" title=\"486. Predict the Winner\"></a>486. Predict the Winner</h3><h4 id=\"两个选手每次从一堆球的两边拿，每人都是最优解，问最后A是否能赢。原题\"><a href=\"#两个选手每次从一堆球的两边拿，每人都是最优解，问最后A是否能赢。原题\" class=\"headerlink\" title=\"两个选手每次从一堆球的两边拿，每人都是最优解，问最后A是否能赢。原题\"></a>两个选手每次从一堆球的两边拿，每人都是最优解，问最后A是否能赢。<a href=\"https://leetcode.com/problems/predict-the-winner/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [1, 5, 2]</span><br><span class=\"line\">Output: False</span><br><span class=\"line\">Explanation: Initially, player 1 can choose between 1 and 2. </span><br><span class=\"line\">If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). </span><br><span class=\"line\">So, final score of player 1 is 1 + 2 &#x3D; 3, and player 2 is 5. </span><br><span class=\"line\">Hence, player 1 will never be the winner and you need to return False.</span><br></pre></td></tr></table></figure>\n<p>方法一：主要找到公式。递归。<code>dp[i][j]</code>表示从i~j最大能赢多少分。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">PredictTheWinner</span><span class=\"params\">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class=\"line\">    memo = &#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pick</span><span class=\"params\">(i, j)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i, j) <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> memo:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i == j:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> nums[i]</span><br><span class=\"line\">            memo[(i, j)] = max(nums[i]-pick(i+<span class=\"number\">1</span>, j), nums[j]-pick(i, j<span class=\"number\">-1</span>))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> memo[(i, j)]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> pick(<span class=\"number\">0</span>, len(nums)<span class=\"number\">-1</span>) &gt;= <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<p>方法二：迭代的方法更新顺序不太好想，s表示长度。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">PredictTheWinner</span><span class=\"params\">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class=\"line\">     dp = [[<span class=\"number\">0</span>] * len(nums) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(len(nums))]</span><br><span class=\"line\">     <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> range(len(nums)):</span><br><span class=\"line\">         <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(nums)-s):</span><br><span class=\"line\">             j = i + s</span><br><span class=\"line\">             <span class=\"keyword\">if</span> i == j:</span><br><span class=\"line\">                 dp[i][i] = nums[i]</span><br><span class=\"line\">             <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                 dp[i][j] = max(nums[j] - dp[i][j<span class=\"number\">-1</span>], nums[i] - dp[i+<span class=\"number\">1</span>][j])</span><br><span class=\"line\">     <span class=\"keyword\">return</span> dp[<span class=\"number\">0</span>][<span class=\"number\">-1</span>] &gt;= <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"576-Out-of-Boundary-Paths\"><a href=\"#576-Out-of-Boundary-Paths\" class=\"headerlink\" title=\"576. Out of Boundary Paths\"></a>576. Out of Boundary Paths</h3><h4 id=\"将球踢出边界的路径数量，步数在N步之内。原题\"><a href=\"#将球踢出边界的路径数量，步数在N步之内。原题\" class=\"headerlink\" title=\"将球踢出边界的路径数量，步数在N步之内。原题\"></a>将球踢出边界的路径数量，步数在N步之内。<a href=\"https://leetcode.com/problems/out-of-boundary-paths/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：比较直观的方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findPaths</span><span class=\"params\">(self, m: int, n: int, N: int, i: int, j: int)</span> -&gt; int:</span></span><br><span class=\"line\">    mod = <span class=\"number\">10</span>**<span class=\"number\">9</span> + <span class=\"number\">7</span></span><br><span class=\"line\">    g = [[<span class=\"number\">0</span>] * n <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(m)]</span><br><span class=\"line\">    g[i][j] = <span class=\"number\">1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">count</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">        total = <span class=\"number\">0</span></span><br><span class=\"line\">        total += sum(g[<span class=\"number\">0</span>][j] <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n))</span><br><span class=\"line\">        total += sum(g[m<span class=\"number\">-1</span>][j] <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n))</span><br><span class=\"line\">        total += sum(g[i][<span class=\"number\">0</span>] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m))</span><br><span class=\"line\">        total += sum(g[i][n<span class=\"number\">-1</span>] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> total</span><br><span class=\"line\">    </span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(N):</span><br><span class=\"line\">        ans = (ans + count()) % mod</span><br><span class=\"line\">        new_g = [[<span class=\"number\">0</span>] * n <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(m)]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">                new_g[i][j] += g[i<span class=\"number\">-1</span>][j] <span class=\"keyword\">if</span> i <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br><span class=\"line\">                new_g[i][j] += g[i+<span class=\"number\">1</span>][j] <span class=\"keyword\">if</span> i&lt;m<span class=\"number\">-1</span> <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br><span class=\"line\">                new_g[i][j] += g[i][j<span class=\"number\">-1</span>] <span class=\"keyword\">if</span> j <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br><span class=\"line\">                new_g[i][j] += g[i][j+<span class=\"number\">1</span>] <span class=\"keyword\">if</span> j&lt;n<span class=\"number\">-1</span> <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br><span class=\"line\">        g = new_g</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：从边界到目标点。这个要这样想比如例子2，一步的时候是<code>[3,2,3]</code>，第二步是<code>[5,8,5]</code>，第3步是<code>[11,12,11]</code>，当从2加到3步时，两边的点1~2步的结果，加了一步，可以从四周到达这个节点，两边+了一步变成2~3步的个数。然后再加上和下边界1步的个数</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findPaths</span><span class=\"params\">(self, m: int, n: int, N: int, i: int, j: int)</span> -&gt; int:</span></span><br><span class=\"line\">    dp = [[<span class=\"number\">0</span>]*n <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(m)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(N):</span><br><span class=\"line\">    <span class=\"comment\"># deep copy of dp</span></span><br><span class=\"line\">        t = [s[:] <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> dp]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(m):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> y <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">                a = t[x<span class=\"number\">-1</span>][y] <span class=\"keyword\">if</span> x &gt; <span class=\"number\">0</span> <span class=\"keyword\">else</span> <span class=\"number\">1</span></span><br><span class=\"line\">                b = t[x+<span class=\"number\">1</span>][y] <span class=\"keyword\">if</span> x + <span class=\"number\">1</span> &lt; m <span class=\"keyword\">else</span> <span class=\"number\">1</span></span><br><span class=\"line\">                c = t[x][y<span class=\"number\">-1</span>] <span class=\"keyword\">if</span> y &gt; <span class=\"number\">0</span> <span class=\"keyword\">else</span> <span class=\"number\">1</span></span><br><span class=\"line\">                d = t[x][y+<span class=\"number\">1</span>] <span class=\"keyword\">if</span> y + <span class=\"number\">1</span> &lt; n <span class=\"keyword\">else</span> <span class=\"number\">1</span></span><br><span class=\"line\">                dp[x][y] = a + b + c + d</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[i][j] % (<span class=\"number\">10</span>**<span class=\"number\">9</span>+<span class=\"number\">7</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"688-Knight-Probability-in-Chessboard\"><a href=\"#688-Knight-Probability-in-Chessboard\" class=\"headerlink\" title=\"688. Knight Probability in Chessboard\"></a>688. Knight Probability in Chessboard</h3><h4 id=\"中国象棋的马，在棋盘上走K步，问还在棋盘上的概率。原题\"><a href=\"#中国象棋的马，在棋盘上走K步，问还在棋盘上的概率。原题\" class=\"headerlink\" title=\"中国象棋的马，在棋盘上走K步，问还在棋盘上的概率。原题\"></a>中国象棋的马，在棋盘上走K步，问还在棋盘上的概率。<a href=\"https://leetcode.com/problems/knight-probability-in-chessboard/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：和576一样。区别在于刚好K步，走法不同。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">knightProbability</span><span class=\"params\">(self, N: int, K: int, r: int, c: int)</span> -&gt; float:</span></span><br><span class=\"line\">    directions = ((<span class=\"number\">-1</span>, <span class=\"number\">-2</span>), (<span class=\"number\">-2</span>, <span class=\"number\">-1</span>), (<span class=\"number\">-2</span>, <span class=\"number\">1</span>), (<span class=\"number\">-1</span>, <span class=\"number\">2</span>),</span><br><span class=\"line\">                  (<span class=\"number\">1</span>, <span class=\"number\">-2</span>), (<span class=\"number\">2</span>, <span class=\"number\">-1</span>), (<span class=\"number\">2</span>, <span class=\"number\">1</span>), (<span class=\"number\">1</span>, <span class=\"number\">2</span>))</span><br><span class=\"line\">    </span><br><span class=\"line\">    dp = [[<span class=\"number\">0</span>]*N <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(N)]</span><br><span class=\"line\">    dp[r][c] = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(K):</span><br><span class=\"line\">        new_dp = [[<span class=\"number\">0</span>]*N <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(N)]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(N):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(N):</span><br><span class=\"line\">                new_dp[i][j] = sum(dp[i+di][j+dj] <span class=\"keyword\">for</span> di, dj <span class=\"keyword\">in</span> directions</span><br><span class=\"line\">                                   <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=i+di&lt;N <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=j+dj&lt;N)</span><br><span class=\"line\">        dp = new_dp</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(sum(dp, [])) / (<span class=\"number\">8</span>**K)</span><br></pre></td></tr></table></figure>\n<p>方法二：少了最后一步求和的过程。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">knightProbability</span><span class=\"params\">(self, N: int, K: int, r: int, c: int)</span> -&gt; float:</span></span><br><span class=\"line\">    directions = ((<span class=\"number\">-1</span>, <span class=\"number\">-2</span>), (<span class=\"number\">-2</span>, <span class=\"number\">-1</span>), (<span class=\"number\">-2</span>, <span class=\"number\">1</span>), (<span class=\"number\">-1</span>, <span class=\"number\">2</span>),</span><br><span class=\"line\">                  (<span class=\"number\">1</span>, <span class=\"number\">-2</span>), (<span class=\"number\">2</span>, <span class=\"number\">-1</span>), (<span class=\"number\">2</span>, <span class=\"number\">1</span>), (<span class=\"number\">1</span>, <span class=\"number\">2</span>))</span><br><span class=\"line\">    </span><br><span class=\"line\">    dp = [[<span class=\"number\">0</span>]*N <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(N)]</span><br><span class=\"line\">    dp[r][c], out = <span class=\"number\">1</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(K):</span><br><span class=\"line\">        new_dp = [[<span class=\"number\">0</span>]*N <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(N)]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(N):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(N):</span><br><span class=\"line\">                <span class=\"keyword\">for</span> di, dj <span class=\"keyword\">in</span> directions:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=i+di&lt;N <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=j+dj&lt;N:</span><br><span class=\"line\">                        new_dp[i+di][j+dj] += dp[i][j] / <span class=\"number\">8</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                        out += dp[i][j] / <span class=\"number\">8</span></span><br><span class=\"line\">        dp = new_dp</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span> - out</span><br></pre></td></tr></table></figure>\n<h3 id=\"132-Palindrome-Partitioning-II\"><a href=\"#132-Palindrome-Partitioning-II\" class=\"headerlink\" title=\"132. Palindrome Partitioning II\"></a>132. Palindrome Partitioning II</h3><h4 id=\"最少需要多少次分割，可以将s切成的每段都是回文串。原题\"><a href=\"#最少需要多少次分割，可以将s切成的每段都是回文串。原题\" class=\"headerlink\" title=\"最少需要多少次分割，可以将s切成的每段都是回文串。原题\"></a>最少需要多少次分割，可以将s切成的每段都是回文串。<a href=\"https://leetcode.com/problems/palindrome-partitioning-ii/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;aab&quot;</span><br><span class=\"line\">Output: 1</span><br><span class=\"line\">Explanation: The palindrome partitioning [&quot;aa&quot;,&quot;b&quot;] could be produced using 1 cut.</span><br></pre></td></tr></table></figure>\n<p>方法一：比较暴力的方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minCut</span><span class=\"params\">(self, s: str)</span> -&gt; int:</span></span><br><span class=\"line\">    n = len(s)</span><br><span class=\"line\">    cut = list(range(n))</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> s[:i+<span class=\"number\">1</span>] == s[:i+<span class=\"number\">1</span>][::<span class=\"number\">-1</span>]:</span><br><span class=\"line\">            cut[i] = <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        cut[i] = min(cut[j]+<span class=\"number\">1</span> <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i) <span class=\"keyword\">if</span> s[j+<span class=\"number\">1</span>:i+<span class=\"number\">1</span>]==s[j+<span class=\"number\">1</span>:i+<span class=\"number\">1</span>][::<span class=\"number\">-1</span>])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cut[<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"1043-Partition-Array-for-Maximum-Sum\"><a href=\"#1043-Partition-Array-for-Maximum-Sum\" class=\"headerlink\" title=\"1043. Partition Array for Maximum Sum\"></a>1043. Partition Array for Maximum Sum</h3><h4 id=\"将一个数组切分，-每段可以把所有的值变成当前段最大值。每段最长不能超过k。求切分后所有数的最大的和。原题\"><a href=\"#将一个数组切分，-每段可以把所有的值变成当前段最大值。每段最长不能超过k。求切分后所有数的最大的和。原题\" class=\"headerlink\" title=\"将一个数组切分， 每段可以把所有的值变成当前段最大值。每段最长不能超过k。求切分后所有数的最大的和。原题\"></a>将一个数组切分， 每段可以把所有的值变成当前段最大值。每段最长不能超过k。求切分后所有数的最大的和。<a href=\"https://leetcode.com/problems/partition-array-for-maximum-sum/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: arr &#x3D; [1,15,7,9,2,5,10], k &#x3D; 3</span><br><span class=\"line\">Output: 84</span><br><span class=\"line\">Explanation: arr becomes [15,15,15,9,10,10,10]</span><br></pre></td></tr></table></figure>\n<p>方法一：稍微想一想就想到了dp。这个AC的方法将近3s了。不过也beats了20%。索引那里需要注意是从1开始的，切片的时候得减去。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxSumAfterPartitioning</span><span class=\"params\">(self, A: List[int], K: int)</span> -&gt; int:</span></span><br><span class=\"line\">    n = len(A)</span><br><span class=\"line\">    dp = [<span class=\"number\">0</span>] * (n+<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, a <span class=\"keyword\">in</span> enumerate(A, <span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, K+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i-j &gt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">                dp[i] = max(dp[i], dp[i-j] + max(A[i-j:i])*j)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：优化一下，768ms, beats 50%了。最大值可以不用每次都算，索引改从0开始了，从1开始某些地方太让人困惑。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxSumAfterPartitioning</span><span class=\"params\">(self, A: List[int], K: int)</span> -&gt; int:</span></span><br><span class=\"line\">    n = len(A)</span><br><span class=\"line\">    dp = [<span class=\"number\">0</span>] * (n+<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, a <span class=\"keyword\">in</span> enumerate(A):</span><br><span class=\"line\">        r = a</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, K+<span class=\"number\">1</span>):</span><br><span class=\"line\">            r = max(r, A[i-j+<span class=\"number\">1</span>] <span class=\"keyword\">if</span> i-j+<span class=\"number\">1</span>&gt;=<span class=\"number\">0</span> <span class=\"keyword\">else</span> <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i-j+<span class=\"number\">1</span> &gt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">                dp[i+<span class=\"number\">1</span>] = max(dp[i+<span class=\"number\">1</span>], dp[i-j+<span class=\"number\">1</span>] + r*j)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：Lee的方法和我一样，在循环边界上更加整洁。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxSumAfterPartitioning</span><span class=\"params\">(self, A: List[int], K: int)</span> -&gt; int:</span></span><br><span class=\"line\">    n = len(A)</span><br><span class=\"line\">    dp = [<span class=\"number\">0</span>] * (n+<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, a <span class=\"keyword\">in</span> enumerate(A):</span><br><span class=\"line\">        r = a</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, min(i+<span class=\"number\">1</span>, K)+<span class=\"number\">1</span>):</span><br><span class=\"line\">            r = max(r, A[i-j+<span class=\"number\">1</span>])</span><br><span class=\"line\">            dp[i+<span class=\"number\">1</span>] = max(dp[i+<span class=\"number\">1</span>], dp[i-j+<span class=\"number\">1</span>] + r*j)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"790-Domino-and-Tromino-Tiling\"><a href=\"#790-Domino-and-Tromino-Tiling\" class=\"headerlink\" title=\"790. Domino and Tromino Tiling\"></a>790. Domino and Tromino Tiling</h3><h4 id=\"在2-N的平台上摆放两种多米诺骨牌，一共有多少种摆法。原题\"><a href=\"#在2-N的平台上摆放两种多米诺骨牌，一共有多少种摆法。原题\" class=\"headerlink\" title=\"在2*N的平台上摆放两种多米诺骨牌，一共有多少种摆法。原题\"></a>在2*N的平台上摆放两种多米诺骨牌，一共有多少种摆法。<a href=\"https://leetcode.com/problems/domino-and-tromino-tiling/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Example:</span><br><span class=\"line\">Input: 3</span><br><span class=\"line\">Output: 5</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">The five different ways are listed below, different letters indicates different tiles:</span><br><span class=\"line\">XYZ XXZ XYY XXY XYY</span><br><span class=\"line\">XYZ YYZ XZZ XYY XXY</span><br></pre></td></tr></table></figure>\n<p>方法一：这题看了答案，自己推的状态方程不太对。没考虑第2种骨牌的多种摆法。引用一张高票的手写推导图。</p>\n<img src=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AF%87%EF%BC%89Danymic-Programming/domino.png\" class>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">dp[n]&#x3D;dp[n-1]+dp[n-2]+ 2*(dp[n-3]+...+d[0])</span><br><span class=\"line\">&#x3D;dp[n-1]+dp[n-2]+dp[n-3]+dp[n-3]+2*(dp[n-4]+...+d[0])</span><br><span class=\"line\">&#x3D;dp[n-1]+dp[n-3]+(dp[n-2]+dp[n-3]+2*(dp[n-4]+...+d[0]))</span><br><span class=\"line\">&#x3D;dp[n-1]+dp[n-3]+dp[n-1]</span><br><span class=\"line\">&#x3D;2*dp[n-1]+dp[n-3]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numTilings</span><span class=\"params\">(self, N: int)</span> -&gt; int:</span></span><br><span class=\"line\">    mod = <span class=\"number\">10</span>**<span class=\"number\">9</span> + <span class=\"number\">7</span></span><br><span class=\"line\">    dp = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>, N+<span class=\"number\">1</span>):</span><br><span class=\"line\">        dp.append(<span class=\"number\">2</span>*dp[i<span class=\"number\">-1</span>] + dp[i<span class=\"number\">-3</span>])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[<span class=\"number\">-1</span>]%mod <span class=\"keyword\">if</span> N&gt;<span class=\"number\">3</span> <span class=\"keyword\">else</span> dp[N]</span><br></pre></td></tr></table></figure>\n<h3 id=\"329-Longest-Increasing-Path-in-a-Matrix\"><a href=\"#329-Longest-Increasing-Path-in-a-Matrix\" class=\"headerlink\" title=\"329. Longest Increasing Path in a Matrix\"></a>329. Longest Increasing Path in a Matrix</h3><h4 id=\"矩阵中最长的递增路径。原题\"><a href=\"#矩阵中最长的递增路径。原题\" class=\"headerlink\" title=\"矩阵中最长的递增路径。原题\"></a>矩阵中最长的递增路径。<a href=\"https://leetcode.com/problems/longest-increasing-path-in-a-matrix/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; </span><br><span class=\"line\">[</span><br><span class=\"line\">  [9,9,4],</span><br><span class=\"line\">  [6,6,8],</span><br><span class=\"line\">  [2,1,1]</span><br><span class=\"line\">] </span><br><span class=\"line\">Output: 4 </span><br><span class=\"line\">Explanation: The longest increasing path is [1, 2, 6, 9].</span><br></pre></td></tr></table></figure>\n<p>方法一：回溯+记忆化搜索。这题做的时候状态不太好，导致好几次WA和超时。首先要明白几点。因为是递增，不包含重复的，所以不需要对已遍历的节点进行重复判断。对于每个点来说，它所能延长到最长的路径是一定的。所以当得到这个值之后，后续再到这个节点就无需再计算了。使用一个字典来记录它的值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestIncreasingPath</span><span class=\"params\">(self, g: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> g: <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    m, n = len(g), len(g[<span class=\"number\">0</span>])</span><br><span class=\"line\">    </span><br><span class=\"line\">    seen = &#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">spread</span><span class=\"params\">(i, j, p)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i, j) <span class=\"keyword\">in</span> seen: <span class=\"keyword\">return</span> seen[(i, j)]</span><br><span class=\"line\">        p.append(g[i][j])</span><br><span class=\"line\">        </span><br><span class=\"line\">        nxt = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> ((i+<span class=\"number\">1</span>, j), (i, j+<span class=\"number\">1</span>), (i<span class=\"number\">-1</span>, j), (i, j<span class=\"number\">-1</span>)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=x&lt;m <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=y&lt;n:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> g[x][y] &gt; p[<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                    nxt = max(nxt, spread(x, y, p))</span><br><span class=\"line\">        ans = <span class=\"number\">1</span> + nxt</span><br><span class=\"line\">        seen[(i, j)] = ans</span><br><span class=\"line\">        p.pop()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">                    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            spread(i, j, [])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(seen.values())</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：这题先入为主了，矩阵中的路径老想着回溯。其实dfs就行了，参数p除了比较根本没用。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestIncreasingPath</span><span class=\"params\">(self, g: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> g: <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    m, n = len(g), len(g[<span class=\"number\">0</span>])</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(i, j)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> dp[i][j]:</span><br><span class=\"line\">            val, ans = g[i][j], <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> ((i+<span class=\"number\">1</span>, j), (i, j+<span class=\"number\">1</span>), (i<span class=\"number\">-1</span>, j), (i, j<span class=\"number\">-1</span>)):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=x&lt;m <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=y&lt;n <span class=\"keyword\">and</span> val &lt; g[x][y]:</span><br><span class=\"line\">                    ans = max(ans, dfs(x, y))</span><br><span class=\"line\">            dp[i][j] = <span class=\"number\">1</span> + ans</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[i][j]</span><br><span class=\"line\">    </span><br><span class=\"line\">    dp = [[<span class=\"number\">0</span>] * n <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(m)]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(dfs(i, j) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m) <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n))</span><br></pre></td></tr></table></figure>\n<h3 id=\"638-Shopping-Offers\"><a href=\"#638-Shopping-Offers\" class=\"headerlink\" title=\"638. Shopping Offers\"></a>638. Shopping Offers</h3><h4 id=\"这题和329差不多的方法。说商店有东西打折。一些商品打包打折卖。给定每种东西的数量，问最少需要多少钱。最多只有6个商品，每样不超过6个。你不能多买，即便需要的钱更少。原题\"><a href=\"#这题和329差不多的方法。说商店有东西打折。一些商品打包打折卖。给定每种东西的数量，问最少需要多少钱。最多只有6个商品，每样不超过6个。你不能多买，即便需要的钱更少。原题\" class=\"headerlink\" title=\"这题和329差不多的方法。说商店有东西打折。一些商品打包打折卖。给定每种东西的数量，问最少需要多少钱。最多只有6个商品，每样不超过6个。你不能多买，即便需要的钱更少。原题\"></a>这题和329差不多的方法。说商店有东西打折。一些商品打包打折卖。给定每种东西的数量，问最少需要多少钱。最多只有6个商品，每样不超过6个。你不能多买，即便需要的钱更少。<a href=\"https://leetcode.com/problems/shopping-offers/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [2,5], [[3,0,5],[1,2,10]], [3,2]</span><br><span class=\"line\">Output: 14</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">There are two kinds of items, A and B. Their prices are $2 and $5 respectively. </span><br><span class=\"line\">In special offer 1, you can pay $5 for 3A and 0B</span><br><span class=\"line\">In special offer 2, you can pay $10 for 1A and 2B. </span><br><span class=\"line\">You need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A.</span><br></pre></td></tr></table></figure>\n<p>方法一：思路还算清晰，但是这里因为自作聪明加了两行代码，导致最后严重超时。方法还是dfs + 记忆化。因为加了注释中的代码，这里原本想的是，索性将原价商品页当做打包卖，只不过价格不一样而已。但是这样会增加dfs中的m。最后导致了超时。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">shoppingOffers</span><span class=\"params\">(self, price: List[int], special: List[List[int]], needs: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    n = len(price)</span><br><span class=\"line\">    <span class=\"comment\"># for i in range(n):</span></span><br><span class=\"line\">    <span class=\"comment\">#     special.append([int(i==j) for j in range(n)] + [price[i]])</span></span><br><span class=\"line\">    m = len(special)</span><br><span class=\"line\">    memo = &#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(*needs)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> needs <span class=\"keyword\">in</span> memo: <span class=\"keyword\">return</span> memo[needs]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> all(need==<span class=\"number\">0</span> <span class=\"keyword\">for</span> need <span class=\"keyword\">in</span> needs):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        ans = sum(need*p <span class=\"keyword\">for</span> need, p <span class=\"keyword\">in</span> zip(needs, price))</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(m):</span><br><span class=\"line\">            left = [cn-a <span class=\"keyword\">for</span> cn, a <span class=\"keyword\">in</span> zip(needs, special[j][:<span class=\"number\">-1</span>])]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> all(l&gt;=<span class=\"number\">0</span> <span class=\"keyword\">for</span> l <span class=\"keyword\">in</span> left) <span class=\"keyword\">and</span> ans &gt; special[j][<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                ans = min(ans, special[j][<span class=\"number\">-1</span>] + dfs(*left))</span><br><span class=\"line\">        memo[needs] = ans</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> dfs(*needs)</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：优化方法一，删除一些没用的变量。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">shoppingOffers</span><span class=\"params\">(self, price: List[int], special: List[List[int]], needs: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    memo = &#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(*needs)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> needs <span class=\"keyword\">in</span> memo: <span class=\"keyword\">return</span> memo[needs]</span><br><span class=\"line\">        ans = sum(need*p <span class=\"keyword\">for</span> need, p <span class=\"keyword\">in</span> zip(needs, price))</span><br><span class=\"line\">        <span class=\"keyword\">for</span> spec <span class=\"keyword\">in</span> special:</span><br><span class=\"line\">            left = [cn-a <span class=\"keyword\">for</span> cn, a <span class=\"keyword\">in</span> zip(needs, spec[:<span class=\"number\">-1</span>])]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> min(left)&gt;=<span class=\"number\">0</span> <span class=\"keyword\">and</span> ans &gt; spec[<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                ans = min(ans, spec[<span class=\"number\">-1</span>] + dfs(*left))</span><br><span class=\"line\">        memo[needs] = ans</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> dfs(*needs)</span><br></pre></td></tr></table></figure>\n<h3 id=\"152-Maximum-Product-Subarray\"><a href=\"#152-Maximum-Product-Subarray\" class=\"headerlink\" title=\"152. Maximum Product Subarray\"></a>152. Maximum Product Subarray</h3><h4 id=\"最大的子数组乘积。和1567题目类似，那题是求长度，可以贪心，这题没有。原题\"><a href=\"#最大的子数组乘积。和1567题目类似，那题是求长度，可以贪心，这题没有。原题\" class=\"headerlink\" title=\"最大的子数组乘积。和1567题目类似，那题是求长度，可以贪心，这题没有。原题\"></a>最大的子数组乘积。和1567题目类似，那题是求长度，可以贪心，这题没有。<a href=\"https://leetcode.com/problems/maximum-product-subarray/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [2,3,-2,4]</span><br><span class=\"line\">Output: 6</span><br><span class=\"line\">Explanation: [2,3] has the largest product 6.</span><br></pre></td></tr></table></figure>\n<p>方法一：dp写法和1567dp解法相似。<code>[-2]</code>的例子只需要在前面判断一下长度是否为1即可。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxProduct</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    ans, n = float(<span class=\"string\">'-inf'</span>), len(nums)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">1</span>: <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>]</span><br><span class=\"line\">    pos, neg = [<span class=\"number\">0</span>]*n, [<span class=\"number\">0</span>]*n</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, num <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> num &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            pos[i] = num * (pos[i<span class=\"number\">-1</span>] <span class=\"keyword\">if</span> pos[i<span class=\"number\">-1</span>]!=<span class=\"number\">0</span> <span class=\"keyword\">else</span> <span class=\"number\">1</span>)</span><br><span class=\"line\">            neg[i] = num * (neg[i<span class=\"number\">-1</span>])</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> num &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            pos[i] = num * (neg[i<span class=\"number\">-1</span>])</span><br><span class=\"line\">            neg[i] = num * (pos[i<span class=\"number\">-1</span>] <span class=\"keyword\">if</span> pos[i<span class=\"number\">-1</span>]!=<span class=\"number\">0</span> <span class=\"keyword\">else</span> <span class=\"number\">1</span>)</span><br><span class=\"line\">        ans = max(ans, pos[i], neg[i])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：本来方法一也是和lee的1567解法写的。寻思这回不能差太多吧。啊这。。不知道怎么证明，但是看着答案就能想明白，最大值一定存在于这两个数组中。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxProduct</span><span class=\"params\">(self, A: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    B = A[::<span class=\"number\">-1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(A)):</span><br><span class=\"line\">        A[i] *= A[i - <span class=\"number\">1</span>] <span class=\"keyword\">or</span> <span class=\"number\">1</span></span><br><span class=\"line\">        B[i] *= B[i - <span class=\"number\">1</span>] <span class=\"keyword\">or</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(A + B)</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：改了一个生成器写法。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxProduct</span><span class=\"params\">(self, A: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">count</span><span class=\"params\">(x, y)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (x <span class=\"keyword\">or</span> <span class=\"number\">1</span>) * y</span><br><span class=\"line\">    A, B = itertools.accumulate(A, count), itertools.accumulate(A[::<span class=\"number\">-1</span>], count)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(itertools.chain(A, B))</span><br></pre></td></tr></table></figure>\n<h3 id=\"LCP-20-快速公交\"><a href=\"#LCP-20-快速公交\" class=\"headerlink\" title=\"LCP 20. 快速公交\"></a><a href=\"https://leetcode-cn.com/problems/meChtZ/\" target=\"_blank\" rel=\"noopener\">LCP 20. 快速公交</a></h3><h4 id=\"有这么个站点，每次从站点网下走需要inc时间，往回走需要dec时间，可以通过乘坐i公交车从移动到jum-i-x站点，耗时为cost-i-，问到达target站点最少需要多少时间。\"><a href=\"#有这么个站点，每次从站点网下走需要inc时间，往回走需要dec时间，可以通过乘坐i公交车从移动到jum-i-x站点，耗时为cost-i-，问到达target站点最少需要多少时间。\" class=\"headerlink\" title=\"有这么个站点，每次从站点网下走需要inc时间，往回走需要dec时间，可以通过乘坐i公交车从移动到jum[i]*x站点，耗时为cost[i]，问到达target站点最少需要多少时间。\"></a>有这么个站点，每次从站点网下走需要inc时间，往回走需要dec时间，可以通过乘坐i公交车从移动到jum[i]*x站点，耗时为cost[i]，问到达target站点最少需要多少时间。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：target &#x3D; 612, inc &#x3D; 4, dec &#x3D; 5, jump &#x3D; [3,6,8,11,5,10,4], cost &#x3D; [4,7,6,3,7,6,4]</span><br><span class=\"line\"></span><br><span class=\"line\">输出：26</span><br><span class=\"line\"></span><br><span class=\"line\">解释：</span><br><span class=\"line\">小扣步行至 1 号站点，花费时间为 4；</span><br><span class=\"line\">小扣从 1 号站台搭乘 0 号公交至 3 * 1 &#x3D; 3 站台，花费时间为 4；</span><br><span class=\"line\">小扣从 3 号站台搭乘 3 号公交至 11 * 3 &#x3D; 33 站台，花费时间为 3；</span><br><span class=\"line\">小扣从 33 号站台步行至 34 站台，花费时间为 4；</span><br><span class=\"line\">小扣从 34 号站台搭乘 0 号公交至 3 * 34 &#x3D; 102 站台，花费时间为 4；</span><br><span class=\"line\">小扣从 102 号站台搭乘 1 号公交至 6 * 102 &#x3D; 612 站台，花费时间为 7；</span><br><span class=\"line\">最终小扣花费总时间为 26。</span><br></pre></td></tr></table></figure>\n<p>方法一：记忆化搜索了。杯赛时没做出来。不好想的地方在12行，往回退的时候。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">busRapidTransit</span><span class=\"params\">(self, target: int, inc: int, dec: int, jump: List[int], cost: List[int])</span> -&gt; int:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @lru_cache(None)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dp</span><span class=\"params\">(i)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == <span class=\"number\">0</span>: <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == <span class=\"number\">1</span>: <span class=\"keyword\">return</span> inc</span><br><span class=\"line\">        ans = i * inc</span><br><span class=\"line\">        <span class=\"keyword\">for</span> bus, times <span class=\"keyword\">in</span> enumerate(jump):</span><br><span class=\"line\">            j, mod = divmod(i, times)</span><br><span class=\"line\">            ans = min(ans, mod*inc + cost[bus] + dp(j))</span><br><span class=\"line\">            <span class=\"keyword\">if</span> mod:</span><br><span class=\"line\">                ans = min(ans, (times-mod)*dec + cost[bus] + dp(j+<span class=\"number\">1</span>))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp(target) % (<span class=\"number\">10</span>**<span class=\"number\">9</span>+<span class=\"number\">7</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"877-Stone-Game\"><a href=\"#877-Stone-Game\" class=\"headerlink\" title=\"877. Stone Game\"></a>877. Stone Game</h3><h4 id=\"石头游戏，一共有偶数堆，并且总数为奇数。每次拿左或者右的一堆，每次拿都是最优解，问Alex先拿能否赢。原题\"><a href=\"#石头游戏，一共有偶数堆，并且总数为奇数。每次拿左或者右的一堆，每次拿都是最优解，问Alex先拿能否赢。原题\" class=\"headerlink\" title=\"石头游戏，一共有偶数堆，并且总数为奇数。每次拿左或者右的一堆，每次拿都是最优解，问Alex先拿能否赢。原题\"></a>石头游戏，一共有偶数堆，并且总数为奇数。每次拿左或者右的一堆，每次拿都是最优解，问Alex先拿能否赢。<a href=\"https://leetcode.com/problems/stone-game/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight d\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: piles = [<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]</span><br><span class=\"line\">Output: <span class=\"literal\">true</span></span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">Alex starts first, and can only take the first <span class=\"number\">5</span> or the last <span class=\"number\">5.</span></span><br><span class=\"line\">Say he takes the first <span class=\"number\">5</span>, so that the row becomes [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>].</span><br><span class=\"line\">If Lee takes <span class=\"number\">3</span>, then the board <span class=\"keyword\">is</span> [<span class=\"number\">4</span>, <span class=\"number\">5</span>], and Alex takes <span class=\"number\">5</span> to win <span class=\"keyword\">with</span> <span class=\"number\">10</span> points.</span><br><span class=\"line\">If Lee takes the last <span class=\"number\">5</span>, then the board <span class=\"keyword\">is</span> [<span class=\"number\">3</span>, <span class=\"number\">4</span>], and Alex takes <span class=\"number\">4</span> to win <span class=\"keyword\">with</span> <span class=\"number\">9</span> points.</span><br><span class=\"line\">This demonstrated that taking the first <span class=\"number\">5</span> was a winning move <span class=\"keyword\">for</span> Alex, so we <span class=\"keyword\">return</span> <span class=\"literal\">true</span>.</span><br></pre></td></tr></table></figure>\n<p>方法一：还算简单的一个dp，488ms, beats40%。内存有点多120多M。思路是从两边到中间。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">stoneGame</span><span class=\"params\">(self, piles: List[int])</span> -&gt; bool:</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">    @lru_cache(None)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dp</span><span class=\"params\">(i, j)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == j:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(piles[i] + dp(i+<span class=\"number\">1</span>, j), piles[j] + dp(i, j<span class=\"number\">-1</span>))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp(<span class=\"number\">0</span>, len(piles)<span class=\"number\">-1</span>)</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：迭代，不会用那么多的空间20M。不过过程不好想，从哪里开始，d表示段的长度，从最小的段开始。这里用了减法表示dp[i][j] 在piles[i]~piles[j]之间能领先多少。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">stoneGame</span><span class=\"params\">(self, p: List[int])</span> -&gt; bool:</span></span><br><span class=\"line\">    n = len(p)</span><br><span class=\"line\">    dp = [[<span class=\"number\">0</span>]*n <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">        dp[i][i] = p[i]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n - d):</span><br><span class=\"line\">            dp[i][i+d] = max(p[i]-dp[i+<span class=\"number\">1</span>][i+d], p[i+d]-dp[i][i+d<span class=\"number\">-1</span>])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[<span class=\"number\">0</span>][<span class=\"number\">-1</span>] &gt; <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：一维空间实现。这个方法好难想，dp[i] 表示以i为起点d为长度堆 也就是piles[i:i+d]最多能赢对手多少。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">stoneGame</span><span class=\"params\">(self, p: List[int])</span> -&gt; bool:</span></span><br><span class=\"line\">    n = len(p)</span><br><span class=\"line\">    dp = p[:]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n - d):</span><br><span class=\"line\">            <span class=\"comment\"># print(i, d, dp, p[i]-dp[i+1], p[i+d]-dp[i])</span></span><br><span class=\"line\">            dp[i] = max(p[i] - dp[i + <span class=\"number\">1</span>], p[i + d] - dp[i])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[<span class=\"number\">0</span>] &gt; <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<p>以<code>[5,3,4,5]</code>输出i, d ，dp是这样的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span> <span class=\"number\">1</span> [<span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>] <span class=\"number\">2</span> <span class=\"number\">-2</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">1</span> [<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>] <span class=\"number\">-1</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span> <span class=\"number\">1</span> [<span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>] <span class=\"number\">-1</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"number\">2</span> [<span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">5</span>] <span class=\"number\">4</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">2</span> [<span class=\"number\">4</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">5</span>] <span class=\"number\">2</span> <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"number\">3</span> [<span class=\"number\">4</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>, <span class=\"number\">5</span>] <span class=\"number\">1</span> <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>方法四：对于此题来说，堆为偶数个，和为奇数。那么将其分为两组，奇数索引组合偶数索引组，假设这两个人都按照这个拿，Alex先手总能拿到多的那个。因为Alex可以保证拿到多的那组，比如<code>[5,3,4,5]</code>奇数组的5+4&gt;5+3，那么在拿走第一个5，对手只能从两个偶数组选，而无论对手选哪个偶数，Alex总有下一个奇数组的数可选。这题曾经在知乎上看到过uwi在比赛中思考了1分多钟就写出了这样的答案，不愧为常年霸榜的选手。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">stoneGame</span><span class=\"params\">(self, p: List[int])</span> -&gt; bool:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1690-Stone-Game-VII\"><a href=\"#1690-Stone-Game-VII\" class=\"headerlink\" title=\"1690. Stone Game VII\"></a><a href=\"https://leetcode.com/problems/stone-game-vii/\" target=\"_blank\" rel=\"noopener\">1690. Stone Game VII</a></h3><h4 id=\"此题和877题相似，区别在于拿取一个石头得分为剩余石头的总和。\"><a href=\"#此题和877题相似，区别在于拿取一个石头得分为剩余石头的总和。\" class=\"headerlink\" title=\"此题和877题相似，区别在于拿取一个石头得分为剩余石头的总和。\"></a>此题和877题相似，区别在于拿取一个石头得分为剩余石头的总和。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: stones &#x3D; [5,3,1,4,2]</span><br><span class=\"line\">Output: 6</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">- Alice removes 2 and gets 5 + 3 + 1 + 4 &#x3D; 13 points. Alice &#x3D; 13, Bob &#x3D; 0, stones &#x3D; [5,3,1,4].</span><br><span class=\"line\">- Bob removes 5 and gets 3 + 1 + 4 &#x3D; 8 points. Alice &#x3D; 13, Bob &#x3D; 8, stones &#x3D; [3,1,4].</span><br><span class=\"line\">- Alice removes 3 and gets 1 + 4 &#x3D; 5 points. Alice &#x3D; 18, Bob &#x3D; 8, stones &#x3D; [1,4].</span><br><span class=\"line\">- Bob removes 1 and gets 4 points. Alice &#x3D; 18, Bob &#x3D; 12, stones &#x3D; [4].</span><br><span class=\"line\">- Alice removes 4 and gets 0 points. Alice &#x3D; 18, Bob &#x3D; 12, stones &#x3D; [].</span><br><span class=\"line\">The score difference is 18 - 12 &#x3D; 6.</span><br></pre></td></tr></table></figure>\n<p>方法一：此题竞赛没过，写了递归的超时了，迭代的状态转移方程没有找到。但是将<code>lru_cache</code>最大长度改为<code>1000</code>就能过，耗时6000ms。就很迷</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">stoneGameVII</span><span class=\"params\">(self, stones: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    total = sum(stones)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @lru_cache(1000)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dp</span><span class=\"params\">(i, j, remain)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># print(i, j, remain)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == j:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(remain-stones[i]-dp(i+<span class=\"number\">1</span>, j, remain-stones[i]),</span><br><span class=\"line\">                   remain-stones[j]-dp(i, j<span class=\"number\">-1</span>, remain-stones[j]))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp(<span class=\"number\">0</span>, len(stones)<span class=\"number\">-1</span>, total)</span><br></pre></td></tr></table></figure>\n<p>方法二：<code>remain</code>是冗余的，这个比赛时没有想好。这个方法<code>lru_cache(None)</code>同样过不了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">stoneGameVII</span><span class=\"params\">(self, stones: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    total = sum(stones)</span><br><span class=\"line\">    p = list(accumulate([<span class=\"number\">0</span>]+stones))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @lru_cache(1000)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dp</span><span class=\"params\">(i, j)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == j:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(p[j+<span class=\"number\">1</span>]-p[i+<span class=\"number\">1</span>]-dp(i+<span class=\"number\">1</span>, j),</span><br><span class=\"line\">                   p[j]-p[i]-dp(i, j<span class=\"number\">-1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp(<span class=\"number\">0</span>, len(stones)<span class=\"number\">-1</span>)</span><br></pre></td></tr></table></figure>\n<p>方法三：迭代。这里想错了一件事情，<code>dp[i][j]</code>表示<code>stones[i]~stones[j]</code>最多的得分是多少。而不是<code>stones[i]</code>开始j长度最多的得分，这里将j和d搞混了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">stoneGameVII</span><span class=\"params\">(self, stones: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    n = len(stones)</span><br><span class=\"line\">    p = list(accumulate([<span class=\"number\">0</span>]+stones))</span><br><span class=\"line\">    dp = [[<span class=\"number\">0</span>]*n <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n-d):</span><br><span class=\"line\">            j = i + d</span><br><span class=\"line\">            dp[i][j] = max(p[j+<span class=\"number\">1</span>]-p[i+<span class=\"number\">1</span>]-dp[i+<span class=\"number\">1</span>][j],</span><br><span class=\"line\">                           p[j]-p[i]-dp[i][j<span class=\"number\">-1</span>])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[<span class=\"number\">0</span>][<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"300-Longest-Increasing-Subsequence\"><a href=\"#300-Longest-Increasing-Subsequence\" class=\"headerlink\" title=\"300. Longest Increasing Subsequence\"></a><a href=\"https://leetcode.com/problems/longest-increasing-subsequence/\" target=\"_blank\" rel=\"noopener\">300. Longest Increasing Subsequence</a></h3><h4 id=\"最长的递增子序列长度。\"><a href=\"#最长的递增子序列长度。\" class=\"headerlink\" title=\"最长的递增子序列长度。\"></a>最长的递增子序列长度。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [10,9,2,5,3,7,101,18]</span><br><span class=\"line\">Output: 4 </span><br><span class=\"line\">Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.</span><br></pre></td></tr></table></figure>\n<p>方法一：首次AC的方法，时间O(n^2)。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lengthOfLIS</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"comment\"># dp[i] means the ans of nums[:i]</span></span><br><span class=\"line\">    n = len(nums)</span><br><span class=\"line\">    dp = [<span class=\"number\">1</span>] * (n+<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i)[::<span class=\"number\">-1</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[j] &lt; nums[i]:</span><br><span class=\"line\">                dp[i] = max(dp[i], dp[j] + <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums <span class=\"keyword\">and</span> max(dp) <span class=\"keyword\">or</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：看了follow up: 有N*(logN)的方法，那么就往二分法和堆上想。这个二分法太难想了，创了一个缓冲数组用来记录当前的子序列。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lengthOfLIS</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    tails = [<span class=\"number\">0</span>] * len(nums)</span><br><span class=\"line\">    size = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        print(tails)</span><br><span class=\"line\">        lo, hi = <span class=\"number\">0</span>, size</span><br><span class=\"line\">        <span class=\"keyword\">while</span> lo &lt; hi:</span><br><span class=\"line\">            mid = (lo+hi) // <span class=\"number\">2</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> tails[mid] &lt; num:</span><br><span class=\"line\">                lo = mid + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                hi = mid</span><br><span class=\"line\">        tails[lo] = num</span><br><span class=\"line\">        size = max(lo+<span class=\"number\">1</span>, size)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> size</span><br></pre></td></tr></table></figure>\n<p>假设输入是<code>[10,9,2,5,3,7,101,18,-1,0,1]</code>，tails这样变化，当出现一个较小的数，找到位置并替换，这样tails有效的部分还是有序的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span><br><span class=\"line\">[10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span><br><span class=\"line\">[9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span><br><span class=\"line\">[2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span><br><span class=\"line\">[2, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span><br><span class=\"line\">[2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span><br><span class=\"line\">[2, 3, 7, 0, 0, 0, 0, 0, 0, 0, 0]</span><br><span class=\"line\">[2, 3, 7, 101, 0, 0, 0, 0, 0, 0, 0]</span><br><span class=\"line\">[2, 3, 7, 18, 0, 0, 0, 0, 0, 0, 0]</span><br><span class=\"line\">[-1, 3, 7, 18, 0, 0, 0, 0, 0, 0, 0]</span><br><span class=\"line\">[-1, 0, 7, 18, 0, 0, 0, 0, 0, 0, 0]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：方法二的简写。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lengthOfLIS</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    dp = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        i = bisect.bisect_left(dp, num)</span><br><span class=\"line\">        dp[i:i+<span class=\"number\">1</span>] = [num]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> len(dp)</span><br></pre></td></tr></table></figure>\n<h3 id=\"673-Number-of-Longest-Increasing-Subsequence\"><a href=\"#673-Number-of-Longest-Increasing-Subsequence\" class=\"headerlink\" title=\"673. Number of Longest Increasing Subsequence\"></a><a href=\"https://leetcode.com/problems/number-of-longest-increasing-subsequence/\" target=\"_blank\" rel=\"noopener\">673. Number of Longest Increasing Subsequence</a></h3><h4 id=\"求最长递增子序列的个数。和300很像，基于300上进行修改。\"><a href=\"#求最长递增子序列的个数。和300很像，基于300上进行修改。\" class=\"headerlink\" title=\"求最长递增子序列的个数。和300很像，基于300上进行修改。\"></a>求最长递增子序列的个数。和300很像，基于300上进行修改。</h4><p>方法一：基于300方法一进行修改，dp元素保存两个信息，一个是最大长度，一个是数量。思考的时候要想如果<code>dp[-1][-1]</code>不能直接求得值的话，要考虑重新遍历一遍。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findNumberOfLIS</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    n, longest = len(nums), <span class=\"number\">1</span></span><br><span class=\"line\">    dp = [[<span class=\"number\">1</span>, <span class=\"number\">1</span>] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n):</span><br><span class=\"line\">        cur_long = <span class=\"number\">1</span></span><br><span class=\"line\">        c = collections.defaultdict(int)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i] &gt; nums[j]:</span><br><span class=\"line\">                c[dp[j][<span class=\"number\">0</span>]] += dp[j][<span class=\"number\">1</span>]</span><br><span class=\"line\">                cur_long = max(cur_long, dp[j][<span class=\"number\">0</span>] + <span class=\"number\">1</span>)</span><br><span class=\"line\">        dp[i] = [cur_long, max(c[cur_long<span class=\"number\">-1</span>], <span class=\"number\">1</span>)]</span><br><span class=\"line\">        longest = max(longest, cur_long)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(cnt <span class=\"keyword\">for</span> l, cnt <span class=\"keyword\">in</span> dp <span class=\"keyword\">if</span> l==longest)</span><br></pre></td></tr></table></figure>\n<p>方法二：进行了一些优化。比方法一快了300ms，写完之后和评论区方法比较，明明是一样的，不知道为啥慢了100ms，后来一行一行代码进行替换，调了半天，发现注释部分的代码要慢100ms，刷新了我的认知，为什么数组下标取值会慢这么多？这也太玄学了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findNumberOfLIS</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    n, max_for_all = len(nums), <span class=\"number\">1</span></span><br><span class=\"line\">    dp = [[<span class=\"number\">1</span>, <span class=\"number\">1</span>] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, num <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">        max_len, count = <span class=\"number\">1</span>, <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i):</span><br><span class=\"line\">            <span class=\"comment\"># if nums[j] &lt; nums[i]:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[j] &lt; num:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> dp[j][<span class=\"number\">0</span>] + <span class=\"number\">1</span> &gt; max_len:</span><br><span class=\"line\">                    max_len = dp[j][<span class=\"number\">0</span>] + <span class=\"number\">1</span> </span><br><span class=\"line\">                    count = <span class=\"number\">0</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> dp[j][<span class=\"number\">0</span>] == max_len - <span class=\"number\">1</span>:</span><br><span class=\"line\">                    count += dp[j][<span class=\"number\">1</span>]</span><br><span class=\"line\">        dp[i] = [max_len, max(count, dp[i][<span class=\"number\">1</span>])]</span><br><span class=\"line\">        max_for_all = max(max_len, max_for_all)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum([item[<span class=\"number\">1</span>] <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> dp <span class=\"keyword\">if</span> item[<span class=\"number\">0</span>] == max_for_all])</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：这题最好的方法还是二分法。<code>dp[i][x]</code>表示长度为i的子序列以x结尾的有多少个。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findNumberOfLIS</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    dp = collections.defaultdict(collections.Counter)</span><br><span class=\"line\">    dp[<span class=\"number\">-1</span>][float(<span class=\"string\">'-inf'</span>)] = <span class=\"number\">1</span></span><br><span class=\"line\">    seq = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        i = bisect.bisect_left(seq, num)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == len(seq):</span><br><span class=\"line\">            seq.append(num)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            seq[i] = num</span><br><span class=\"line\">        dp[i][num] += sum(dp[i<span class=\"number\">-1</span>][end] <span class=\"keyword\">for</span> end <span class=\"keyword\">in</span> dp[i<span class=\"number\">-1</span>] <span class=\"keyword\">if</span> end &lt; num)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(dp[max(<span class=\"number\">0</span>, len(seq)<span class=\"number\">-1</span>)].values())</span><br></pre></td></tr></table></figure>\n<h3 id=\"面试题-17-08-马戏团人塔\"><a href=\"#面试题-17-08-马戏团人塔\" class=\"headerlink\" title=\"面试题 17.08. 马戏团人塔\"></a><a href=\"https://leetcode-cn.com/problems/circus-tower-lcci/\" target=\"_blank\" rel=\"noopener\">面试题 17.08. 马戏团人塔</a></h3><h4 id=\"300的变种，比较两个维度。说人可以叠罗汉，但是只能将高度和体重都大的人放在下面。\"><a href=\"#300的变种，比较两个维度。说人可以叠罗汉，但是只能将高度和体重都大的人放在下面。\" class=\"headerlink\" title=\"300的变种，比较两个维度。说人可以叠罗汉，但是只能将高度和体重都大的人放在下面。\"></a>300的变种，比较两个维度。说人可以叠罗汉，但是只能将高度和体重都大的人放在下面。</h4><p>方法一：这题测试用例n^2的写法过不了。这题比堆箱子简单一点。将高度升序排列，体重降序排列。就可以按照体重来求最长上升子序列了。体重降序可以避免了高度相同的人导致结果错误。评论区学了一个方法。</p>\n<figure class=\"highlight prolog\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入样例:[[<span class=\"number\">4</span>,<span class=\"number\">5</span>],[<span class=\"number\">4</span>,<span class=\"number\">6</span>],[<span class=\"number\">6</span>,<span class=\"number\">7</span>],[<span class=\"number\">2</span>,<span class=\"number\">3</span>],[<span class=\"number\">1</span>,<span class=\"number\">1</span>]]</span><br><span class=\"line\">先按升高升序排列,再按体重升序排列</span><br><span class=\"line\">&gt;&gt;&gt;:[<span class=\"number\">1</span>, <span class=\"number\">1</span>],[<span class=\"number\">2</span>, <span class=\"number\">3</span>],[<span class=\"number\">4</span>, <span class=\"number\">5</span>],[<span class=\"number\">4</span>, <span class=\"number\">6</span>],[<span class=\"number\">6</span>, <span class=\"number\">7</span>]</span><br><span class=\"line\">&gt;&gt;&gt;answer = <span class=\"number\">5</span></span><br><span class=\"line\">先按升高升序排列,再按体重降序排列</span><br><span class=\"line\">&gt;&gt;&gt;:[<span class=\"number\">1</span>, <span class=\"number\">1</span>],[<span class=\"number\">2</span>, <span class=\"number\">3</span>],[<span class=\"number\">4</span>, <span class=\"number\">6</span>],[<span class=\"number\">4</span>, <span class=\"number\">5</span>],[<span class=\"number\">6</span>, <span class=\"number\">7</span>]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bestSeqAtIndex</span><span class=\"params\">(self, height: List[int], weight: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    dp=[]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> sorted(zip(height, weight), key=<span class=\"keyword\">lambda</span> x:(x[<span class=\"number\">0</span>],-x[<span class=\"number\">1</span>])):</span><br><span class=\"line\">       pos = bisect.bisect_left(dp, b)</span><br><span class=\"line\">       dp[pos:pos+<span class=\"number\">1</span>] = [b]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> len(dp)</span><br></pre></td></tr></table></figure>\n<h3 id=\"面试题-08-13-堆箱子\"><a href=\"#面试题-08-13-堆箱子\" class=\"headerlink\" title=\"面试题 08.13. 堆箱子\"></a><a href=\"https://leetcode-cn.com/problems/pile-box-lcci/\" target=\"_blank\" rel=\"noopener\">面试题 08.13. 堆箱子</a></h3><h4 id=\"这题和300题很像，是一个变种题。要把长宽高都大的放在底层，问最多可以叠多高。\"><a href=\"#这题和300题很像，是一个变种题。要把长宽高都大的放在底层，问最多可以叠多高。\" class=\"headerlink\" title=\"这题和300题很像，是一个变种题。要把长宽高都大的放在底层，问最多可以叠多高。\"></a>这题和300题很像，是一个变种题。要把长宽高都大的放在底层，问最多可以叠多高。</h4><p>方法一：和300一样，但是要排序，因为箱子可以随便选，这里有点迷，我一直没有想明白为什么zip会超时，而直接数组比较就不会超时。我想了想300题的NlogN的解法，但在此题上并不适用。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pileBox</span><span class=\"params\">(self, box: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    n = len(box)</span><br><span class=\"line\">    box.sort()</span><br><span class=\"line\">    dp = [<span class=\"number\">0</span>] * n</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">        dp[i] = box[i][<span class=\"number\">-1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i):</span><br><span class=\"line\">            <span class=\"comment\"># if all(b &gt; t for b, t in zip(box[i], box[j])):</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> box[j][<span class=\"number\">0</span>]&lt;box[i][<span class=\"number\">0</span>] <span class=\"keyword\">and</span> box[j][<span class=\"number\">1</span>]&lt;box[i][<span class=\"number\">1</span>] <span class=\"keyword\">and</span> box[j][<span class=\"number\">2</span>]&lt;box[i][<span class=\"number\">2</span>]:</span><br><span class=\"line\">                dp[i] = max(dp[i], dp[j] + box[i][<span class=\"number\">-1</span>])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(dp)</span><br></pre></td></tr></table></figure>\n<p>方法二：sort时以长度升序，宽度降序。这样比较的时候可以不用比较长度了，降序是为了适应长度相等的情况。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pileBox</span><span class=\"params\">(self, box: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">        n = len(box)</span><br><span class=\"line\">        box.sort(key=<span class=\"keyword\">lambda</span> x: (x[<span class=\"number\">0</span>], -x[<span class=\"number\">1</span>]))</span><br><span class=\"line\">        dp = [<span class=\"number\">0</span>] * n</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            dp[i] = box[i][<span class=\"number\">-1</span>]</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> box[j][<span class=\"number\">1</span>]&lt;box[i][<span class=\"number\">1</span>] <span class=\"keyword\">and</span> box[j][<span class=\"number\">2</span>]&lt;box[i][<span class=\"number\">2</span>]:</span><br><span class=\"line\">                    dp[i] = max(dp[i], dp[j] + box[i][<span class=\"number\">-1</span>])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(dp)</span><br></pre></td></tr></table></figure>\n<h3 id=\"1594-Maximum-Non-Negative-Product-in-a-Matrix\"><a href=\"#1594-Maximum-Non-Negative-Product-in-a-Matrix\" class=\"headerlink\" title=\"1594. Maximum Non Negative Product in a Matrix\"></a><a href=\"https://leetcode.com/problems/maximum-non-negative-product-in-a-matrix/\" target=\"_blank\" rel=\"noopener\">1594. Maximum Non Negative Product in a Matrix</a></h3><h4 id=\"最大的从左上到右下的乘积。\"><a href=\"#最大的从左上到右下的乘积。\" class=\"headerlink\" title=\"最大的从左上到右下的乘积。\"></a>最大的从左上到右下的乘积。</h4><p>方法一：这题想着迭代方法，竞赛的时候差了一行代码，时间就到了。递归的思路好想。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxProductPath</span><span class=\"params\">(self, g: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    mod = <span class=\"number\">10</span>**<span class=\"number\">9</span> + <span class=\"number\">7</span></span><br><span class=\"line\">    M, N = len(g), len(g[<span class=\"number\">0</span>])</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">    @lru_cache(None)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dp</span><span class=\"params\">(i, j)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i==<span class=\"number\">0</span> <span class=\"keyword\">and</span> j==<span class=\"number\">0</span>: <span class=\"keyword\">return</span> g[<span class=\"number\">0</span>][<span class=\"number\">0</span>], g[<span class=\"number\">0</span>][<span class=\"number\">0</span>]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i&lt;<span class=\"number\">0</span> <span class=\"keyword\">or</span> j&lt;<span class=\"number\">0</span>: <span class=\"keyword\">return</span> float(<span class=\"string\">'-inf'</span>), float(<span class=\"string\">'inf'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> g[i][j] == <span class=\"number\">0</span>: <span class=\"keyword\">return</span> <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">        mx1, mn1 = dp(i<span class=\"number\">-1</span>, j)</span><br><span class=\"line\">        mx2, mn2 = dp(i, j<span class=\"number\">-1</span>)</span><br><span class=\"line\">        mx, mn = max(mx1, mx2)*g[i][j], min(mn1, mn2)*g[i][j]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (mx, mn) <span class=\"keyword\">if</span> g[i][j]&gt;<span class=\"number\">0</span> <span class=\"keyword\">else</span> (mn, mx)</span><br><span class=\"line\">    </span><br><span class=\"line\">    mx, _ = dp(M<span class=\"number\">-1</span>, N<span class=\"number\">-1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mx % mod <span class=\"keyword\">if</span> mx&gt;=<span class=\"number\">0</span> <span class=\"keyword\">else</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<p>方法二：迭代的初识值没想好，想着赋值成<code>(g[0][0], float(&#39;inf&#39;))</code>了，实际上<code>(g[0][0], g[0][0])</code>就对了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxProductPath</span><span class=\"params\">(self, g: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    mod = <span class=\"number\">10</span>**<span class=\"number\">9</span> + <span class=\"number\">7</span></span><br><span class=\"line\">    M, N = len(g), len(g[<span class=\"number\">0</span>])</span><br><span class=\"line\">    default = (float(<span class=\"string\">'-inf'</span>), float(<span class=\"string\">'inf'</span>))</span><br><span class=\"line\">    dp = [[default]*N <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(M)]</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = (g[<span class=\"number\">0</span>][<span class=\"number\">0</span>], g[<span class=\"number\">0</span>][<span class=\"number\">0</span>])</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(M):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(N):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i==<span class=\"number\">0</span> <span class=\"keyword\">and</span> j==<span class=\"number\">0</span>: <span class=\"keyword\">continue</span></span><br><span class=\"line\">            cur = g[i][j]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> cur == <span class=\"number\">0</span>:</span><br><span class=\"line\">                dp[i][j] = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            mx1, mn1 = dp[i<span class=\"number\">-1</span>][j] <span class=\"keyword\">if</span> i <span class=\"keyword\">else</span> default</span><br><span class=\"line\">            mx2, mn2 = dp[i][j<span class=\"number\">-1</span>] <span class=\"keyword\">if</span> j <span class=\"keyword\">else</span> default</span><br><span class=\"line\">            mx, mn = max(mx1, mx2)*cur, min(mn1, mn2)*cur</span><br><span class=\"line\">            dp[i][j] = (mx, mn) <span class=\"keyword\">if</span> cur&gt;<span class=\"number\">0</span> <span class=\"keyword\">else</span> (mn, mx)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[<span class=\"number\">-1</span>][<span class=\"number\">-1</span>][<span class=\"number\">0</span>] % mod <span class=\"keyword\">if</span> dp[<span class=\"number\">-1</span>][<span class=\"number\">-1</span>][<span class=\"number\">0</span>]&gt;=<span class=\"number\">0</span> <span class=\"keyword\">else</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"面试题-08-14-布尔运算\"><a href=\"#面试题-08-14-布尔运算\" class=\"headerlink\" title=\"面试题 08.14. 布尔运算\"></a><a href=\"https://leetcode-cn.com/problems/boolean-evaluation-lcci/\" target=\"_blank\" rel=\"noopener\">面试题 08.14. 布尔运算</a></h3><h4 id=\"给定一个布尔表达式和一个期望的布尔结果-result，布尔表达式由-0-false-、1-true-、-amp-AND-、-OR-和-XOR-符号组成。实现一个函数，算出有几种可使该表达式得出-result-值的括号方法。\"><a href=\"#给定一个布尔表达式和一个期望的布尔结果-result，布尔表达式由-0-false-、1-true-、-amp-AND-、-OR-和-XOR-符号组成。实现一个函数，算出有几种可使该表达式得出-result-值的括号方法。\" class=\"headerlink\" title=\"给定一个布尔表达式和一个期望的布尔结果 result，布尔表达式由 0 (false)、1 (true)、&amp; (AND)、 | (OR) 和 ^ (XOR) 符号组成。实现一个函数，算出有几种可使该表达式得出 result 值的括号方法。\"></a>给定一个布尔表达式和一个期望的布尔结果 result，布尔表达式由 0 (false)、1 (true)、&amp; (AND)、 | (OR) 和 ^ (XOR) 符号组成。实现一个函数，算出有几种可使该表达式得出 result 值的括号方法。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: s &#x3D; &quot;1^0|0|1&quot;, result &#x3D; 0</span><br><span class=\"line\"></span><br><span class=\"line\">输出: 2</span><br><span class=\"line\">解释: 两种可能的括号方法是</span><br><span class=\"line\">1^(0|(0|1))</span><br><span class=\"line\">1^((0|0)|1)</span><br></pre></td></tr></table></figure>\n<p>方法一：我开始想的是将0，1的个数都分别计算。但是效率却不高。时间只beats5%。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countEval</span><span class=\"params\">(self, s: str, result: int)</span> -&gt; int:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @lru_cache(None)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(q)</span>:</span></span><br><span class=\"line\">        n = len(q)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n==<span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (<span class=\"number\">0</span>, <span class=\"number\">1</span>) <span class=\"keyword\">if</span> q==<span class=\"string\">'1'</span> <span class=\"keyword\">else</span> (<span class=\"number\">1</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">        ans = [<span class=\"number\">0</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n, <span class=\"number\">2</span>):</span><br><span class=\"line\">            <span class=\"comment\"># l_zero, l_one = dfs(q[:i])</span></span><br><span class=\"line\">            <span class=\"comment\"># r_zero, r_one = dfs(q[i+1:])</span></span><br><span class=\"line\">            <span class=\"comment\"># ans[eval('0&#123;&#125;1'.format(q[i]))] += l_zero*r_one</span></span><br><span class=\"line\">            <span class=\"comment\"># ans[eval('0&#123;&#125;0'.format(q[i]))] += l_zero*r_zero</span></span><br><span class=\"line\">            <span class=\"comment\"># ans[eval('1&#123;&#125;0'.format(q[i]))] += l_one*r_zero</span></span><br><span class=\"line\">            <span class=\"comment\"># ans[eval('1&#123;&#125;1'.format(q[i]))] += l_one*r_one</span></span><br><span class=\"line\">            left, right = dfs(q[:i]), dfs(q[i+<span class=\"number\">1</span>:])</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (l_v, l_c), (r_v, r_c) <span class=\"keyword\">in</span> itertools.product(enumerate(left), enumerate(right)):</span><br><span class=\"line\">                ans[eval(<span class=\"string\">'&#123;&#125;&#123;&#125;&#123;&#125;'</span>.format(l_v, q[i], r_v))] += l_c * r_c</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dfs(s)[result]</span><br></pre></td></tr></table></figure>\n<p>方法二：根据评论区的方法，找到自己方法的性能瓶颈。在于大量的创建字符串执行<code>eval</code>，将这里改为字典映射后，从500ms减少为90ms。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countEval</span><span class=\"params\">(self, s: str, result: int)</span> -&gt; int:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @lru_cache(None)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(q)</span>:</span></span><br><span class=\"line\">        n = len(q)</span><br><span class=\"line\">        ans = [<span class=\"number\">0</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n==<span class=\"number\">1</span>:</span><br><span class=\"line\">            ans[int(q)] += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n, <span class=\"number\">2</span>):</span><br><span class=\"line\">            left, right = dfs(q[:i]), dfs(q[i+<span class=\"number\">1</span>:])</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (l_v, l_c), (r_v, r_c) <span class=\"keyword\">in</span> itertools.product(enumerate(left), enumerate(right)):</span><br><span class=\"line\">                ans[ops[q[i]](l_v, r_v)] += l_c * r_c</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">    ops = &#123;<span class=\"string\">'|'</span>: or_, <span class=\"string\">'^'</span>: xor, <span class=\"string\">'&amp;'</span>: and_&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dfs(s)[result]</span><br></pre></td></tr></table></figure>\n<h3 id=\"面试题-17-13-恢复空格\"><a href=\"#面试题-17-13-恢复空格\" class=\"headerlink\" title=\"面试题 17.13. 恢复空格\"></a><a href=\"https://leetcode-cn.com/problems/re-space-lcci/\" target=\"_blank\" rel=\"noopener\">面试题 17.13. 恢复空格</a></h3><h4 id=\"你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子”I-reset-the-computer-It-still-didn’t-boot-”已经变成了”iresetthecomputeritstilldidntboot”。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典dictionary，不过，有些词没在词典里。假设文章用sentence表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。\"><a href=\"#你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子”I-reset-the-computer-It-still-didn’t-boot-”已经变成了”iresetthecomputeritstilldidntboot”。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典dictionary，不过，有些词没在词典里。假设文章用sentence表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。\" class=\"headerlink\" title=\"你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子”I reset the computer. It still didn’t boot!”已经变成了”iresetthecomputeritstilldidntboot”。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典dictionary，不过，有些词没在词典里。假设文章用sentence表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。\"></a>你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子”I reset the computer. It still didn’t boot!”已经变成了”iresetthecomputeritstilldidntboot”。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典dictionary，不过，有些词没在词典里。假设文章用sentence表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。</h4><p>方法一：特别慢，虽然ac了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">respace</span><span class=\"params\">(self, dictionary: List[str], sentence: str)</span> -&gt; int:</span></span><br><span class=\"line\">        dic = set(dictionary)</span><br><span class=\"line\">        max_len = len(max(dictionary, key=len))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">        @lru_cache(None)</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(s)</span>:</span></span><br><span class=\"line\">            <span class=\"comment\"># print(s)</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> s: <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">            ans = float(<span class=\"string\">'inf'</span>)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, min(len(s), max_len)+<span class=\"number\">1</span>):</span><br><span class=\"line\">                right = dfs(s[i:])</span><br><span class=\"line\">                <span class=\"keyword\">if</span> s[:i] <span class=\"keyword\">in</span> dic:</span><br><span class=\"line\">                    ans = min(ans, right)</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    ans = min(ans, i + right)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ans</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs(sentence)</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：从头开始匹配这样就快了只要300ms</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">respace</span><span class=\"params\">(self, dictionary: List[str], sentence: str)</span> -&gt; int:</span></span><br><span class=\"line\">    dic, N = set(dictionary), len(sentence)</span><br><span class=\"line\">    lens = &#123;len(w) <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> dictionary&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @lru_cache(None)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(i)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i &gt;= N:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        tails = [dfs(i+d) <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> lens <span class=\"keyword\">if</span> i+d&lt;=N <span class=\"keyword\">and</span> sentence[i:i+d] <span class=\"keyword\">in</span> dic]</span><br><span class=\"line\">        tails.append(<span class=\"number\">1</span> + dfs(i+<span class=\"number\">1</span>))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> min(tails, default=<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dfs(<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：dp的迭代写法。260ms</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">respace</span><span class=\"params\">(self, dictionary: List[str], sentence: str)</span> -&gt; int:</span></span><br><span class=\"line\">    dic, N = set(dictionary), len(sentence)</span><br><span class=\"line\">    lens = &#123;len(w) <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> dictionary&#125;</span><br><span class=\"line\">    dp = [<span class=\"number\">0</span>]+ [float(<span class=\"string\">'inf'</span>)]*N <span class=\"comment\"># dp[i]表示前sentence[:i]未识别的字符数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, N+<span class=\"number\">1</span>):</span><br><span class=\"line\">        dp[i] = dp[i<span class=\"number\">-1</span>] + <span class=\"number\">1</span></span><br><span class=\"line\">        dp[i] = min([dp[i]]+[dp[i-d] </span><br><span class=\"line\">            <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> lens <span class=\"keyword\">if</span> sentence[i-d:i] <span class=\"keyword\">in</span> dic <span class=\"keyword\">and</span> i&gt;=d]</span><br><span class=\"line\">        )</span><br><span class=\"line\">    <span class=\"comment\"># print(dp)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"1611-Minimum-One-Bit-Operations-to-Make-Integers-Zero\"><a href=\"#1611-Minimum-One-Bit-Operations-to-Make-Integers-Zero\" class=\"headerlink\" title=\"1611. Minimum One Bit Operations to Make Integers Zero\"></a><a href=\"https://leetcode.com/problems/minimum-one-bit-operations-to-make-integers-zero/\" target=\"_blank\" rel=\"noopener\">1611. Minimum One Bit Operations to Make Integers Zero</a></h3><h4 id=\"最少需要多少步能将数变成0。两种操作方式，一种翻转最低位的数字。一种是找到x100-00（n个0-n可以-0）的x位翻转。\"><a href=\"#最少需要多少步能将数变成0。两种操作方式，一种翻转最低位的数字。一种是找到x100-00（n个0-n可以-0）的x位翻转。\" class=\"headerlink\" title=\"最少需要多少步能将数变成0。两种操作方式，一种翻转最低位的数字。一种是找到x100..00（n个0,n可以=0）的x位翻转。\"></a>最少需要多少步能将数变成0。两种操作方式，一种翻转最低位的数字。一种是找到<code>x100..00（n个0,n可以=0）</code>的x位翻转。</h4><p>方法一：这题竞赛时想了个七七八八，还是没写出来。总体来说此题不难，比第3题简单。</p>\n<p>分为这样的步骤。1XXXXXXX -&gt; 11000000 -&gt; 10000000 -&gt; 0</p>\n<p>1XXXXXX -&gt; 1100000 needs minimumOneBitOperations(1XXXXXX ^ 1100000), 这步没有想明白，可以递归，因为想让1XXXXXX ^ 1100000 == 0，就只能让 1XXXXXX变为1100000 。所以这里是等价的。</p>\n<p>1100000 -&gt; 100000 needs 1 operation.<br>100000 -&gt; 0, where 100000 is 2^k, needs 2^(k-1) - 1 operations.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    dp = &#123;<span class=\"number\">0</span>: <span class=\"number\">0</span>&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minimumOneBitOperations</span><span class=\"params\">(self, n: int)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> self.dp:</span><br><span class=\"line\">            b = <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (b&lt;&lt;<span class=\"number\">1</span>) &lt;= n:</span><br><span class=\"line\">                b &lt;&lt;= <span class=\"number\">1</span></span><br><span class=\"line\">            self.dp[n] = self.minimumOneBitOperations((b&gt;&gt;<span class=\"number\">1</span>) ^ b ^ n) + <span class=\"number\">1</span> + b - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.dp[n]</span><br></pre></td></tr></table></figure>\n<h3 id=\"1027-Longest-Arithmetic-Subsequence\"><a href=\"#1027-Longest-Arithmetic-Subsequence\" class=\"headerlink\" title=\"1027. Longest Arithmetic Subsequence\"></a><a href=\"https://leetcode.com/problems/longest-arithmetic-subsequence/\" target=\"_blank\" rel=\"noopener\">1027. Longest Arithmetic Subsequence</a></h3><h4 id=\"最长的等差子序列长度。\"><a href=\"#最长的等差子序列长度。\" class=\"headerlink\" title=\"最长的等差子序列长度。\"></a>最长的等差子序列长度。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: A &#x3D; [9,4,7,2,10]</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">The longest arithmetic subsequence is [4,7,10].</span><br></pre></td></tr></table></figure>\n<p>方法一：O(N^2)的方法。时间beats80%, 2.6s。这里试了一下<code>ans = max([ans] + list(dp[i].values()))</code> 居然要4s多。Lee这里使用了一个tuple作为key，但是要慢一点，3s。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestArithSeqLength</span><span class=\"params\">(self, A: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    dp = defaultdict(<span class=\"keyword\">lambda</span> : defaultdict(<span class=\"keyword\">lambda</span> : <span class=\"number\">1</span>))</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, a <span class=\"keyword\">in</span> enumerate(A):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j, b <span class=\"keyword\">in</span> enumerate(islice(A, i)):</span><br><span class=\"line\">            dp[i][a-b] = dp[j][a-b] + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(max(dp[i].values()) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(A)))</span><br></pre></td></tr></table></figure>\n<h3 id=\"416-分割等和子集\"><a href=\"#416-分割等和子集\" class=\"headerlink\" title=\"416. 分割等和子集\"></a><a href=\"https://leetcode-cn.com/problems/partition-equal-subset-sum/\" target=\"_blank\" rel=\"noopener\">416. 分割等和子集</a></h3><h4 id=\"能否将数组分为两个和相等的子数组。经典的0-1背包问题。\"><a href=\"#能否将数组分为两个和相等的子数组。经典的0-1背包问题。\" class=\"headerlink\" title=\"能否将数组分为两个和相等的子数组。经典的0-1背包问题。\"></a>能否将数组分为两个和相等的子数组。经典的0-1背包问题。</h4><p>方法一：看了题解做上的，主要没想到怎么将它转化为背包问题的。它其实等价于从数组中选出一些数字，使得这些数的和为数组和的一半。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">canPartition</span><span class=\"params\">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class=\"line\">    s, N = sum(nums), len(nums)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> s&amp;<span class=\"number\">1</span> <span class=\"keyword\">or</span> N&lt;<span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    target = s // <span class=\"number\">2</span></span><br><span class=\"line\">    dp = [[<span class=\"literal\">False</span>]*(target+<span class=\"number\">1</span>) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(N)] <span class=\"comment\"># dp[i][j]表示nums[:i]的元素能否组成和恰好为j</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, a <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(target+<span class=\"number\">1</span>):</span><br><span class=\"line\">            dp[i][j] = a==j <span class=\"keyword\">or</span> dp[i<span class=\"number\">-1</span>][j] <span class=\"keyword\">or</span> (j&gt;=a <span class=\"keyword\">and</span> dp[i<span class=\"number\">-1</span>][j-a])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[<span class=\"number\">-1</span>][<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<p>方法二：方法一空间优化。正序会对结果造成影响，导致计算错误。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">canPartition</span><span class=\"params\">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class=\"line\">    s, N = sum(nums), len(nums)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> s&amp;<span class=\"number\">1</span> <span class=\"keyword\">or</span> N&lt;<span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    target = s // <span class=\"number\">2</span></span><br><span class=\"line\">    dp = [<span class=\"literal\">False</span>] * (target+<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, a <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(target+<span class=\"number\">1</span>)[::<span class=\"number\">-1</span>]:</span><br><span class=\"line\">            dp[j] = a==j <span class=\"keyword\">or</span> dp[j] <span class=\"keyword\">or</span> (j&gt;=a <span class=\"keyword\">and</span> dp[j-a])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"4\">方法三：同样的原理，但是使用位运算来保存结果。速度是前两种的30倍！！<code>bool(mask&gt;&gt;k &amp; 1)</code>表示是否可以组成和为k。python得益于int没有长度限制，所以不用转成数组的形式。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">canPartition</span><span class=\"params\">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class=\"line\">    s, N = sum(nums), len(nums)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> s&amp;<span class=\"number\">1</span> <span class=\"keyword\">or</span> N&lt;<span class=\"number\">2</span>: <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    target = s // <span class=\"number\">2</span></span><br><span class=\"line\">    mask = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        mask |= mask&lt;&lt;num</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bool(mask&gt;&gt;target &amp; <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n<p>方法四：可以写成一行，评论中大神的写法和我的写法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">canPartition</span><span class=\"params\">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>-sum(nums)%<span class=\"number\">2</span> == reduce(<span class=\"keyword\">lambda</span> x, y: x | (x&lt;&lt;y), nums, <span class=\"number\">1</span>) &gt;&gt; (sum(nums))//<span class=\"number\">2</span> &amp; <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"comment\"># return not sum(nums)&amp;1 and bool(reduce(lambda x, y: x | (x&lt;&lt;y), nums, 1) &gt;&gt; (sum(nums))//2 &amp; 1)</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"128-Longest-Consecutive-Sequence\"><a href=\"#128-Longest-Consecutive-Sequence\" class=\"headerlink\" title=\"128. Longest Consecutive Sequence\"></a><a href=\"https://leetcode.com/problems/longest-consecutive-sequence/\" target=\"_blank\" rel=\"noopener\">128. Longest Consecutive Sequence</a></h3><h4 id=\"求数组中最长的连续序列，可以打乱顺序。要求时间复杂度O-n-。\"><a href=\"#求数组中最长的连续序列，可以打乱顺序。要求时间复杂度O-n-。\" class=\"headerlink\" title=\"求数组中最长的连续序列，可以打乱顺序。要求时间复杂度O(n)。\"></a>求数组中最长的连续序列，可以打乱顺序。要求时间复杂度O(n)。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [100, 4, 200, 1, 3, 2]</span><br><span class=\"line\">Output: 4</span><br><span class=\"line\">Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.</span><br></pre></td></tr></table></figure>\n<p>方法一：Union-Find。没想到能用并查集来求，看了标签提示才恍然大悟。一开始写错了，把num和num-1也相连了，这样1和3就被连到了一起，注意一下空输入。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestConsecutive</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">union</span><span class=\"params\">(x, y)</span>:</span></span><br><span class=\"line\">        uf[find(x)] = find(y)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">find</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">        uf.setdefault(x, x)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> x != uf[x]:</span><br><span class=\"line\">            uf[x] = find(uf[x])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> uf[x]</span><br><span class=\"line\"></span><br><span class=\"line\">    uf = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        union(num, num+<span class=\"number\">1</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums <span class=\"keyword\">and</span> Counter(find(x) <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> set(nums)).most_common(<span class=\"number\">1</span>)[<span class=\"number\">0</span>][<span class=\"number\">1</span>] <span class=\"keyword\">or</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"4\">方法二：动态规划。这个方法非常好，我记得Lee215好像用过，我一时想不起来是哪道题了。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestConsecutive</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    d, ans = defaultdict(int), <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> d[num]:   <span class=\"comment\"># 这里不能使用 if num not in d，因为再找最右时可能会更新d[num-1]为0</span></span><br><span class=\"line\">            left, right = d[num<span class=\"number\">-1</span>], d[num+<span class=\"number\">1</span>]</span><br><span class=\"line\">            d[num] = left + right + <span class=\"number\">1</span></span><br><span class=\"line\">            d[num-left] = d[num+right] = d[num]</span><br><span class=\"line\">            ans = max(ans, d[num])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"4\">方法三：by@stefan。时间O(n)，因为只对比了开头。每个数字只遍历一次。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestConsecutive</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    nums = set(nums)</span><br><span class=\"line\">    best = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> x - <span class=\"number\">1</span> <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> nums:  <span class=\"comment\"># 如果x是一段连续数字的开头</span></span><br><span class=\"line\">            y = x + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> y <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">                y += <span class=\"number\">1</span></span><br><span class=\"line\">            best = max(best, y - x)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> best</span><br></pre></td></tr></table></figure>\n<h3 id=\"1314-Matrix-Block-Sum\"><a href=\"#1314-Matrix-Block-Sum\" class=\"headerlink\" title=\"1314. Matrix Block Sum\"></a>1314. Matrix Block Sum</h3><h4 id=\"矩阵块的求和。原题\"><a href=\"#矩阵块的求和。原题\" class=\"headerlink\" title=\"矩阵块的求和。原题\"></a>矩阵块的求和。<a href=\"https://leetcode.com/problems/matrix-block-sum/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: mat &#x3D; [[1,2,3],[4,5,6],[7,8,9]], K &#x3D; 1</span><br><span class=\"line\">Output: [[12,21,16],[27,45,33],[24,39,28]]</span><br></pre></td></tr></table></figure>\n<p>方法一：竞赛时暴力法过的。这里实际上求和时可以利用之前的和。</p>\n<img src=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AF%87%EF%BC%89Danymic-Programming/block_sum.png\" class>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">matrixBlockSum</span><span class=\"params\">(self, mat: List[List[int]], k: int)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">    m, n = len(mat), len(mat[<span class=\"number\">0</span>])</span><br><span class=\"line\">    dp = [list(itertools.accumulate(row)) <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> mat]</span><br><span class=\"line\">    dp = [list(itertools.accumulate(row)) <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> zip(*dp)]        </span><br><span class=\"line\">    dp = list(zip(*dp))</span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m):</span><br><span class=\"line\">        tmp = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            r_lo, r_hi = max(<span class=\"number\">0</span>, i-k), min(i+k, m<span class=\"number\">-1</span>)</span><br><span class=\"line\">            c_lo, c_hi = max(<span class=\"number\">0</span>, j-k), min(j+k, n<span class=\"number\">-1</span>)</span><br><span class=\"line\">            cur_sum = dp[r_hi][c_hi]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> r_lo &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                cur_sum -= dp[r_lo<span class=\"number\">-1</span>][c_hi]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> c_lo &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                cur_sum -= dp[r_hi][c_lo<span class=\"number\">-1</span>]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> r_lo &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> c_lo &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                cur_sum += dp[r_lo<span class=\"number\">-1</span>][c_lo<span class=\"number\">-1</span>]</span><br><span class=\"line\">            tmp.append(cur_sum)</span><br><span class=\"line\">        ans.append(tmp)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"1738-Find-Kth-Largest-XOR-Coordinate-Value\"><a href=\"#1738-Find-Kth-Largest-XOR-Coordinate-Value\" class=\"headerlink\" title=\"1738. Find Kth Largest XOR Coordinate Value\"></a><a href=\"https://leetcode.com/problems/find-kth-largest-xor-coordinate-value/\" target=\"_blank\" rel=\"noopener\">1738. Find Kth Largest XOR Coordinate Value</a></h3><h4 id=\"找到矩阵中第K大的值，值是指坐标-a-b-所有妈祖0-lt-i-lt-a-lt-m，0-lt-j-lt-b-lt-n条件的异或和。\"><a href=\"#找到矩阵中第K大的值，值是指坐标-a-b-所有妈祖0-lt-i-lt-a-lt-m，0-lt-j-lt-b-lt-n条件的异或和。\" class=\"headerlink\" title=\"找到矩阵中第K大的值，值是指坐标(a,b)所有妈祖0&lt;=i&lt;=a&lt;m，0&lt;=j&lt;=b&lt;n条件的异或和。\"></a>找到矩阵中第K大的值，值是指坐标(a,b)所有妈祖0&lt;=i&lt;=a&lt;m，0&lt;=j&lt;=b&lt;n条件的异或和。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: matrix &#x3D; [[5,2],[1,6]], k &#x3D; 1</span><br><span class=\"line\">Output: 7</span><br><span class=\"line\">Explanation: The value of coordinate (0,1) is 5 XOR 2 &#x3D; 7, which is the largest value.</span><br></pre></td></tr></table></figure>\n<p>方法一：dp，和1314很像。比赛时没有时间做。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">kthLargestValue</span><span class=\"params\">(self, matrix: List[List[int]], k: int)</span> -&gt; int:</span></span><br><span class=\"line\">    M, N = len(matrix), len(matrix[<span class=\"number\">0</span>])</span><br><span class=\"line\">    g = [[<span class=\"number\">0</span>] * (N+<span class=\"number\">1</span>) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(M+<span class=\"number\">1</span>)]        </span><br><span class=\"line\">    heap = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, M+<span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, N+<span class=\"number\">1</span>):</span><br><span class=\"line\">            g[i][j] = matrix[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>] ^ g[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>] ^ g[i<span class=\"number\">-1</span>][j] ^ g[i][j<span class=\"number\">-1</span>]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(heap) &lt; k:</span><br><span class=\"line\">                heapq.heappush(heap, g[i][j])</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> g[i][j] &gt; heap[<span class=\"number\">0</span>]:</span><br><span class=\"line\">                heapq.heapreplace(heap, g[i][j])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> heap[<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"1626-Best-Team-With-No-Conflicts\"><a href=\"#1626-Best-Team-With-No-Conflicts\" class=\"headerlink\" title=\"1626. Best Team With No Conflicts\"></a><a href=\"https://leetcode.com/problems/best-team-with-no-conflicts/\" target=\"_blank\" rel=\"noopener\">1626. Best Team With No Conflicts</a></h3><h4 id=\"有这样一个球队，每个人有一个自己的得分。当一个团队中有一个年轻的球员是比自己年长球员分多时，这两个球员就会打架。所以为了避免这样的情况，选出一个最大得分的团队，问得分是多少。\"><a href=\"#有这样一个球队，每个人有一个自己的得分。当一个团队中有一个年轻的球员是比自己年长球员分多时，这两个球员就会打架。所以为了避免这样的情况，选出一个最大得分的团队，问得分是多少。\" class=\"headerlink\" title=\"有这样一个球队，每个人有一个自己的得分。当一个团队中有一个年轻的球员是比自己年长球员分多时，这两个球员就会打架。所以为了避免这样的情况，选出一个最大得分的团队，问得分是多少。\"></a>有这样一个球队，每个人有一个自己的得分。当一个团队中有一个年轻的球员是比自己年长球员分多时，这两个球员就会打架。所以为了避免这样的情况，选出一个最大得分的团队，问得分是多少。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: scores &#x3D; [1,2,3,5], ages &#x3D; [8,9,10,1]</span><br><span class=\"line\">Output: 6</span><br><span class=\"line\">Explanation: It is best to choose the first 3 players. </span><br><span class=\"line\">Input: scores &#x3D; [4,5,6,5], ages &#x3D; [2,1,2,1]</span><br><span class=\"line\">Output: 16</span><br><span class=\"line\">Explanation: It is best to choose the last 3 players. Notice that you are allowed to choose multiple people of the same age.</span><br></pre></td></tr></table></figure>\n<p>方法一：这题因为竞赛时卡在第二题上，所以没有时间来做了。和俄罗斯套娃问题很像。当球员按照年龄，得分排好序后。问题转化为了一个最长上升子序列和的问题。时间复杂度是O(n^2)。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bestTeamScore</span><span class=\"params\">(self, scores: List[int], ages: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    p = sorted(zip(ages, scores))</span><br><span class=\"line\">    n, ans = len(p), <span class=\"number\">0</span></span><br><span class=\"line\">    dp = [<span class=\"number\">0</span>] * n</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(p)):</span><br><span class=\"line\">        dp[i] = p[i][<span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> p[i][<span class=\"number\">1</span>] &gt;= p[j][<span class=\"number\">1</span>]:</span><br><span class=\"line\">                dp[i] = max(dp[i], dp[j]+p[i][<span class=\"number\">1</span>])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(dp)</span><br></pre></td></tr></table></figure>\n<h3 id=\"823-Binary-Trees-With-Factors\"><a href=\"#823-Binary-Trees-With-Factors\" class=\"headerlink\" title=\"823. Binary Trees With Factors\"></a><a href=\"https://leetcode.com/problems/binary-trees-with-factors/\" target=\"_blank\" rel=\"noopener\">823. Binary Trees With Factors</a></h3><h4 id=\"给你一些大于1的数，要求用这些数组成一个树，树的父节点为两个子节点的乘积。问有多少种组成方式。\"><a href=\"#给你一些大于1的数，要求用这些数组成一个树，树的父节点为两个子节点的乘积。问有多少种组成方式。\" class=\"headerlink\" title=\"给你一些大于1的数，要求用这些数组成一个树，树的父节点为两个子节点的乘积。问有多少种组成方式。\"></a>给你一些大于1的数，要求用这些数组成一个树，树的父节点为两个子节点的乘积。问有多少种组成方式。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: A &#x3D; [2, 4, 5, 10]</span><br><span class=\"line\">Output: 7</span><br><span class=\"line\">Explanation: We can make these trees: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2].</span><br></pre></td></tr></table></figure>\n<p>方法一：很容易想到dp，以每个点为父节点，看组成子节点的组合有多少种，然后相乘。400ms</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numFactoredBinaryTrees</span><span class=\"params\">(self, A: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    mod = <span class=\"number\">10</span>**<span class=\"number\">9</span> + <span class=\"number\">7</span></span><br><span class=\"line\">    N = len(A)</span><br><span class=\"line\">    s_nums = set(A)</span><br><span class=\"line\">    dp = &#123;n: <span class=\"number\">1</span> <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> s_nums&#125;</span><br><span class=\"line\">    nums = sorted(s_nums)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, n <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> n%nums[j]==<span class=\"number\">0</span> <span class=\"keyword\">and</span> n//nums[j] <span class=\"keyword\">in</span> s_nums:</span><br><span class=\"line\">                dp[n] += dp[nums[j]] * dp[n//nums[j]]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(dp.values()) % mod</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"4\">方法二：这里容易想到一个优化，当左右子树节点不同时，可以通过互换的方式来增加；那么也就是说找左右子节点时，因为这里将其排了序，所以左子节点&lt;=右子节点。运行时间减少为原来的一半还少。</font>144ms<br><br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numFactoredBinaryTrees</span><span class=\"params\">(self, A: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    mod = <span class=\"number\">10</span>**<span class=\"number\">9</span> + <span class=\"number\">7</span></span><br><span class=\"line\">    N = len(A)</span><br><span class=\"line\">    s_nums = set(A)</span><br><span class=\"line\">    dp = &#123;n: <span class=\"number\">1</span> <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> s_nums&#125;</span><br><span class=\"line\">    nums = sorted(s_nums)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, n <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[j] &gt; sqrt(n): <span class=\"keyword\">break</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> n%nums[j]==<span class=\"number\">0</span> <span class=\"keyword\">and</span> n//nums[j] <span class=\"keyword\">in</span> s_nums:</span><br><span class=\"line\">                dp[n] += (dp[nums[j]] * dp[n//nums[j]]) * (<span class=\"number\">1</span>+(nums[j]!=n//nums[j]))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(dp.values()) % mod</span><br></pre></td></tr></table></figure><br>方法三：Lee的写法。但是运行时间比方法一略优，时间相当于方法二的2倍。336ms<br><br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numFactoredBinaryTrees</span><span class=\"params\">(self, A: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    dp = &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> sorted(A):</span><br><span class=\"line\">        dp[a] = sum(dp[b] * dp.get(a//b, <span class=\"number\">0</span>) <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> dp <span class=\"keyword\">if</span> a%b==<span class=\"number\">0</span>) + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(dp.values()) % (<span class=\"number\">10</span>**<span class=\"number\">9</span>+<span class=\"number\">7</span>)</span><br></pre></td></tr></table></figure><br>方法四：再尽量简洁的情况下，保证效率，使用OrderedDict保证key的顺序。192ms。<br><br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numFactoredBinaryTrees</span><span class=\"params\">(self, A: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    dp = OrderedDict()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> sorted(A):</span><br><span class=\"line\">        left = takewhile(<span class=\"keyword\">lambda</span> x: x &lt;= sqrt(a), dp)</span><br><span class=\"line\">        dp[a] = sum(dp[b] * dp.get(a//b, <span class=\"number\">0</span>) * (<span class=\"number\">1</span>+(b!=a//b)) <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> left <span class=\"keyword\">if</span> a%b==<span class=\"number\">0</span>) + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(dp.values()) % (<span class=\"number\">10</span>**<span class=\"number\">9</span>+<span class=\"number\">7</span>)</span><br></pre></td></tr></table></figure><br>### <a href=\"https://leetcode-cn.com/problems/delete-and-earn/\" target=\"_blank\" rel=\"noopener\">740. Delete and Earn</a><br><br>#### 给定一个整数数组 nums ，你可以对它进行一些操作。每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除每个等于 nums[i] - 1 或 nums[i] + 1 的元素。返回你能通过这些操作获得的最大点数。<br><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [2, 2, 3, 3, 3, 4]</span><br><span class=\"line\">Output: 9</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">Delete 3 to earn 3 points, deleting both 2&#39;s and the 4.</span><br><span class=\"line\">Then, delete 3 again to earn 3 points, and 3 again to earn 3 points.</span><br><span class=\"line\">9 total points are earned</span><br></pre></td></tr></table></figure><br><br>方法一：这题二十分钟AC的。首先将数组分成几个连续的段，再求每段的最大值，和抢房子问题一样。<br><br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">deleteAndEarn</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">max_value_of_seq</span><span class=\"params\">(ary)</span>:</span></span><br><span class=\"line\">        pick, not_pick = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> ary: </span><br><span class=\"line\">            not_pick, pick = pick, max(not_pick+num*c[num], pick)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pick</span><br><span class=\"line\"></span><br><span class=\"line\">    parts, c = [], Counter(nums)</span><br><span class=\"line\">    N = len(nums)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, num <span class=\"keyword\">in</span> enumerate(sorted(set(nums))):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> parts <span class=\"keyword\">or</span> parts[<span class=\"number\">-1</span>][<span class=\"number\">-1</span>]+<span class=\"number\">1</span>!=num:</span><br><span class=\"line\">            parts.append([num])</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            parts[<span class=\"number\">-1</span>].append(num)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(map(max_value_of_seq, parts)</span><br></pre></td></tr></table></figure><br><br>方法二：看到有大神能用四行写出来，于是我不服。<br><br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">deleteAndEarn</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    not_pick, pick, last, c = <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, Counter(nums)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> sorted(set(nums)):</span><br><span class=\"line\">        not_pick, pick, last = pick, max(not_pick+c[a]*a, pick+c[a]*a*(a&gt;last+<span class=\"number\">1</span>)), a</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pick</span><br></pre></td></tr></table></figure><br><br>### <a href=\"https://leetcode.com/problems/arithmetic-slices/\" target=\"_blank\" rel=\"noopener\">413. Arithmetic Slices</a><br><br>#### 一个等差数列，至少需要三个数字，每两个挨着的数字差一样。求有多少个连续的等差数列。<br><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">A &#x3D; [1, 2, 3, 4]</span><br><span class=\"line\"></span><br><span class=\"line\">return: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.</span><br></pre></td></tr></table></figure><br><br>方法一：dp。模拟时间内没做出来是因为忽略了连续。仔细审题后10分钟AC。<br><br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numberOfArithmeticSlices</span><span class=\"params\">(self, A: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    dp, ans = defaultdict(int), <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>, len(A)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> A[i<span class=\"number\">-2</span>]-A[i<span class=\"number\">-1</span>] == A[i<span class=\"number\">-1</span>]-A[i]:</span><br><span class=\"line\">            dp[i] += dp[i<span class=\"number\">-1</span>] + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(dp.values())</span><br></pre></td></tr></table></figure><br><br>方法二：双指针。<br><br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numberOfArithmeticSlices</span><span class=\"params\">(self, A: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    left, right, ans = <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> right &lt; len(A):</span><br><span class=\"line\">        <span class=\"keyword\">while</span> right&lt;len(A) <span class=\"keyword\">and</span> A[left+<span class=\"number\">1</span>]-A[left]==A[right]-A[right<span class=\"number\">-1</span>]:</span><br><span class=\"line\">            ans += right-left<span class=\"number\">-1</span></span><br><span class=\"line\">            right += <span class=\"number\">1</span></span><br><span class=\"line\">        left = right<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure><br><br>### <a href=\"https://leetcode.com/problems/minimum-number-of-removals-to-make-mountain-array/\" target=\"_blank\" rel=\"noopener\">1671. Minimum Number of Removals to Make Mountain Array</a><br><br>#### 最少的删除步骤使得变成山峰数组。<br><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [2,1,1,5,6,2,3,1]</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: One solution is to remove the elements at indices 0, 1, and 5, making the array nums &#x3D; [1,5,6,3,1].</span><br></pre></td></tr></table></figure><br><br>方法一：竞赛时没做出来，想成和941,845题中的思路了。其实是LIS问题，最长上升子序列。这里需要注意一点就是要以当前节点为结尾的最长上升子序列，而不是<code>len(ans)</code>。时间复杂度O(n^2<em>logn)。<br><br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minimumMountainRemovals</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longest_up</span><span class=\"params\">(ary)</span>:</span></span><br><span class=\"line\">        ans = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> ary:</span><br><span class=\"line\">            i = bisect.bisect_left(ans, n)</span><br><span class=\"line\">            ans[i:i+<span class=\"number\">1</span>] = [n]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans.index(ary[<span class=\"number\">-1</span>])</span><br><span class=\"line\">    </span><br><span class=\"line\">    res = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(nums)<span class=\"number\">-1</span>):</span><br><span class=\"line\">        res = max(res, longest_up(nums[:i+<span class=\"number\">1</span>])+longest_up(nums[i:][::<span class=\"number\">-1</span>])+<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> len(nums) - res</span><br></pre></td></tr></table></figure><br>方法二：dp。<br><br>### <a href=\"https://leetcode.com/problems/wiggle-subsequence/\" target=\"_blank\" rel=\"noopener\">376. Wiggle Subsequence</a><br><br>#### 最长的摆动序列长度，和LIS最长上升子序列问题一样。<br><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [1,17,5,10,13,15,10,5,16,8]</span><br><span class=\"line\">Output: 7</span><br><span class=\"line\">Explanation: There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].</span><br></pre></td></tr></table></figure><br><br>方法一：dp。一开始用了n^2的方法，其实没有必要。<br><br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wiggleMaxLength</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    N = len(nums)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> N &lt; <span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> N</span><br><span class=\"line\">    up = down = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, N):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[i] &gt; nums[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">            up = max(up, down+<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> nums[i] &lt; nums[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">            down = max(down, up+<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(up, down)</span><br></pre></td></tr></table></figure><br><br>方法二：重复的数字是不需要考虑的。这里做了一次错位。为什么最后一行是<code>or</code>，因为这里对于这个调教<code>a&lt;b&gt;c</code>和<code>a&gt;b&lt;c</code>来说，有一部分重复的比较在里面。<br><br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wiggleMaxLength</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    norep = [num <span class=\"keyword\">for</span> num, _ <span class=\"keyword\">in</span> itertools.groupby(nums)]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(norep) &lt; <span class=\"number\">2</span>: <span class=\"keyword\">return</span> len(norep)</span><br><span class=\"line\">    triples = list(zip(norep, norep[<span class=\"number\">1</span>:], norep[<span class=\"number\">2</span>:]))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span> + sum(a&lt;b&gt;c <span class=\"keyword\">or</span> a&gt;b&lt;c <span class=\"keyword\">for</span> a, b, c <span class=\"keyword\">in</span> triples)</span><br></pre></td></tr></table></figure><br><br>### <a href=\"https://leetcode.com/problems/where-will-the-ball-fall/\" target=\"_blank\" rel=\"noopener\">1706. Where Will the Ball Fall</a><br><br>#### 每列的球能落到最下面哪一列，到不了的话返回-1<br><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: grid &#x3D; [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]]</span><br><span class=\"line\">Output: [1,-1,-1,-1,-1]</span><br><span class=\"line\">Explanation: This example is shown in the photo.</span><br><span class=\"line\">Ball b0 is dropped at column 0 and falls out of the box at column 1.</span><br><span class=\"line\">Ball b1 is dropped at column 1 and will get stuck in the box between column 2 and 3 and row 1.</span><br><span class=\"line\">Ball b2 is dropped at column 2 and will get stuck on the box between column 2 and 3 and row 0.</span><br><span class=\"line\">Ball b3 is dropped at column 3 and will get stuck on the box between column 2 and 3 and row 0.</span><br><span class=\"line\">Ball b4 is dropped at column 4 and will get stuck on the box between column 2 and 3 and row 1.</span><br></pre></td></tr></table></figure><br><br>方法一：比赛时没做出来，觉得和959很像，所以用并查集去想，结果是不对的。因为并查集可以向上走，而小球只能向下落。<br><br>这题应该是dfs或者Dp。<br><br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findBall</span><span class=\"params\">(self, grid: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    N = len(grid[<span class=\"number\">0</span>])</span><br><span class=\"line\">    res = [j <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(N)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> grid:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(N):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> res[j] &gt; <span class=\"number\">-1</span>:</span><br><span class=\"line\">                k = res[j]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> row[k] == <span class=\"number\">1</span> <span class=\"keyword\">and</span> k&lt;N<span class=\"number\">-1</span> <span class=\"keyword\">and</span> row[k+<span class=\"number\">1</span>]==<span class=\"number\">1</span>:</span><br><span class=\"line\">                    res[j] += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">elif</span> row[k] == <span class=\"number\">-1</span> <span class=\"keyword\">and</span> k&gt;<span class=\"number\">0</span> <span class=\"keyword\">and</span> row[k<span class=\"number\">-1</span>]==<span class=\"number\">-1</span>:</span><br><span class=\"line\">                    res[j] -= <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    res[j] = <span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure><br><br>方法二：Lee的方法，如果小球往左或右移动，那么隔板必须是相同的。<br><br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findBall</span><span class=\"params\">(self, grid: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    m, n = len(grid), len(grid[<span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test</span><span class=\"params\">(i)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(m):</span><br><span class=\"line\">            i2 = i + grid[j][i]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i2 &lt; <span class=\"number\">0</span> <span class=\"keyword\">or</span> i2 &gt;= n <span class=\"keyword\">or</span> grid[j][i2] != grid[j][i]:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">            i = i2</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i</span><br><span class=\"line\">    <span class=\"keyword\">return</span> map(test, range(n))</span><br></pre></td></tr></table></figure><br><br>### <a href=\"https://leetcode.com/problems/cherry-pickup-ii/\" target=\"_blank\" rel=\"noopener\">1463. Cherry Pickup II</a><br><br>#### 收集樱桃，每个机器人只能向左下，下，右下移动收集。两个机器人走到同一位置，只能收集一次。<br><br><img src=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AF%87%EF%BC%89Danymic-Programming/1463q.png\" class><br><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: grid &#x3D; [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]</span><br><span class=\"line\">Output: 24</span><br><span class=\"line\">Explanation: Path of robot #1 and #2 are described in color green and blue respectively.</span><br><span class=\"line\">Cherries taken by Robot #1, (3 + 2 + 5 + 2) &#x3D; 12.</span><br><span class=\"line\">Cherries taken by Robot #2, (1 + 5 + 5 + 1) &#x3D; 12.</span><br><span class=\"line\">Total of cherries: 12 + 12 &#x3D; 24.</span><br></pre></td></tr></table></figure><br><br>方法一：dp。<code>dp[i][j1][j2]</code>表示i行，robot1在j1,robot2在j2时的结果。2600ms。<br><br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">cherryPickup</span><span class=\"params\">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"comment\"># dp[i][j1][j2] 表示i行，robot1在j1, robot2在j2时的结果</span></span><br><span class=\"line\">    M, N = len(grid), len(grid[<span class=\"number\">0</span>])</span><br><span class=\"line\">    dp = [[[-inf]*(N+<span class=\"number\">2</span>) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(N+<span class=\"number\">2</span>)] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(M)]</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>][<span class=\"number\">1</span>][N] = grid[<span class=\"number\">0</span>][<span class=\"number\">0</span>] + grid[<span class=\"number\">0</span>][N<span class=\"number\">-1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, M):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j1, j2 <span class=\"keyword\">in</span> product(range(<span class=\"number\">1</span>, N+<span class=\"number\">1</span>), repeat=<span class=\"number\">2</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> s1, s2 <span class=\"keyword\">in</span> product([<span class=\"number\">-1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>], repeat=<span class=\"number\">2</span>):</span><br><span class=\"line\">                dp[i][j1][j2] = max(dp[i][j1][j2], dp[i<span class=\"number\">-1</span>][j1+s1][j2+s2])</span><br><span class=\"line\">            dp[i][j1][j2] += grid[i][j1<span class=\"number\">-1</span>] + grid[i][j2<span class=\"number\">-1</span>] * (j1!=j2)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># return max(map(max, dp[-1]))</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(sum(dp[<span class=\"number\">-1</span>], []))</span><br></pre></td></tr></table></figure><br><br>方法二：记忆化搜索。1000ms。<br><br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">cherryPickup</span><span class=\"params\">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    m, n = len(grid), len(grid[<span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @lru_cache(None)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(r, c1, c2)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> r == m: <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        cherries = grid[r][c1] + grid[r][c2] * (c1!=c2)</span><br><span class=\"line\">        ans = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> nc1 <span class=\"keyword\">in</span> range(c1 - <span class=\"number\">1</span>, c1 + <span class=\"number\">2</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> nc2 <span class=\"keyword\">in</span> range(c2 - <span class=\"number\">1</span>, c2 + <span class=\"number\">2</span>):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"number\">0</span> &lt;= nc1 &lt; n <span class=\"keyword\">and</span> <span class=\"number\">0</span> &lt;= nc2 &lt; n:</span><br><span class=\"line\">                    ans = max(ans, dfs(r + <span class=\"number\">1</span>, nc1, nc2))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans + cherries</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dfs(<span class=\"number\">0</span>, <span class=\"number\">0</span>, n - <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure><br><br>### <a href=\"https://leetcode.com/problems/palindrome-partitioning-iv/\" target=\"_blank\" rel=\"noopener\">1745. Palindrome Partitioning IV</a><br><br>#### 能否将字符串分为三个回文串。<br><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;abcbdd&quot;</span><br><span class=\"line\">Output: true</span><br><span class=\"line\">Explanation: &quot;abcbdd&quot; &#x3D; &quot;a&quot; + &quot;bcb&quot; + &quot;dd&quot;, and all three substrings are palindromes.</span><br></pre></td></tr></table></figure><br><br>方法一：竞赛没时间做，其实比3题简单，亏了。N</em>2时间复杂度可过。只要可以从O(1)时间得到s[i:j]是否是回文串就可以了。<br><br>而这个可以通过N<em>2的动态规划来实现。<br><br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">checkPartitioning</span><span class=\"params\">(self, s: str)</span> -&gt; bool:</span></span><br><span class=\"line\">    N = len(s)</span><br><span class=\"line\">    dp = [[<span class=\"literal\">False</span>]*N <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(N)]  <span class=\"comment\"># dp[i][j]表示s[i:j+1]是否为回文串</span></span><br><span class=\"line\">    <span class=\"comment\"># 单个字符为回文串</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(N):</span><br><span class=\"line\">        dp[i][i] = <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 预处理, 倒序</span></span><br><span class=\"line\">    <span class=\"comment\"># for i in range(N-2, -1, -1):</span></span><br><span class=\"line\">    <span class=\"comment\">#     for j in range(i+1, N):</span></span><br><span class=\"line\">    <span class=\"comment\">#         if j == i+1:</span></span><br><span class=\"line\">    <span class=\"comment\">#             dp[i][j] = s[i]==s[j]</span></span><br><span class=\"line\">    <span class=\"comment\">#         else:</span></span><br><span class=\"line\">    <span class=\"comment\">#             dp[i][j] = s[i]==s[j] and dp[i+1][j-1] </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, N):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(j<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i == j<span class=\"number\">-1</span>:</span><br><span class=\"line\">                dp[i][j] = s[i]==s[j]</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                dp[i][j] = s[i]==s[j] <span class=\"keyword\">and</span> dp[i+<span class=\"number\">1</span>][j<span class=\"number\">-1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(N):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i+<span class=\"number\">1</span>, N):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> dp[<span class=\"number\">0</span>][i] <span class=\"keyword\">and</span> dp[i+<span class=\"number\">1</span>][j] <span class=\"keyword\">and</span> dp[j+<span class=\"number\">1</span>][N<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure><br><br>### <a href=\"https://leetcode.com/problems/minimum-number-of-removals-to-make-mountain-array/\" target=\"_blank\" rel=\"noopener\">1671. Minimum Number of Removals to Make Mountain Array</a><br><br>#### 最少的删除使数组变为山峰数组。<br><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [2,1,1,5,6,2,3,1]</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: One solution is to remove the elements at indices 0, 1, and 5, making the array nums &#x3D; [1,5,6,3,1].</span><br></pre></td></tr></table></figure><br><br>方法一：和LIS问题一样，找到2个方向的最长上升子序列，然后求和用总数相减，<code>&gt;=2</code>表示既要有上升又要有下降。<br><br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minimumMountainRemovals</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lis</span><span class=\"params\">(nums: List[int])</span>:</span></span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        dp = [<span class=\"number\">1</span>] * (n)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i)[::<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> nums[j] &lt; nums[i]:</span><br><span class=\"line\">                    dp[i] = max(dp[i], dp[j] + <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp</span><br><span class=\"line\"></span><br><span class=\"line\">    left, right = lis(nums), lis(nums[::<span class=\"number\">-1</span>])[::<span class=\"number\">-1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> len(nums) - (max(a+b <span class=\"keyword\">if</span> a&gt;=<span class=\"number\">2</span> <span class=\"keyword\">and</span> b&gt;=<span class=\"number\">2</span> <span class=\"keyword\">else</span> <span class=\"number\">0</span> <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> zip(left, right))<span class=\"number\">-1</span>)</span><br></pre></td></tr></table></figure><br><br>方法二：nlogn的方法。使用二分法。<br><br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minimumMountainRemovals</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lis</span><span class=\"params\">(nums: List[int])</span>:</span></span><br><span class=\"line\">        dp = [inf] * (len(nums) + <span class=\"number\">1</span>)</span><br><span class=\"line\">        lens = [<span class=\"number\">0</span>] * len(nums)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, num <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">            lens[i] = bisect.bisect_left(dp, num) + <span class=\"number\">1</span></span><br><span class=\"line\">            dp[lens[i]<span class=\"number\">-1</span>] = num</span><br><span class=\"line\">        <span class=\"keyword\">return</span> lens</span><br><span class=\"line\"></span><br><span class=\"line\">    left, right = lis(nums), lis(nums[::<span class=\"number\">-1</span>])[::<span class=\"number\">-1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> len(nums) - (max(a+b <span class=\"keyword\">if</span> a&gt;=<span class=\"number\">2</span> <span class=\"keyword\">and</span> b&gt;=<span class=\"number\">2</span> <span class=\"keyword\">else</span> <span class=\"number\">0</span> <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> zip(left, right))<span class=\"number\">-1</span>)</span><br></pre></td></tr></table></figure><br><br>### <a href=\"https://leetcode.com/problems/maximum-score-from-performing-multiplication-operations/\" target=\"_blank\" rel=\"noopener\">1770. Maximum Score from Performing Multiplication Operations</a><br><br>#### 每次从数组前后拿出一个数和multiplires按序相乘，求累加和最大为多少。<br><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [1,2,3], multipliers &#x3D; [3,2,1]</span><br><span class=\"line\">Output: 14</span><br><span class=\"line\">Explanation: An optimal solution is as follows:</span><br><span class=\"line\">- Choose from the end, [1,2,3], adding 3 * 3 &#x3D; 9 to the score.</span><br><span class=\"line\">- Choose from the end, [1,2], adding 2 * 2 &#x3D; 4 to the score.</span><br><span class=\"line\">- Choose from the end, [1], adding 1 * 1 &#x3D; 1 to the score.</span><br><span class=\"line\">The total score is 9 + 4 + 1 &#x3D; 14.</span><br></pre></td></tr></table></figure><br><br>方法一：比赛时没有AC，超时了，如果将<code>lru_cache(None)</code>改为<code>lru_cache(M)</code>可以减少耗时。这里LC各个testcase之间是不会清掉cache的，所以有时cache长度过长会导致超时。<br><br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maximumScore</span><span class=\"params\">(self, nums: List[int], mult: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    M = len(mult)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @lru_cache(M)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dp</span><span class=\"params\">(idx, i, j)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> idx == M:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        res1 = mult[idx] * nums[i] + dp(idx+<span class=\"number\">1</span>, i+<span class=\"number\">1</span>, j)</span><br><span class=\"line\">        res2 = mult[idx] * nums[j] + dp(idx+<span class=\"number\">1</span>, i, j<span class=\"number\">-1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(res1, res2)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp(<span class=\"number\">0</span>, <span class=\"number\">0</span>, len(nums)<span class=\"number\">-1</span>)</span><br></pre></td></tr></table></figure><br><br>方法二：自底向上的方法很难想。<br><br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maximumScore</span><span class=\"params\">(self, nums: List[int], multipliers: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    n, m = len(nums), len(multipliers)</span><br><span class=\"line\">    dp = [[<span class=\"number\">0</span>]*m <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(m+<span class=\"number\">1</span>)]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> reversed(range(m)):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i, m): </span><br><span class=\"line\">            k = i + m - j - <span class=\"number\">1</span></span><br><span class=\"line\">            dp[i][j] = max(nums[i] * multipliers[k] + dp[i+<span class=\"number\">1</span>][j], nums[j-m+n] * multipliers[k] + dp[i][j<span class=\"number\">-1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[<span class=\"number\">0</span>][<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure><br><br>### 1799. Maximize Score After N Operations<br><br>#### N步操作的最大分。每次能从数组中选出一对数，次数</em>这两个数的最大公约数累加。<br><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [1,2,3,4,5,6]</span><br><span class=\"line\">Output: 14</span><br><span class=\"line\">Explanation: The optimal choice of operations is:</span><br><span class=\"line\">(1 * gcd(1, 5)) + (2 * gcd(2, 4)) + (3 * gcd(3, 6)) &#x3D; 1 + 4 + 9 &#x3D; 14</span><br></pre></td></tr></table></figure><br><br>方法一：竞赛没有时间做。记忆化搜索就能过。<br><br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxScore</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    n = len(nums)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @lru_cache(None)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(i, status)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == n//<span class=\"number\">2</span>+<span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        cnt = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(j+<span class=\"number\">1</span>, n):</span><br><span class=\"line\">                new_mask = (<span class=\"number\">1</span>&lt;&lt;j) | (<span class=\"number\">1</span>&lt;&lt;k)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> status &amp; new_mask:</span><br><span class=\"line\">                    cnt = max(cnt, i * gcd(nums[j], nums[k]) + dfs(i+<span class=\"number\">1</span>, status | new_mask))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cnt</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dfs(<span class=\"number\">1</span>, <span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure><br><br>### 1824. Minimum Sideway Jumps<br><br>#### 青蛙🐸最小横跳几次能到达终点。<br><br><img src=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AF%87%EF%BC%89Danymic-Programming/frog_jump.png\" class><br><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: obstacles &#x3D; [0,1,2,3,0]</span><br><span class=\"line\">Output: 2 </span><br><span class=\"line\">Explanation: The optimal solution is shown by the arrows above. There are 2 side jumps (red arrows).</span><br><span class=\"line\">Note that the frog can jump over obstacles only when making side jumps (as shown at point 2).</span><br></pre></td></tr></table></figure><br><br>方法一：比赛时错了一次。<br><br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minSideJumps</span><span class=\"params\">(self, obstacles: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    a, b, c = <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, ob <span class=\"keyword\">in</span> enumerate(obstacles):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ob == <span class=\"number\">1</span>:</span><br><span class=\"line\">            b = min(b, c+<span class=\"number\">1</span>)</span><br><span class=\"line\">            c = min(c, b+<span class=\"number\">1</span>)</span><br><span class=\"line\">            a = inf</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> ob == <span class=\"number\">2</span>:</span><br><span class=\"line\">            a = min(a, c+<span class=\"number\">1</span>)</span><br><span class=\"line\">            c = min(c, a+<span class=\"number\">1</span>)</span><br><span class=\"line\">            b = inf</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> ob == <span class=\"number\">3</span>:</span><br><span class=\"line\">            a = min(a, b+<span class=\"number\">1</span>)</span><br><span class=\"line\">            b = min(b, a+<span class=\"number\">1</span>)</span><br><span class=\"line\">            c = inf</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> obstacles[i<span class=\"number\">-1</span>]==<span class=\"number\">1</span>:</span><br><span class=\"line\">                    a = min(b+<span class=\"number\">1</span>, c+<span class=\"number\">1</span>)</span><br><span class=\"line\">                <span class=\"keyword\">elif</span> obstacles[i<span class=\"number\">-1</span>]==<span class=\"number\">2</span>:</span><br><span class=\"line\">                    b = min(a+<span class=\"number\">1</span>, c+<span class=\"number\">1</span>)</span><br><span class=\"line\">                <span class=\"keyword\">elif</span> obstacles[i<span class=\"number\">-1</span>]==<span class=\"number\">3</span>:</span><br><span class=\"line\">                    c = min(a+<span class=\"number\">1</span>, b+<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min(a, b, c)</span><br></pre></td></tr></table></figure><br><br>方法二：当前不是障碍时，才能计算min。这里使用取余来简化代码<br><br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minSideJumps</span><span class=\"params\">(self, A: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    dp = [<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> A:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> a:</span><br><span class=\"line\">            dp[a - <span class=\"number\">1</span>] = float(<span class=\"string\">'inf'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">3</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> a != i + <span class=\"number\">1</span>:</span><br><span class=\"line\">                dp[i] = min(dp[i], dp[(i + <span class=\"number\">1</span>) % <span class=\"number\">3</span>] + <span class=\"number\">1</span>, dp[(i + <span class=\"number\">2</span>) % <span class=\"number\">3</span>] + <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min(dp)</span><br></pre></td></tr></table></figure><br><br>### <a href=\"https://leetcode.com/problems/maximum-number-of-groups-getting-fresh-donuts/\" target=\"_blank\" rel=\"noopener\">1815. Maximum Number of Groups Getting Fresh Donuts</a><br><br>#### 有一个甜甜圈商店，每批次都烤 batchSize 个甜甜圈。这个店铺有个规则，就是在烤一批新的甜甜圈时，之前 所有 甜甜圈都必须已经全部销售完毕。给你一个整数 batchSize 和一个整数数组 groups ，数组中的每个整数都代表一批前来购买甜甜圈的顾客，其中 groups[i] 表示这一批顾客的人数。每一位顾客都恰好只要一个甜甜圈。当有一批顾客来到商店时，他们所有人都必须在下一批顾客来之前购买完甜甜圈。如果一批顾客中第一位顾客得到的甜甜圈不是上一组剩下的，那么这一组人都会很开心。你可以随意安排每批顾客到来的顺序。请你返回在此前提下，最多 有多少组人会感到开心。<br><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: batchSize &#x3D; 3, groups &#x3D; [1,2,3,4,5,6]</span><br><span class=\"line\">Output: 4</span><br><span class=\"line\">Explanation: You can arrange the groups as [6,2,4,5,1,3]. Then the 1st, 2nd, 4th, and 6th groups will be happy.</span><br></pre></td></tr></table></figure><br><br>方法一：此题的动态规划有点难想。这里学到一个新的方法：模拟退火算法，是一种随机算法。因为最后的结果是有顺序的，通过随机交换两个元素，比较结果；如果这个结果是比较优的，那么保留操作。如果较差，则以一定概率保留操作，以跳出局部最优解，从而得到全局最优解。<br><br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxHappyGroups</span><span class=\"params\">(self, batchSize: int, groups: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    self.res = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    RAND_MAX = <span class=\"number\">2</span>**<span class=\"number\">15</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">calculate</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">        cnt = <span class=\"number\">1</span></span><br><span class=\"line\">        s = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            s = (s+groups[i]) % m</span><br><span class=\"line\">            <span class=\"keyword\">if</span> s==<span class=\"number\">0</span> <span class=\"keyword\">and</span> i!=n<span class=\"number\">-1</span>:</span><br><span class=\"line\">                cnt += <span class=\"number\">1</span></span><br><span class=\"line\">        self.res = max(self.res, cnt)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cnt</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">simulate_anneal</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">        random.shuffle(groups)</span><br><span class=\"line\">        t = <span class=\"number\">1e6</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> t &gt; <span class=\"number\">1e-5</span>:</span><br><span class=\"line\">            a, b = randint(<span class=\"number\">0</span>, RAND_MAX) % n, randint(<span class=\"number\">0</span>, RAND_MAX) % n</span><br><span class=\"line\">            x = calculate()</span><br><span class=\"line\">            groups[a], groups[b] = groups[b], groups[a]</span><br><span class=\"line\">            y = calculate()</span><br><span class=\"line\">            delta = y - x</span><br><span class=\"line\">            d = uniform(<span class=\"number\">0</span>, RAND_MAX)</span><br><span class=\"line\">            <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                c = exp(-delta / t)</span><br><span class=\"line\">            <span class=\"keyword\">except</span> OverflowError:</span><br><span class=\"line\">                c = float(<span class=\"string\">'inf'</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> delta&lt;<span class=\"number\">0</span> <span class=\"keyword\">and</span> c&gt;d:</span><br><span class=\"line\">                <span class=\"comment\"># 当 y 小于 x 时 , 一定概率 exp(-1 * delta / t) 保留操作</span></span><br><span class=\"line\">                <span class=\"comment\"># 当 y 大于 x 时 ， 就保留交换</span></span><br><span class=\"line\">                groups[a], groups[b] = groups[b], groups[a]</span><br><span class=\"line\">            t *= <span class=\"number\">0.985</span>   <span class=\"comment\"># 调参，这个值越大，迭代次数越多，越可能超时；这个值越小，迭代次数越少，就可能WA，因为跳不出局部最优解</span></span><br><span class=\"line\"></span><br><span class=\"line\">    mod_zero = sum(g % batchSize==<span class=\"number\">0</span> <span class=\"keyword\">for</span> g <span class=\"keyword\">in</span> groups)</span><br><span class=\"line\">    groups = [g <span class=\"keyword\">for</span> g <span class=\"keyword\">in</span> groups <span class=\"keyword\">if</span> g%batchSize!=<span class=\"number\">0</span>]</span><br><span class=\"line\">    n = len(groups)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mod_zero</span><br><span class=\"line\">    m = batchSize</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">20</span>):</span><br><span class=\"line\">        simulate_anneal()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.res + mod_zero</span><br></pre></td></tr></table></figure><br><br>### <a href=\"https://leetcode.com/problems/ones-and-zeroes/\" target=\"_blank\" rel=\"noopener\">474. Ones and Zeroes</a><br><br>#### 最多包含m个0，n个1的最多的子集个数有多少。<br><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: strs &#x3D; [&quot;10&quot;,&quot;0001&quot;,&quot;111001&quot;,&quot;1&quot;,&quot;0&quot;], m &#x3D; 5, n &#x3D; 3</span><br><span class=\"line\">Output: 4</span><br><span class=\"line\">Explanation: The largest subset with at most 5 0&#39;s and 3 1&#39;s is &#123;&quot;10&quot;, &quot;0001&quot;, &quot;1&quot;, &quot;0&quot;&#125;, so the answer is 4.</span><br><span class=\"line\">Other valid but smaller subsets include &#123;&quot;0001&quot;, &quot;1&quot;&#125; and &#123;&quot;10&quot;, &quot;1&quot;, &quot;0&quot;&#125;.</span><br><span class=\"line\">&#123;&quot;111001&quot;&#125; is an invalid subset because it contains 4 1&#39;s, greater than the maximum of 3.</span><br></pre></td></tr></table></figure><br><br>方法一：可以dfs+记忆化。<br><br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findMaxForm</span><span class=\"params\">(self, strs: List[str], m: int, n: int)</span> -&gt; int:</span></span><br><span class=\"line\">    N = len(strs)</span><br><span class=\"line\">    self.res = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @lru_cache(None)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(m, n, i, cnt)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == N:</span><br><span class=\"line\">            self.res = max(self.res, cnt)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        one, zero = strs[i].count(<span class=\"string\">\"1\"</span>), strs[i].count(<span class=\"string\">\"0\"</span>)</span><br><span class=\"line\">        m1, n1 = m-zero, n-one</span><br><span class=\"line\">        <span class=\"keyword\">if</span> m1 &gt;=<span class=\"number\">0</span> <span class=\"keyword\">and</span> n1 &gt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">            dfs(m1, n1, i+<span class=\"number\">1</span>, cnt+<span class=\"number\">1</span>)</span><br><span class=\"line\">        dfs(m, n, i+<span class=\"number\">1</span>, cnt)</span><br><span class=\"line\"></span><br><span class=\"line\">    dfs(m, n, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.res</span><br></pre></td></tr></table></figure><br><br>方法二: 这是一个背包问题。要将原问题转换为「背包问题」，往往需要从题目中抽象出「价值」与「成本」的概念。<br><br>这道题如果抽象成「背包问题」的话，应该是：<br><br>每个字符串的价值都是 1（对答案的贡献都是 1），选择的成本是该字符串中 1 的数量和 0 的数量。<br><br>问我们在 1 的数量不超过 m，0 的数量不超过 n 的条件下，最大价值是多少。<br><br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findMaxForm</span><span class=\"params\">(self, strs: List[str], m: int, n: int)</span> -&gt; int:</span></span><br><span class=\"line\">    N = len(strs)</span><br><span class=\"line\">    dp = [[[<span class=\"number\">0</span>] * (n+<span class=\"number\">1</span>) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(m+<span class=\"number\">1</span>)] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(N+<span class=\"number\">1</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, N+<span class=\"number\">1</span>):</span><br><span class=\"line\">        cnt0 = strs[i<span class=\"number\">-1</span>].count(<span class=\"string\">\"0\"</span>)</span><br><span class=\"line\">        cnt1 = strs[i<span class=\"number\">-1</span>].count(<span class=\"string\">\"1\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(m+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(n+<span class=\"number\">1</span>):</span><br><span class=\"line\">                dp[i][j][k] = dp[i<span class=\"number\">-1</span>][j][k]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> j-cnt0 &gt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> k-cnt1 &gt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">                    dp[i][j][k] = max(dp[i][j][k], dp[i<span class=\"number\">-1</span>][j-cnt0][k-cnt1]+<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[N][m][n]</span><br></pre></td></tr></table></figure><br><br>方法三：可以倒序，节省一层空间。<br><br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findMaxForm</span><span class=\"params\">(self, strs: List[str], m: int, n: int)</span> -&gt; int:</span></span><br><span class=\"line\">    N = len(strs)</span><br><span class=\"line\">    dp = [[<span class=\"number\">0</span>] * (n+<span class=\"number\">1</span>) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(m+<span class=\"number\">1</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, N+<span class=\"number\">1</span>):</span><br><span class=\"line\">        cnt0 = strs[i<span class=\"number\">-1</span>].count(<span class=\"string\">\"0\"</span>)</span><br><span class=\"line\">        cnt1 = strs[i<span class=\"number\">-1</span>].count(<span class=\"string\">\"1\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m, cnt0 - <span class=\"number\">1</span>, <span class=\"number\">-1</span>):    <span class=\"comment\">#0-1背包问题，内循环逆序</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n, cnt1 - <span class=\"number\">1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">                dp[i][j] = max(dp[i][j], dp[i-cnt0][j-cnt1] + <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[m][n]</span><br></pre></td></tr></table></figure><br><br>### <a href=\"https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/\" target=\"_blank\" rel=\"noopener\">2369. Check if There is a Valid Partition For The Array</a><br><br>#### 判断数组是否符合要求。<br><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [4,4,4,5,6]</span><br><span class=\"line\">Output: true</span><br><span class=\"line\">Explanation: The array can be partitioned into the subarrays [4,4] and [4,5,6].</span><br><span class=\"line\">This partition is valid, so we return true.</span><br></pre></td></tr></table></figure><br><br>方法一： dp，比赛时过了，不过空间需要优化。<br><br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">validPartition</span><span class=\"params\">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class=\"line\">    N = len(nums)</span><br><span class=\"line\">    dp = [<span class=\"literal\">False</span>] * N</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, N):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i]==nums[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                dp[i] = <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> i == <span class=\"number\">2</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i]==nums[i<span class=\"number\">-1</span>]==nums[i<span class=\"number\">-2</span>]) <span class=\"keyword\">or</span> (nums[i]==nums[i<span class=\"number\">-1</span>]+<span class=\"number\">1</span>==nums[i<span class=\"number\">-2</span>]+<span class=\"number\">2</span>):</span><br><span class=\"line\">                dp[i] = <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> dp[i]:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> nums[i]==nums[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                    dp[i] = dp[i<span class=\"number\">-2</span>]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> dp[i]:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nums[i]==nums[i<span class=\"number\">-1</span>]==nums[i<span class=\"number\">-2</span>]) <span class=\"keyword\">or</span> (nums[i]==nums[i<span class=\"number\">-1</span>]+<span class=\"number\">1</span>==nums[i<span class=\"number\">-2</span>]+<span class=\"number\">2</span>):</span><br><span class=\"line\">                    dp[i] = dp[i<span class=\"number\">-3</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure><br><br>方法二：lee215的写法。因为条件最多用到3个连续元素，所以长度为4的数组就够用了。<br><br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">validPartition</span><span class=\"params\">(self, A: List[int])</span> -&gt; bool:</span></span><br><span class=\"line\">    n = len(A)</span><br><span class=\"line\">    dp = [<span class=\"literal\">False</span>, <span class=\"literal\">False</span>, <span class=\"literal\">False</span>, <span class=\"literal\">True</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">        dp[i % <span class=\"number\">4</span>] = <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> A[i] == A[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">            dp[i % <span class=\"number\">4</span>] |= dp[(i - <span class=\"number\">2</span>) % <span class=\"number\">4</span>]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i - <span class=\"number\">2</span> &gt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> A[i] == A[i<span class=\"number\">-1</span>] == A[i<span class=\"number\">-2</span>]:</span><br><span class=\"line\">            dp[i % <span class=\"number\">4</span>] |= dp[(i - <span class=\"number\">3</span>) % <span class=\"number\">4</span>]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i - <span class=\"number\">2</span> &gt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> A[i] == A[i<span class=\"number\">-1</span>] + <span class=\"number\">1</span> == A[i<span class=\"number\">-2</span>] + <span class=\"number\">2</span>:</span><br><span class=\"line\">            dp[i % <span class=\"number\">4</span>] |= dp[(i - <span class=\"number\">3</span>) % <span class=\"number\">4</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[(n - <span class=\"number\">1</span>) % <span class=\"number\">4</span>]</span><br></pre></td></tr></table></figure><br><br>### <a href=\"https://leetcode.com/problems/longest-ideal-subsequence/\" target=\"_blank\" rel=\"noopener\">2370. Longest Ideal Subsequence</a><br><br>#### 最长的理想子序列的长度。子序列中小写字母的ascii码小于等于k。<br><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;acfgbd&quot;, k &#x3D; 2</span><br><span class=\"line\">Output: 4</span><br><span class=\"line\">Explanation: The longest ideal string is &quot;acbd&quot;. The length of this string is 4, so 4 is returned.</span><br><span class=\"line\">Note that &quot;acfgbd&quot; is not ideal because &#39;c&#39; and &#39;f&#39; have a difference of 3 in alphabet order.</span><br></pre></td></tr></table></figure><br><br>方法一：竞赛时的方法。空间有很大优化空间。时间4000ms<br><br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestIdealString</span><span class=\"params\">(self, s: str, k: int)</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get</span><span class=\"params\">(c)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ord(c)-ord(<span class=\"string\">'a'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    N = len(s)</span><br><span class=\"line\">    dp = [[<span class=\"number\">0</span>]*<span class=\"number\">26</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(N)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(N):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == <span class=\"number\">0</span>:</span><br><span class=\"line\">            dp[<span class=\"number\">0</span>][get(s[i])] = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            dp[i] = dp[i<span class=\"number\">-1</span>]</span><br><span class=\"line\">            max_d = dp[i][get(s[i])]</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(max(get(s[i])-k, <span class=\"number\">0</span>), min(get(s[i])+k+<span class=\"number\">1</span>, <span class=\"number\">26</span>)):</span><br><span class=\"line\">                max_d = max(max_d, dp[i<span class=\"number\">-1</span>][j]+<span class=\"number\">1</span>, dp[i<span class=\"number\">-1</span>][j])</span><br><span class=\"line\"></span><br><span class=\"line\">            dp[i][get(s[i])] = max_d</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(dp[<span class=\"number\">-1</span>])</span><br></pre></td></tr></table></figure><br><br><font color=\"#32CD32\" size=\"3\">方法二：写法优化，时间600ms。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestIdealString</span><span class=\"params\">(self, s: str, k: int)</span> -&gt; int:</span></span><br><span class=\"line\">    dp = [<span class=\"number\">0</span>] * <span class=\"number\">26</span> </span><br><span class=\"line\">    <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">        i = ord(c) - ord(<span class=\"string\">'a'</span>)</span><br><span class=\"line\">        dp[i] = max(dp[max(<span class=\"number\">0</span>, i-k):min(<span class=\"number\">26</span>, i+k+<span class=\"number\">1</span>)]) + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(dp)</span><br></pre></td></tr></table></figure>\n<h3 id=\"940-Distinct-Subsequences-II\"><a href=\"#940-Distinct-Subsequences-II\" class=\"headerlink\" title=\"940. Distinct Subsequences II\"></a><a href=\"https://leetcode.com/problems/distinct-subsequences-ii/\" target=\"_blank\" rel=\"noopener\">940. Distinct Subsequences II</a></h3><p>一个字符串不同的子序列有多少种。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;aba&quot;</span><br><span class=\"line\">Output: 6</span><br><span class=\"line\">Explanation: The 6 distinct subsequences are &quot;a&quot;, &quot;b&quot;, &quot;ab&quot;, &quot;aa&quot;, &quot;ba&quot;, and &quot;aba&quot;.</span><br></pre></td></tr></table></figure>\n<p>方法一：关键点在于，每增加一个字符都可以选择增加到原有的字符上，如果不考虑重复的话，总数为2*n+1，重复的字符串，第二次出现的时候，恰好上该字符上次出现时增加的次数，记作repeat_cnt。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">distinctSubseqII</span><span class=\"params\">(self, s: str)</span> -&gt; int:</span></span><br><span class=\"line\">    MOD = <span class=\"number\">10</span>**<span class=\"number\">9</span> + <span class=\"number\">7</span></span><br><span class=\"line\">    pre_cnt = Counter()</span><br><span class=\"line\">    res = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">        add = res</span><br><span class=\"line\">        res = (res + add - pre_cnt[c]) % MOD</span><br><span class=\"line\">        pre_cnt[c] = add</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res - <span class=\"number\">1</span>  <span class=\"comment\"># 去掉空串</span></span><br></pre></td></tr></table></figure>\n","categories":["算法"],"tags":["LeetCode","Python","Algorithm","Dynamic Programming"]},{"title":"LeetCode算法题整理（数组篇）Array","url":"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%95%B0%E7%BB%84%E7%AF%87%EF%BC%89Array/","content":"<h3 id=\"26-Remove-Duplicates-from-Sorted-Array\"><a href=\"#26-Remove-Duplicates-from-Sorted-Array\" class=\"headerlink\" title=\"26. Remove Duplicates from Sorted Array\"></a>26. Remove Duplicates from Sorted Array</h3><h4 id=\"删除排序数组中重复的元素-在原数组上操作，返回一个长度，标识前n个元素为目标数组。原题\"><a href=\"#删除排序数组中重复的元素-在原数组上操作，返回一个长度，标识前n个元素为目标数组。原题\" class=\"headerlink\" title=\"删除排序数组中重复的元素, 在原数组上操作，返回一个长度，标识前n个元素为目标数组。原题\"></a>删除排序数组中重复的元素, 在原数组上操作，返回一个长度，标识前n个元素为目标数组。<a href=\"https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Given nums &#x3D; [0,0,1,1,1,2,2,3,3,4],</span><br><span class=\"line\"></span><br><span class=\"line\">Your function should return length &#x3D; 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.</span><br><span class=\"line\"></span><br><span class=\"line\">It doesn&#39;t matter what values are set beyond the returned length.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">remove_duplicates</span><span class=\"params\">(nums)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> nums:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    index = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(nums)<span class=\"number\">-1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[i] != nums[i+<span class=\"number\">1</span>]:</span><br><span class=\"line\">            nums[index] = nums[i+<span class=\"number\">1</span>]</span><br><span class=\"line\">            index += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> index</span><br></pre></td></tr></table></figure>\n<h3 id=\"80-Remove-Duplicates-from-Sorted-Array-II\"><a href=\"#80-Remove-Duplicates-from-Sorted-Array-II\" class=\"headerlink\" title=\"80. Remove Duplicates from Sorted Array II\"></a>80. Remove Duplicates from Sorted Array II</h3><h4 id=\"和上题一样，但是可以允许重复两次。原题\"><a href=\"#和上题一样，但是可以允许重复两次。原题\" class=\"headerlink\" title=\"和上题一样，但是可以允许重复两次。原题\"></a>和上题一样，但是可以允许重复两次。<a href=\"https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：双指针调了半天。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removeDuplicates</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    left = right = cnt = <span class=\"number\">0</span></span><br><span class=\"line\">    last_left = <span class=\"literal\">None</span></span><br><span class=\"line\">    n = len(nums)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> right &lt; n:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> right&lt;n <span class=\"keyword\">and</span> nums[right]==last_left <span class=\"keyword\">and</span> cnt:</span><br><span class=\"line\">            right += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> right &gt;= n: <span class=\"keyword\">break</span></span><br><span class=\"line\">        nums[left] = nums[right]</span><br><span class=\"line\">        cnt = last_left==nums[left]</span><br><span class=\"line\">        last_left = nums[left]</span><br><span class=\"line\">        left += <span class=\"number\">1</span></span><br><span class=\"line\">        right += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> left</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：stefan的方法原来这么简单。i作为待插入的索引位置，用n和他前两位比较，如果一样的话，保持插入位置不动，而nums[i-2]是不变的，一直可以用来作比较。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removeDuplicates</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    i = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i&lt;<span class=\"number\">2</span> <span class=\"keyword\">or</span> n&gt;nums[i<span class=\"number\">-2</span>]:</span><br><span class=\"line\">            nums[i] = n</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> i</span><br></pre></td></tr></table></figure>\n<h3 id=\"66-Plus-One\"><a href=\"#66-Plus-One\" class=\"headerlink\" title=\"66. Plus One\"></a>66. Plus One</h3><h4 id=\"给数组加一，元素为非负整数，不以0开头，每个元素只有一个数字。原题\"><a href=\"#给数组加一，元素为非负整数，不以0开头，每个元素只有一个数字。原题\" class=\"headerlink\" title=\"给数组加一，元素为非负整数，不以0开头，每个元素只有一个数字。原题\"></a>给数组加一，元素为非负整数，不以0开头，每个元素只有一个数字。<a href=\"https://leetcode.com/problems/plus-one/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [4,3,2,1]</span><br><span class=\"line\">Output: [4,3,2,2]</span><br><span class=\"line\">Explanation: The array represents the integer 4321.</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法一：转成字符串再转成数字</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">plusOne</span><span class=\"params\">(self, digits: <span class=\"string\">'List[int]'</span>)</span> -&gt; 'List[int]':</span></span><br><span class=\"line\">    num = int(<span class=\"string\">''</span>.join(map(str, digits)))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [int(d) <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> str(num + <span class=\"number\">1</span>)]</span><br></pre></td></tr></table></figure>\n<p>方法二：Math 进位</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">plus_one</span><span class=\"params\">(digits)</span>:</span></span><br><span class=\"line\">    d = digits[:]  </span><br><span class=\"line\">    plused = []</span><br><span class=\"line\">    carry = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> d <span class=\"keyword\">or</span> carry:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> d:</span><br><span class=\"line\">            v = d.pop()</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            v = <span class=\"number\">0</span></span><br><span class=\"line\">        carry, val = divmod(carry+v, <span class=\"number\">10</span>)</span><br><span class=\"line\">        plused.append(val)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> plused[::<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：数组进位。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">plusOne</span><span class=\"params\">(self, digits: <span class=\"string\">'List[int]'</span>)</span> -&gt; 'List[int]':</span></span><br><span class=\"line\">    d = digits[:]</span><br><span class=\"line\">    d[<span class=\"number\">-1</span>] += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(d)<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">        carry, d[i] = divmod(d[i], <span class=\"number\">10</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i: d[i<span class=\"number\">-1</span>] += carry</span><br><span class=\"line\">    <span class=\"keyword\">if</span> carry:</span><br><span class=\"line\">        d.insert(<span class=\"number\">0</span>, carry)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> d</span><br></pre></td></tr></table></figure>\n<h3 id=\"989-Add-to-Array-Form-of-Integer\"><a href=\"#989-Add-to-Array-Form-of-Integer\" class=\"headerlink\" title=\"989. Add to Array-Form of Integer\"></a>989. Add to Array-Form of Integer</h3><h4 id=\"和66题很相似。不同的是这个K会大于10，以至于余数也会大于10。原题\"><a href=\"#和66题很相似。不同的是这个K会大于10，以至于余数也会大于10。原题\" class=\"headerlink\" title=\"和66题很相似。不同的是这个K会大于10，以至于余数也会大于10。原题\"></a>和66题很相似。不同的是这个K会大于10，以至于余数也会大于10。<a href=\"https://leetcode.com/contest/weekly-contest-123/problems/add-to-array-form-of-integer/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: A &#x3D; [2,7,4], K &#x3D; 181</span><br><span class=\"line\">Output: [4,5,5]</span><br><span class=\"line\">Explanation: 274 + 181 &#x3D; 455</span><br></pre></td></tr></table></figure>\n<p>方法一：竞赛写法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addToArrayForm</span><span class=\"params\">(self, A: <span class=\"string\">'List[int]'</span>, K: <span class=\"string\">'int'</span>)</span> -&gt; 'List[int]':</span></span><br><span class=\"line\">    a = int(<span class=\"string\">''</span>.join(map(str, A)))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [int(c) <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> str(a + K)]</span><br></pre></td></tr></table></figure>\n<p>方法二：原理实现。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addToArrayForm</span><span class=\"params\">(self, A: <span class=\"string\">'List[int]'</span>, K: <span class=\"string\">'int'</span>)</span> -&gt; 'List[int]':</span></span><br><span class=\"line\">    A[<span class=\"number\">-1</span>] += K</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(A)<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">        carry, A[i] = divmod(A[i], <span class=\"number\">10</span>) </span><br><span class=\"line\">        <span class=\"keyword\">if</span> i: A[i<span class=\"number\">-1</span>] += carry</span><br><span class=\"line\">    <span class=\"keyword\">if</span> carry:</span><br><span class=\"line\">        A = list(map(int, str(carry))) + A</span><br><span class=\"line\">    <span class=\"keyword\">return</span> A</span><br></pre></td></tr></table></figure>\n<h3 id=\"88-Merge-Sorted-Array\"><a href=\"#88-Merge-Sorted-Array\" class=\"headerlink\" title=\"88. Merge Sorted Array\"></a>88. Merge Sorted Array</h3><h4 id=\"合并两个有序数组，在nums1上修改。原题\"><a href=\"#合并两个有序数组，在nums1上修改。原题\" class=\"headerlink\" title=\"合并两个有序数组，在nums1上修改。原题\"></a>合并两个有序数组，在nums1上修改。<a href=\"https://leetcode.com/problems/merge-sorted-array/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3</span><br><span class=\"line\">nums2 &#x3D; [2,5,6],       n &#x3D; 3</span><br><span class=\"line\"></span><br><span class=\"line\">Output: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge</span><span class=\"params\">(self, nums1, m, nums2, n)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> m&gt;<span class=\"number\">0</span> <span class=\"keyword\">and</span> n&gt;<span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums1[m<span class=\"number\">-1</span>] &gt; nums2[n<span class=\"number\">-1</span>]:</span><br><span class=\"line\">            nums1[n+m<span class=\"number\">-1</span>] = nums1[m<span class=\"number\">-1</span>]</span><br><span class=\"line\">            m -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            nums1[n+m<span class=\"number\">-1</span>] = nums2[n<span class=\"number\">-1</span>]</span><br><span class=\"line\">            n -= <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> n &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">        nums1[:n] = nums2[:n]</span><br></pre></td></tr></table></figure>\n<h3 id=\"118-Pascal’s-Triangle\"><a href=\"#118-Pascal’s-Triangle\" class=\"headerlink\" title=\"118. Pascal’s Triangle\"></a>118. Pascal’s Triangle</h3><h4 id=\"杨辉三角。原题\"><a href=\"#杨辉三角。原题\" class=\"headerlink\" title=\"杨辉三角。原题\"></a>杨辉三角。<a href=\"https://leetcode.com/problems/pascals-triangle/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: 5</span><br><span class=\"line\">Output:</span><br><span class=\"line\">[</span><br><span class=\"line\">     [1],</span><br><span class=\"line\">    [1,1],</span><br><span class=\"line\">   [1,2,1],</span><br><span class=\"line\">  [1,3,3,1],</span><br><span class=\"line\"> [1,4,6,4,1]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法一: 错位相加。这里也可以使用zip，值得注意的是，res需要➕一个二维数组，而不是一维。结尾的切片是为了0的情况。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">generate</span><span class=\"params\">(self, numRows: <span class=\"string\">'int'</span>)</span> -&gt; 'List[List[int]]':</span></span><br><span class=\"line\">    ans = [[<span class=\"number\">1</span>]]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(numRows<span class=\"number\">-1</span>):</span><br><span class=\"line\">        ans += [[a+b <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> zip([<span class=\"number\">0</span>]+ans[<span class=\"number\">-1</span>], ans[<span class=\"number\">-1</span>]+[<span class=\"number\">0</span>])]]</span><br><span class=\"line\">        <span class=\"comment\"># ans.append(list(map(lambda x, y: x + y, [0]+ans[-1], ans[-1]+[0])))</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans[:numRows]</span><br></pre></td></tr></table></figure>\n<p>方法二</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">generate</span><span class=\"params\">(num)</span>:</span></span><br><span class=\"line\">    triangle = []</span><br><span class=\"line\">    inner = [<span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(num):</span><br><span class=\"line\">        triangle.append(list(inner))</span><br><span class=\"line\">        inner.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">        right = [inner[i]+inner[i+<span class=\"number\">1</span>] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(inner)<span class=\"number\">-1</span>)]</span><br><span class=\"line\">        inner = [<span class=\"number\">1</span>] + right</span><br><span class=\"line\">    <span class=\"keyword\">return</span> triangle</span><br></pre></td></tr></table></figure>\n<h3 id=\"119-Pascal’s-Triangle-II\"><a href=\"#119-Pascal’s-Triangle-II\" class=\"headerlink\" title=\"119.Pascal’s Triangle II\"></a>119.Pascal’s Triangle II</h3><h4 id=\"杨辉三角，只打印一层。原题\"><a href=\"#杨辉三角，只打印一层。原题\" class=\"headerlink\" title=\"杨辉三角，只打印一层。原题\"></a>杨辉三角，只打印一层。<a href=\"https://leetcode.com/problems/pascals-triangle-ii/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getRow</span><span class=\"params\">(self, rowIndex: <span class=\"string\">'int'</span>)</span> -&gt; 'List[int]':</span></span><br><span class=\"line\">    ans = [<span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(rowIndex):</span><br><span class=\"line\">        ans = [a+b <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> zip([<span class=\"number\">0</span>]+ans, ans+[<span class=\"number\">0</span>])]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"169-Majority-Element\"><a href=\"#169-Majority-Element\" class=\"headerlink\" title=\"169. Majority Element\"></a>169. Majority Element</h3><h4 id=\"找出数组中出现次数超过一半的元素。原题\"><a href=\"#找出数组中出现次数超过一半的元素。原题\" class=\"headerlink\" title=\"找出数组中出现次数超过一半的元素。原题\"></a>找出数组中出现次数超过一半的元素。<a href=\"https://leetcode.com/problems/majority-element/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：排序. Time-O(nlogn), Space-O(n)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">majority_element</span><span class=\"params\">(nums)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sorted(nums)[len(nums)//<span class=\"number\">2</span>]</span><br></pre></td></tr></table></figure>\n<p>方法二：Counter Time-O(n), Space-O(n)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">majority_element</span><span class=\"params\">(nums)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Counter</span><br><span class=\"line\">    c = Counter(nums)</span><br><span class=\"line\">    <span class=\"comment\"># return max(c.keys(), key=c.get)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> c.most_common(<span class=\"number\">1</span>)[<span class=\"number\">0</span>][<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：Boyer-Moore Voting Algorithm. 书中的算法说的就是这个，这里附上自己的见解。</font>\n\n<a href=\"/%E6%B3%A2%E4%B9%89%E5%B0%94%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95%EF%BC%88Boyer-Moore-Voting-Algorithm%EF%BC%89/\" title=\"波义尔摩尔投票算法\">波义尔摩尔投票算法</a>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">majorityElement</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">    count = <span class=\"number\">0</span></span><br><span class=\"line\">    candidate = <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> count == <span class=\"number\">0</span>:</span><br><span class=\"line\">            candidate = num</span><br><span class=\"line\">        count += (<span class=\"number\">1</span> <span class=\"keyword\">if</span> num == candidate <span class=\"keyword\">else</span> <span class=\"number\">-1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> candidate</span><br></pre></td></tr></table></figure>\n<h3 id=\"229-Majority-Element-II\"><a href=\"#229-Majority-Element-II\" class=\"headerlink\" title=\"229. Majority Element II\"></a>229. Majority Element II</h3><h4 id=\"找到数组中出现超过n-3次的元素。原题\"><a href=\"#找到数组中出现超过n-3次的元素。原题\" class=\"headerlink\" title=\"找到数组中出现超过n/3次的元素。原题\"></a>找到数组中出现超过n/3次的元素。<a href=\"https://leetcode.com/problems/majority-element-ii/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [1,1,1,3,3,2,2,2]</span><br><span class=\"line\">Output: [1,2]</span><br></pre></td></tr></table></figure>\n<p>方法一：波义尔摩尔投票法同样可用，但是我一开始想一次遍历求，发现好像不可以，最后都要遍历一次判断是否满足条件。循环中是elif，两个候选人开始设为不同的值以用来区分。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">majorityElement</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    count1, count2, candidate1, candidate2 = <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == candidate1:</span><br><span class=\"line\">            count1 += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> n == candidate2:</span><br><span class=\"line\">            count2 += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> count1 == <span class=\"number\">0</span>:</span><br><span class=\"line\">            candidate1, count1 = n, <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> count2 == <span class=\"number\">0</span>:</span><br><span class=\"line\">            candidate2, count2 = n, <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            count1, count2 = count1 - <span class=\"number\">1</span>, count2 - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [n <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> (candidate1, candidate2)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums.count(n) &gt; len(nums) // <span class=\"number\">3</span>]</span><br></pre></td></tr></table></figure>\n<p>方法二：Counter. by Stefan.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">majorityElement</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    ctr = Counter()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        ctr[n] += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(ctr)==<span class=\"number\">3</span>:</span><br><span class=\"line\">            ctr -= Counter(set(ctr))  <span class=\"comment\"># 均-1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [n <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> ctr <span class=\"keyword\">if</span> nums.count(n) &gt; len(nums)//<span class=\"number\">3</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"189-Rotate-Array\"><a href=\"#189-Rotate-Array\" class=\"headerlink\" title=\"189. Rotate Array\"></a>189. Rotate Array</h3><h4 id=\"旋转数组。进阶：使用O-1-空间实现。原题\"><a href=\"#旋转数组。进阶：使用O-1-空间实现。原题\" class=\"headerlink\" title=\"旋转数组。进阶：使用O(1)空间实现。原题\"></a>旋转数组。进阶：使用O(1)空间实现。<a href=\"https://leetcode.com/problems/rotate-array/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [1,2,3,4,5,6,7] and k &#x3D; 3</span><br><span class=\"line\">Output: [5,6,7,1,2,3,4]</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">rotate 1 steps to the right: [7,1,2,3,4,5,6]</span><br><span class=\"line\">rotate 2 steps to the right: [6,7,1,2,3,4,5]</span><br><span class=\"line\">rotate 3 steps to the right: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"4\">方法一：slicing。使用生成器而不是单纯的切片可以使复杂度降到常数。这里也是抱着试试看的态度，发现可以直接将chain的生成器对象赋值给nums。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rotate</span><span class=\"params\">(self, nums: List[int], k: int)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">    n = len(nums)</span><br><span class=\"line\">    k = k % n</span><br><span class=\"line\">    nums[:] = chain(islice(nums, n-k, n), islice(nums, n-k))</span><br></pre></td></tr></table></figure>\n<p>方法二：reverse的方法很新颖，不过要遍历两次数组。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rotate</span><span class=\"params\">(self, nums: List[int], k: int)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverse</span><span class=\"params\">(ary, lo, hi)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> lo &lt; hi: </span><br><span class=\"line\">            ary[lo], ary[hi] = ary[hi], ary[lo]</span><br><span class=\"line\">            lo += <span class=\"number\">1</span></span><br><span class=\"line\">            hi -= <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    N = len(nums)</span><br><span class=\"line\">    k = k % N</span><br><span class=\"line\">    reverse(nums, <span class=\"number\">0</span>, N<span class=\"number\">-1</span>)</span><br><span class=\"line\">    reverse(nums, <span class=\"number\">0</span>, k<span class=\"number\">-1</span>)</span><br><span class=\"line\">    reverse(nums, k, N<span class=\"number\">-1</span>)</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"4\">方法三: 想这种要求常数空间复杂度的并且允许修改原数组的，可以使用这种思想，<strong>把每个数放到应该放到的位置。</strong></font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rotate</span><span class=\"params\">(self, nums: List[int], k: int)</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">    N = len(nums)</span><br><span class=\"line\">    k %= N</span><br><span class=\"line\"></span><br><span class=\"line\">    start = count = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> count &lt; N:</span><br><span class=\"line\">        cur, prev = start, nums[start]</span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">            cur = (cur + k) % N</span><br><span class=\"line\">            nums[cur], prev = prev, nums[cur]</span><br><span class=\"line\">            count += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> cur == start: <span class=\"keyword\">break</span></span><br><span class=\"line\">        start += <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"217-Contains-Duplicate\"><a href=\"#217-Contains-Duplicate\" class=\"headerlink\" title=\"217. Contains Duplicate\"></a>217. Contains Duplicate</h3><h4 id=\"数组中是否包含重复元素。原题\"><a href=\"#数组中是否包含重复元素。原题\" class=\"headerlink\" title=\"数组中是否包含重复元素。原题\"></a>数组中是否包含重复元素。<a href=\"https://leetcode.com/problems/contains-duplicate/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [1,2,3,1]</span><br><span class=\"line\">Output: true</span><br></pre></td></tr></table></figure>\n<p>方法一：set</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">contains_duplicate</span><span class=\"params\">(nums)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> len(set(nums)) &lt; len(nums)</span><br></pre></td></tr></table></figure>\n<p>方法二：hash</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">containsDuplicate</span><span class=\"params\">(self, nums: <span class=\"string\">'List[int]'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\">    seen = set()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> num <span class=\"keyword\">in</span> seen:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            seen.add(num)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"219-Contains-Duplicate-II\"><a href=\"#219-Contains-Duplicate-II\" class=\"headerlink\" title=\"219. Contains Duplicate II\"></a>219. Contains Duplicate II</h3><h4 id=\"数组中是否包含重复元素，且元素下标差小于等于k。原题\"><a href=\"#数组中是否包含重复元素，且元素下标差小于等于k。原题\" class=\"headerlink\" title=\"数组中是否包含重复元素，且元素下标差小于等于k。原题\"></a>数组中是否包含重复元素，且元素下标差小于等于k。<a href=\"https://leetcode.com/problems/contains-duplicate-ii/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [1,2,3,1], k &#x3D; 3</span><br><span class=\"line\">Output: true</span><br><span class=\"line\">Input: nums &#x3D; [1,0,1,1], k &#x3D; 1</span><br><span class=\"line\">Output: true</span><br></pre></td></tr></table></figure>\n<p>思路：开始想用set作切片来判断，同上题方法一，但是效率太低。故使用字典。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">containsNearbyDuplicate</span><span class=\"params\">(self, nums, k)</span>:</span></span><br><span class=\"line\">    n = len(nums)</span><br><span class=\"line\">    seen = &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, num <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> num <span class=\"keyword\">in</span> seen:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i-seen[num] &lt;= k:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        seen[num] = i</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"220-Contains-Duplicate-III\"><a href=\"#220-Contains-Duplicate-III\" class=\"headerlink\" title=\"220. Contains Duplicate III\"></a>220. Contains Duplicate III</h3><h4 id=\"是否存在索引差k范围内的绝对值不大于t的两个值。原题\"><a href=\"#是否存在索引差k范围内的绝对值不大于t的两个值。原题\" class=\"headerlink\" title=\"是否存在索引差k范围内的绝对值不大于t的两个值。原题\"></a>是否存在索引差k范围内的绝对值不大于t的两个值。<a href=\"https://leetcode.com/problems/contains-duplicate-iii/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [1,2,3,1], k &#x3D; 3, t &#x3D; 0</span><br><span class=\"line\">Output: true</span><br><span class=\"line\">Input: nums &#x3D; [1,5,9,1,5,9], k &#x3D; 2, t &#x3D; 3</span><br><span class=\"line\">Output: false</span><br></pre></td></tr></table></figure>\n<p>方法一：实际上是桶排序的原理，每个桶的size为t。两个差值为t的的数，只可能出现在同一个桶或者两边的桶中。每个桶只维护一个值就行了，因为如果有两个值，那么肯定就返回了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">containsNearbyAlmostDuplicate</span><span class=\"params\">(self, nums: List[int], k: int, t: int)</span> -&gt; bool:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> k &lt; <span class=\"number\">1</span> <span class=\"keyword\">or</span> t &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    dic = collections.OrderedDict()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        key = n <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> t <span class=\"keyword\">else</span> n // t</span><br><span class=\"line\">        <span class=\"keyword\">for</span> m <span class=\"keyword\">in</span> (dic.get(key - <span class=\"number\">1</span>), dic.get(key), dic.get(key + <span class=\"number\">1</span>)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> m <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span> <span class=\"keyword\">and</span> abs(n - m) &lt;= t:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(dic) == k:</span><br><span class=\"line\">            dic.popitem(<span class=\"literal\">False</span>)</span><br><span class=\"line\">        dic[key] = n</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"283-Move-Zeroes\"><a href=\"#283-Move-Zeroes\" class=\"headerlink\" title=\"283. Move Zeroes\"></a>283. Move Zeroes</h3><h4 id=\"将数组0元素移动到末尾，保证其他元素顺序。原题\"><a href=\"#将数组0元素移动到末尾，保证其他元素顺序。原题\" class=\"headerlink\" title=\"将数组0元素移动到末尾，保证其他元素顺序。原题\"></a>将数组0元素移动到末尾，保证其他元素顺序。<a href=\"https://leetcode.com/problems/move-zeroes/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [0,1,0,3,12]</span><br><span class=\"line\">Output: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>\n<p>方法一：two pointers</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">move_zero</span><span class=\"params\">(nums)</span>:</span></span><br><span class=\"line\">    l, r = <span class=\"number\">0</span>, len(nums)<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> l &lt; r:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[l] == <span class=\"number\">0</span>:</span><br><span class=\"line\">            nums[:] = nums[:l] + nums[l+<span class=\"number\">1</span>:] + [<span class=\"number\">0</span>]</span><br><span class=\"line\">            r -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            l += <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>方法二： slicing</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">move_zero</span><span class=\"params\">(nums)</span>:</span></span><br><span class=\"line\">    nums[:] = [x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> nums <span class=\"keyword\">if</span> x != <span class=\"number\">0</span>] + [x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> nums <span class=\"keyword\">if</span> x == <span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：最后0的位置，感觉像冒泡。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">moveZeroes</span><span class=\"params\">(self, nums: <span class=\"string\">'List[int]'</span>)</span> -&gt; '<span class=\"keyword\">None</span>':</span></span><br><span class=\"line\">    p = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, num <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> num != <span class=\"number\">0</span>:</span><br><span class=\"line\">            nums[p], nums[i] = nums[i], nums[p]</span><br><span class=\"line\">            p += <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>方法四：排序。时间复杂度略高。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">moveZeroes</span><span class=\"params\">(self, nums: <span class=\"string\">'List[int]'</span>)</span> -&gt; '<span class=\"keyword\">None</span>':</span></span><br><span class=\"line\">    nums.sort(key=<span class=\"keyword\">lambda</span> x: <span class=\"number\">1</span> <span class=\"keyword\">if</span> x==<span class=\"number\">0</span> <span class=\"keyword\">else</span> <span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"54-Spiral-Matrix\"><a href=\"#54-Spiral-Matrix\" class=\"headerlink\" title=\"54. Spiral Matrix\"></a>54. Spiral Matrix</h3><h4 id=\"螺旋矩阵，顺时针打印矩阵。原题\"><a href=\"#螺旋矩阵，顺时针打印矩阵。原题\" class=\"headerlink\" title=\"螺旋矩阵，顺时针打印矩阵。原题\"></a>螺旋矩阵，顺时针打印矩阵。<a href=\"https://leetcode.com/problems/spiral-matrix/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>这里注意一点<code>matrix.pop(0)</code>需要转成list，因为zip函数中的每个元素是一个tuple，如果不转变成了一个<code>tuple+list</code>，会抛出异常。</p>\n<p>ps: 此题解法为LeetCode一位大神，经常能看到此人的答案，不过这个是我认为最pythonic的一个，没有为了强行one-line而one-line。brilliant!</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">TypeError: can only concatenate tuple (not &quot;list&quot;) to tuple</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">spiralOrder</span><span class=\"params\">(self, matrix)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> matrix <span class=\"keyword\">and</span> list(matrix.pop(<span class=\"number\">0</span>))+self.spiralOrder(list(zip(*matrix))[::<span class=\"number\">-1</span>])</span><br></pre></td></tr></table></figure>\n<p>方法二：迭代写法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">spiralOrder</span><span class=\"params\">(self, matrix: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> matrix: <span class=\"keyword\">return</span> []</span><br><span class=\"line\">    M, N = len(matrix), len(matrix[<span class=\"number\">0</span>])</span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    seen = [[<span class=\"literal\">False</span>]*N <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(M)]</span><br><span class=\"line\">    x, y, di, dj = <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> len(ans) &lt; M*N:</span><br><span class=\"line\">        seen[x][y] = <span class=\"literal\">True</span></span><br><span class=\"line\">        ans.append(matrix[x][y])        </span><br><span class=\"line\">        nx, ny = x+di, y+dj</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> (<span class=\"number\">0</span>&lt;=nx&lt;M <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=ny&lt;N <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> seen[nx][ny]):</span><br><span class=\"line\">            di, dj = dj, -di</span><br><span class=\"line\">        x, y = x+di, y+dj</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>此题有个变形，如果逆时针该如何打印。这样的话情况稍微复杂一些。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">anti_clock_wise</span><span class=\"params\">(self, matrix)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">if</span> <span class=\"title\">not</span> <span class=\"title\">matrix</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> []</span><br><span class=\"line\">    clock_wise = list(zip(*(matrix[::<span class=\"number\">-1</span>])))</span><br><span class=\"line\">    a = list(clock_wise.pop(<span class=\"number\">0</span>))[::<span class=\"number\">-1</span>]</span><br><span class=\"line\">    b = self.anti_clock_wise(clock_wise)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b</span><br></pre></td></tr></table></figure>\n<h3 id=\"59-Spiral-Matrix-II\"><a href=\"#59-Spiral-Matrix-II\" class=\"headerlink\" title=\"59. Spiral Matrix II\"></a>59. Spiral Matrix II</h3><h4 id=\"按照顺时针的顺序生成一个矩阵。原题\"><a href=\"#按照顺时针的顺序生成一个矩阵。原题\" class=\"headerlink\" title=\"按照顺时针的顺序生成一个矩阵。原题\"></a>按照顺时针的顺序生成一个矩阵。<a href=\"https://leetcode.com/problems/spiral-matrix-ii/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: 3</span><br><span class=\"line\">Output:</span><br><span class=\"line\">[</span><br><span class=\"line\"> [ 1, 2, 3 ],</span><br><span class=\"line\"> [ 8, 9, 4 ],</span><br><span class=\"line\"> [ 7, 6, 5 ]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>方法一：自己的方法。使用了一个控制方向，如果超范围或者有值就换方向。<br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">generateMatrix</span><span class=\"params\">(self, n: int)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">    ans = [[<span class=\"number\">0</span>]*n <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">    op = itertools.cycle([(<span class=\"number\">0</span>, <span class=\"number\">1</span>), (<span class=\"number\">1</span>, <span class=\"number\">0</span>), (<span class=\"number\">0</span>, <span class=\"number\">-1</span>), (<span class=\"number\">-1</span>, <span class=\"number\">0</span>)])</span><br><span class=\"line\">    d = next(op)</span><br><span class=\"line\">    x, y = (<span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n**<span class=\"number\">2</span>+<span class=\"number\">1</span>):</span><br><span class=\"line\">        ans[x][y] = k</span><br><span class=\"line\">        i, j = x+d[<span class=\"number\">0</span>], y+d[<span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> <span class=\"number\">0</span>&lt;=i&lt;n <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> <span class=\"number\">0</span>&lt;=j&lt;n <span class=\"keyword\">or</span> ans[i][j]:</span><br><span class=\"line\">            d = next(op)</span><br><span class=\"line\">            x, y = x+d[<span class=\"number\">0</span>], y+d[<span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            x, y = i, j</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure><br>方法二：stefan的旋转法，我往这边想了，zip也想到了，没想到的是，从里往外遍历，还有一点是根据A的长度确定起始点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">||  &#x3D;&gt;  |9|  &#x3D;&gt;  |8|      |6 7|      |4 5|      |1 2 3|</span><br><span class=\"line\">                 |9|  &#x3D;&gt;  |9 8|  &#x3D;&gt;  |9 6|  &#x3D;&gt;  |8 9 4|</span><br><span class=\"line\">                                     |8 7|      |7 6 5|</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">generateMatrix</span><span class=\"params\">(self, n: int)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">    A, lo = [], n**<span class=\"number\">2</span>+<span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> lo &gt; <span class=\"number\">1</span>:</span><br><span class=\"line\">        lo, hi = lo - len(A), lo</span><br><span class=\"line\">        A = [range(lo, hi)] + list(zip(*A[::<span class=\"number\">-1</span>]))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> A</span><br></pre></td></tr></table></figure>\n<h3 id=\"885-Spiral-Matrix-III\"><a href=\"#885-Spiral-Matrix-III\" class=\"headerlink\" title=\"885. Spiral Matrix III\"></a>885. Spiral Matrix III</h3><h4 id=\"从二维数组中的某一个点开始顺时针旋转输出所有的坐标。原题\"><a href=\"#从二维数组中的某一个点开始顺时针旋转输出所有的坐标。原题\" class=\"headerlink\" title=\"从二维数组中的某一个点开始顺时针旋转输出所有的坐标。原题\"></a>从二维数组中的某一个点开始顺时针旋转输出所有的坐标。<a href=\"https://leetcode.com/problems/spiral-matrix-iii/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><font color=\"#32CD32\" size=\"3\">方法一：还是通过生成器控制方向，当处于水平位置时步数增加1。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">spiralMatrixIII</span><span class=\"params\">(self, R: int, C: int, r0: int, c0: int)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">    direction = itertools.cycle([(<span class=\"number\">0</span>, <span class=\"number\">1</span>), (<span class=\"number\">1</span>, <span class=\"number\">0</span>), (<span class=\"number\">0</span>, <span class=\"number\">-1</span>), (<span class=\"number\">-1</span>, <span class=\"number\">0</span>)])</span><br><span class=\"line\">    ans = [(r0, c0)]</span><br><span class=\"line\">    step = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> len(ans) &lt; R*C:</span><br><span class=\"line\">        di, dj = next(direction)        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> di==<span class=\"number\">0</span>:</span><br><span class=\"line\">            step += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(step):</span><br><span class=\"line\">            r0 += di</span><br><span class=\"line\">            c0 += dj</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=r0&lt;R <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=c0&lt;C:</span><br><span class=\"line\">                ans.append((r0, c0))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：Lee的方法。使用了<code>di, dj = dj, -di</code>刚好是这个右转的方向。然后用一个n来计算步数。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">spiralMatrixIII</span><span class=\"params\">(self, R: int, C: int, r0: int, c0: int)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    di, dj, step = <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> len(ans) &lt; R*C:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> range(step//<span class=\"number\">2</span>+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=r0&lt;R <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=c0&lt;C:</span><br><span class=\"line\">                ans.append((r0, c0))</span><br><span class=\"line\">            r0, c0 = r0+di, c0+dj</span><br><span class=\"line\">        di, dj, step = dj, -di, step+<span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法三：Lee的几何方法。根据到目标点的距离大小排序。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">spiralMatrixIII</span><span class=\"params\">(self, R, C, r, c)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">key</span><span class=\"params\">(<span class=\"params\">(x, y)</span>)</span>:</span></span><br><span class=\"line\">        x, y = x - r, y - c</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (max(abs(x), abs(y)), -((math.atan2(<span class=\"number\">-1</span>, <span class=\"number\">1</span>) - math.atan2(x, y)) % (math.pi * <span class=\"number\">2</span>)))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sorted([(i, j) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> xrange(R) <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> xrange(C)], key=key)</span><br></pre></td></tr></table></figure>\n<h3 id=\"53-Maximum-Subarray\"><a href=\"#53-Maximum-Subarray\" class=\"headerlink\" title=\"53. Maximum Subarray\"></a>53. Maximum Subarray</h3><h4 id=\"连续子数组的最大和。原题\"><a href=\"#连续子数组的最大和。原题\" class=\"headerlink\" title=\"连续子数组的最大和。原题\"></a>连续子数组的最大和。<a href=\"https://leetcode.com/problems/maximum-subarray/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class=\"line\">Output: 6</span><br><span class=\"line\">Explanation: [4,-1,2,1] has the largest sum &#x3D; 6.</span><br></pre></td></tr></table></figure>\n<p>方法一：书中的思想。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxSubArray</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">    cp_nums = nums[:]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(nums)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cp_nums[i<span class=\"number\">-1</span>] &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            cp_nums[i] += cp_nums[i<span class=\"number\">-1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(cp_nums)</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：one-liner。注意<code>accumulate</code>是把函数放到后面的。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxSubArray</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> itertools <span class=\"keyword\">import</span> accumulate</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(accumulate(nums, <span class=\"keyword\">lambda</span> x, y: x+y <span class=\"keyword\">if</span> x &gt; <span class=\"number\">0</span> <span class=\"keyword\">else</span> y))</span><br></pre></td></tr></table></figure>\n<h3 id=\"918-Maximum-Sum-Circular-Subarray\"><a href=\"#918-Maximum-Sum-Circular-Subarray\" class=\"headerlink\" title=\"918. Maximum Sum Circular Subarray\"></a>918. Maximum Sum Circular Subarray</h3><h4 id=\"连续数组的最大和，数组可以首位相连，但是最大长度不能超过一个数组。原题\"><a href=\"#连续数组的最大和，数组可以首位相连，但是最大长度不能超过一个数组。原题\" class=\"headerlink\" title=\"连续数组的最大和，数组可以首位相连，但是最大长度不能超过一个数组。原题\"></a>连续数组的最大和，数组可以首位相连，但是最大长度不能超过一个数组。<a href=\"https://leetcode.com/problems/maximum-sum-circular-subarray/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [1,-2,3,-2]</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: Subarray [3] has maximum sum 3</span><br></pre></td></tr></table></figure>\n<p>方法一：by @Lee215。看完这个解法豁然开朗，只需要同时找到一个累加和最小的子数组，再用总数减掉。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxSubarraySumCircular</span><span class=\"params\">(self, A: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    total = cur_max = cur_min = <span class=\"number\">0</span></span><br><span class=\"line\">    sum_max, sum_min = float(<span class=\"string\">'-inf'</span>), float(<span class=\"string\">'inf'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> A:</span><br><span class=\"line\">        cur_max = max(cur_max+a, a)</span><br><span class=\"line\">        sum_max = max(sum_max, cur_max)</span><br><span class=\"line\">        cur_min = min(cur_min+a, a)</span><br><span class=\"line\">        sum_min = min(sum_min, cur_min)</span><br><span class=\"line\">        total += a</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(sum_max, total-sum_min) <span class=\"keyword\">if</span> sum_max &gt; <span class=\"number\">0</span> <span class=\"keyword\">else</span> sum_max</span><br></pre></td></tr></table></figure>\n<h3 id=\"904-Fruit-Into-Baskets\"><a href=\"#904-Fruit-Into-Baskets\" class=\"headerlink\" title=\"904. Fruit Into Baskets\"></a>904. Fruit Into Baskets</h3><h4 id=\"实际上该题抽象为求最大滑动窗口的长度，滑动窗口不同元素最多不超过两个。原题\"><a href=\"#实际上该题抽象为求最大滑动窗口的长度，滑动窗口不同元素最多不超过两个。原题\" class=\"headerlink\" title=\"实际上该题抽象为求最大滑动窗口的长度，滑动窗口不同元素最多不超过两个。原题\"></a>实际上该题抽象为求最大滑动窗口的长度，滑动窗口不同元素最多不超过两个。<a href=\"https://leetcode.com/problems/fruit-into-baskets/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">tree &#x3D; [3,3,3,1,2,1,1,2,3,3,4]   # 5</span><br><span class=\"line\">tree &#x3D; [1,0,1,4,1,4,1,2,3]  # 5</span><br><span class=\"line\">tree &#x3D; [1,2,3,2,2]  # 4</span><br><span class=\"line\">tree &#x3D; [0,1,6,6,4,4,6]  # 5</span><br></pre></td></tr></table></figure>\n<p>一开始没有找到滑动窗口的左边界，老是想直接删除一个key，后来看别人代码受到启发，可以用一个内循环来解决，可以逐个删除，然后判断是否为空。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">totalFruit</span><span class=\"params\">(self, tree)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Counter</span><br><span class=\"line\">    basket = Counter()</span><br><span class=\"line\">    l, res = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> r <span class=\"keyword\">in</span> range(len(tree)):</span><br><span class=\"line\">        basket[tree[r]] += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> len(basket) &gt; <span class=\"number\">2</span>:</span><br><span class=\"line\">            basket[tree[l]] -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> basket[tree[l]] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                basket.pop(tree[l])</span><br><span class=\"line\">            l += <span class=\"number\">1</span></span><br><span class=\"line\">        res = max(res, r-l+<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"27-Remove-Element\"><a href=\"#27-Remove-Element\" class=\"headerlink\" title=\"27. Remove Element\"></a>27. Remove Element</h3><h4 id=\"从数组中删除元素，在原数组修改，要求返回一个长度。原题\"><a href=\"#从数组中删除元素，在原数组修改，要求返回一个长度。原题\" class=\"headerlink\" title=\"从数组中删除元素，在原数组修改，要求返回一个长度。原题\"></a>从数组中删除元素，在原数组修改，要求返回一个长度。<a href=\"https://leetcode.com/problems/remove-element/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Given nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2,</span><br><span class=\"line\">Your function should return length &#x3D; 5,</span><br></pre></td></tr></table></figure>\n<p>方法一：前后指针，r要从<code>n</code>开始，以<code>n-1</code>作比较，这里r不是从<code>n-1</code>开始是因为<code>nums=[]</code>的情况，否则<code>l+1</code>将超出数组范围。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removeElement</span><span class=\"params\">(self, nums, val)</span>:</span></span><br><span class=\"line\">    l, r = <span class=\"number\">0</span>, len(nums)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> l &lt; r:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[l] == val:</span><br><span class=\"line\">            nums[l], nums[r<span class=\"number\">-1</span>] = nums[r<span class=\"number\">-1</span>], nums[l]</span><br><span class=\"line\">            r -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            l += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> l</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：快慢指针，几乎和283题中的方法一样。 </font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removeElement</span><span class=\"params\">(self, nums, val)</span>:</span></span><br><span class=\"line\">    i = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(nums)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[j] != val:</span><br><span class=\"line\">            nums[i] = nums[j]</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> i</span><br></pre></td></tr></table></figure>\n<h3 id=\"349-Intersection-of-Two-Arrays\"><a href=\"#349-Intersection-of-Two-Arrays\" class=\"headerlink\" title=\"349. Intersection of Two Arrays\"></a>349. Intersection of Two Arrays</h3><h4 id=\"求两个数组的交集。返回的数组必须元素唯一，可以无序。原题\"><a href=\"#求两个数组的交集。返回的数组必须元素唯一，可以无序。原题\" class=\"headerlink\" title=\"求两个数组的交集。返回的数组必须元素唯一，可以无序。原题\"></a>求两个数组的交集。返回的数组必须元素唯一，可以无序。<a href=\"https://leetcode.com/problems/intersection-of-two-arrays/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>思路：一开始看到这题以为是两个链表求相交点。最后发现<code>Intersection</code>不应该理解为“十字路口”而应该是“交集”。这里翻了一下<code>discuss</code>，大部分都是使用方法一，其它方法要么太繁琐，要么效率低。值得注意的是，此题的相关话题还有一项是<code>Binary Search</code>也就是说，可能会有一个较为高效的二分搜索法的实现方式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Example 2:</span><br><span class=\"line\">Input: nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]</span><br><span class=\"line\">Output: [9,4]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\"><strong>方法一：最快的方法。</strong></font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">intersection</span><span class=\"params\">(self, nums1, nums2)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> list(set(nums1) &amp; set(nums2))</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：Sort &amp; Two Pointers.</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">intersection</span><span class=\"params\">(self, nums1: <span class=\"string\">'List[int]'</span>, nums2: <span class=\"string\">'List[int]'</span>)</span> -&gt; 'List[int]':</span></span><br><span class=\"line\">    nums1.sort()</span><br><span class=\"line\">    nums2.sort()</span><br><span class=\"line\">    i, n1 = <span class=\"number\">0</span>, len(nums1)</span><br><span class=\"line\">    j, n2 = <span class=\"number\">0</span>, len(nums2)</span><br><span class=\"line\">    ans, last = [], <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> i &lt; n1 <span class=\"keyword\">and</span> j &lt; n2:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums1[i] == nums2[j]:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums1[i] != last:</span><br><span class=\"line\">                ans.append(nums1[i])</span><br><span class=\"line\">                last = nums1[i]</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">            j += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> nums1[i] &gt; nums2[j]:</span><br><span class=\"line\">            j += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> nums1[i] &lt; nums2[j]:</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"350-Intersection-of-Two-Arrays-II\"><a href=\"#350-Intersection-of-Two-Arrays-II\" class=\"headerlink\" title=\"350. Intersection of Two Arrays II\"></a>350. Intersection of Two Arrays II</h3><h4 id=\"和上题不同的是要返回所有的交集元素。原题\"><a href=\"#和上题不同的是要返回所有的交集元素。原题\" class=\"headerlink\" title=\"和上题不同的是要返回所有的交集元素。原题\"></a>和上题不同的是要返回所有的交集元素。<a href=\"https://leetcode.com/problems/intersection-of-two-arrays-ii/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Example 1:</span><br><span class=\"line\"></span><br><span class=\"line\">Input: nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]</span><br><span class=\"line\">Output: [2,2]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\"><strong>方法一：Counter实现了&amp;操作可以直接取交集。</strong></font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">intersect</span><span class=\"params\">(self, nums1, nums2)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Counter</span><br><span class=\"line\">    a, b = map(Counter, (nums1, nums2))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list((a &amp; b).elements())</span><br></pre></td></tr></table></figure>\n<p>方法二：不使用<code>Counter</code>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">intersect</span><span class=\"params\">(self, nums1, nums2)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> defaultdict</span><br><span class=\"line\">    counter = defaultdict(int)</span><br><span class=\"line\">    res = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> num1 <span class=\"keyword\">in</span> nums1:</span><br><span class=\"line\">        counter[num1] += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> num2 <span class=\"keyword\">in</span> nums2:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> counter[num2] != <span class=\"number\">0</span>:</span><br><span class=\"line\">            res.append(num2)</span><br><span class=\"line\">            counter[num2] -= <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：可以采用上题349的方法，只需要去掉<code>last</code>即可。</font>\n\n<h3 id=\"905-Sort-Array-By-Parity\"><a href=\"#905-Sort-Array-By-Parity\" class=\"headerlink\" title=\"905. Sort Array By Parity\"></a>905. Sort Array By Parity</h3><h4 id=\"将一个数组重新排列，是偶数在前奇数在后。原题\"><a href=\"#将一个数组重新排列，是偶数在前奇数在后。原题\" class=\"headerlink\" title=\"将一个数组重新排列，是偶数在前奇数在后。原题\"></a>将一个数组重新排列，是偶数在前奇数在后。<a href=\"https://leetcode.com/problems/sort-array-by-parity/description/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [3,1,2,4]</span><br><span class=\"line\">Output: [2,4,3,1]</span><br><span class=\"line\">The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\"><strong>方法一：双指针。</strong></font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sortArrayByParity</span><span class=\"params\">(self, A)</span>:</span></span><br><span class=\"line\">    l, r = <span class=\"number\">0</span>, len(A)<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> l &lt; r:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> l&lt;r <span class=\"keyword\">and</span> A[l]&amp;<span class=\"number\">1</span>==<span class=\"number\">0</span>:</span><br><span class=\"line\">            l += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> l&lt;r <span class=\"keyword\">and</span> A[r]&amp;<span class=\"number\">1</span>==<span class=\"number\">1</span>:</span><br><span class=\"line\">            r -= <span class=\"number\">1</span></span><br><span class=\"line\">        A[l], A[r] = A[r], A[l]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> A</span><br></pre></td></tr></table></figure>\n<p>方法二：列表生成式。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sortArrayByParity</span><span class=\"params\">(self, A)</span>:</span></span><br><span class=\"line\">    even = [num <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> A <span class=\"keyword\">if</span> num &amp; <span class=\"number\">1</span> == <span class=\"number\">0</span>]</span><br><span class=\"line\">    odd = [num <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> A <span class=\"keyword\">if</span> num &amp; <span class=\"number\">1</span> == <span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> even + odd</span><br></pre></td></tr></table></figure>\n<h3 id=\"922-Sort-Array-By-Parity-II\"><a href=\"#922-Sort-Array-By-Parity-II\" class=\"headerlink\" title=\"922. Sort Array By Parity II\"></a>922. Sort Array By Parity II</h3><h4 id=\"输入一个奇数偶数数量相同的数组，返回下标和其对应的值都是奇数或偶数，即奇偶交叉。和905相似。原题\"><a href=\"#输入一个奇数偶数数量相同的数组，返回下标和其对应的值都是奇数或偶数，即奇偶交叉。和905相似。原题\" class=\"headerlink\" title=\"输入一个奇数偶数数量相同的数组，返回下标和其对应的值都是奇数或偶数，即奇偶交叉。和905相似。原题\"></a>输入一个奇数偶数数量相同的数组，返回下标和其对应的值都是奇数或偶数，即奇偶交叉。和905相似。<a href=\"https://leetcode.com/contest/weekly-contest-106/problems/sort-array-by-parity-ii/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><font color=\"#32CD32\" size=\"3\"><strong>方法一：使用切片的特性赋值。</strong></font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sortArrayByParityII</span><span class=\"params\">(self, A)</span>:</span></span><br><span class=\"line\">    res = [<span class=\"literal\">None</span>] * len(A)</span><br><span class=\"line\">    res[::<span class=\"number\">2</span>] = (num <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> A <span class=\"keyword\">if</span> num &amp; <span class=\"number\">1</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">    res[<span class=\"number\">1</span>::<span class=\"number\">2</span>] = (num <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> A <span class=\"keyword\">if</span> num &amp; <span class=\"number\">1</span> == <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：双指针。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sortArrayByParityII</span><span class=\"params\">(self, A: <span class=\"string\">'List[int]'</span>)</span> -&gt; 'List[int]':</span></span><br><span class=\"line\">    j = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(A), <span class=\"number\">2</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> A[i] &amp; <span class=\"number\">1</span> == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">while</span> A[j] &amp; <span class=\"number\">1</span> == <span class=\"number\">1</span>:</span><br><span class=\"line\">                j += <span class=\"number\">2</span></span><br><span class=\"line\">            A[i], A[j] = A[j], A[i]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> A</span><br></pre></td></tr></table></figure>\n<h3 id=\"933-Number-of-Recent-Calls\"><a href=\"#933-Number-of-Recent-Calls\" class=\"headerlink\" title=\"933. Number of Recent Calls\"></a>933. Number of Recent Calls</h3><h4 id=\"输入一个时间t，返回3000毫秒内所有的请求个数。原题\"><a href=\"#输入一个时间t，返回3000毫秒内所有的请求个数。原题\" class=\"headerlink\" title=\"输入一个时间t，返回3000毫秒内所有的请求个数。原题\"></a>输入一个时间t，返回3000毫秒内所有的请求个数。<a href=\"https://leetcode.com/problems/number-of-recent-calls/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：deque.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RecentCounter</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.q = collections.deque()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">ping</span><span class=\"params\">(self, t: <span class=\"string\">'int'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">        self.q.append(t)</span><br><span class=\"line\">        <span class=\"keyword\">while</span> self.q[<span class=\"number\">0</span>] &lt; t - <span class=\"number\">3000</span>:</span><br><span class=\"line\">            self.q.popleft()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> len(self.q)</span><br></pre></td></tr></table></figure>\n<h3 id=\"937-Reorder-Log-Files\"><a href=\"#937-Reorder-Log-Files\" class=\"headerlink\" title=\"937. Reorder Log Files\"></a>937. Reorder Log Files</h3><h4 id=\"按照规则将log文件排序。原题\"><a href=\"#按照规则将log文件排序。原题\" class=\"headerlink\" title=\"按照规则将log文件排序。原题\"></a>按照规则将log文件排序。<a href=\"https://leetcode.com/problems/reorder-log-files/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [&quot;a1 9 2 3 1&quot;,&quot;g1 act car&quot;,&quot;zo4 4 7&quot;,&quot;ab1 off key dog&quot;,&quot;a8 act zoo&quot;]</span><br><span class=\"line\">Output: [&quot;g1 act car&quot;,&quot;a8 act zoo&quot;,&quot;ab1 off key dog&quot;,&quot;a1 9 2 3 1&quot;,&quot;zo4 4 7&quot;]</span><br></pre></td></tr></table></figure>\n<p>方法一：列表生成式。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reorderLogFiles</span><span class=\"params\">(self, logs)</span>:</span></span><br><span class=\"line\">    letter_logs = [l <span class=\"keyword\">for</span> l <span class=\"keyword\">in</span> logs <span class=\"keyword\">if</span> l.split()[<span class=\"number\">1</span>].isalpha()]</span><br><span class=\"line\">    digit_logs = [l <span class=\"keyword\">for</span> l <span class=\"keyword\">in</span> logs <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> l.split()[<span class=\"number\">1</span>].isalpha()]</span><br><span class=\"line\">    letter_logs.sort(key=<span class=\"keyword\">lambda</span> x: x.split()[<span class=\"number\">1</span>:])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> letter_logs + digit_logs</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：sort. </font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reorderLogFiles</span><span class=\"params\">(self, logs: <span class=\"string\">'List[str]'</span>)</span> -&gt; 'List[str]':</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(log)</span>:</span></span><br><span class=\"line\">        pk, text = log.split(<span class=\"string\">\" \"</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"number\">0</span>, text) <span class=\"keyword\">if</span> text[<span class=\"number\">0</span>].isalpha() <span class=\"keyword\">else</span> (<span class=\"number\">1</span>, )</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sorted(logs, key=f)</span><br></pre></td></tr></table></figure>\n<h3 id=\"485-Max-Consecutive-Ones\"><a href=\"#485-Max-Consecutive-Ones\" class=\"headerlink\" title=\"485. Max Consecutive Ones\"></a>485. Max Consecutive Ones</h3><h4 id=\"输入一个二进制数组，返回最大的连续1的长度。原题\"><a href=\"#输入一个二进制数组，返回最大的连续1的长度。原题\" class=\"headerlink\" title=\"输入一个二进制数组，返回最大的连续1的长度。原题\"></a>输入一个二进制数组，返回最大的连续1的长度。<a href=\"https://leetcode.com/problems/max-consecutive-ones/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [1,1,0,1,1,1]</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: The first two digits or the last three digits are consecutive 1s.</span><br><span class=\"line\">    The maximum number of consecutive 1s is 3.</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法一：不使用标准库。末尾补0是因为，如果原数组末尾是1的情况下，还需要计算一次max的值。缺点是改变了原数组。也可以使用再计算一次的方式。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findMaxConsecutiveOnes</span><span class=\"params\">(self, nums: <span class=\"string\">'List[int]'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    ans = count = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums+[<span class=\"number\">0</span>]:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> num == <span class=\"number\">1</span>:</span><br><span class=\"line\">            count += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            ans = max(ans, count)</span><br><span class=\"line\">            count = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法二：使用groupby。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findMaxConsecutiveOnes</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> itertools <span class=\"keyword\">import</span> groupby</span><br><span class=\"line\">    max_con = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> d, group <span class=\"keyword\">in</span> groupby(nums):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> d == <span class=\"number\">1</span>:</span><br><span class=\"line\">            max_con = max(max_con, len(list(group)))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max_con</span><br></pre></td></tr></table></figure>\n<p>方法三：split。不过这个效率不高。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findMaxConsecutiveOnes</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">    nums_str = <span class=\"string\">''</span>.join(map(str, nums))</span><br><span class=\"line\">    ones = nums_str.split(<span class=\"string\">'0'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> len(max(ones))</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法四：使用accumulate。Space-complex O(n)。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findMaxConsecutiveOnes</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> itertools <span class=\"keyword\">import</span> accumulate</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(accumulate(nums, <span class=\"keyword\">lambda</span> x, y: x+y <span class=\"keyword\">if</span> y==<span class=\"number\">1</span> <span class=\"keyword\">else</span> y))</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法五：二进制的方法，将一个数不断左移并按位与，直到它为0，次数就是连续的1的个数。不过由于给的是数组不是数字，所以总体比方法四慢一丢丢。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findMaxConsecutiveOnes</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    ans, b = <span class=\"number\">0</span>, int(<span class=\"string\">''</span>.join(map(str, nums)), <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> b:</span><br><span class=\"line\">        b = b &amp; (b&lt;&lt;<span class=\"number\">1</span>)</span><br><span class=\"line\">        ans += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"1004-Max-Consecutive-Ones-III\"><a href=\"#1004-Max-Consecutive-Ones-III\" class=\"headerlink\" title=\"1004. Max Consecutive Ones III\"></a>1004. Max Consecutive Ones III</h3><h4 id=\"与上题不同的是，有K次机会可以将0变成1-原题\"><a href=\"#与上题不同的是，有K次机会可以将0变成1-原题\" class=\"headerlink\" title=\"与上题不同的是，有K次机会可以将0变成1. 原题\"></a>与上题不同的是，有K次机会可以将0变成1. <a href=\"https://leetcode.com/problems/max-consecutive-ones-iii/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: A &#x3D; [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K &#x3D; 3</span><br><span class=\"line\">Output: 10</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]</span><br><span class=\"line\">Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.</span><br></pre></td></tr></table></figure>\n<p>方法一：这题竞赛时没想出来，受上题影响，思路跑到了<code>groupby</code>那里，想着怎么分组后操作。实际上此题完全不同，应该使用滑动窗口。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestOnes</span><span class=\"params\">(self, A: List[int], K: int)</span> -&gt; int:</span></span><br><span class=\"line\">    ans = i = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(A)):</span><br><span class=\"line\">        K -= A[j]==<span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> K &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            K += A[i]==<span class=\"number\">0</span></span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">        ans = max(ans, j-i+<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"496-Next-Greater-Element-I\"><a href=\"#496-Next-Greater-Element-I\" class=\"headerlink\" title=\"496. Next Greater Element I\"></a>496. Next Greater Element I</h3><h4 id=\"找出数组nums2中对应的nums1元素的位置之后的第一个比nums1大的元素。nums1是nums2的子集，二者均无重复的元素。原题\"><a href=\"#找出数组nums2中对应的nums1元素的位置之后的第一个比nums1大的元素。nums1是nums2的子集，二者均无重复的元素。原题\" class=\"headerlink\" title=\"找出数组nums2中对应的nums1元素的位置之后的第一个比nums1大的元素。nums1是nums2的子集，二者均无重复的元素。原题\"></a>找出数组nums2中对应的nums1元素的位置之后的第一个比nums1大的元素。nums1是nums2的子集，二者均无重复的元素。<a href=\"https://leetcode.com/problems/next-greater-element-i/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums1 &#x3D; [4,1,2], nums2 &#x3D; [1,3,4,2].</span><br><span class=\"line\">Output: [-1,3,-1]</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">    For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.</span><br><span class=\"line\">    For number 1 in the first array, the next greater number for it in the second array is 3.</span><br><span class=\"line\">    For number 2 in the first array, there is no next greater number for it in the second array, so output -1.</span><br><span class=\"line\">    </span><br><span class=\"line\">Input: nums1 &#x3D; [2,4], nums2 &#x3D; [1,2,3,4].</span><br><span class=\"line\">Output: [3,-1]</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">    For number 2 in the first array, the next greater number for it in the second array is 3.</span><br><span class=\"line\">    For number 4 in the first array, there is no next greater number for it in the second array, so output -1.</span><br></pre></td></tr></table></figure>\n<p>方法一：暴力法，因为题中给了范围数组长度小于1000，所以也没有超时。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">nextGreaterElement</span><span class=\"params\">(self, nums1, nums2)</span>:</span></span><br><span class=\"line\">    res = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> num1 <span class=\"keyword\">in</span> nums1:</span><br><span class=\"line\">        index = nums2.index(num1)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> nums2[index+<span class=\"number\">1</span>:]:</span><br><span class=\"line\">            res.append(<span class=\"number\">-1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> num2 <span class=\"keyword\">in</span> nums2[index+<span class=\"number\">1</span>:]:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> num2 &gt; num1:</span><br><span class=\"line\">                    res.append(num2)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                res.append(<span class=\"number\">-1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<p>方法二：one-liner，生成器一开始想到了，没想到next函数还可以设默认值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">nextGreaterElement</span><span class=\"params\">(self, nums1, nums2)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [next((y <span class=\"keyword\">for</span> y <span class=\"keyword\">in</span> nums2[nums2.index(x):] <span class=\"keyword\">if</span> y &gt; x), <span class=\"number\">-1</span>) </span><br><span class=\"line\">            <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> nums1]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：Time: O(n). </font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">nextGreaterElement</span><span class=\"params\">(self, nums1, nums2)</span>:</span></span><br><span class=\"line\">    st, d = [], &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> nums2:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> st <span class=\"keyword\">and</span> st[<span class=\"number\">-1</span>] &lt; n:</span><br><span class=\"line\">            d[st.pop()] = n</span><br><span class=\"line\">        st.append(n)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list(map(<span class=\"keyword\">lambda</span> x: d.get(x, <span class=\"number\">-1</span>), nums1))</span><br></pre></td></tr></table></figure>\n<h3 id=\"953-Verifying-an-Alien-Dictionary\"><a href=\"#953-Verifying-an-Alien-Dictionary\" class=\"headerlink\" title=\"953. Verifying an Alien Dictionary\"></a>953. Verifying an Alien Dictionary</h3><h4 id=\"判断一个字符串数组是否按照特定的字典顺序排序。原题\"><a href=\"#判断一个字符串数组是否按照特定的字典顺序排序。原题\" class=\"headerlink\" title=\"判断一个字符串数组是否按照特定的字典顺序排序。原题\"></a>判断一个字符串数组是否按照特定的字典顺序排序。<a href=\"https://leetcode.com/contest/weekly-contest-114/problems/verifying-an-alien-dictionary/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: words &#x3D; [&quot;hello&quot;,&quot;leetcode&quot;], order &#x3D; &quot;hlabcdefgijkmnopqrstuvwxyz&quot;</span><br><span class=\"line\">Output: true</span><br><span class=\"line\">Explanation: As &#39;h&#39; comes before &#39;l&#39; in this language, then the sequence is sorted.</span><br><span class=\"line\">Input: words &#x3D; [&quot;word&quot;,&quot;world&quot;,&quot;row&quot;], order &#x3D; &quot;worldabcefghijkmnpqstuvxyz&quot;</span><br><span class=\"line\">Output: false</span><br><span class=\"line\">Explanation: As &#39;d&#39; comes after &#39;l&#39; in this language, then words[0] &gt; words[1], hence the sequence is unsorted.</span><br><span class=\"line\">Input: words &#x3D; [&quot;apple&quot;,&quot;app&quot;], order &#x3D; &quot;abcdefghijklmnopqrstuvwxyz&quot;</span><br><span class=\"line\">Output: false</span><br><span class=\"line\">Explanation: The first three characters &quot;app&quot; match, and the second string is shorter (in size.) According to lexicographical rules &quot;apple&quot; &gt; &quot;app&quot;, because &#39;l&#39; &gt; &#39;∅&#39;, where &#39;∅&#39; is defined as the blank character which is less than any other character (More info).</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法一：这道题想了很久，最后还是没有做出来，一开始想用zip来自己实现，也想到了sort，但是key里面的匿名函数一直没有想对，关键是二维数组也能排序这点没有想到。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isAlienSorted</span><span class=\"params\">(self, words: <span class=\"string\">'List[str]'</span>, order: <span class=\"string\">'str'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\">    d = dict(zip(order, range(<span class=\"number\">26</span>)))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> words == sorted(words, key=<span class=\"keyword\">lambda</span> w: [d[c] <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> w])</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：传统方法，优点在于提前退出。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isAlienSorted</span><span class=\"params\">(self, words: <span class=\"string\">'List[str]'</span>, order: <span class=\"string\">'str'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\">    d = dict(zip(order, range(<span class=\"number\">26</span>)))</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(words)<span class=\"number\">-1</span>):</span><br><span class=\"line\">        word1, word2 = words[i:i+<span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> c1, c2 <span class=\"keyword\">in</span> zip(word1, word2):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> c1 != c2:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> d[c1] &gt; d[c2]:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(word1) &gt; len(word2):</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"506-Relative-Ranks\"><a href=\"#506-Relative-Ranks\" class=\"headerlink\" title=\"506. Relative Ranks\"></a>506. Relative Ranks</h3><h4 id=\"根据得分，返回排名。前三要用奖牌表示。原题\"><a href=\"#根据得分，返回排名。前三要用奖牌表示。原题\" class=\"headerlink\" title=\"根据得分，返回排名。前三要用奖牌表示。原题\"></a>根据得分，返回排名。前三要用奖牌表示。<a href=\"https://leetcode.com/problems/relative-ranks/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [5, 4, 3, 2, 1]</span><br><span class=\"line\">Output: [&quot;Gold Medal&quot;, &quot;Silver Medal&quot;, &quot;Bronze Medal&quot;, &quot;4&quot;, &quot;5&quot;]</span><br><span class=\"line\">Explanation: The first three athletes got the top three highest scores, so they got &quot;Gold Medal&quot;, &quot;Silver Medal&quot; and &quot;Bronze Medal&quot;. </span><br><span class=\"line\">For the left two athletes, you just need to output their relative ranks according to their scores.</span><br></pre></td></tr></table></figure>\n<p>方法一：先生成一个排行榜单，再根据每个得分把排序映射上去。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findRelativeRanks</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">    ranks = list(map(str,range(<span class=\"number\">1</span>, len(nums)+<span class=\"number\">1</span>)))</span><br><span class=\"line\">    ranks[:<span class=\"number\">3</span>] = [<span class=\"string\">\"Gold Medal\"</span>, <span class=\"string\">\"Silver Medal\"</span>, <span class=\"string\">\"Bronze Medal\"</span>]</span><br><span class=\"line\">    sorted_nums = sorted(nums, reverse=<span class=\"literal\">True</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [ranks[sorted_nums.index(num)] <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums]  <span class=\"comment\"># slow</span></span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：使用map映射。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findRelativeRanks</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">    ranks = list(map(str,range(<span class=\"number\">1</span>, len(nums)+<span class=\"number\">1</span>)))</span><br><span class=\"line\">    ranks[:<span class=\"number\">3</span>] = [<span class=\"string\">\"Gold Medal\"</span>, <span class=\"string\">\"Silver Medal\"</span>, <span class=\"string\">\"Bronze Medal\"</span>]</span><br><span class=\"line\">    sorted_nums = sorted(nums, reverse=<span class=\"literal\">True</span>)</span><br><span class=\"line\">    <span class=\"comment\"># map_rank = &#123;num: ranks[i] for i, num in enumerate(sorted_nums)&#125;</span></span><br><span class=\"line\">    <span class=\"comment\"># return list(map(map_rank.get, nums))</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> list(map(dict(zip(sorted_nums, ranks)).get, nums))</span><br></pre></td></tr></table></figure>\n<h3 id=\"532-K-diff-Pairs-in-an-Array\"><a href=\"#532-K-diff-Pairs-in-an-Array\" class=\"headerlink\" title=\"532. K-diff Pairs in an Array\"></a>532. K-diff Pairs in an Array</h3><h4 id=\"找出差为k的不重复的成对元素的个数。原题\"><a href=\"#找出差为k的不重复的成对元素的个数。原题\" class=\"headerlink\" title=\"找出差为k的不重复的成对元素的个数。原题\"></a>找出差为k的不重复的成对元素的个数。<a href=\"https://leetcode.com/problems/k-diff-pairs-in-an-array/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [3, 1, 4, 1, 5], k &#x3D; 2</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).</span><br><span class=\"line\">Although we have two 1s in the input, we should only return the number of unique pairs.</span><br></pre></td></tr></table></figure>\n<p>方法一：Counter，一开始没想到，想sort或是set，然后实现不了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findPairs</span><span class=\"params\">(self, nums, k)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Counter</span><br><span class=\"line\">    c = Counter(nums)</span><br><span class=\"line\">    res = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> num, count <span class=\"keyword\">in</span> c.items():</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == <span class=\"number\">0</span> <span class=\"keyword\">and</span> count &gt; <span class=\"number\">1</span>) <span class=\"keyword\">or</span> (k &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> num+k <span class=\"keyword\">in</span> c):</span><br><span class=\"line\">            res += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"961-N-Repeated-Element-in-Size-2N-Array\"><a href=\"#961-N-Repeated-Element-in-Size-2N-Array\" class=\"headerlink\" title=\"961. N-Repeated Element in Size 2N Array\"></a>961. N-Repeated Element in Size 2N Array</h3><h4 id=\"找出2N长的数组中重复N次的数字，其它数字均只出现一次。此题不能用波义尔摩尔投票因为数量没有大于半数。原题\"><a href=\"#找出2N长的数组中重复N次的数字，其它数字均只出现一次。此题不能用波义尔摩尔投票因为数量没有大于半数。原题\" class=\"headerlink\" title=\"找出2N长的数组中重复N次的数字，其它数字均只出现一次。此题不能用波义尔摩尔投票因为数量没有大于半数。原题\"></a>找出2N长的数组中重复N次的数字，其它数字均只出现一次。此题不能用波义尔摩尔投票因为数量没有大于半数。<a href=\"https://leetcode.com/problems/n-repeated-element-in-size-2n-array/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [2,1,2,5,3,2]</span><br><span class=\"line\">Output: 2</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法一：这题本意我看是哈希表，所以大部分答案都是Counter之类的，我看排行榜签名的Python选手也是这么用的，我是灵机一动一动动想出了一个数学方法。看上去迭代了两次数组，并使用了一些空间，但其实速度很快。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">repeatedNTimes</span><span class=\"params\">(self, A)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (sum(A)-sum(set(A))) // (len(A)//<span class=\"number\">2</span><span class=\"number\">-1</span>)</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：其实是找重复的数字，那么就数量是一定的话，其他数字的相邻两位中可能会有重复，其他一种不重复情况，<code>2234</code>和<code>2342</code>。此方法不能用于169题，因为169题中的其它元素是可能重复的。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">repeatedNTimes</span><span class=\"params\">(self, A: <span class=\"string\">'List[int]'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>, len(A)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> A[i] == A[i<span class=\"number\">-1</span>] <span class=\"keyword\">or</span> A[i] == A[i<span class=\"number\">-2</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> A[i]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> A[<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"967-Numbers-With-Same-Consecutive-Differences\"><a href=\"#967-Numbers-With-Same-Consecutive-Differences\" class=\"headerlink\" title=\"967. Numbers With Same Consecutive Differences\"></a>967. Numbers With Same Consecutive Differences</h3><h4 id=\"根据规则生成一组数组，数字长度为N，每两位的差为K。原题\"><a href=\"#根据规则生成一组数组，数字长度为N，每两位的差为K。原题\" class=\"headerlink\" title=\"根据规则生成一组数组，数字长度为N，每两位的差为K。原题\"></a>根据规则生成一组数组，数字长度为N，每两位的差为K。<a href=\"https://leetcode.com/problems/numbers-with-same-consecutive-differences/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：迭代生成，其实此题本是一道动态规划题，但由于解法不是，暂时归到数组里。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numsSameConsecDiff</span><span class=\"params\">(self, N, K)</span>:</span></span><br><span class=\"line\">    ans = &#123;x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">10</span>)&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(N<span class=\"number\">-1</span>):</span><br><span class=\"line\">        ans2 = set()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> digit <span class=\"keyword\">in</span> ans:</span><br><span class=\"line\">            d = digit % <span class=\"number\">10</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> d - K &gt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">                ans2.add(digit*<span class=\"number\">10</span> + d - K)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> d + K &lt;= <span class=\"number\">9</span>:</span><br><span class=\"line\">                ans2.add(digit*<span class=\"number\">10</span> + d + K)</span><br><span class=\"line\">        ans = ans2</span><br><span class=\"line\">    <span class=\"keyword\">if</span> N == <span class=\"number\">1</span>:</span><br><span class=\"line\">        ans.add(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list(ans)</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：简化。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numsSameConsecDiff</span><span class=\"params\">(self, N, K)</span>:</span></span><br><span class=\"line\">    ans = range(<span class=\"number\">10</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(N<span class=\"number\">-1</span>):</span><br><span class=\"line\">        ans = &#123;x*<span class=\"number\">10</span>+y <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> ans <span class=\"keyword\">for</span> y <span class=\"keyword\">in</span> (x%<span class=\"number\">10</span>-K, x%<span class=\"number\">10</span>+K) </span><br><span class=\"line\">               <span class=\"keyword\">if</span> x <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=y&lt;<span class=\"number\">10</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list(ans)</span><br></pre></td></tr></table></figure>\n<h3 id=\"561-Array-Partition-I\"><a href=\"#561-Array-Partition-I\" class=\"headerlink\" title=\"561. Array Partition I\"></a>561. Array Partition I</h3><h4 id=\"将数组两两分成一组，累加每组的最小值，使之尽量大。原题\"><a href=\"#将数组两两分成一组，累加每组的最小值，使之尽量大。原题\" class=\"headerlink\" title=\"将数组两两分成一组，累加每组的最小值，使之尽量大。原题\"></a>将数组两两分成一组，累加每组的最小值，使之尽量大。<a href=\"https://leetcode.com/problems/array-partition-i/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [1,4,3,2]</span><br><span class=\"line\"></span><br><span class=\"line\">Output: 4</span><br><span class=\"line\">Explanation: n is 2, and the maximum sum of pairs is 4 &#x3D; min(1, 2) + min(3, 4).</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">arrayPairSum</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(sorted(nums)[::<span class=\"number\">2</span>])</span><br></pre></td></tr></table></figure>\n<h3 id=\"566-Reshape-the-Matrix\"><a href=\"#566-Reshape-the-Matrix\" class=\"headerlink\" title=\"566. Reshape the Matrix\"></a>566. Reshape the Matrix</h3><h4 id=\"改变矩阵的形状，如果元素超出或不足，返回原矩阵。原题\"><a href=\"#改变矩阵的形状，如果元素超出或不足，返回原矩阵。原题\" class=\"headerlink\" title=\"改变矩阵的形状，如果元素超出或不足，返回原矩阵。原题\"></a>改变矩阵的形状，如果元素超出或不足，返回原矩阵。<a href=\"https://leetcode.com/problems/reshape-the-matrix/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: </span><br><span class=\"line\">nums &#x3D; </span><br><span class=\"line\">[[1,2],</span><br><span class=\"line\"> [3,4]]</span><br><span class=\"line\">r &#x3D; 1, c &#x3D; 4</span><br><span class=\"line\">Output: </span><br><span class=\"line\">[[1,2,3,4]]</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.</span><br></pre></td></tr></table></figure>\n<p>方法一：扁平化后重组。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">matrixReshape</span><span class=\"params\">(self, nums, r, c)</span>:</span></span><br><span class=\"line\">    a = [x <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> nums <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> row]</span><br><span class=\"line\">    n = len(a)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> r*c != n:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [a[i*c:i*c+c] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(r)]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：使用itertools.</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">matrixReshape</span><span class=\"params\">(self, nums, r, c)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> r*c != len(nums)*len(nums[<span class=\"number\">0</span>]):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums</span><br><span class=\"line\">    <span class=\"keyword\">from</span> itertools <span class=\"keyword\">import</span> islice, chain</span><br><span class=\"line\">    it = chain(*nums)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [list(islice(it, c)) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(r)]</span><br></pre></td></tr></table></figure>\n<h3 id=\"575-Distribute-Candies\"><a href=\"#575-Distribute-Candies\" class=\"headerlink\" title=\"575. Distribute Candies\"></a>575. Distribute Candies</h3><h4 id=\"给姐姐弟弟分糖，两人数量一样，保证姐姐的种类最多，求姐姐最多能分到多少种。原题\"><a href=\"#给姐姐弟弟分糖，两人数量一样，保证姐姐的种类最多，求姐姐最多能分到多少种。原题\" class=\"headerlink\" title=\"给姐姐弟弟分糖，两人数量一样，保证姐姐的种类最多，求姐姐最多能分到多少种。原题\"></a>给姐姐弟弟分糖，两人数量一样，保证姐姐的种类最多，求姐姐最多能分到多少种。<a href=\"https://leetcode.com/problems/distribute-candies/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: candies &#x3D; [1,1,2,2,3,3]</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">There are three different kinds of candies (1, 2 and 3), and two candies for each kind.</span><br><span class=\"line\">Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too. </span><br><span class=\"line\">The sister has three different kinds of candies.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">distributeCandies</span><span class=\"params\">(self, candies)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> min(len(candies)//<span class=\"number\">2</span>, len(set(candies)))</span><br></pre></td></tr></table></figure>\n<h3 id=\"594-Longest-Harmonious-Subsequence\"><a href=\"#594-Longest-Harmonious-Subsequence\" class=\"headerlink\" title=\"594. Longest Harmonious Subsequence\"></a>594. Longest Harmonious Subsequence</h3><h4 id=\"最长的和谐子数组，即元素的最大值和最小值正好相差一的子数组，元素顺序无关，求最大子数组长度。原题\"><a href=\"#最长的和谐子数组，即元素的最大值和最小值正好相差一的子数组，元素顺序无关，求最大子数组长度。原题\" class=\"headerlink\" title=\"最长的和谐子数组，即元素的最大值和最小值正好相差一的子数组，元素顺序无关，求最大子数组长度。原题\"></a>最长的和谐子数组，即元素的最大值和最小值正好相差一的子数组，元素顺序无关，求最大子数组长度。<a href=\"https://leetcode.com/problems/longest-harmonious-subsequence/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [1,3,2,2,5,2,3,7]</span><br><span class=\"line\">Output: 5</span><br><span class=\"line\">Explanation: The longest harmonious subsequence is [3,2,2,2,3].</span><br></pre></td></tr></table></figure>\n<p>方法一：开始想错了，后来发现子数组只能包含两个元素。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findLHS</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Counter</span><br><span class=\"line\">    res = <span class=\"number\">0</span></span><br><span class=\"line\">    c = Counter(nums)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> num, count <span class=\"keyword\">in</span> c.items():</span><br><span class=\"line\">        sum_count = count+c[num+<span class=\"number\">1</span>] <span class=\"keyword\">if</span> c[num+<span class=\"number\">1</span>] <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br><span class=\"line\">        res = max(res, sum_count)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：one-liner.</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findLHS</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Counter</span><br><span class=\"line\">    c = Counter(nums)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max([count+c[num+<span class=\"number\">1</span>] <span class=\"keyword\">for</span> num, count <span class=\"keyword\">in</span> c.items() </span><br><span class=\"line\">                <span class=\"keyword\">if</span> num+<span class=\"number\">1</span> <span class=\"keyword\">in</span> c] <span class=\"keyword\">or</span> [<span class=\"number\">0</span>])</span><br></pre></td></tr></table></figure>\n<h3 id=\"598-Range-Addition-II\"><a href=\"#598-Range-Addition-II\" class=\"headerlink\" title=\"598. Range Addition II\"></a>598. Range Addition II</h3><h4 id=\"这题看上去挺长，其实抽象起来很简单，把整个矩阵想象成一个积木，然后每次往上叠加，每次叠放的矩形都会和左上角对齐，所以最后完成的时候，左上角的一小块一定是最“厚”的，问题就变成和左上一样的厚度的面积。实际上等于叠放的所有矩形的最小长度和最小宽度的乘积。原题\"><a href=\"#这题看上去挺长，其实抽象起来很简单，把整个矩阵想象成一个积木，然后每次往上叠加，每次叠放的矩形都会和左上角对齐，所以最后完成的时候，左上角的一小块一定是最“厚”的，问题就变成和左上一样的厚度的面积。实际上等于叠放的所有矩形的最小长度和最小宽度的乘积。原题\" class=\"headerlink\" title=\"这题看上去挺长，其实抽象起来很简单，把整个矩阵想象成一个积木，然后每次往上叠加，每次叠放的矩形都会和左上角对齐，所以最后完成的时候，左上角的一小块一定是最“厚”的，问题就变成和左上一样的厚度的面积。实际上等于叠放的所有矩形的最小长度和最小宽度的乘积。原题\"></a>这题看上去挺长，其实抽象起来很简单，把整个矩阵想象成一个积木，然后每次往上叠加，每次叠放的矩形都会和左上角对齐，所以最后完成的时候，左上角的一小块一定是最“厚”的，问题就变成和左上一样的厚度的面积。实际上等于叠放的所有矩形的最小长度和最小宽度的乘积。<a href=\"https://leetcode.com/problems/range-addition-ii/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: </span><br><span class=\"line\">m &#x3D; 3, n &#x3D; 3</span><br><span class=\"line\">operations &#x3D; [[2,2],[3,3]]</span><br><span class=\"line\">Output: 4</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">Initially, M &#x3D; </span><br><span class=\"line\">[[0, 0, 0],</span><br><span class=\"line\"> [0, 0, 0],</span><br><span class=\"line\"> [0, 0, 0]]</span><br><span class=\"line\"></span><br><span class=\"line\">After performing [2,2], M &#x3D; </span><br><span class=\"line\">[[1, 1, 0],</span><br><span class=\"line\"> [1, 1, 0],</span><br><span class=\"line\"> [0, 0, 0]]</span><br><span class=\"line\"></span><br><span class=\"line\">After performing [3,3], M &#x3D; </span><br><span class=\"line\">[[2, 2, 1],</span><br><span class=\"line\"> [2, 2, 1],</span><br><span class=\"line\"> [1, 1, 1]]</span><br><span class=\"line\"></span><br><span class=\"line\">So the maximum integer in M is 2, and there are four of it in M. So return 4.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxCount</span><span class=\"params\">(self, m, n, ops)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> ops:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m*n</span><br><span class=\"line\">    length, width = list(zip(*ops))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min(length) * min(width)</span><br></pre></td></tr></table></figure>\n<h3 id=\"599-Minimum-Index-Sum-of-Two-Lists\"><a href=\"#599-Minimum-Index-Sum-of-Two-Lists\" class=\"headerlink\" title=\"599. Minimum Index Sum of Two Lists\"></a>599. Minimum Index Sum of Two Lists</h3><h4 id=\"找出两个人共同最喜欢的餐厅。如果有多个输出多个。原题\"><a href=\"#找出两个人共同最喜欢的餐厅。如果有多个输出多个。原题\" class=\"headerlink\" title=\"找出两个人共同最喜欢的餐厅。如果有多个输出多个。原题\"></a>找出两个人共同最喜欢的餐厅。如果有多个输出多个。<a href=\"https://leetcode.com/problems/minimum-index-sum-of-two-lists/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">[&quot;Shogun&quot;,&quot;Tapioca Express&quot;,&quot;Burger King&quot;,&quot;KFC&quot;]</span><br><span class=\"line\">[&quot;Piatti&quot;,&quot;The Grill at Torrey Pines&quot;,&quot;Tapioca Express&quot;,&quot;Shogun&quot;]</span><br><span class=\"line\">Output: [&#39;Shogun&#39;, &#39;Tapioca Express&#39;]</span><br></pre></td></tr></table></figure>\n<p>方法一：这里做了一个优化，以原list1的顺序输出数组，如果索引太大超出了最小索引和，这样即使是map2使用第一个元素也无法满足条件，直接退出。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findRestaurant</span><span class=\"params\">(self, list1, list2)</span>:</span></span><br><span class=\"line\">    map2 = &#123;x: i <span class=\"keyword\">for</span> i, x <span class=\"keyword\">in</span> enumerate(list2)&#125;</span><br><span class=\"line\">    res, min_sum = [], float(<span class=\"string\">'inf'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, rest <span class=\"keyword\">in</span> enumerate(list1):</span><br><span class=\"line\">        <span class=\"comment\"># optimize </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i &gt; min_sum: </span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> rest <span class=\"keyword\">in</span> map2:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i+map2[rest] &lt; min_sum:</span><br><span class=\"line\">                res = [rest]</span><br><span class=\"line\">                min_sum = i+map2[rest]</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> i+map2[rest] == min_sum:</span><br><span class=\"line\">                res += [rest]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"605-Can-Place-Flowers\"><a href=\"#605-Can-Place-Flowers\" class=\"headerlink\" title=\"605. Can Place Flowers\"></a>605. Can Place Flowers</h3><h4 id=\"是否可以种下给定数量的花。两颗花不能挨着，给定的数组中满足这一条件。原题\"><a href=\"#是否可以种下给定数量的花。两颗花不能挨着，给定的数组中满足这一条件。原题\" class=\"headerlink\" title=\"是否可以种下给定数量的花。两颗花不能挨着，给定的数组中满足这一条件。原题\"></a>是否可以种下给定数量的花。两颗花不能挨着，给定的数组中满足这一条件。<a href=\"https://leetcode.com/problems/can-place-flowers/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: flowerbed &#x3D; [1,0,0,0,1], n &#x3D; 2</span><br><span class=\"line\">Output: False</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">canPlaceFlowers</span><span class=\"params\">(self, flowerbed, n)</span>:</span></span><br><span class=\"line\">    plots = [<span class=\"number\">0</span>] + flowerbed + [<span class=\"number\">0</span>]</span><br><span class=\"line\">    p = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> p &lt;= len(flowerbed) <span class=\"keyword\">and</span> n &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> plots[p] == <span class=\"number\">0</span> <span class=\"keyword\">and</span> plots[p<span class=\"number\">-1</span>] == <span class=\"number\">0</span> <span class=\"keyword\">and</span> plots[p+<span class=\"number\">1</span>] == <span class=\"number\">0</span>:</span><br><span class=\"line\">            plots[p] = <span class=\"number\">1</span></span><br><span class=\"line\">            n -= <span class=\"number\">1</span></span><br><span class=\"line\">        p += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> n == <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"643-Maximum-Average-Subarray-I\"><a href=\"#643-Maximum-Average-Subarray-I\" class=\"headerlink\" title=\"643. Maximum Average Subarray I\"></a>643. Maximum Average Subarray I</h3><h4 id=\"最大的连续的长度为k的子数组的平均值。原题\"><a href=\"#最大的连续的长度为k的子数组的平均值。原题\" class=\"headerlink\" title=\"最大的连续的长度为k的子数组的平均值。原题\"></a>最大的连续的长度为k的子数组的平均值。<a href=\"https://leetcode.com/problems/maximum-average-subarray-i/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [1,12,-5,-6,50,3], k &#x3D; 4</span><br><span class=\"line\">Output: 12.75</span><br><span class=\"line\">Explanation: Maximum average is (12-5-6+50)&#x2F;4 &#x3D; 51&#x2F;4 &#x3D; 12.75</span><br></pre></td></tr></table></figure>\n<p>方法一：参考了stefen大神的答案，自己写的滑动窗口居然超时了。accumulate也不是想不到，此答案厉害的地方在于 补0 和map操作。像这种固定长度的滑动窗口使用补0的<code>accumulate</code>，可以用到其他的题上。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findMaxAverage</span><span class=\"params\">(self, nums, k)</span>:</span></span><br><span class=\"line\">    sums = [<span class=\"number\">0</span>] + list(itertools.accumulate(nums))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(map(operator.sub, sums[k:], sums)) / k</span><br></pre></td></tr></table></figure>\n<h3 id=\"661-Image-Smoother\"><a href=\"#661-Image-Smoother\" class=\"headerlink\" title=\"661. Image Smoother\"></a>661. Image Smoother</h3><h4 id=\"使图片平滑模糊，一个矩阵使每个点的值为周围所有点的平均值，包括自己。原题\"><a href=\"#使图片平滑模糊，一个矩阵使每个点的值为周围所有点的平均值，包括自己。原题\" class=\"headerlink\" title=\"使图片平滑模糊，一个矩阵使每个点的值为周围所有点的平均值，包括自己。原题\"></a>使图片平滑模糊，一个矩阵使每个点的值为周围所有点的平均值，包括自己。<a href=\"https://leetcode.com/problems/image-smoother/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">[[1,1,1],</span><br><span class=\"line\"> [1,0,1],</span><br><span class=\"line\"> [1,1,1]]</span><br><span class=\"line\">Output:</span><br><span class=\"line\">[[0, 0, 0],</span><br><span class=\"line\"> [0, 0, 0],</span><br><span class=\"line\"> [0, 0, 0]]</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">For the point (0,0), (0,2), (2,0), (2,2): floor(3&#x2F;4) &#x3D; floor(0.75) &#x3D; 0</span><br><span class=\"line\">For the point (0,1), (1,0), (1,2), (2,1): floor(5&#x2F;6) &#x3D; floor(0.83333333) &#x3D; 0</span><br><span class=\"line\">For the point (1,1): floor(8&#x2F;9) &#x3D; floor(0.88888889) &#x3D; 0</span><br></pre></td></tr></table></figure>\n<p>方法一：参考了评论区一位朋友的写法，不过效率不是很高，800ms，Solution给出的方法也是这个速度，看来如果优化的话，可能使用<code>numpy</code>会好一点。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">imageSmoother</span><span class=\"params\">(self, M)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">import</span> itertools</span><br><span class=\"line\">    R, C = len(M), len(M[<span class=\"number\">0</span>]) </span><br><span class=\"line\">    res = [[<span class=\"number\">0</span>]*C <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(R)]</span><br><span class=\"line\">    offset = list(itertools.product([<span class=\"number\">-1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>], [<span class=\"number\">-1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>]))</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(R):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(C):</span><br><span class=\"line\">            points = [M[i+x][j+y] <span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> offset</span><br><span class=\"line\">                      <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=i+x&lt;R <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=j+y&lt;C]</span><br><span class=\"line\">            res[i][j] = sum(points) // len(points)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"665-Non-decreasing-Array\"><a href=\"#665-Non-decreasing-Array\" class=\"headerlink\" title=\"665. Non-decreasing Array\"></a>665. Non-decreasing Array</h3><h4 id=\"判断是否改变一个数，可使其变成单调递增数组。原题\"><a href=\"#判断是否改变一个数，可使其变成单调递增数组。原题\" class=\"headerlink\" title=\"判断是否改变一个数，可使其变成单调递增数组。原题\"></a>判断是否改变一个数，可使其变成单调递增数组。<a href=\"https://leetcode.com/problems/non-decreasing-array/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [4,2,3]</span><br><span class=\"line\">Output: True</span><br><span class=\"line\">Explanation: You could modify the first 4 to 1 to get a non-decreasing array.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">checkPossibility</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">    n = len(nums)</span><br><span class=\"line\">    p = <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n<span class=\"number\">-1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[i] &gt; nums[i+<span class=\"number\">1</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> p <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">            p = i</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">not</span> p) <span class=\"keyword\">or</span> p == n<span class=\"number\">-2</span> <span class=\"keyword\">or</span> nums[p<span class=\"number\">-1</span>] &lt;= nums[p+<span class=\"number\">1</span>] <span class=\"keyword\">or</span> \\</span><br><span class=\"line\">           nums[p] &lt;= nums[p+<span class=\"number\">2</span>]</span><br></pre></td></tr></table></figure>\n<ul>\n<li>If p = 0, then we could make the array good by setting A[p] = A[p+1]</li>\n<li>if p = len(A) - 2, then we could make the array good by setting A[p+1] = A[p]</li>\n<li>Otherwise, A[p-1], A[p], A[p+1], A[p+2] all exist, and:<ul>\n<li>change A[p] to be between A[p-1] and A[p+1] if possible, or: [4, 8, 6]</li>\n<li>change A[p+1] to be between A[p] and A[p+2] if possible. [4, 5, 3, 6]</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"674-Longest-Continuous-Increasing-Subsequence\"><a href=\"#674-Longest-Continuous-Increasing-Subsequence\" class=\"headerlink\" title=\"674. Longest Continuous Increasing Subsequence\"></a>674. Longest Continuous Increasing Subsequence</h3><h4 id=\"最长连续递增子数组长度。原题\"><a href=\"#最长连续递增子数组长度。原题\" class=\"headerlink\" title=\"最长连续递增子数组长度。原题\"></a>最长连续递增子数组长度。<a href=\"https://leetcode.com/problems/longest-continuous-increasing-subsequence/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [1,3,5,4,7]</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3. </span><br><span class=\"line\">Even though [1,3,5,7] is also an increasing subsequence, it&#39;s not a continuous one where 5 and 7 are separated by 4.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findLengthOfLCIS</span><span class=\"params\">(self, nums: <span class=\"string\">'List[int]'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    ans = anchor = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(nums)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i <span class=\"keyword\">and</span> nums[i] &lt;= nums[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">            anchor = i</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            ans = max(ans, i-anchor+<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"682-Baseball-Game\"><a href=\"#682-Baseball-Game\" class=\"headerlink\" title=\"682. Baseball Game\"></a>682. Baseball Game</h3><h4 id=\"棒球游戏，给了一些积分规则。原题\"><a href=\"#棒球游戏，给了一些积分规则。原题\" class=\"headerlink\" title=\"棒球游戏，给了一些积分规则。原题\"></a>棒球游戏，给了一些积分规则。<a href=\"https://leetcode.com/problems/baseball-game/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [&quot;5&quot;,&quot;2&quot;,&quot;C&quot;,&quot;D&quot;,&quot;+&quot;]</span><br><span class=\"line\">Output: 30</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">Round 1: You could get 5 points. The sum is: 5.</span><br><span class=\"line\">Round 2: You could get 2 points. The sum is: 7.</span><br><span class=\"line\">Operation 1: The round 2&#39;s data was invalid. The sum is: 5.  </span><br><span class=\"line\">Round 3: You could get 10 points (the round 2&#39;s data has been removed). The sum is: 15.</span><br><span class=\"line\">Round 4: You could get 5 + 10 &#x3D; 15 points. The sum is: 30.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">calPoints</span><span class=\"params\">(self, ops)</span>:</span></span><br><span class=\"line\">    stack = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> op <span class=\"keyword\">in</span> ops:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> op == <span class=\"string\">'C'</span>:</span><br><span class=\"line\">            stack.pop()</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> op == <span class=\"string\">'D'</span>:</span><br><span class=\"line\">            stack.append(stack[<span class=\"number\">-1</span>]*<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> op == <span class=\"string\">'+'</span>:</span><br><span class=\"line\">            stack.append(stack[<span class=\"number\">-1</span>] + stack[<span class=\"number\">-2</span>])</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            stack.append(int(op))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(stack)</span><br></pre></td></tr></table></figure>\n<h3 id=\"690-Employee-Importance\"><a href=\"#690-Employee-Importance\" class=\"headerlink\" title=\"690. Employee Importance\"></a>690. Employee Importance</h3><h4 id=\"员工重要值。原题\"><a href=\"#员工重要值。原题\" class=\"headerlink\" title=\"员工重要值。原题\"></a>员工重要值。<a href=\"https://leetcode.com/problems/employee-importance/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1</span><br><span class=\"line\">Output: 11</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">Employee 1 has importance value 5, and he has two direct subordinates: employee 2 and employee 3. They both have importance value 3. So the total importance value of employee 1 is 5 + 3 + 3 &#x3D; 11.</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法一：iteratively.</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getImportance</span><span class=\"params\">(self, employees, id)</span>:</span></span><br><span class=\"line\">    emp_dict = &#123;ep.id: (ep.importance, ep.subordinates) <span class=\"keyword\">for</span> ep <span class=\"keyword\">in</span> employees&#125;</span><br><span class=\"line\">    res, stack = <span class=\"number\">0</span>, [id]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> stack:</span><br><span class=\"line\">        value, subs = emp_dict.get(stack.pop())</span><br><span class=\"line\">        res += value</span><br><span class=\"line\">        stack += subs</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<p>方法二：recursively.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getImportance</span><span class=\"params\">(self, employees, id)</span>:</span></span><br><span class=\"line\">    emp_dict = &#123;ep.id: (ep.importance, ep.subordinates) <span class=\"keyword\">for</span> ep <span class=\"keyword\">in</span> employees&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(pk)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> emp_dict[pk][<span class=\"number\">0</span>] + sum(dfs(sub) <span class=\"keyword\">for</span> sub <span class=\"keyword\">in</span> emp_dict[pk][<span class=\"number\">1</span>])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dfs(id)</span><br></pre></td></tr></table></figure>\n<h3 id=\"724-Find-Pivot-Index\"><a href=\"#724-Find-Pivot-Index\" class=\"headerlink\" title=\"724. Find Pivot Index\"></a>724. Find Pivot Index</h3><h4 id=\"找到中心索引，使得左右两边和相等。左右求和时均不包含该索引。原题\"><a href=\"#找到中心索引，使得左右两边和相等。左右求和时均不包含该索引。原题\" class=\"headerlink\" title=\"找到中心索引，使得左右两边和相等。左右求和时均不包含该索引。原题\"></a>找到中心索引，使得左右两边和相等。左右求和时均不包含该索引。<a href=\"https://leetcode.com/problems/find-pivot-index/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: </span><br><span class=\"line\">nums &#x3D; [1, 7, 3, 6, 5, 6]</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">The sum of the numbers to the left of index 3 (nums[3] &#x3D; 6) is equal to the sum of numbers to the right of index 3.</span><br><span class=\"line\">Also, 3 is the first index where this occurs.</span><br><span class=\"line\"></span><br><span class=\"line\">Input:</span><br><span class=\"line\">nums &#x3D; [1,0]</span><br><span class=\"line\">Output: 0</span><br></pre></td></tr></table></figure>\n<p>方法一：指针。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pivotIndex</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">    left, right, i = <span class=\"number\">0</span>, sum(nums), <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> i &lt; len(nums):</span><br><span class=\"line\">        left += nums[i<span class=\"number\">-1</span>] <span class=\"keyword\">if</span> i &gt; <span class=\"number\">0</span> <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br><span class=\"line\">        right -= nums[i] </span><br><span class=\"line\">        <span class=\"keyword\">if</span> left == right:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> i</span><br><span class=\"line\">        i += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：不使用指针。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pivotIndex</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">    S, left = sum(nums), <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, num <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> left == S-left-num:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> i</span><br><span class=\"line\">        left += num</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"985-Sum-of-Even-Numbers-After-Queries\"><a href=\"#985-Sum-of-Even-Numbers-After-Queries\" class=\"headerlink\" title=\"985. Sum of Even Numbers After Queries\"></a>985. Sum of Even Numbers After Queries</h3><h4 id=\"计算Queries后，累加所有的偶数。原题\"><a href=\"#计算Queries后，累加所有的偶数。原题\" class=\"headerlink\" title=\"计算Queries后，累加所有的偶数。原题\"></a>计算Queries后，累加所有的偶数。<a href=\"https://leetcode.com/problems/sum-of-even-numbers-after-queries/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: A &#x3D; [1,2,3,4], queries &#x3D; [[1,0],[-3,1],[-4,0],[2,3]]</span><br><span class=\"line\">Output: [8,6,2,4]</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">At the beginning, the array is [1,2,3,4].</span><br><span class=\"line\">After adding 1 to A[0], the array is [2,2,3,4], and the sum of even values is 2 + 2 + 4 &#x3D; 8.</span><br><span class=\"line\">After adding -3 to A[1], the array is [2,-1,3,4], and the sum of even values is 2 + 4 &#x3D; 6.</span><br><span class=\"line\">After adding -4 to A[0], the array is [-2,-1,3,4], and the sum of even values is -2 + 4 &#x3D; 2.</span><br><span class=\"line\">After adding 2 to A[3], the array is [-2,-1,3,6], and the sum of even values is -2 + 6 &#x3D; 4.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sumEvenAfterQueries</span><span class=\"params\">(self, A: <span class=\"string\">'List[int]'</span>, queries: <span class=\"string\">'List[List[int]]'</span>)</span> -&gt; 'List[int]':</span></span><br><span class=\"line\">    res = []</span><br><span class=\"line\">    sum_even = sum(x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> A <span class=\"keyword\">if</span> x &amp; <span class=\"number\">1</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> v, i <span class=\"keyword\">in</span> queries:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> A[i] &amp; <span class=\"number\">1</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">            sum_even -= A[i]</span><br><span class=\"line\">        A[i] += v</span><br><span class=\"line\">        <span class=\"keyword\">if</span> A[i] &amp; <span class=\"number\">1</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">            sum_even += A[i]</span><br><span class=\"line\">        res.append(sum_even)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"986-Interval-List-Intersections\"><a href=\"#986-Interval-List-Intersections\" class=\"headerlink\" title=\"986. Interval List Intersections\"></a>986. Interval List Intersections</h3><h4 id=\"两个区间列表求相交。原题\"><a href=\"#两个区间列表求相交。原题\" class=\"headerlink\" title=\"两个区间列表求相交。原题\"></a>两个区间列表求相交。<a href=\"https://leetcode.com/problems/interval-list-intersections/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><img src=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%95%B0%E7%BB%84%E7%AF%87%EF%BC%89Array/interval1.png\" class>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: A &#x3D; [[0,2],[5,10],[13,23],[24,25]], B &#x3D; [[1,5],[8,12],[15,24],[25,26]]</span><br><span class=\"line\">Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]</span><br><span class=\"line\">Reminder: The inputs and the desired output are lists of Interval objects, and not arrays or lists.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">intervalIntersection</span><span class=\"params\">(self, A: <span class=\"string\">'List[Interval]'</span>, B: <span class=\"string\">'List[Interval]'</span>)</span> -&gt; 'List[Interval]':</span></span><br><span class=\"line\">    i = j = <span class=\"number\">0</span></span><br><span class=\"line\">    res = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> i &lt; len(A) <span class=\"keyword\">and</span> j &lt; len(B):</span><br><span class=\"line\">        lo = max(A[i].start, B[j].start)</span><br><span class=\"line\">        hi = min(A[i].end, B[j].end)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> lo &lt;= hi:</span><br><span class=\"line\">            res.append(Interval(lo, hi))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> A[i].end &gt; B[j].end:</span><br><span class=\"line\">            j += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"747-Largest-Number-At-Least-Twice-of-Others\"><a href=\"#747-Largest-Number-At-Least-Twice-of-Others\" class=\"headerlink\" title=\"747. Largest Number At Least Twice of Others\"></a>747. Largest Number At Least Twice of Others</h3><h4 id=\"最大的数是否大于等于所有其它数的两倍。原题\"><a href=\"#最大的数是否大于等于所有其它数的两倍。原题\" class=\"headerlink\" title=\"最大的数是否大于等于所有其它数的两倍。原题\"></a>最大的数是否大于等于所有其它数的两倍。<a href=\"https://leetcode.com/problems/largest-number-at-least-twice-of-others/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [3, 6, 1, 0]</span><br><span class=\"line\">Output: 1</span><br><span class=\"line\">Explanation: 6 is the largest integer, and for every other number in the array x,</span><br><span class=\"line\">6 is more than twice as big as x.  The index of value 6 is 1, so we return 1.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dominantIndex</span><span class=\"params\">(self, nums: <span class=\"string\">'List[int]'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    max_v = max(nums)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> all(max_v &gt;= <span class=\"number\">2</span>*x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> nums <span class=\"keyword\">if</span> x!=max_v):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums.index(max_v)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"766-Toeplitz-Matrix\"><a href=\"#766-Toeplitz-Matrix\" class=\"headerlink\" title=\"766. Toeplitz Matrix\"></a>766. Toeplitz Matrix</h3><h4 id=\"Toeplitz矩阵，即对角矩阵，斜角具有相同的值，判断一个矩阵是否是对角矩阵。原题\"><a href=\"#Toeplitz矩阵，即对角矩阵，斜角具有相同的值，判断一个矩阵是否是对角矩阵。原题\" class=\"headerlink\" title=\"Toeplitz矩阵，即对角矩阵，斜角具有相同的值，判断一个矩阵是否是对角矩阵。原题\"></a>Toeplitz矩阵，即对角矩阵，斜角具有相同的值，判断一个矩阵是否是对角矩阵。<a href=\"https://leetcode.com/problems/toeplitz-matrix/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">matrix &#x3D; [</span><br><span class=\"line\">  [1,2,3,4],</span><br><span class=\"line\">  [5,1,2,3],</span><br><span class=\"line\">  [9,5,1,2]</span><br><span class=\"line\">]</span><br><span class=\"line\">Output: True</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">In the above grid, the diagonals are:</span><br><span class=\"line\">&quot;[9]&quot;, &quot;[5, 5]&quot;, &quot;[1, 1, 1]&quot;, &quot;[2, 2, 2]&quot;, &quot;[3, 3]&quot;, &quot;[4]&quot;.</span><br><span class=\"line\">In each diagonal all elements are the same, so the answer is True.</span><br></pre></td></tr></table></figure>\n<p>方法一：嵌套循环。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isToeplitzMatrix</span><span class=\"params\">(self, matrix: <span class=\"string\">'List[List[int]]'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> all(x==<span class=\"number\">0</span> <span class=\"keyword\">or</span> y==<span class=\"number\">0</span> <span class=\"keyword\">or</span> matrix[x<span class=\"number\">-1</span>][y<span class=\"number\">-1</span>]==val</span><br><span class=\"line\">               <span class=\"keyword\">for</span> x, rows <span class=\"keyword\">in</span> enumerate(matrix)</span><br><span class=\"line\">               <span class=\"keyword\">for</span> y, val <span class=\"keyword\">in</span> enumerate(rows))</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：切片，与上述方法在效率空间上没有差距，更喜欢这个方法。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isToeplitzMatrix</span><span class=\"params\">(self, matrix: <span class=\"string\">'List[List[int]]'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> all(matrix[i][<span class=\"number\">1</span>:]==matrix[i<span class=\"number\">-1</span>][:<span class=\"number\">-1</span>]</span><br><span class=\"line\">               <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(matrix)))</span><br></pre></td></tr></table></figure>\n<h3 id=\"830-Positions-of-Large-Groups\"><a href=\"#830-Positions-of-Large-Groups\" class=\"headerlink\" title=\"830. Positions of Large Groups\"></a>830. Positions of Large Groups</h3><h4 id=\"根据指定字符串分组，超过三个元素的称为大组，求所有大组的位置。原题\"><a href=\"#根据指定字符串分组，超过三个元素的称为大组，求所有大组的位置。原题\" class=\"headerlink\" title=\"根据指定字符串分组，超过三个元素的称为大组，求所有大组的位置。原题\"></a>根据指定字符串分组，超过三个元素的称为大组，求所有大组的位置。<a href=\"https://leetcode.com/problems/positions-of-large-groups/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: &quot;abcdddeeeeaabbbcd&quot;</span><br><span class=\"line\">Output: [[3,5],[6,9],[12,14]]</span><br></pre></td></tr></table></figure>\n<p>方法一：groupby.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">largeGroupPositions</span><span class=\"params\">(self, S: <span class=\"string\">'str'</span>)</span> -&gt; 'List[List[int]]':</span></span><br><span class=\"line\">    groups = itertools.groupby(S)</span><br><span class=\"line\">    index, ans = <span class=\"number\">0</span>, []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> s, group <span class=\"keyword\">in</span> groups:</span><br><span class=\"line\">        count = len(list(group))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> count &gt;= <span class=\"number\">3</span>:</span><br><span class=\"line\">            ans.append([index, index+count<span class=\"number\">-1</span>])</span><br><span class=\"line\">        index += count</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法二：two pointers.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">largeGroupPositions</span><span class=\"params\">(self, S: <span class=\"string\">'str'</span>)</span> -&gt; 'List[List[int]]':</span></span><br><span class=\"line\">    i = <span class=\"number\">0</span> <span class=\"comment\"># start of each group</span></span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(S)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> j == len(S)<span class=\"number\">-1</span> <span class=\"keyword\">or</span> S[j] != S[j+<span class=\"number\">1</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> j - i &gt;= <span class=\"number\">2</span>:</span><br><span class=\"line\">                ans.append([i, j])</span><br><span class=\"line\">            i = j + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"832-Flipping-an-Image\"><a href=\"#832-Flipping-an-Image\" class=\"headerlink\" title=\"832. Flipping an Image\"></a>832. Flipping an Image</h3><h4 id=\"水平翻转一张图片并反转-invert-原题\"><a href=\"#水平翻转一张图片并反转-invert-原题\" class=\"headerlink\" title=\"水平翻转一张图片并反转(invert). 原题\"></a>水平翻转一张图片并反转(invert). <a href=\"https://leetcode.com/problems/flipping-an-image/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [[1,1,0],[1,0,1],[0,0,0]]</span><br><span class=\"line\">Output: [[1,0,0],[0,1,0],[1,1,1]]</span><br><span class=\"line\">Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].</span><br><span class=\"line\">Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">flipAndInvertImage</span><span class=\"params\">(self, A: <span class=\"string\">'List[List[int]]'</span>)</span> -&gt; 'List[List[int]]':</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[x ^ <span class=\"number\">1</span> <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> reversed(row)] <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> A]</span><br></pre></td></tr></table></figure>\n<h3 id=\"840-Magic-Squares-In-Grid\"><a href=\"#840-Magic-Squares-In-Grid\" class=\"headerlink\" title=\"840. Magic Squares In Grid\"></a>840. Magic Squares In Grid</h3><h4 id=\"找出grid中数独的个数。原题\"><a href=\"#找出grid中数独的个数。原题\" class=\"headerlink\" title=\"找出grid中数独的个数。原题\"></a>找出grid中数独的个数。<a href=\"https://leetcode.com/problems/magic-squares-in-grid/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [[4,3,8,4],</span><br><span class=\"line\">        [9,5,1,9],</span><br><span class=\"line\">        [2,7,6,2]]</span><br><span class=\"line\">Output: 1</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">The following subgrid is a 3 x 3 magic square:</span><br><span class=\"line\">438</span><br><span class=\"line\">951</span><br><span class=\"line\">276</span><br><span class=\"line\"></span><br><span class=\"line\">while this one is not:</span><br><span class=\"line\">384</span><br><span class=\"line\">519</span><br><span class=\"line\">762</span><br><span class=\"line\"></span><br><span class=\"line\">In total, there is only one magic square inside the given grid.</span><br></pre></td></tr></table></figure>\n<p>方法一：Brute Force.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numMagicSquaresInside</span><span class=\"params\">(self, grid: <span class=\"string\">'List[List[int]]'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    digits = set(range(<span class=\"number\">1</span>, <span class=\"number\">10</span>))</span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_sudoku</span><span class=\"params\">(matrix)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> matrix[<span class=\"number\">1</span>][<span class=\"number\">1</span>] != <span class=\"number\">5</span>:   <span class=\"comment\"># for optimization</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> set(sum(matrix, [])) != digits:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> &#123;sum(row) <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> matrix&#125; != &#123;<span class=\"number\">15</span>&#125;:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> &#123;sum(col) <span class=\"keyword\">for</span> col <span class=\"keyword\">in</span> zip(*matrix)&#125; != &#123;<span class=\"number\">15</span>&#125;:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> matrix[<span class=\"number\">0</span>][<span class=\"number\">0</span>] + matrix[<span class=\"number\">1</span>][<span class=\"number\">1</span>] + matrix[<span class=\"number\">2</span>][<span class=\"number\">2</span>] != <span class=\"number\">15</span> <span class=\"keyword\">or</span> \\</span><br><span class=\"line\">           matrix[<span class=\"number\">2</span>][<span class=\"number\">0</span>] + matrix[<span class=\"number\">1</span>][<span class=\"number\">1</span>] + matrix[<span class=\"number\">0</span>][<span class=\"number\">2</span>] != <span class=\"number\">15</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(grid)<span class=\"number\">-2</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(grid[<span class=\"number\">0</span>])<span class=\"number\">-2</span>):</span><br><span class=\"line\">            matrix = [rows[j:j+<span class=\"number\">3</span>] <span class=\"keyword\">for</span> rows <span class=\"keyword\">in</span> grid[i:i+<span class=\"number\">3</span>]]</span><br><span class=\"line\">            <span class=\"comment\"># print(matrix)</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> is_sudoku(matrix):</span><br><span class=\"line\">                ans += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法二：参考了大神的解法。外层循环中只把左上角的点传入子方法进行判断，并在外循环判断中心点是否为5；</p>\n<p>另外一个规律就是，满足条件数独的9宫格中，4个角都是偶数，4个边都是奇数，并且沿着一个方向必然是’43816729’的正序或者倒序。所以当左上角为偶数时，并满足顺序要求，另两个条件也自然满足了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numMagicSquaresInside</span><span class=\"params\">(self, g: <span class=\"string\">'List[List[int]]'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_sudoku</span><span class=\"params\">(i, j)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># clockwise begin i, j</span></span><br><span class=\"line\">        s = <span class=\"string\">''</span>.join(str(g[i + x//<span class=\"number\">3</span>][j + x%<span class=\"number\">3</span>])</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> (<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>, <span class=\"number\">7</span>, <span class=\"number\">6</span>, <span class=\"number\">3</span>))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> g[i][j] &amp; <span class=\"number\">1</span> == <span class=\"number\">0</span> <span class=\"keyword\">and</span> (</span><br><span class=\"line\">            s <span class=\"keyword\">in</span> <span class=\"string\">'43816729'</span>*<span class=\"number\">2</span> <span class=\"keyword\">or</span> s <span class=\"keyword\">in</span> <span class=\"string\">'43816729'</span>[::<span class=\"number\">-1</span>]*<span class=\"number\">2</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(is_sudoku(i, j) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(g)<span class=\"number\">-2</span>)</span><br><span class=\"line\">               <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(g[<span class=\"number\">0</span>])<span class=\"number\">-2</span>) <span class=\"keyword\">if</span> g[i+<span class=\"number\">1</span>][j+<span class=\"number\">1</span>] == <span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"849-Maximize-Distance-to-Closest-Person\"><a href=\"#849-Maximize-Distance-to-Closest-Person\" class=\"headerlink\" title=\"849. Maximize Distance to Closest Person\"></a>849. Maximize Distance to Closest Person</h3><h4 id=\"一排电影院座位，离人的最远距离。数组中必含有一个1和0。原题\"><a href=\"#一排电影院座位，离人的最远距离。数组中必含有一个1和0。原题\" class=\"headerlink\" title=\"一排电影院座位，离人的最远距离。数组中必含有一个1和0。原题\"></a>一排电影院座位，离人的最远距离。数组中必含有一个1和0。<a href=\"https://leetcode.com/problems/maximize-distance-to-closest-person/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [1,0,0,0,1,0,1]</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">If Alex sits in the second open seat (seats[2]), then the closest person has distance 2.</span><br><span class=\"line\">If Alex sits in any other open seat, the closest person has distance 1.</span><br><span class=\"line\">Thus, the maximum distance to the closest person is 2.</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法一：groupby。需要注意两个地方：一个是group是一个生成器，必须转成list才可以求长度；另一个地方是<code>reversed(seats)</code>也是一个生成器，所以这里要用切片。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxDistToClosest</span><span class=\"params\">(self, seats: <span class=\"string\">'List[int]'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    groups = itertools.groupby(seats)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> seat, group <span class=\"keyword\">in</span> groups:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> seat:</span><br><span class=\"line\">            ans = max(ans, (len(list(group))+<span class=\"number\">1</span>) // <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(ans, seats.index(<span class=\"number\">1</span>), seats[::<span class=\"number\">-1</span>].index(<span class=\"number\">1</span>))</span><br></pre></td></tr></table></figure>\n<p>方法二：two pointers. 在第一个1出现之前长度都是j。直到第二个1出现时，计算方式变为平均数。这里使用<code>i = j + 1</code>而不是<code>i = j</code>是因为有根据i判断的条件，在计算平均距离时又将其加了回来。最后的<code>len(seats)-i</code>是为了<code>[1, 0, 0, 0]</code>末尾的0作结算。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxDistToClosest</span><span class=\"params\">(self, seats: <span class=\"string\">'List[int]'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    ans = i = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(seats)):</span><br><span class=\"line\">        <span class=\"comment\"># print(j, i, ans)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> seats[j] == <span class=\"number\">1</span>:</span><br><span class=\"line\">            dis = (j - i + <span class=\"number\">1</span>) // <span class=\"number\">2</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> i == <span class=\"number\">0</span>:</span><br><span class=\"line\">                dis = j    </span><br><span class=\"line\">            ans = max(ans, dis)</span><br><span class=\"line\">            i = j + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"comment\"># print(ans)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(ans, len(seats)-i)</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：方法二的简洁写法。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxDistToClosest</span><span class=\"params\">(self, seats: <span class=\"string\">'List[int]'</span>)</span> -&gt; 'int':</span></span><br><span class=\"line\">    ans = i = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(seats)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> seats[j] == <span class=\"number\">1</span>:</span><br><span class=\"line\">            ans = max(ans, ((j-i+<span class=\"number\">1</span>)//<span class=\"number\">2</span>, j)[i==<span class=\"number\">0</span>])</span><br><span class=\"line\">            i = j + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(ans, len(seats)-i)</span><br></pre></td></tr></table></figure>\n<h3 id=\"867-Transpose-Matrix\"><a href=\"#867-Transpose-Matrix\" class=\"headerlink\" title=\"867. Transpose Matrix\"></a>867. Transpose Matrix</h3><h4 id=\"转置矩阵。原题\"><a href=\"#转置矩阵。原题\" class=\"headerlink\" title=\"转置矩阵。原题\"></a>转置矩阵。<a href=\"https://leetcode.com/problems/transpose-matrix/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class=\"line\">Output: [[1,4,7],[2,5,8],[3,6,9]]</span><br></pre></td></tr></table></figure>\n<p>方法一：zip。 这里testcase并没有检测其中的元素是否为list。所以不需要转换。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">transpose</span><span class=\"params\">(self, A: <span class=\"string\">'List[List[int]]'</span>)</span> -&gt; 'List[List[int]]':</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> list(zip(*A))</span><br></pre></td></tr></table></figure>\n<p>方法二：zip原理。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">transpose</span><span class=\"params\">(self, A: <span class=\"string\">'List[List[int]]'</span>)</span> -&gt; 'List[List[int]]':</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> list(map(<span class=\"keyword\">lambda</span> *arg: arg, *A))</span><br></pre></td></tr></table></figure>\n<p>方法三：列表生成式。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">transpose</span><span class=\"params\">(self, A: <span class=\"string\">'List[List[int]]'</span>)</span> -&gt; 'List[List[int]]':</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[A[i][j] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(A))]</span><br><span class=\"line\">           <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(A[<span class=\"number\">0</span>]))]</span><br></pre></td></tr></table></figure>\n<p>方法四：numpy.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">transpose</span><span class=\"params\">(self, A)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\">    <span class=\"keyword\">return</span> np.transpose(A).tolist()</span><br></pre></td></tr></table></figure>\n<h3 id=\"888-Fair-Candy-Swap\"><a href=\"#888-Fair-Candy-Swap\" class=\"headerlink\" title=\"888. Fair Candy Swap\"></a>888. Fair Candy Swap</h3><h4 id=\"公平的糖果交换。两个人有很多糖果酒吧，交换其中一间使，糖果相同，可能有多个答案，返回任意一个。原题\"><a href=\"#公平的糖果交换。两个人有很多糖果酒吧，交换其中一间使，糖果相同，可能有多个答案，返回任意一个。原题\" class=\"headerlink\" title=\"公平的糖果交换。两个人有很多糖果酒吧，交换其中一间使，糖果相同，可能有多个答案，返回任意一个。原题\"></a>公平的糖果交换。两个人有很多糖果酒吧，交换其中一间使，糖果相同，可能有多个答案，返回任意一个。<a href=\"https://leetcode.com/problems/fair-candy-swap/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: A &#x3D; [1,1], B &#x3D; [2,2]</span><br><span class=\"line\">Output: [1,2]</span><br></pre></td></tr></table></figure>\n<p>方法一：Solution中的答案。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fairCandySwap</span><span class=\"params\">(self, A: <span class=\"string\">'List[int]'</span>, B: <span class=\"string\">'List[int]'</span>)</span> -&gt; 'List[int]':</span></span><br><span class=\"line\">    diff = (sum(B) - sum(A)) // <span class=\"number\">2</span></span><br><span class=\"line\">    set_b = set(B)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> A:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> diff + a <span class=\"keyword\">in</span> set_b:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> a, diff + a</span><br></pre></td></tr></table></figure>\n<h3 id=\"896-Monotonic-Array\"><a href=\"#896-Monotonic-Array\" class=\"headerlink\" title=\"896. Monotonic Array\"></a>896. Monotonic Array</h3><h4 id=\"判断一个数组是不是单调递增或递减。原题\"><a href=\"#判断一个数组是不是单调递增或递减。原题\" class=\"headerlink\" title=\"判断一个数组是不是单调递增或递减。原题\"></a>判断一个数组是不是单调递增或递减。<a href=\"https://leetcode.com/problems/monotonic-array/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [1,2,2,3]</span><br><span class=\"line\">Output: true</span><br><span class=\"line\"></span><br><span class=\"line\">Input: [6,5,4,4]</span><br><span class=\"line\">Output: true</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法一：迭代两次。但是由于是生成器，平均效率比下面要高。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isMonotonic</span><span class=\"params\">(self, A: <span class=\"string\">'List[int]'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> all(A[i] &lt;= A[i+<span class=\"number\">1</span>] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(A)<span class=\"number\">-1</span>)) <span class=\"keyword\">or</span> \\</span><br><span class=\"line\">           all(A[i] &gt;= A[i+<span class=\"number\">1</span>] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(A)<span class=\"number\">-1</span>))</span><br></pre></td></tr></table></figure>\n<p>方法二：迭代一次。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isMonotonic</span><span class=\"params\">(self, A: <span class=\"string\">'List[int]'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\">    increasing = decreasing = <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(A)<span class=\"number\">-1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> A[i+<span class=\"number\">1</span>] &gt; A[i]:</span><br><span class=\"line\">            decreasing = <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> A[i+<span class=\"number\">1</span>] &lt; A[i]:</span><br><span class=\"line\">            increasing = <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> decreasing <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> increasing:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<p>方法三：python2的一种写法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isMonotonic</span><span class=\"params\">(self, A)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">not</span> &#123;cmp(i, j) <span class=\"keyword\">for</span> i, j <span class=\"keyword\">in</span> zip(A, A[<span class=\"number\">1</span>:])&#125; &gt;= &#123;<span class=\"number\">1</span>, <span class=\"number\">-1</span>&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"977-Squares-of-a-Sorted-Array\"><a href=\"#977-Squares-of-a-Sorted-Array\" class=\"headerlink\" title=\"977. Squares of a Sorted Array\"></a>977. Squares of a Sorted Array</h3><h4 id=\"求一个有序数组，平方后的有序结果。原题\"><a href=\"#求一个有序数组，平方后的有序结果。原题\" class=\"headerlink\" title=\"求一个有序数组，平方后的有序结果。原题\"></a>求一个有序数组，平方后的有序结果。<a href=\"https://leetcode.com/problems/squares-of-a-sorted-array/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [-4,-1,0,3,10]</span><br><span class=\"line\">Output: [0,1,9,16,100]</span><br></pre></td></tr></table></figure>\n<p>方法一：双指针填充数组。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sortedSquares</span><span class=\"params\">(self, A: <span class=\"string\">'List[int]'</span>)</span> -&gt; 'List[int]':</span></span><br><span class=\"line\">    answer = [<span class=\"number\">0</span>] * len(A)</span><br><span class=\"line\">    l, r = <span class=\"number\">0</span>, len(A) - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> l &lt;= r:</span><br><span class=\"line\">        left, right = abs(A[l]), abs(A[r])</span><br><span class=\"line\">        <span class=\"keyword\">if</span> left &gt; right:</span><br><span class=\"line\">            answer[r - l] = left * left</span><br><span class=\"line\">            l += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            answer[r - l] = right * right</span><br><span class=\"line\">            r -= <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> answer</span><br></pre></td></tr></table></figure>\n<h3 id=\"941-Valid-Mountain-Array\"><a href=\"#941-Valid-Mountain-Array\" class=\"headerlink\" title=\"941. Valid Mountain Array\"></a>941. Valid Mountain Array</h3><h4 id=\"验证是否是山峰数组，前段单调增（不重复），后段单调减，必须是单峰值。原题\"><a href=\"#验证是否是山峰数组，前段单调增（不重复），后段单调减，必须是单峰值。原题\" class=\"headerlink\" title=\"验证是否是山峰数组，前段单调增（不重复），后段单调减，必须是单峰值。原题\"></a>验证是否是山峰数组，前段单调增（不重复），后段单调减，必须是单峰值。<a href=\"https://leetcode.com/problems/valid-mountain-array/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [0,3,2,1]</span><br><span class=\"line\">Output: true</span><br></pre></td></tr></table></figure>\n<p>方法一：传统迭代方式。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">validMountainArray</span><span class=\"params\">(self, A: <span class=\"string\">'List[int]'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\">    increasing = <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(A)<span class=\"number\">-1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> A[i] == A[i+<span class=\"number\">1</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> A[i] &gt; A[i+<span class=\"number\">1</span>]:</span><br><span class=\"line\">            increasing = <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> increasing <span class=\"keyword\">and</span> (A[i] &lt; A[i+<span class=\"number\">1</span>] <span class=\"keyword\">or</span> i ==<span class=\"number\">0</span>):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == len(A)<span class=\"number\">-2</span> <span class=\"keyword\">and</span> increasing:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> len(A) &gt;= <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：这个方法挺新颖，根据值来递增索引。中途暂停一下判断峰值是否在首位点。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">validMountainArray</span><span class=\"params\">(self, A: <span class=\"string\">'List[int]'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\">    l, r = <span class=\"number\">0</span>, len(A)<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> l &lt; r <span class=\"keyword\">and</span> A[l] &lt; A[l+<span class=\"number\">1</span>]:</span><br><span class=\"line\">        l += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> l==<span class=\"number\">0</span> <span class=\"keyword\">or</span> l == r:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> l &lt; r <span class=\"keyword\">and</span> A[l] &gt; A[l+<span class=\"number\">1</span>]:</span><br><span class=\"line\">        l += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> l == r</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：Lee神的双指针，想象两个人同时从左右两边爬山，最终是否相遇在一点。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">validMountainArray</span><span class=\"params\">(self, A: <span class=\"string\">'List[int]'</span>)</span> -&gt; 'bool':</span></span><br><span class=\"line\">    l, r, n = <span class=\"number\">0</span>, len(A)<span class=\"number\">-1</span>, len(A)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> l &lt; r <span class=\"keyword\">and</span> A[l] &lt; A[l+<span class=\"number\">1</span>]: l += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> r &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> A[r] &lt; A[r<span class=\"number\">-1</span>]: r -= <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span> &lt; l==r &lt; n<span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"845-Longest-Mountain-in-Array\"><a href=\"#845-Longest-Mountain-in-Array\" class=\"headerlink\" title=\"845. Longest Mountain in Array\"></a><a href=\"https://leetcode.com/problems/longest-mountain-in-array/\" target=\"_blank\" rel=\"noopener\">845. Longest Mountain in Array</a></h3><h4 id=\"数组中最长的山峰。题和字符串篇821一样的解法。\"><a href=\"#数组中最长的山峰。题和字符串篇821一样的解法。\" class=\"headerlink\" title=\"数组中最长的山峰。题和字符串篇821一样的解法。\"></a>数组中最长的山峰。题和字符串篇821一样的解法。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [2,1,4,7,3,2,5]</span><br><span class=\"line\">Output: 5</span><br><span class=\"line\">Explanation: The largest mountain is [1,4,7,3,2] which has length 5.</span><br></pre></td></tr></table></figure>\n<p>方法一：左右各遍历一次。此题有很多相似题都有这个解法。53 Maximum Subarray，121 Best Time to Buy and Sell Stock，152 Maximum Product Subarray，238 Product of Array Except Self，739 Daily Temperatures，769 Max Chunks to Make Sorted，770 Max Chunks to Make Sorted II，821 Shortest Distance to a Character，845 Longest Mountain in Array</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestMountain</span><span class=\"params\">(self, A: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    N = len(A)</span><br><span class=\"line\">    left = [<span class=\"number\">0</span>] * N</span><br><span class=\"line\">    right = [<span class=\"number\">0</span>] * N</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, N):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> A[i] &gt; A[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">            left[i] += left[i<span class=\"number\">-1</span>] + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(N<span class=\"number\">-1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>): </span><br><span class=\"line\">        <span class=\"keyword\">if</span> A[i] &lt; A[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">            right[i<span class=\"number\">-1</span>] += right[i] + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> max((l+r+<span class=\"number\">1</span> <span class=\"keyword\">for</span> l, r <span class=\"keyword\">in</span> zip(left, right) <span class=\"keyword\">if</span> l <span class=\"keyword\">and</span> r), default=<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：时间复杂度还可以优化，空间可以降到O(1)， 一次遍历。使用两个数字来表示上坡和下坡，当有下拨并且再次上坡时，或者相等的时候重置up,down为0。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestMountain</span><span class=\"params\">(self, A: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    res = up = down = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(A)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> down <span class=\"keyword\">and</span> A[i]&gt;A[i<span class=\"number\">-1</span>] <span class=\"keyword\">or</span> A[i]==A[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">            up = down = <span class=\"number\">0</span></span><br><span class=\"line\">        up += A[i] &gt; A[i<span class=\"number\">-1</span>]</span><br><span class=\"line\">        down += A[i] &lt; A[i<span class=\"number\">-1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> up <span class=\"keyword\">and</span> down: res = max(res, up+down+<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"942-DI-String-Match\"><a href=\"#942-DI-String-Match\" class=\"headerlink\" title=\"942. DI String Match\"></a>942. DI String Match</h3><h4 id=\"根据一个”IDID”字符串（I表示增加，D表示减少）生成一个数组，数组元素不能重复，答案不唯一。原题\"><a href=\"#根据一个”IDID”字符串（I表示增加，D表示减少）生成一个数组，数组元素不能重复，答案不唯一。原题\" class=\"headerlink\" title=\"根据一个”IDID”字符串（I表示增加，D表示减少）生成一个数组，数组元素不能重复，答案不唯一。原题\"></a>根据一个”IDID”字符串（I表示增加，D表示减少）生成一个数组，数组元素不能重复，答案不唯一。<a href=\"https://leetcode.com/problems/di-string-match/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: &quot;IDID&quot;</span><br><span class=\"line\">Output: [0,4,1,3,2]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">diStringMatch</span><span class=\"params\">(self, S: <span class=\"string\">'str'</span>)</span> -&gt; 'List[int]':</span></span><br><span class=\"line\">    l = r = <span class=\"number\">0</span></span><br><span class=\"line\">    ans = [<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> S:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> s == <span class=\"string\">'I'</span>:</span><br><span class=\"line\">            r += <span class=\"number\">1</span></span><br><span class=\"line\">            ans.append(r)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            l -= <span class=\"number\">1</span></span><br><span class=\"line\">            ans.append(l)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [x-l <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> ans]</span><br></pre></td></tr></table></figure>\n<h3 id=\"1007-Minimum-Domino-Rotations-For-Equal-Row\"><a href=\"#1007-Minimum-Domino-Rotations-For-Equal-Row\" class=\"headerlink\" title=\"1007. Minimum Domino Rotations For Equal Row\"></a>1007. Minimum Domino Rotations For Equal Row</h3><h4 id=\"旋转最小次，是上下的多米诺骨牌有一行全部相同。原题\"><a href=\"#旋转最小次，是上下的多米诺骨牌有一行全部相同。原题\" class=\"headerlink\" title=\"旋转最小次，是上下的多米诺骨牌有一行全部相同。原题\"></a>旋转最小次，是上下的多米诺骨牌有一行全部相同。<a href=\"https://leetcode.com/problems/minimum-domino-rotations-for-equal-row/\" target=\"_blank\" rel=\"noopener\">原题</a></h4>\n<p>方法一：竞赛时写的Brute Force.当时觉得炒鸡硬核。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minDominoRotations</span><span class=\"params\">(self, A: List[int], B: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    ans = reduce(<span class=\"keyword\">lambda</span> x, y: set(x) &amp; set(y), zip(A, B))</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> ans:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        a = set(ans).pop()</span><br><span class=\"line\">        dul = sum(a==c==d <span class=\"keyword\">for</span> c, d <span class=\"keyword\">in</span> zip(A, B))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> min(A.count(a), B.count(a)) - dul</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：Lee神的方法。有个地方想错了，想要算出重复的值，实际上就是求非目标值的最小值就行了。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minDominoRotations</span><span class=\"params\">(self, A: List[int], B: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    ans = reduce(<span class=\"keyword\">lambda</span> x, y: x &amp; y, map(set, zip(A, B)))</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> ans:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        a = ans.pop()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> min(len(A)-A.count(a), len(B)-B.count(a))</span><br></pre></td></tr></table></figure>\n<h3 id=\"48-Rotate-Image\"><a href=\"#48-Rotate-Image\" class=\"headerlink\" title=\"48. Rotate Image\"></a>48. Rotate Image</h3><h4 id=\"矩阵顺时针旋转90度。原题\"><a href=\"#矩阵顺时针旋转90度。原题\" class=\"headerlink\" title=\"矩阵顺时针旋转90度。原题\"></a>矩阵顺时针旋转90度。<a href=\"https://leetcode.com/problems/rotate-image/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Given input matrix &#x3D; </span><br><span class=\"line\">[</span><br><span class=\"line\">  [1,2,3],</span><br><span class=\"line\">  [4,5,6],</span><br><span class=\"line\">  [7,8,9]</span><br><span class=\"line\">],</span><br><span class=\"line\"></span><br><span class=\"line\">rotate the input matrix in-place such that it becomes:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [7,4,1],</span><br><span class=\"line\">  [8,5,2],</span><br><span class=\"line\">  [9,6,3]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>方法一：使用zip。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rotate</span><span class=\"params\">(self, matrix: List[List[int]])</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">\tmatrix[:] = list(zip(*reversed(matrix)))</span><br></pre></td></tr></table></figure>\n<p>方法二：通用写法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rotate</span><span class=\"params\">(self, matrix: List[List[int]])</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">    matrix.reverse()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(matrix)):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i+<span class=\"number\">1</span>, len(matrix[<span class=\"number\">0</span>])):</span><br><span class=\"line\">            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]</span><br></pre></td></tr></table></figure>\n<p>方法三：找到四个点，直接互换。</p>\n<img src=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%95%B0%E7%BB%84%E7%AF%87%EF%BC%89Array/rotate_img.png\" class width=\"300\" height=\"200\">\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rotate</span><span class=\"params\">(self, A: List[List[int]])</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">    n = len(A)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n//<span class=\"number\">2</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n-n//<span class=\"number\">2</span>):</span><br><span class=\"line\">            A[i][j], A[~j][i], A[~i][~j], A[j][~i] = \\</span><br><span class=\"line\">                     A[~j][i], A[~i][~j], A[j][~i], A[i][j]</span><br></pre></td></tr></table></figure>\n<h3 id=\"1020-Partition-Array-Into-Three-Parts-With-Equal-Sum\"><a href=\"#1020-Partition-Array-Into-Three-Parts-With-Equal-Sum\" class=\"headerlink\" title=\"1020. Partition Array Into Three Parts With Equal Sum\"></a>1020. Partition Array Into Three Parts With Equal Sum</h3><h4 id=\"一个数组是否可以分成三个和相同的部分。原题\"><a href=\"#一个数组是否可以分成三个和相同的部分。原题\" class=\"headerlink\" title=\"一个数组是否可以分成三个和相同的部分。原题\"></a>一个数组是否可以分成三个和相同的部分。<a href=\"https://leetcode.com/problems/partition-array-into-three-parts-with-equal-sum/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [0,2,1,-6,6,-7,9,1,2,0,1]</span><br><span class=\"line\">Output: true</span><br><span class=\"line\">Explanation: 0 + 2 + 1 &#x3D; -6 + 6 - 7 + 9 + 1 &#x3D; 2 + 0 + 1</span><br></pre></td></tr></table></figure>\n<p>方法一：竞赛时写的Time: O(n²)的方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">canThreePartsEqualSum</span><span class=\"params\">(self, A: List[int])</span> -&gt; bool:</span></span><br><span class=\"line\">    a = list(itertools.accumulate(A))</span><br><span class=\"line\">    n, a_set = len(a), set(a)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, total <span class=\"keyword\">in</span> enumerate(a):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> total==a[<span class=\"number\">-1</span>]//<span class=\"number\">3</span> <span class=\"keyword\">and</span> total*<span class=\"number\">2</span> <span class=\"keyword\">in</span> a_set:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> n<span class=\"number\">-1</span>-a[::<span class=\"number\">-1</span>].index(total*<span class=\"number\">2</span>) &gt; i:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：其实不需要遍历。每部分的和可以通过总和/3得到。比如每部分和为3，只要找到3和6，并且3在6的左边。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">canThreePartsEqualSum</span><span class=\"params\">(self, A: List[int])</span> -&gt; bool:</span></span><br><span class=\"line\">    a = list(itertools.accumulate(A))</span><br><span class=\"line\">    total = sum(A)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> total % <span class=\"number\">3</span> != <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    one = total // <span class=\"number\">3</span></span><br><span class=\"line\">    two = one * <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> one <span class=\"keyword\">in</span> a:</span><br><span class=\"line\">        l_index = a.index(one)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> two <span class=\"keyword\">in</span> a[l_index:]:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1021-Best-Sightseeing-Pair\"><a href=\"#1021-Best-Sightseeing-Pair\" class=\"headerlink\" title=\"1021. Best Sightseeing Pair\"></a>1021. Best Sightseeing Pair</h3><h4 id=\"得分最高的两个景点。原题\"><a href=\"#得分最高的两个景点。原题\" class=\"headerlink\" title=\"得分最高的两个景点。原题\"></a>得分最高的两个景点。<a href=\"https://leetcode.com/problems/best-sightseeing-pair/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>两个景点之间有距离。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [8,1,5,2,6]</span><br><span class=\"line\">Output: 11</span><br><span class=\"line\">Explanation: i &#x3D; 0, j &#x3D; 2, A[i] + A[j] + i - j &#x3D; 8 + 5 + 0 - 2 &#x3D; 11</span><br></pre></td></tr></table></figure>\n<p>方法一：<code>cur</code>保存着一个上一次最好的景点。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxScoreSightseeingPair</span><span class=\"params\">(self, A: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    cur = res = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> A:</span><br><span class=\"line\">        res = max(res, cur + a)</span><br><span class=\"line\">        cur = max(cur, a) - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"56-Merge-Intervals\"><a href=\"#56-Merge-Intervals\" class=\"headerlink\" title=\"56. Merge Intervals\"></a>56. Merge Intervals</h3><h4 id=\"合并时间段。如果时间段有重叠，则将其合并成一个。原题\"><a href=\"#合并时间段。如果时间段有重叠，则将其合并成一个。原题\" class=\"headerlink\" title=\"合并时间段。如果时间段有重叠，则将其合并成一个。原题\"></a>合并时间段。如果时间段有重叠，则将其合并成一个。<a href=\"https://leetcode.com/problems/merge-intervals/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class=\"line\">Output: [[1,6],[8,10],[15,18]]</span><br><span class=\"line\">Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].</span><br></pre></td></tr></table></figure>\n<p>方法一：先排序，在根据条件判断是合并还是修改。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class Interval:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, s=0, e=0):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.start = s</span></span><br><span class=\"line\"><span class=\"comment\">#         self.end = e</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge</span><span class=\"params\">(self, intervals: List[Interval])</span> -&gt; List[Interval]:</span></span><br><span class=\"line\">        intervals.sort(key=operator.attrgetter(<span class=\"string\">'start'</span>))</span><br><span class=\"line\">        ans = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> interval <span class=\"keyword\">in</span> intervals:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> ans <span class=\"keyword\">or</span> ans[<span class=\"number\">-1</span>].end &lt; interval.start:</span><br><span class=\"line\">                ans.append(interval)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                ans[<span class=\"number\">-1</span>].end = max(ans[<span class=\"number\">-1</span>].end, interval.end)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"57-Insert-Interval\"><a href=\"#57-Insert-Interval\" class=\"headerlink\" title=\"57. Insert Interval\"></a>57. Insert Interval</h3><h4 id=\"有一个排好序的时间段，并且没有重复，现在有一个新的段，要求插入其中，如果有重合需要合并。原题\"><a href=\"#有一个排好序的时间段，并且没有重复，现在有一个新的段，要求插入其中，如果有重合需要合并。原题\" class=\"headerlink\" title=\"有一个排好序的时间段，并且没有重复，现在有一个新的段，要求插入其中，如果有重合需要合并。原题\"></a>有一个排好序的时间段，并且没有重复，现在有一个新的段，要求插入其中，如果有重合需要合并。<a href=\"https://leetcode.com/problems/insert-interval/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: intervals &#x3D; [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval &#x3D; [4,8]</span><br><span class=\"line\">Output: [[1,2],[3,10],[12,16]]</span><br><span class=\"line\">Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].</span><br></pre></td></tr></table></figure>\n<p>方法一：用56的方法合并，使用二分法将其插入。140ms。这题本来想用二分法找到索引，然后前后切片做，后来发现边界太多不好判断，还是从头到尾遍历一遍比较稳。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">insert</span><span class=\"params\">(self, inter: List[List[int]], newInterval: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">    n = len(inter)</span><br><span class=\"line\">    i = bisect.insort(inter, [*newInterval])</span><br><span class=\"line\">    <span class=\"comment\"># print(inter, i)</span></span><br><span class=\"line\">    stack = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, n+<span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> stack <span class=\"keyword\">or</span> stack[<span class=\"number\">-1</span>][<span class=\"number\">1</span>] &lt; inter[j][<span class=\"number\">0</span>]:</span><br><span class=\"line\">            stack.append(inter[j])</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            stack[<span class=\"number\">-1</span>][<span class=\"number\">1</span>] = max(stack[<span class=\"number\">-1</span>][<span class=\"number\">1</span>], inter[j][<span class=\"number\">1</span>])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stack</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：stefan的方法1，我改了点，条件语句改成长度比较了。启发1，用长度记录索引，简洁明了。72ms</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">insert</span><span class=\"params\">(self, inter: List[List[int]], newInterval: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">    s, e = newInterval</span><br><span class=\"line\">    left = [i <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> inter <span class=\"keyword\">if</span> i[<span class=\"number\">1</span>] &lt; s]</span><br><span class=\"line\">    right = [i <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> inter <span class=\"keyword\">if</span> i[<span class=\"number\">0</span>] &gt; e]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(left) + len(right) != len(inter):</span><br><span class=\"line\">        s = min(s, inter[len(left)][<span class=\"number\">0</span>])</span><br><span class=\"line\">        e = max(e, inter[~len(right)][<span class=\"number\">1</span>])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> left + [[s, e]] + right</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：stefan的方法2，和方法二思路一样，写法上不同。right里添加时索引是-1。还有一种一次遍历的实现就是每次都求一下s, e。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">insert</span><span class=\"params\">(self, inter: List[List[int]], newInterval: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">    s, e = newInterval</span><br><span class=\"line\">    parts = merge, left, right = [], [], []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> start, end <span class=\"keyword\">in</span> inter:</span><br><span class=\"line\">        parts[(end&lt;s) - (start&gt;e)].append((start, end))</span><br><span class=\"line\">    <span class=\"keyword\">if</span> merge:</span><br><span class=\"line\">        s = min(s, merge[<span class=\"number\">0</span>][<span class=\"number\">0</span>])</span><br><span class=\"line\">        e = max(e, merge[<span class=\"number\">-1</span>][<span class=\"number\">-1</span>])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> left + [[s, e]] + right</span><br></pre></td></tr></table></figure>\n<h3 id=\"1030-Matrix-Cells-in-Distance-Order\"><a href=\"#1030-Matrix-Cells-in-Distance-Order\" class=\"headerlink\" title=\"1030. Matrix Cells in Distance Order\"></a>1030. Matrix Cells in Distance Order</h3><h4 id=\"矩阵坐标距离指定点的排序。原题\"><a href=\"#矩阵坐标距离指定点的排序。原题\" class=\"headerlink\" title=\"矩阵坐标距离指定点的排序。原题\"></a>矩阵坐标距离指定点的排序。<a href=\"https://leetcode.com/problems/matrix-cells-in-distance-order/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: R &#x3D; 2, C &#x3D; 2, r0 &#x3D; 0, c0 &#x3D; 1</span><br><span class=\"line\">Output: [[0,1],[0,0],[1,1],[1,0]]</span><br><span class=\"line\">Explanation: The distances from (r0, c0) to other cells are: [0,1,1,2]</span><br><span class=\"line\">The answer [[0,1],[1,1],[0,0],[1,0]] would also be accepted as correct.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">allCellsDistOrder</span><span class=\"params\">(self, R: int, C: int, r0: int, c0: int)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">    cells = [[x, y] <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(R) <span class=\"keyword\">for</span> y <span class=\"keyword\">in</span> range(C)]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sorted(cells, key=<span class=\"keyword\">lambda</span> x: abs(x[<span class=\"number\">0</span>]-r0)+abs(x[<span class=\"number\">1</span>]-c0))</span><br></pre></td></tr></table></figure>\n<h3 id=\"1033-Moving-Stones-Until-Consecutive\"><a href=\"#1033-Moving-Stones-Until-Consecutive\" class=\"headerlink\" title=\"1033. Moving Stones Until Consecutive\"></a>1033. Moving Stones Until Consecutive</h3><h4 id=\"三个石子移到连续的位置，最少和最多需要几步。原题\"><a href=\"#三个石子移到连续的位置，最少和最多需要几步。原题\" class=\"headerlink\" title=\"三个石子移到连续的位置，最少和最多需要几步。原题\"></a>三个石子移到连续的位置，最少和最多需要几步。<a href=\"https://leetcode.com/problems/moving-stones-until-consecutive/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: a &#x3D; 1, b &#x3D; 2, c &#x3D; 5</span><br><span class=\"line\">Output: [1,2]</span><br><span class=\"line\">Explanation: Move the stone from 5 to 3, or move the stone from 5 to 4 to 3.</span><br><span class=\"line\">Input: a &#x3D; 4, b &#x3D; 3, c &#x3D; 2</span><br><span class=\"line\">Output: [0,0]</span><br><span class=\"line\">Explanation: We cannot make any moves.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numMovesStones</span><span class=\"params\">(self, a: int, b: int, c: int)</span> -&gt; List[int]:</span></span><br><span class=\"line\">    a, b, c = sorted((a, b, c))</span><br><span class=\"line\">    <span class=\"keyword\">if</span> c-b==<span class=\"number\">1</span> <span class=\"keyword\">and</span> b-a==<span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>, c-a<span class=\"number\">-2</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> c-b&lt;=<span class=\"number\">2</span> <span class=\"keyword\">or</span> b-a&lt;=<span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>, c-a<span class=\"number\">-2</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">2</span>, c-a<span class=\"number\">-2</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1051-Height-Checker\"><a href=\"#1051-Height-Checker\" class=\"headerlink\" title=\"1051. Height Checker\"></a>1051. Height Checker</h3><h4 id=\"高度检查。原题\"><a href=\"#高度检查。原题\" class=\"headerlink\" title=\"高度检查。原题\"></a>高度检查。<a href=\"https://leetcode.com/problems/height-checker/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">heightChecker</span><span class=\"params\">(self, heights: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(a!=b <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> zip(heights, sorted(heights)))</span><br></pre></td></tr></table></figure>\n<h3 id=\"1052-Grumpy-Bookstore-Owner\"><a href=\"#1052-Grumpy-Bookstore-Owner\" class=\"headerlink\" title=\"1052. Grumpy Bookstore Owner\"></a>1052. Grumpy Bookstore Owner</h3><h4 id=\"这题描述的比较抽象，其实就是一个滑动窗口的问题。原题\"><a href=\"#这题描述的比较抽象，其实就是一个滑动窗口的问题。原题\" class=\"headerlink\" title=\"这题描述的比较抽象，其实就是一个滑动窗口的问题。原题\"></a>这题描述的比较抽象，其实就是一个滑动窗口的问题。<a href=\"https://leetcode.com/problems/grumpy-bookstore-owner/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：一开始我用的双端队列，并且使用了compress.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxSatisfied</span><span class=\"params\">(self, customers: List[int], grumpy: List[int], X: int)</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> itertools <span class=\"keyword\">import</span> compress</span><br><span class=\"line\">    <span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> deque</span><br><span class=\"line\">    base_satisfied = sum(compress(customers, map(<span class=\"keyword\">lambda</span> x: x^<span class=\"number\">1</span>, grumpy)))</span><br><span class=\"line\">    q = deque([customers[i] <span class=\"keyword\">if</span> grumpy[i]==<span class=\"number\">1</span> <span class=\"keyword\">else</span> <span class=\"number\">0</span>  <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(X)])</span><br><span class=\"line\">    cur_sum = <span class=\"number\">0</span></span><br><span class=\"line\">    max_sum = cur_sum</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(grumpy)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> grumpy[i] == <span class=\"number\">1</span>:</span><br><span class=\"line\">            q.append(customers[i])</span><br><span class=\"line\">            cur_sum += q[<span class=\"number\">-1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            q.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">        cur_sum -= q.popleft()</span><br><span class=\"line\">        max_sum = max(max_sum, cur_sum)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max_sum + base_satisfied</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：其实不需要双端队列。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxSatisfied</span><span class=\"params\">(self, customers: List[int], grumpy: List[int], X: int)</span> -&gt; int:</span></span><br><span class=\"line\">    n = len(grumpy)</span><br><span class=\"line\">    base = sum(c <span class=\"keyword\">for</span> c, g <span class=\"keyword\">in</span> zip(customers, grumpy) <span class=\"keyword\">if</span> g == <span class=\"number\">0</span>)</span><br><span class=\"line\">    max_added = added = sum(c <span class=\"keyword\">for</span> c, g <span class=\"keyword\">in</span> zip(customers, grumpy[:X]) <span class=\"keyword\">if</span> g == <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(X, n):</span><br><span class=\"line\">        added -= customers[i-X] * grumpy[i-X]</span><br><span class=\"line\">        added += customers[i] * grumpy[i]</span><br><span class=\"line\">        max_added = max(max_added, added)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max_added + base</span><br></pre></td></tr></table></figure>\n<h3 id=\"1139-Largest-1-Bordered-Square\"><a href=\"#1139-Largest-1-Bordered-Square\" class=\"headerlink\" title=\"1139. Largest 1-Bordered Square\"></a>1139. Largest 1-Bordered Square</h3><h4 id=\"最大的以1为边长的正方形。原题\"><a href=\"#最大的以1为边长的正方形。原题\" class=\"headerlink\" title=\"最大的以1为边长的正方形。原题\"></a>最大的以1为边长的正方形。<a href=\"https://leetcode.com/problems/largest-1-bordered-square/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: grid &#x3D; [[1,1,1],[1,0,1],[1,1,1]]</span><br><span class=\"line\">Output: 9</span><br></pre></td></tr></table></figure>\n<p>方法一：开始以为像其他小岛问题那样，要回溯延伸。其实此题是暴力法。先对数组进行一个预处理，判断每个点上面和左面连续的1的个数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">largest1BorderedSquare</span><span class=\"params\">(self, g: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    R, C = len(g), len(g[<span class=\"number\">0</span>])</span><br><span class=\"line\">    <span class=\"keyword\">from</span> copy <span class=\"keyword\">import</span> deepcopy</span><br><span class=\"line\">    top, left = deepcopy(g), deepcopy(g)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(R):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(C):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> g[i][j]:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> i: top[i][j] = top[i - <span class=\"number\">1</span>][j] + <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> j: left[i][j] = left[i][j - <span class=\"number\">1</span>] + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> range(min(R, C), <span class=\"number\">0</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(R-w+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(C-w+<span class=\"number\">1</span>):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> top[i+w<span class=\"number\">-1</span>][j] &gt;= w <span class=\"keyword\">and</span> top[i+w<span class=\"number\">-1</span>][j+w<span class=\"number\">-1</span>] &gt;= w:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> left[i][j+w<span class=\"number\">-1</span>] &gt;= w <span class=\"keyword\">and</span> left[i+w<span class=\"number\">-1</span>][j+w<span class=\"number\">-1</span>] &gt;= w:</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> w * w</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1078-Occurrences-After-Bigram\"><a href=\"#1078-Occurrences-After-Bigram\" class=\"headerlink\" title=\"1078. Occurrences After Bigram\"></a>1078. Occurrences After Bigram</h3><h4 id=\"打印第三个单词。原题\"><a href=\"#打印第三个单词。原题\" class=\"headerlink\" title=\"打印第三个单词。原题\"></a>打印第三个单词。<a href=\"https://leetcode.com/problems/occurrences-after-bigram/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: text &#x3D; &quot;alice is a good girl she is a good student&quot;, first &#x3D; &quot;a&quot;, second &#x3D; &quot;good&quot;</span><br><span class=\"line\">Output: [&quot;girl&quot;,&quot;student&quot;]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findOcurrences</span><span class=\"params\">(self, text: str, first: str, second: str)</span> -&gt; List[str]:</span></span><br><span class=\"line\">    words = text.split()</span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(words)<span class=\"number\">-2</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> words[i] == first <span class=\"keyword\">and</span> words[i+<span class=\"number\">1</span>] == second:</span><br><span class=\"line\">            ans.append(words[i+<span class=\"number\">2</span>]) </span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"1144-Decrease-Elements-To-Make-Array-Zigzag\"><a href=\"#1144-Decrease-Elements-To-Make-Array-Zigzag\" class=\"headerlink\" title=\"1144. Decrease Elements To Make Array Zigzag\"></a>1144. Decrease Elements To Make Array Zigzag</h3><h4 id=\"每次操作某个元素-1，多少次操作后，可以使数组称为一个zigzag。原题\"><a href=\"#每次操作某个元素-1，多少次操作后，可以使数组称为一个zigzag。原题\" class=\"headerlink\" title=\"每次操作某个元素-1，多少次操作后，可以使数组称为一个zigzag。原题\"></a>每次操作某个元素-1，多少次操作后，可以使数组称为一个zigzag。<a href=\"https://leetcode.com/problems/decrease-elements-to-make-array-zigzag/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [9,6,1,6,2]</span><br><span class=\"line\">Output: 4</span><br></pre></td></tr></table></figure>\n<p>方法一：暴力的方法。遍历两次。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">movesToMakeZigzag</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    n = len(nums)</span><br><span class=\"line\">    even_sum = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n, <span class=\"number\">2</span>):</span><br><span class=\"line\">        left = float(<span class=\"string\">'inf'</span>) <span class=\"keyword\">if</span> i == <span class=\"number\">0</span> <span class=\"keyword\">else</span> nums[i<span class=\"number\">-1</span>]</span><br><span class=\"line\">        right = float(<span class=\"string\">'inf'</span>) <span class=\"keyword\">if</span> i == n<span class=\"number\">-1</span> <span class=\"keyword\">else</span> nums[i+<span class=\"number\">1</span>]</span><br><span class=\"line\">        to_add = nums[i]-min(left, right)+<span class=\"number\">1</span></span><br><span class=\"line\">        even_sum += to_add <span class=\"keyword\">if</span> to_add &gt; <span class=\"number\">0</span> <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    odd_sum = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, n, <span class=\"number\">2</span>):</span><br><span class=\"line\">        left = float(<span class=\"string\">'inf'</span>) <span class=\"keyword\">if</span> i == <span class=\"number\">0</span> <span class=\"keyword\">else</span> nums[i<span class=\"number\">-1</span>]</span><br><span class=\"line\">        right = float(<span class=\"string\">'inf'</span>) <span class=\"keyword\">if</span> i == n<span class=\"number\">-1</span> <span class=\"keyword\">else</span> nums[i+<span class=\"number\">1</span>]</span><br><span class=\"line\">        to_min = nums[i]-min(left, right)+<span class=\"number\">1</span></span><br><span class=\"line\">        odd_sum += to_min <span class=\"keyword\">if</span> to_min &gt; <span class=\"number\">0</span> <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> min(even_sum, odd_sum)</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：利用奇偶性，整合到一次循环。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">movesToMakeZigzag</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    ans = [<span class=\"number\">0</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\">    ary = [float(<span class=\"string\">'inf'</span>)] + nums + [float(<span class=\"string\">'inf'</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(ary)<span class=\"number\">-1</span>):  </span><br><span class=\"line\">        ans[i % <span class=\"number\">2</span>] += max(<span class=\"number\">0</span>, ary[i]-min(ary[i<span class=\"number\">-1</span>], ary[i+<span class=\"number\">1</span>])+<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min(ans)</span><br></pre></td></tr></table></figure>\n<h3 id=\"1089-Duplicate-Zeros\"><a href=\"#1089-Duplicate-Zeros\" class=\"headerlink\" title=\"1089. Duplicate Zeros\"></a>1089. Duplicate Zeros</h3><h4 id=\"复制数组中的0，数组长度不变，多出的元素将被“挤掉”。要求在原数组上修改。原题\"><a href=\"#复制数组中的0，数组长度不变，多出的元素将被“挤掉”。要求在原数组上修改。原题\" class=\"headerlink\" title=\"复制数组中的0，数组长度不变，多出的元素将被“挤掉”。要求在原数组上修改。原题\"></a>复制数组中的0，数组长度不变，多出的元素将被“挤掉”。要求在原数组上修改。<a href=\"https://leetcode.com/problems/duplicate-zeros/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [1,0,2,3,0,4,5,0]</span><br><span class=\"line\">Output: null</span><br><span class=\"line\">Explanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4]</span><br></pre></td></tr></table></figure>\n<p>方法一：竞赛时的方法，需要注意末尾不要多加0。空间复杂度过高。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">duplicateZeros</span><span class=\"params\">(self, arr: List[int])</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># arr_reversed = arr[::-1]</span></span><br><span class=\"line\">    <span class=\"comment\"># ans = []</span></span><br><span class=\"line\">    <span class=\"comment\"># while len(ans) &lt; len(arr):</span></span><br><span class=\"line\">    <span class=\"comment\">#     val = arr_reversed.pop()</span></span><br><span class=\"line\">    <span class=\"comment\">#     if val == 0 and len(ans) &lt; len(arr)-1:</span></span><br><span class=\"line\">    <span class=\"comment\">#         ans.extend([0, 0])</span></span><br><span class=\"line\">    <span class=\"comment\">#     else:</span></span><br><span class=\"line\">    <span class=\"comment\">#         ans.append(val)</span></span><br><span class=\"line\">    <span class=\"comment\"># arr[:] = ans</span></span><br><span class=\"line\">    arr[:] = [x <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> arr <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> ([a] <span class=\"keyword\">if</span> a <span class=\"keyword\">else</span> [<span class=\"number\">0</span>, <span class=\"number\">0</span>])][:len(arr)]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：双指针的O(1)Space。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">duplicateZeros</span><span class=\"params\">(self, arr: List[int])</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">    zero_c = arr.count(<span class=\"number\">0</span>)</span><br><span class=\"line\">    n = len(arr)</span><br><span class=\"line\">    j = n + zero_c - <span class=\"number\">1</span></span><br><span class=\"line\">    i = n - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> i &gt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> arr[i] != <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> j &lt; n:</span><br><span class=\"line\">                arr[j] = arr[i]</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> j &lt; n:</span><br><span class=\"line\">                arr[j] = arr[i]</span><br><span class=\"line\">            j -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> j &lt; n:</span><br><span class=\"line\">                arr[j] = arr[i]</span><br><span class=\"line\">        j -= <span class=\"number\">1</span></span><br><span class=\"line\">        i -= <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1169-Invalid-Transactions\"><a href=\"#1169-Invalid-Transactions\" class=\"headerlink\" title=\"1169. Invalid Transactions\"></a>1169. Invalid Transactions</h3><h4 id=\"非法交易，单笔金额大于1000，或者60分钟内有异地交易，那么为非法交易。列出所有的非法交易。原题\"><a href=\"#非法交易，单笔金额大于1000，或者60分钟内有异地交易，那么为非法交易。列出所有的非法交易。原题\" class=\"headerlink\" title=\"非法交易，单笔金额大于1000，或者60分钟内有异地交易，那么为非法交易。列出所有的非法交易。原题\"></a>非法交易，单笔金额大于1000，或者60分钟内有异地交易，那么为非法交易。列出所有的非法交易。<a href=\"https://leetcode.com/problems/invalid-transactions/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: transactions &#x3D; [&quot;alice,20,800,mtv&quot;,&quot;alice,50,100,beijing&quot;]</span><br><span class=\"line\">Output: [&quot;alice,20,800,mtv&quot;,&quot;alice,50,100,beijing&quot;]</span><br><span class=\"line\">Explanation: The first transaction is invalid because the second transaction occurs within a difference of 60 minutes, have the same name and is in a different city. Similarly the second one is invalid too.</span><br></pre></td></tr></table></figure>\n<p>方法一：暴力法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">invalidTransactions</span><span class=\"params\">(self, transactions: List[str])</span> -&gt; List[str]:</span></span><br><span class=\"line\">    ts = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> transactions:</span><br><span class=\"line\">        name, time, amount, city = line.split(<span class=\"string\">','</span>)</span><br><span class=\"line\">        ts.append((name, time, amount, city))</span><br><span class=\"line\">    city_times = collections.defaultdict(list)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> ts:</span><br><span class=\"line\">        city_times[t[<span class=\"number\">0</span>]+<span class=\"string\">','</span>+t[<span class=\"number\">3</span>]].append(int(t[<span class=\"number\">1</span>]))</span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> ts:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> int(t[<span class=\"number\">2</span>]) &gt; <span class=\"number\">1000</span>:</span><br><span class=\"line\">            ans.append(<span class=\"string\">','</span>.join(t))</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            diff_cities = (c <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> city_times.keys() <span class=\"keyword\">if</span> c!=t[<span class=\"number\">0</span>]+<span class=\"string\">','</span>+t[<span class=\"number\">3</span>] <span class=\"keyword\">and</span> c.startswith(t[<span class=\"number\">0</span>]+<span class=\"string\">','</span>))</span><br><span class=\"line\">            <span class=\"keyword\">for</span> d_c <span class=\"keyword\">in</span> diff_cities:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> any(abs(tt-int(t[<span class=\"number\">1</span>])) &lt;= <span class=\"number\">60</span> <span class=\"keyword\">for</span> tt <span class=\"keyword\">in</span> city_times[d_c]):</span><br><span class=\"line\">                    ans.append(<span class=\"string\">','</span>.join(t))</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"1170-Compare-Strings-by-Frequency-of-the-Smallest-Character\"><a href=\"#1170-Compare-Strings-by-Frequency-of-the-Smallest-Character\" class=\"headerlink\" title=\"1170. Compare Strings by Frequency of the Smallest Character\"></a>1170. Compare Strings by Frequency of the Smallest Character</h3><h4 id=\"比较最小字符的频率。原题\"><a href=\"#比较最小字符的频率。原题\" class=\"headerlink\" title=\"比较最小字符的频率。原题\"></a>比较最小字符的频率。<a href=\"https://leetcode.com/problems/compare-strings-by-frequency-of-the-smallest-character/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: queries &#x3D; [&quot;cbd&quot;], words &#x3D; [&quot;zaaaz&quot;]</span><br><span class=\"line\">Output: [1]</span><br><span class=\"line\">Explanation: On the first query we have f(&quot;cbd&quot;) &#x3D; 1, f(&quot;zaaaz&quot;) &#x3D; 3 so f(&quot;cbd&quot;) &lt; f(&quot;zaaaz&quot;).</span><br></pre></td></tr></table></figure>\n<p>方法一：暴力法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numSmallerByFrequency</span><span class=\"params\">(self, queries: List[str], words: List[str])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    qq = [q.count(min(q)) <span class=\"keyword\">for</span> q <span class=\"keyword\">in</span> queries]</span><br><span class=\"line\">    ww = [w.count(min(w)) <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> words]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [sum(q &lt; w <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> ww) <span class=\"keyword\">for</span> q <span class=\"keyword\">in</span> qq]</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：二分法</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numSmallerByFrequency</span><span class=\"params\">(self, queries: List[str], words: List[str])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    qq = [q.count(min(q)) <span class=\"keyword\">for</span> q <span class=\"keyword\">in</span> queries]</span><br><span class=\"line\">    ww = [w.count(min(w)) <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> words]</span><br><span class=\"line\">    ww.sort()</span><br><span class=\"line\">    n = len(ww)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [n-bisect.bisect_right(ww, q) <span class=\"keyword\">for</span> q <span class=\"keyword\">in</span> qq]</span><br></pre></td></tr></table></figure>\n<h3 id=\"1122-Relative-Sort-Array\"><a href=\"#1122-Relative-Sort-Array\" class=\"headerlink\" title=\"1122. Relative Sort Array\"></a>1122. Relative Sort Array</h3><h4 id=\"按照数组2的相对位置给另一个数组排序。原题\"><a href=\"#按照数组2的相对位置给另一个数组排序。原题\" class=\"headerlink\" title=\"按照数组2的相对位置给另一个数组排序。原题\"></a>按照数组2的相对位置给另一个数组排序。<a href=\"https://leetcode.com/contest/weekly-contest-145/problems/relative-sort-array/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：和Lee神写法不谋而合，只不过自己用了乘法，其实加法就可以了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">relativeSortArray</span><span class=\"params\">(self, arr1: List[int], arr2: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    index = &#123;d: i <span class=\"keyword\">for</span> i, d <span class=\"keyword\">in</span> enumerate(arr2)&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sorted(arr1, key=<span class=\"keyword\">lambda</span> x: index.get(x, <span class=\"number\">1000</span>+x))</span><br></pre></td></tr></table></figure>\n<h3 id=\"1176-Diet-Plan-Performance\"><a href=\"#1176-Diet-Plan-Performance\" class=\"headerlink\" title=\"1176. Diet Plan Performance\"></a>1176. Diet Plan Performance</h3><h4 id=\"燃烧你的卡路里，卡路里和体重的关系。原题\"><a href=\"#燃烧你的卡路里，卡路里和体重的关系。原题\" class=\"headerlink\" title=\"燃烧你的卡路里，卡路里和体重的关系。原题\"></a>燃烧你的卡路里，卡路里和体重的关系。<a href=\"https://leetcode.com/problems/diet-plan-performance/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: calories &#x3D; [1,2,3,4,5], k &#x3D; 1, lower &#x3D; 3, upper &#x3D; 3</span><br><span class=\"line\">Output: 0</span><br><span class=\"line\">Explanation: Since k &#x3D; 1, we consider each element of the array separately and compare it to lower and upper.</span><br><span class=\"line\">calories[0] and calories[1] are less than lower so 2 points are lost.</span><br><span class=\"line\">calories[3] and calories[4] are greater than upper so 2 points are gained.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dietPlanPerformance</span><span class=\"params\">(self, calories: List[int], k: int, lower: int, upper: int)</span> -&gt; int:</span></span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    calories.insert(<span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    cur_sum = sum(calories[:k])</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(calories)-k+<span class=\"number\">1</span>):</span><br><span class=\"line\">        cur_sum -= calories[i<span class=\"number\">-1</span>]</span><br><span class=\"line\">        cur_sum += calories[i+k<span class=\"number\">-1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cur_sum &gt; upper:</span><br><span class=\"line\">            ans += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> cur_sum &lt; lower:</span><br><span class=\"line\">            ans -= <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"1395-Count-Number-of-Teams\"><a href=\"#1395-Count-Number-of-Teams\" class=\"headerlink\" title=\"1395. Count Number of Teams\"></a>1395. Count Number of Teams</h3><h4 id=\"数字分组计数。原题\"><a href=\"#数字分组计数。原题\" class=\"headerlink\" title=\"数字分组计数。原题\"></a>数字分组计数。<a href=\"https://leetcode.com/problems/count-number-of-teams/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: rating &#x3D; [2,5,3,4,1]</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: We can form three teams given the conditions. (2,3,4), (5,4,1), (5,3,1).</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numTeams</span><span class=\"params\">(self, rating: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> defaultdict</span><br><span class=\"line\">    n = len(rating)</span><br><span class=\"line\">    greater = defaultdict(int)</span><br><span class=\"line\">    less = defaultdict(int)</span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i+<span class=\"number\">1</span>, n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> rating[i] &gt; rating[j]:</span><br><span class=\"line\">                less[i] += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                greater[i] += <span class=\"number\">1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n<span class=\"number\">-2</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i+<span class=\"number\">1</span>, n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> rating[i] &gt; rating[j]:</span><br><span class=\"line\">                ans += less[j]</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                ans += greater[j]</span><br><span class=\"line\">                </span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"1375-Bulb-Switcher-III\"><a href=\"#1375-Bulb-Switcher-III\" class=\"headerlink\" title=\"1375. Bulb Switcher III\"></a>1375. Bulb Switcher III</h3><h4 id=\"灯泡开关，记录灯泡全部变蓝的次数。原题\"><a href=\"#灯泡开关，记录灯泡全部变蓝的次数。原题\" class=\"headerlink\" title=\"灯泡开关，记录灯泡全部变蓝的次数。原题\"></a>灯泡开关，记录灯泡全部变蓝的次数。<a href=\"https://leetcode.com/problems/bulb-switcher-iii/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: light &#x3D; [2,1,3,5,4]</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: All bulbs turned on, are blue at the moment 1, 2 and 4.</span><br></pre></td></tr></table></figure>\n<p>方法一：使用堆。其实没必要增加O(n)的空间</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numTimesAllBlue</span><span class=\"params\">(self, light: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">import</span> heapq <span class=\"keyword\">as</span> hq</span><br><span class=\"line\">    s = []</span><br><span class=\"line\">    hq.heapify(s)</span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, b <span class=\"keyword\">in</span> enumerate(light, <span class=\"number\">1</span>):</span><br><span class=\"line\">        hq.heappush(s, -b)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> -s[<span class=\"number\">0</span>] == i:</span><br><span class=\"line\">            ans += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：只需要维护一个最大值变量即可</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numTimesAllBlue</span><span class=\"params\">(self, light: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    cur_max = ans = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, b <span class=\"keyword\">in</span> enumerate(light, <span class=\"number\">1</span>):</span><br><span class=\"line\">        cur_max = max(cur_max, b)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cur_max == i:</span><br><span class=\"line\">            ans += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：一行</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numTimesAllBlue</span><span class=\"params\">(self, light: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(i==b <span class=\"keyword\">for</span> i, b <span class=\"keyword\">in</span> enumerate(itertools.accumulate(light, max), <span class=\"number\">1</span>))</span><br></pre></td></tr></table></figure>\n<h3 id=\"498-Diagonal-Traverse\"><a href=\"#498-Diagonal-Traverse\" class=\"headerlink\" title=\"498. Diagonal Traverse\"></a>498. Diagonal Traverse</h3><h4 id=\"对角线z字形遍历。原题\"><a href=\"#对角线z字形遍历。原题\" class=\"headerlink\" title=\"对角线z字形遍历。原题\"></a>对角线z字形遍历。<a href=\"https://leetcode.com/problems/diagonal-traverse/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：费劲心思去找i,j的关系，其实只需要知道一点，i和j都是越来越大的就行。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findDiagonalOrder</span><span class=\"params\">(self, matrix: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> matrix:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> []</span><br><span class=\"line\">    dd = collections.defaultdict(list)</span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    m, n = len(matrix), len(matrix[<span class=\"number\">0</span>])</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            dd[i+j].append(matrix[i][j])</span><br><span class=\"line\">    <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(m+n<span class=\"number\">-1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> k % <span class=\"number\">2</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">            dd[k].reverse()</span><br><span class=\"line\">        ans.extend(dd[k])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"1424-Diagonal-Traverse-II\"><a href=\"#1424-Diagonal-Traverse-II\" class=\"headerlink\" title=\"1424. Diagonal Traverse II\"></a>1424. Diagonal Traverse II</h3><h4 id=\"对角线遍历，每行长度可能不一样。原题\"><a href=\"#对角线遍历，每行长度可能不一样。原题\" class=\"headerlink\" title=\"对角线遍历，每行长度可能不一样。原题\"></a>对角线遍历，每行长度可能不一样。<a href=\"https://leetcode.com/problems/diagonal-traverse-ii/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findDiagonalOrder</span><span class=\"params\">(self, g: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    res = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, r <span class=\"keyword\">in</span> enumerate(g):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j, a <span class=\"keyword\">in</span> enumerate(r):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(res) &lt;= i + j:</span><br><span class=\"line\">                res.append([])</span><br><span class=\"line\">            res[i + j].append(a)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [a <span class=\"keyword\">for</span> r <span class=\"keyword\">in</span> res <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> reversed(r)]</span><br></pre></td></tr></table></figure>\n<h3 id=\"1365-How-Many-Numbers-Are-Smaller-Than-the-Current-Number\"><a href=\"#1365-How-Many-Numbers-Are-Smaller-Than-the-Current-Number\" class=\"headerlink\" title=\"1365. How Many Numbers Are Smaller Than the Current Number\"></a>1365. How Many Numbers Are Smaller Than the Current Number</h3><h4 id=\"数组中比当前数小的个数。原题\"><a href=\"#数组中比当前数小的个数。原题\" class=\"headerlink\" title=\"数组中比当前数小的个数。原题\"></a>数组中比当前数小的个数。<a href=\"https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：排序。T=O(n*lgn)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">smallerNumbersThanCurrent</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    indices = &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, d <span class=\"keyword\">in</span> enumerate(sorted(nums)):</span><br><span class=\"line\">        indices.setdefault(d, i)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [indices[d] <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> nums]</span><br></pre></td></tr></table></figure>\n<p>方法二：利用了数的范围在1~100之间。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">smallerNumbersThanCurrent</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    count = [<span class=\"number\">0</span>] * <span class=\"number\">102</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        count[num+<span class=\"number\">1</span>] += <span class=\"number\">1</span></span><br><span class=\"line\">    count = list(itertools.accumulate(count))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [count[num] <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums]</span><br></pre></td></tr></table></figure>\n<h3 id=\"1366-Rank-Teams-by-Votes\"><a href=\"#1366-Rank-Teams-by-Votes\" class=\"headerlink\" title=\"1366. Rank Teams by Votes\"></a>1366. Rank Teams by Votes</h3><h4 id=\"投票选举。首先按照排名，然后按照字母顺序。原题\"><a href=\"#投票选举。首先按照排名，然后按照字母顺序。原题\" class=\"headerlink\" title=\"投票选举。首先按照排名，然后按照字母顺序。原题\"></a>投票选举。首先按照排名，然后按照字母顺序。<a href=\"https://leetcode.com/problems/rank-teams-by-votes/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: votes &#x3D; [&quot;ABC&quot;,&quot;ACB&quot;,&quot;ABC&quot;,&quot;ACB&quot;,&quot;ACB&quot;]</span><br><span class=\"line\">Output: &quot;ACB&quot;</span><br><span class=\"line\">Explanation: Team A was ranked first place by 5 voters. No other team was voted as first place so team A is the first team.</span><br><span class=\"line\">Team B was ranked second by 2 voters and was ranked third by 3 voters.</span><br><span class=\"line\">Team C was ranked second by 3 voters and was ranked third by 2 voters.</span><br><span class=\"line\">As most of the voters ranked C second, team C is the second team and team B is the third.</span><br><span class=\"line\"></span><br><span class=\"line\">Input: votes &#x3D; [&quot;WXYZ&quot;,&quot;XYZW&quot;]</span><br><span class=\"line\">Output: &quot;XWYZ&quot;</span><br><span class=\"line\">Explanation: X is the winner due to tie-breaking rule. X has same votes as W for the first position but X has one vote as second position while W doesn&#39;t have any votes as second position.</span><br></pre></td></tr></table></figure>\n<p>方法一：列举了所有的票数，然后对tuple进行排序。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rankTeams</span><span class=\"params\">(self, votes: List[str])</span> -&gt; str:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Counter, defaultdict</span><br><span class=\"line\">    cc = defaultdict(<span class=\"keyword\">lambda</span> : [<span class=\"number\">0</span>]*<span class=\"number\">26</span>)</span><br><span class=\"line\">    i = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> zip(*votes):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> k, v <span class=\"keyword\">in</span> Counter(w).items():</span><br><span class=\"line\">            cc[k][i] = v</span><br><span class=\"line\">        i += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"comment\"># print(cc)</span></span><br><span class=\"line\">    cmp = (tuple(p) + (-ord(a), a) <span class=\"keyword\">for</span> a, p <span class=\"keyword\">in</span> cc.items())</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(x[<span class=\"number\">-1</span>] <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> sorted(cmp, reverse=<span class=\"literal\">True</span>))</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：忽略了一个问题，其实每个人都需要对所有人投票。根据第一个来进行初始化。数组同样可以比较大小，无须转化为tuple</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rankTeams</span><span class=\"params\">(self, votes: List[str])</span> -&gt; str:</span></span><br><span class=\"line\">    count = &#123;c: [<span class=\"number\">0</span>] * len(votes[<span class=\"number\">0</span>]) + [c] <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> votes[<span class=\"number\">0</span>]&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> vote <span class=\"keyword\">in</span> votes:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, v <span class=\"keyword\">in</span> enumerate(vote):</span><br><span class=\"line\">            count[v][i] -= <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(sorted(votes[<span class=\"number\">0</span>], key=count.get))</span><br></pre></td></tr></table></figure>\n<h3 id=\"1331-Rank-Transform-of-an-Array\"><a href=\"#1331-Rank-Transform-of-an-Array\" class=\"headerlink\" title=\"1331. Rank Transform of an Array\"></a>1331. Rank Transform of an Array</h3><h4 id=\"将数组转化为排行。原题\"><a href=\"#将数组转化为排行。原题\" class=\"headerlink\" title=\"将数组转化为排行。原题\"></a>将数组转化为排行。<a href=\"https://leetcode.com/problems/rank-transform-of-an-array/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: arr &#x3D; [40,10,20,30]</span><br><span class=\"line\">Output: [4,1,2,3]</span><br><span class=\"line\">Explanation: 40 is the largest element. 10 is the smallest. 20 is the second smallest. 30 is the third smallest.</span><br></pre></td></tr></table></figure>\n<p>方法一：<code>setdefault</code>的妙用。 by Lee215</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">arrayRankTransform</span><span class=\"params\">(self, arr: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    rank = &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> sorted(arr):</span><br><span class=\"line\">        rank.setdefault(a, len(rank)+<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> map(rank.get, arr)</span><br></pre></td></tr></table></figure>\n<h3 id=\"1306-Jump-Game-III\"><a href=\"#1306-Jump-Game-III\" class=\"headerlink\" title=\"1306. Jump Game III\"></a>1306. Jump Game III</h3><h4 id=\"跳跃游戏，从start开始，可以沿着value向前向后跳，求是否可以跳到0-原题\"><a href=\"#跳跃游戏，从start开始，可以沿着value向前向后跳，求是否可以跳到0-原题\" class=\"headerlink\" title=\"跳跃游戏，从start开始，可以沿着value向前向后跳，求是否可以跳到0.原题\"></a>跳跃游戏，从start开始，可以沿着value向前向后跳，求是否可以跳到0.<a href=\"https://leetcode.com/problems/jump-game-iii/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: arr &#x3D; [4,2,3,0,3,1,2], start &#x3D; 5</span><br><span class=\"line\">Output: true</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">All possible ways to reach at index 3 with value 0 are: </span><br><span class=\"line\">index 5 -&gt; index 4 -&gt; index 1 -&gt; index 3 </span><br><span class=\"line\">index 5 -&gt; index 6 -&gt; index 4 -&gt; index 1 -&gt; index 3</span><br></pre></td></tr></table></figure>\n<p>方法一：Bfs.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">canReach</span><span class=\"params\">(self, arr: List[int], start: int)</span> -&gt; bool:</span></span><br><span class=\"line\">    q, seen = collections.deque([start]), &#123;start&#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> q:</span><br><span class=\"line\">        i = q.popleft()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> arr[i] == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> nxt <span class=\"keyword\">in</span> (i-arr[i], i+arr[i]):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nxt <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> seen <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=nxt&lt;len(arr):</span><br><span class=\"line\">                q.append(nxt)</span><br><span class=\"line\">                seen.add(nxt)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<p>方法二：数组中元素均为非负数，所以用负数来标记已经跳过的点。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">canReach</span><span class=\"params\">(self, arr: List[int], i: int)</span> -&gt; bool:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=i&lt;len(arr) <span class=\"keyword\">and</span> arr[i]&gt;=<span class=\"number\">0</span>:</span><br><span class=\"line\">        arr[i] = -arr[i]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> arr[i]==<span class=\"number\">0</span> <span class=\"keyword\">or</span> self.canReach(arr, i+arr[i]) <span class=\"keyword\">or</span> self.canReach(arr, i-arr[i])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1696-Jump-Game-VI\"><a href=\"#1696-Jump-Game-VI\" class=\"headerlink\" title=\"1696. Jump Game VI\"></a><a href=\"https://leetcode.com/problems/jump-game-vi/\" target=\"_blank\" rel=\"noopener\">1696. Jump Game VI</a></h3><h4 id=\"跳跃游戏，从数组开头跳跃到数组末尾，数组中元素可能包含负数，每次跳的距离为1-k，跳到哪里可以获得对应的分，问跳到最后最多能得多少分。\"><a href=\"#跳跃游戏，从数组开头跳跃到数组末尾，数组中元素可能包含负数，每次跳的距离为1-k，跳到哪里可以获得对应的分，问跳到最后最多能得多少分。\" class=\"headerlink\" title=\"跳跃游戏，从数组开头跳跃到数组末尾，数组中元素可能包含负数，每次跳的距离为1~k，跳到哪里可以获得对应的分，问跳到最后最多能得多少分。\"></a>跳跃游戏，从数组开头跳跃到数组末尾，数组中元素可能包含负数，每次跳的距离为1~k，跳到哪里可以获得对应的分，问跳到最后最多能得多少分。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [1,-1,-2,4,-7,3], k &#x3D; 2</span><br><span class=\"line\">Output: 7</span><br><span class=\"line\">Explanation: You can choose your jumps forming the subsequence [1,-1,4,3] (underlined above). The sum is 7.</span><br></pre></td></tr></table></figure>\n<p>方法一：比赛时只想到了O(n^2)的dp方法，啥也不是。这题用单调队里，维护一个最长为k的队列，队列中记录索引，有点像剑指offer中滑动窗口的最大值。</p>\n<figure class=\"highlight python\"><figcaption><span>def maxResult(self, nums: List[int], k: int) -> int:</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxResult</span><span class=\"params\">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class=\"line\">    n = len(nums)</span><br><span class=\"line\">    best = [nums[<span class=\"number\">0</span>]] + [-inf] * (n<span class=\"number\">-1</span>)</span><br><span class=\"line\">    q = deque([<span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n):</span><br><span class=\"line\">        <span class=\"keyword\">while</span> q <span class=\"keyword\">and</span> q[<span class=\"number\">0</span>] &lt; i-k:</span><br><span class=\"line\">            q.popleft()</span><br><span class=\"line\">        best[i] = best[q[<span class=\"number\">0</span>]] + nums[i]</span><br><span class=\"line\">        <span class=\"comment\"># maintain the mono dec deque</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> q <span class=\"keyword\">and</span> best[q[<span class=\"number\">-1</span>]] &lt;= best[i]:</span><br><span class=\"line\">            q.pop()</span><br><span class=\"line\">        q.append(i)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> best[<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"1297-Maximum-Number-of-Occurrences-of-a-Substring\"><a href=\"#1297-Maximum-Number-of-Occurrences-of-a-Substring\" class=\"headerlink\" title=\"1297. Maximum Number of Occurrences of a Substring\"></a>1297. Maximum Number of Occurrences of a Substring</h3><h4 id=\"出现次数最多的子串。滑动窗口可伸缩，最多包含maxLetters个字母。原题\"><a href=\"#出现次数最多的子串。滑动窗口可伸缩，最多包含maxLetters个字母。原题\" class=\"headerlink\" title=\"出现次数最多的子串。滑动窗口可伸缩，最多包含maxLetters个字母。原题\"></a>出现次数最多的子串。滑动窗口可伸缩，最多包含maxLetters个字母。<a href=\"https://leetcode.com/problems/maximum-number-of-occurrences-of-a-substring/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxFreq</span><span class=\"params\">(self, s: str, maxLetters: int, k: int, maxSize: int)</span> -&gt; int:</span></span><br><span class=\"line\">    c = collections.Counter(s[i:i+k] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(s)-k+<span class=\"number\">1</span>))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max([n <span class=\"keyword\">for</span> sub, n <span class=\"keyword\">in</span> c.items() <span class=\"keyword\">if</span> len(set(sub)) &lt;= maxLetters] + [<span class=\"number\">0</span>])</span><br></pre></td></tr></table></figure>\n<h3 id=\"1291-Sequential-Digits\"><a href=\"#1291-Sequential-Digits\" class=\"headerlink\" title=\"1291. Sequential Digits\"></a>1291. Sequential Digits</h3><h4 id=\"按序求组区间中的顺子。原题\"><a href=\"#按序求组区间中的顺子。原题\" class=\"headerlink\" title=\"按序求组区间中的顺子。原题\"></a>按序求组区间中的顺子。<a href=\"https://leetcode.com/problems/sequential-digits/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: low &#x3D; 1000, high &#x3D; 13000</span><br><span class=\"line\">Output: [1234,2345,3456,4567,5678,6789,12345]</span><br></pre></td></tr></table></figure>\n<p>方法一：开始时用的转化字符串的方式。不优雅，借鉴了他人解法。生成器有个好处是你可以暂时先不关心顺序。因为low&gt;=10，所以一开始不会以9开头。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sequentialDigits</span><span class=\"params\">(self, low: int, high: int)</span> -&gt; List[int]:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">gen</span><span class=\"params\">(digit)</span>:</span></span><br><span class=\"line\">        num = digit</span><br><span class=\"line\">        <span class=\"keyword\">while</span> num &lt;= high <span class=\"keyword\">and</span> digit &lt; <span class=\"number\">10</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> num &gt;= low:</span><br><span class=\"line\">                <span class=\"keyword\">yield</span> num</span><br><span class=\"line\">            digit += <span class=\"number\">1</span></span><br><span class=\"line\">            num = num*<span class=\"number\">10</span> + digit</span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"keyword\">return</span> sorted(num <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">9</span>) <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> gen(i))</span><br></pre></td></tr></table></figure>\n<h3 id=\"1275-Find-Winner-on-a-Tic-Tac-Toe-Game\"><a href=\"#1275-Find-Winner-on-a-Tic-Tac-Toe-Game\" class=\"headerlink\" title=\"1275. Find Winner on a Tic Tac Toe Game\"></a>1275. Find Winner on a Tic Tac Toe Game</h3><h4 id=\"三子棋的游戏，谁先连到3个子谁就赢。原题\"><a href=\"#三子棋的游戏，谁先连到3个子谁就赢。原题\" class=\"headerlink\" title=\"三子棋的游戏，谁先连到3个子谁就赢。原题\"></a>三子棋的游戏，谁先连到3个子谁就赢。<a href=\"https://leetcode.com/problems/find-winner-on-a-tic-tac-toe-game/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: moves &#x3D; [[0,0],[2,0],[1,1],[2,1],[2,2]]</span><br><span class=\"line\">Output: &quot;A&quot;</span><br><span class=\"line\">Explanation: &quot;A&quot; wins, he always plays first.</span><br><span class=\"line\">&quot;X  &quot;    &quot;X  &quot;    &quot;X  &quot;    &quot;X  &quot;    &quot;X  &quot;</span><br><span class=\"line\">&quot;   &quot; -&gt; &quot;   &quot; -&gt; &quot; X &quot; -&gt; &quot; X &quot; -&gt; &quot; X &quot;</span><br><span class=\"line\">&quot;   &quot;    &quot;O  &quot;    &quot;O  &quot;    &quot;OO &quot;    &quot;OOX&quot;</span><br></pre></td></tr></table></figure>\n<p>方法一：这题是为数不多easy里面想了时间那么长的，除了暴力法没有想到什么思路。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">tictactoe</span><span class=\"params\">(self, moves: List[List[int]])</span> -&gt; str:</span></span><br><span class=\"line\">    line = collections.defaultdict(list)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, (x, y) <span class=\"keyword\">in</span> enumerate(moves):</span><br><span class=\"line\">        p = <span class=\"string\">'A'</span> <span class=\"keyword\">if</span> i&amp;<span class=\"number\">1</span>==<span class=\"number\">0</span> <span class=\"keyword\">else</span> <span class=\"string\">'B'</span> </span><br><span class=\"line\">        xk, yk = <span class=\"string\">'x_&#123;&#125;'</span>.format(x), <span class=\"string\">'y_&#123;&#125;'</span>.format(y)</span><br><span class=\"line\">        line[xk].append(p)</span><br><span class=\"line\">        line[yk].append(p)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> x == y:</span><br><span class=\"line\">            line[<span class=\"string\">'d_0'</span>].append(p)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> x + y == <span class=\"number\">2</span>:</span><br><span class=\"line\">            line[<span class=\"string\">'d_1'</span>].append(p)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> any(len(l)==<span class=\"number\">3</span> <span class=\"keyword\">and</span> len(set(l))==<span class=\"number\">1</span> <span class=\"keyword\">for</span> l <span class=\"keyword\">in</span> (line[xk], line[yk], line[<span class=\"string\">'d_0'</span>], line[<span class=\"string\">'d_1'</span>])):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> p</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'Draw'</span> <span class=\"keyword\">if</span> len(moves) == <span class=\"number\">9</span> <span class=\"keyword\">else</span> <span class=\"string\">'Pending'</span></span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：将A, B分为2组，这样比较时更简单一点。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">tictactoe</span><span class=\"params\">(self, moves: List[List[int]])</span> -&gt; str:</span></span><br><span class=\"line\">    row, col = [[<span class=\"number\">0</span>] * <span class=\"number\">3</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>)], [[<span class=\"number\">0</span>] * <span class=\"number\">3</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>)]</span><br><span class=\"line\">    d1, d2, p = [<span class=\"number\">0</span>] * <span class=\"number\">2</span>, [<span class=\"number\">0</span>] * <span class=\"number\">2</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> r, c <span class=\"keyword\">in</span> moves:</span><br><span class=\"line\">        row[p][r] += <span class=\"number\">1</span></span><br><span class=\"line\">        col[p][c] += <span class=\"number\">1</span></span><br><span class=\"line\">        d1[p] += r==c</span><br><span class=\"line\">        d2[p] += r+c==<span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"number\">3</span> <span class=\"keyword\">in</span> (row[p][r], col[p][c], d1[p], d2[p]):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">'AB'</span>[p]</span><br><span class=\"line\">        p ^= <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'Draw'</span> <span class=\"keyword\">if</span> len(moves)==<span class=\"number\">9</span> <span class=\"keyword\">else</span> <span class=\"string\">'Pending'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"面试题-16-04-井字游戏\"><a href=\"#面试题-16-04-井字游戏\" class=\"headerlink\" title=\"面试题 16.04. 井字游戏\"></a><a href=\"https://leetcode-cn.com/problems/tic-tac-toe-lcci/\" target=\"_blank\" rel=\"noopener\">面试题 16.04. 井字游戏</a></h3><h4 id=\"比1275简单一点，给定棋盘，判断谁赢。\"><a href=\"#比1275简单一点，给定棋盘，判断谁赢。\" class=\"headerlink\" title=\"比1275简单一点，给定棋盘，判断谁赢。\"></a>比1275简单一点，给定棋盘，判断谁赢。</h4><p>方法一：自己用if写的，评论有个正则的写法不错，学习一下。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">tictactoe</span><span class=\"params\">(self, board: List[str])</span> -&gt; str:</span></span><br><span class=\"line\">    N = len(board)</span><br><span class=\"line\">    pattern = re.compile(<span class=\"string\">r'^([XO])\\1*$'</span>)</span><br><span class=\"line\">    col = map(<span class=\"string\">''</span>.join, zip(*board))</span><br><span class=\"line\">    l_dig = (<span class=\"string\">''</span>.join(board[i][i] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(N))), </span><br><span class=\"line\">    r_dig = (<span class=\"string\">''</span>.join(board[N-i<span class=\"number\">-1</span>][i] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(N))), </span><br><span class=\"line\">    <span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> itertools.chain(board, col, l_dig, r_dig):</span><br><span class=\"line\">        match_obj = pattern.match(line)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> match_obj:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> match_obj.group(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"string\">' '</span> <span class=\"keyword\">in</span> itertools.chain.from_iterable(board):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'Pending'</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'Draw'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1260-Shift-2D-Grid\"><a href=\"#1260-Shift-2D-Grid\" class=\"headerlink\" title=\"1260. Shift 2D Grid\"></a>1260. Shift 2D Grid</h3><h4 id=\"2D滑动，每次列右移一次，首列下移一次。原题\"><a href=\"#2D滑动，每次列右移一次，首列下移一次。原题\" class=\"headerlink\" title=\"2D滑动，每次列右移一次，首列下移一次。原题\"></a>2D滑动，每次列右移一次，首列下移一次。<a href=\"https://leetcode.com/problems/shift-2d-grid/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: grid &#x3D; [[1,2,3],[4,5,6],[7,8,9]], k &#x3D; 1</span><br><span class=\"line\">Output: [[9,1,2],[3,4,5],[6,7,8]]</span><br></pre></td></tr></table></figure>\n<p>方法一：deque。最直观的方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">shiftGrid</span><span class=\"params\">(self, g: List[List[int]], k: int)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">    m, n = len(g), len(g[<span class=\"number\">0</span>])</span><br><span class=\"line\">    q = collections.deque(zip(*g))</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(k):</span><br><span class=\"line\">        head = q.pop()</span><br><span class=\"line\">        q.appendleft(head[<span class=\"number\">-1</span>:]+head[:<span class=\"number\">-1</span>])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [a <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> zip(*q)]</span><br></pre></td></tr></table></figure>\n<p>方法二：调了半天，找了一些规律，然而并没有方法一快多少，时间上差不多，反而是更难理解了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">shiftGrid</span><span class=\"params\">(self, g: List[List[int]], k: int)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">    m, n = len(g), len(g[<span class=\"number\">0</span>])</span><br><span class=\"line\">    mk = k % n</span><br><span class=\"line\">    a = list(zip(*g))</span><br><span class=\"line\">    a = a[-mk:] + a[:-mk]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> zip(*[row[-((k//n+(i&lt;mk))%m):] + row[:-((k//n+(i&lt;mk))%m)] <span class=\"keyword\">for</span> i, row <span class=\"keyword\">in</span> enumerate(a)])</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：看来时间效率应该是差不多了，将数组转成一维，会发现规律。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">shiftGrid</span><span class=\"params\">(self, g: List[List[int]], k: int)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">    col, nums = len(g[<span class=\"number\">0</span>]), sum(g, [])</span><br><span class=\"line\">    k = k % len(nums)</span><br><span class=\"line\">    nums = nums[-k:] + nums[:-k]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [nums[i:i+col] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(nums), col)]</span><br></pre></td></tr></table></figure>\n<h3 id=\"1252-Cells-with-Odd-Values-in-a-Matrix\"><a href=\"#1252-Cells-with-Odd-Values-in-a-Matrix\" class=\"headerlink\" title=\"1252. Cells with Odd Values in a Matrix\"></a>1252. Cells with Odd Values in a Matrix</h3><h4 id=\"根据坐标每次将所在的行和列-1，这个点-2，统计所有的奇数个数。原题\"><a href=\"#根据坐标每次将所在的行和列-1，这个点-2，统计所有的奇数个数。原题\" class=\"headerlink\" title=\"根据坐标每次将所在的行和列+1，这个点+2，统计所有的奇数个数。原题\"></a>根据坐标每次将所在的行和列+1，这个点+2，统计所有的奇数个数。<a href=\"https://leetcode.com/problems/cells-with-odd-values-in-a-matrix/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 2, m &#x3D; 3, indices &#x3D; [[0,1],[1,1]]</span><br><span class=\"line\">Output: 6</span><br><span class=\"line\">Explanation: Initial matrix &#x3D; [[0,0,0],[0,0,0]].</span><br><span class=\"line\">After applying first increment it becomes [[1,2,1],[0,1,0]].</span><br><span class=\"line\">The final matrix will be [[1,3,1],[1,3,1]] which contains 6 odd numbers.</span><br></pre></td></tr></table></figure>\n<p>方法一：异或。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">oddCells</span><span class=\"params\">(self, n: int, m: int, indices: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    row, col = [<span class=\"number\">0</span>] * n, [<span class=\"number\">0</span>] * m</span><br><span class=\"line\">    <span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> indices:</span><br><span class=\"line\">        row[x] ^= <span class=\"number\">1</span></span><br><span class=\"line\">        col[y] ^= <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(r ^ c <span class=\"keyword\">for</span> r <span class=\"keyword\">in</span> row <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> col)</span><br></pre></td></tr></table></figure>\n<h3 id=\"1248-Count-Number-of-Nice-Subarrays\"><a href=\"#1248-Count-Number-of-Nice-Subarrays\" class=\"headerlink\" title=\"1248. Count Number of Nice Subarrays\"></a>1248. Count Number of Nice Subarrays</h3><h4 id=\"找到包含k个奇数的子数组个数。原题\"><a href=\"#找到包含k个奇数的子数组个数。原题\" class=\"headerlink\" title=\"找到包含k个奇数的子数组个数。原题\"></a>找到包含k个奇数的子数组个数。<a href=\"https://leetcode.com/problems/count-number-of-nice-subarrays/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [1,1,2,1,1], k &#x3D; 3</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].</span><br></pre></td></tr></table></figure>\n<p>方法一：找到所有的奇数索引，然后滑动窗口累加值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numberOfSubarrays</span><span class=\"params\">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class=\"line\">    n = len(nums)</span><br><span class=\"line\">    odd = [i <span class=\"keyword\">for</span> i, num <span class=\"keyword\">in</span> enumerate(nums) <span class=\"keyword\">if</span> num&amp;<span class=\"number\">1</span>==<span class=\"number\">1</span>]</span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(odd)-k+<span class=\"number\">1</span>):</span><br><span class=\"line\">        pre = <span class=\"number\">-1</span> <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> i <span class=\"keyword\">else</span> odd[i<span class=\"number\">-1</span>]</span><br><span class=\"line\">        hi = n <span class=\"keyword\">if</span> i==len(odd)-k <span class=\"keyword\">else</span> odd[i+k]</span><br><span class=\"line\">        ans += (odd[i]-pre) * (hi-odd[i+k<span class=\"number\">-1</span>])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法二：遍历一次</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numberOfSubarrays</span><span class=\"params\">(self, A: List[int], k: int)</span> -&gt; int:</span></span><br><span class=\"line\">    i = count = res = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(A)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> A[j] &amp; <span class=\"number\">1</span>:</span><br><span class=\"line\">            k -= <span class=\"number\">1</span></span><br><span class=\"line\">            count = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> k == <span class=\"number\">0</span>:</span><br><span class=\"line\">            k += A[i] &amp; <span class=\"number\">1</span></span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">            count += <span class=\"number\">1</span></span><br><span class=\"line\">        res += count</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"1234-Replace-the-Substring-for-Balanced-String\"><a href=\"#1234-Replace-the-Substring-for-Balanced-String\" class=\"headerlink\" title=\"1234. Replace the Substring for Balanced String\"></a>1234. Replace the Substring for Balanced String</h3><h4 id=\"将每个QWER出现的次数变为一样，最少需要修改的子串长度是多少。原题\"><a href=\"#将每个QWER出现的次数变为一样，最少需要修改的子串长度是多少。原题\" class=\"headerlink\" title=\"将每个QWER出现的次数变为一样，最少需要修改的子串长度是多少。原题\"></a>将每个QWER出现的次数变为一样，最少需要修改的子串长度是多少。<a href=\"https://leetcode.com/problems/replace-the-substring-for-balanced-string/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;QQWE&quot;</span><br><span class=\"line\">Output: 1</span><br><span class=\"line\">Explanation: We need to replace a &#39;Q&#39; to &#39;R&#39;, so that &quot;RQWE&quot; (or &quot;QRWE&quot;) is balanced.</span><br></pre></td></tr></table></figure>\n<p>方法一：例子有地不好，子串必须是连续的。和lee大佬解法差不多。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">balancedString</span><span class=\"params\">(self, s: str)</span> -&gt; int:</span></span><br><span class=\"line\">    diff = Counter(s) - Counter(&#123;c: len(s)//<span class=\"number\">4</span> <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> <span class=\"string\">'QWER'</span>&#125;)</span><br><span class=\"line\">    ans = float(<span class=\"string\">'inf'</span>)</span><br><span class=\"line\">    c = Counter()</span><br><span class=\"line\">    i = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j, a <span class=\"keyword\">in</span> enumerate(s):</span><br><span class=\"line\">        c[a] += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i!=len(s) <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> diff-c:</span><br><span class=\"line\">            ans = min(ans, j-i+<span class=\"number\">1</span>)</span><br><span class=\"line\">            c[s[i]] -= <span class=\"number\">1</span></span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"1208-Get-Equal-Substrings-Within-Budget\"><a href=\"#1208-Get-Equal-Substrings-Within-Budget\" class=\"headerlink\" title=\"1208. Get Equal Substrings Within Budget\"></a>1208. Get Equal Substrings Within Budget</h3><h4 id=\"将字符串s变为t。需要ascii码的差，问在指定的差中，最长的可以变成的子串长度是多少。原题\"><a href=\"#将字符串s变为t。需要ascii码的差，问在指定的差中，最长的可以变成的子串长度是多少。原题\" class=\"headerlink\" title=\"将字符串s变为t。需要ascii码的差，问在指定的差中，最长的可以变成的子串长度是多少。原题\"></a>将字符串s变为t。需要ascii码的差，问在指定的差中，最长的可以变成的子串长度是多少。<a href=\"https://leetcode.com/problems/get-equal-substrings-within-budget/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;abcd&quot;, t &#x3D; &quot;bcdf&quot;, maxCost &#x3D; 3</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: &quot;abc&quot; of s can change to &quot;bcd&quot;. That costs 3, so the maximum length is 3.</span><br></pre></td></tr></table></figure>\n<p>方法一：滑动窗口问题。比赛的答案。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">equalSubstring</span><span class=\"params\">(self, s: str, t: str, maxCost: int)</span> -&gt; int:</span></span><br><span class=\"line\">    diff = [abs(ord(a)-ord(b)) <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> zip(s, t)]</span><br><span class=\"line\">    q = collections.deque()</span><br><span class=\"line\">    cur_sum = ans = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> diff:</span><br><span class=\"line\">        q.append(d)</span><br><span class=\"line\">        cur_sum += d</span><br><span class=\"line\">        <span class=\"keyword\">while</span> cur_sum &gt; maxCost:</span><br><span class=\"line\">            cur_sum -= q.popleft()</span><br><span class=\"line\">        ans = max(ans, len(q))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法二：Lee215，开始比较迷惑为什么i, j 不用max来求值，看了评论发现有人和我有一样的疑惑，并且给了解释，对于此题而言，滑动窗口的长度不会缩短。因为只用了if 而不是while</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">equalSubstring</span><span class=\"params\">(self, s: str, t: str, cost: int)</span> -&gt; int:</span></span><br><span class=\"line\">    i = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(s)):</span><br><span class=\"line\">        cost -= abs(ord(s[j]) - ord(t[j]))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cost &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            cost += abs(ord(s[i]) - ord(t[i]))</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> j - i + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Sort-Colors\"><a href=\"#Sort-Colors\" class=\"headerlink\" title=\"Sort Colors\"></a>Sort Colors</h3><h4 id=\"0-1-2的数组排序。原题\"><a href=\"#0-1-2的数组排序。原题\" class=\"headerlink\" title=\"0,1,2的数组排序。原题\"></a>0,1,2的数组排序。<a href=\"https://leetcode.com/problems/sort-colors/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [2,0,2,1,1,0]</span><br><span class=\"line\">Output: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure>\n<p>方法一：没想到有快排的思想。维持三个区间<code>[0,i) [i,j),[j,k)</code>分别表示0，1，2的区间。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sortColors</span><span class=\"params\">(self, nums: List[int])</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">    i, j = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(len(nums)):</span><br><span class=\"line\">        v = nums[k]</span><br><span class=\"line\">        nums[k] = <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> v &lt; <span class=\"number\">2</span>:</span><br><span class=\"line\">            nums[j] = <span class=\"number\">1</span></span><br><span class=\"line\">            j += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> v == <span class=\"number\">0</span>:</span><br><span class=\"line\">            nums[i] = <span class=\"number\">0</span></span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1191-K-Concatenation-Maximum-Sum\"><a href=\"#1191-K-Concatenation-Maximum-Sum\" class=\"headerlink\" title=\"1191. K-Concatenation Maximum Sum\"></a>1191. K-Concatenation Maximum Sum</h3><h4 id=\"求k-arr的连续数组最大和。原题\"><a href=\"#求k-arr的连续数组最大和。原题\" class=\"headerlink\" title=\"求k*arr的连续数组最大和。原题\"></a>求k*arr的连续数组最大和。<a href=\"https://leetcode.com/problems/k-concatenation-maximum-sum/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: arr &#x3D; [1,2], k &#x3D; 3</span><br><span class=\"line\">Output: 9</span><br><span class=\"line\">Input: arr &#x3D; [1,-2,1], k &#x3D; 5</span><br><span class=\"line\">Output: 2</span><br></pre></td></tr></table></figure>\n<p>方法一：想到了卡登算法，但是没想明白为啥要加(k-2)个数组的和，因为首位数组中间可以夹带(k-2)个数组，如果数组和是正数的话，就将它算进去</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">kConcatenationMaxSum</span><span class=\"params\">(self, arr: List[int], k: int, mod=<span class=\"number\">10</span>**<span class=\"number\">9</span>+<span class=\"number\">7</span>)</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">acc</span><span class=\"params\">(nums)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(accumulate(nums+[<span class=\"number\">0</span>], <span class=\"keyword\">lambda</span> x, y: x+y <span class=\"keyword\">if</span> x&gt;<span class=\"number\">0</span> <span class=\"keyword\">else</span> y))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((k<span class=\"number\">-2</span>)*max(sum(arr), <span class=\"number\">0</span>) + acc(arr*<span class=\"number\">2</span>)) % mod <span class=\"keyword\">if</span> k &gt; <span class=\"number\">1</span> <span class=\"keyword\">else</span> acc(arr) % mod</span><br></pre></td></tr></table></figure>\n<h3 id=\"448-Find-All-Numbers-Disappeared-in-an-Array\"><a href=\"#448-Find-All-Numbers-Disappeared-in-an-Array\" class=\"headerlink\" title=\"448. Find All Numbers Disappeared in an Array\"></a>448. Find All Numbers Disappeared in an Array</h3><h4 id=\"找出n长度的数组中1-n缺失的数字，有的数字会出现多次。原题\"><a href=\"#找出n长度的数组中1-n缺失的数字，有的数字会出现多次。原题\" class=\"headerlink\" title=\"找出n长度的数组中1-n缺失的数字，有的数字会出现多次。原题\"></a>找出n长度的数组中1-n缺失的数字，有的数字会出现多次。<a href=\"https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">[4,3,2,7,8,2,3,1]</span><br><span class=\"line\"></span><br><span class=\"line\">Output:</span><br><span class=\"line\">[5,6]</span><br></pre></td></tr></table></figure>\n<p>方法一：这道题解法挺新颖，看着这题和剑指offer中的有点类似，但是那道题是其它数字出现一次。这个题的解法是出现的位置的数变成负的，最后找正数的索引。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findDisappearedNumbers</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(nums)):</span><br><span class=\"line\">        index = abs(nums[i]) - <span class=\"number\">1</span></span><br><span class=\"line\">        nums[index] = -abs(nums[index])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [i+<span class=\"number\">1</span> <span class=\"keyword\">for</span> i, num <span class=\"keyword\">in</span> enumerate(nums) <span class=\"keyword\">if</span> num&gt;<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"11-Container-With-Most-Water\"><a href=\"#11-Container-With-Most-Water\" class=\"headerlink\" title=\"11. Container With Most Water\"></a>11. Container With Most Water</h3><h4 id=\"最大的水容积，用坐标轴装水，有点像木桶原理。原题\"><a href=\"#最大的水容积，用坐标轴装水，有点像木桶原理。原题\" class=\"headerlink\" title=\"最大的水容积，用坐标轴装水，有点像木桶原理。原题\"></a>最大的水容积，用坐标轴装水，有点像木桶原理。<a href=\"https://leetcode.com/problems/container-with-most-water/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：双指针，开始没有想到指针如何移动。其实这样想，如果一个坐标比较矮，那就将其舍弃，因为宽度是越来越小的，所以需要更高的木桶才能弥补。</p>\n<pre><code>def maxArea(self, height: List[int]) -&gt; int:\n    lo, hi = 0, len(height)-1\n    ans = 0\n    while lo &lt; hi:\n        ans = max(ans, (hi-lo)*min(height[hi], height[lo]))\n        if height[lo] &lt; height[hi]:\n            lo += 1\n        else:\n            hi -= 1\n    return ans\n</code></pre><h3 id=\"1498-Number-of-Subsequences-That-Satisfy-the-Given-Sum-Condition\"><a href=\"#1498-Number-of-Subsequences-That-Satisfy-the-Given-Sum-Condition\" class=\"headerlink\" title=\"1498. Number of Subsequences That Satisfy the Given Sum Condition\"></a>1498. Number of Subsequences That Satisfy the Given Sum Condition</h3><h4 id=\"给定一个数组，返回最大值最小值和小于目标值的子序列，可以不连续，的个数。原题\"><a href=\"#给定一个数组，返回最大值最小值和小于目标值的子序列，可以不连续，的个数。原题\" class=\"headerlink\" title=\"给定一个数组，返回最大值最小值和小于目标值的子序列，可以不连续，的个数。原题\"></a>给定一个数组，返回最大值最小值和小于目标值的子序列，可以不连续，的个数。<a href=\"https://leetcode.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [3,5,6,7], target &#x3D; 9</span><br><span class=\"line\">Output: 4</span><br><span class=\"line\">Explanation: There are 4 subsequences that satisfy the condition.</span><br><span class=\"line\">[3] -&gt; Min value + max value &lt;&#x3D; target (3 + 3 &lt;&#x3D; 9)</span><br><span class=\"line\">[3,5] -&gt; (3 + 5 &lt;&#x3D; 9)</span><br><span class=\"line\">[3,5,6] -&gt; (3 + 6 &lt;&#x3D; 9)</span><br><span class=\"line\">[3,6] -&gt; (3 + 6 &lt;&#x3D; 9)</span><br></pre></td></tr></table></figure>\n<p>方法一：一开始思路相对了，但是指针移动没想好。来自Lee215，累加的时候要计算一下mod否则效率会变很慢。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numSubseq</span><span class=\"params\">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class=\"line\">    nums.sort()</span><br><span class=\"line\">    lo, hi = <span class=\"number\">0</span>, len(nums)<span class=\"number\">-1</span></span><br><span class=\"line\">    res = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> lo &lt;= hi:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[lo] + nums[hi] &gt; target:</span><br><span class=\"line\">            hi -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            res += pow(<span class=\"number\">2</span>, hi - lo, <span class=\"number\">10</span>**<span class=\"number\">9</span>+<span class=\"number\">7</span>)</span><br><span class=\"line\">            lo += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res % (<span class=\"number\">10</span>**<span class=\"number\">9</span>+<span class=\"number\">7</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"463-Island-Perimeter\"><a href=\"#463-Island-Perimeter\" class=\"headerlink\" title=\"463. Island Perimeter\"></a>463. Island Perimeter</h3><h4 id=\"小岛的周长，小岛中间没有湖。原题\"><a href=\"#小岛的周长，小岛中间没有湖。原题\" class=\"headerlink\" title=\"小岛的周长，小岛中间没有湖。原题\"></a>小岛的周长，小岛中间没有湖。<a href=\"https://leetcode.com/problems/island-perimeter/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">[[0,1,0,0],</span><br><span class=\"line\"> [1,1,1,0],</span><br><span class=\"line\"> [0,1,0,0],</span><br><span class=\"line\"> [1,1,0,0]]</span><br><span class=\"line\"></span><br><span class=\"line\">Output: 16</span><br></pre></td></tr></table></figure>\n<p>方法一：stefan、因为中间没有湖，所以呢周长等于所以相邻格子不相等的个数。这里将列也放在一起计算了</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">islandPerimeter</span><span class=\"params\">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    cols = list(map(list, zip(*grid)))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(sum(map(ne, [<span class=\"number\">0</span>]+row, row+[<span class=\"number\">0</span>])) <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> grid + cols)</span><br></pre></td></tr></table></figure>\n<h3 id=\"15-3Sum\"><a href=\"#15-3Sum\" class=\"headerlink\" title=\"15. 3Sum\"></a>15. 3Sum</h3><h4 id=\"找出数组中3个数相加为0，返回所有的组合非重复。原题\"><a href=\"#找出数组中3个数相加为0，返回所有的组合非重复。原题\" class=\"headerlink\" title=\"找出数组中3个数相加为0，返回所有的组合非重复。原题\"></a>找出数组中3个数相加为0，返回所有的组合非重复。<a href=\"https://leetcode.com/problems/3sum/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Given array nums &#x3D; [-1, 0, 1, 2, -1, -4],</span><br><span class=\"line\"></span><br><span class=\"line\">A solution set is:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [-1, 0, 1],</span><br><span class=\"line\">  [-1, -1, 2]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>方法一：这里看了提示后用的2sum的方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">threeSum</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">    nums.sort()</span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    seen = set()</span><br><span class=\"line\">    n = len(nums)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">        a = nums[i]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> a <span class=\"keyword\">in</span> seen:</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        seen.add(a)</span><br><span class=\"line\">        d = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i+<span class=\"number\">1</span>, n):</span><br><span class=\"line\">            b = nums[j]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> b <span class=\"keyword\">in</span> d <span class=\"keyword\">and</span> (<span class=\"keyword\">not</span>(ans) <span class=\"keyword\">or</span> (ans[<span class=\"number\">-1</span>][<span class=\"number\">0</span>]!=a <span class=\"keyword\">or</span> ans[<span class=\"number\">-1</span>][<span class=\"number\">2</span>]!=b)):</span><br><span class=\"line\">                ans.append((a, -a-b, b))</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                d[-a-b] = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法二：讨论区看到的一个方法。明白了还有许多可以优化的地方。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">threeSum</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">    nums.sort()</span><br><span class=\"line\">    ans, n = [], len(nums)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n<span class=\"number\">-2</span>):</span><br><span class=\"line\">        a = nums[i]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> a &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">break</span> <span class=\"comment\"># 因为a&gt;0, b,c&gt;0，所以不可能和为0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i <span class=\"keyword\">and</span> a == nums[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        lo, hi = i+<span class=\"number\">1</span>, n<span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> lo &lt; hi:</span><br><span class=\"line\">            total = nums[lo] + nums[hi]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> total &gt; -a:</span><br><span class=\"line\">                hi -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> total &lt; -a:</span><br><span class=\"line\">                lo += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">while</span> lo&lt;hi <span class=\"keyword\">and</span> nums[lo]==nums[lo+<span class=\"number\">1</span>]:</span><br><span class=\"line\">                    lo += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> lo&lt;hi <span class=\"keyword\">and</span> nums[hi]==nums[hi<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                    hi -= <span class=\"number\">1</span></span><br><span class=\"line\">                ans.append((a, nums[lo], nums[hi]))</span><br><span class=\"line\">                lo += <span class=\"number\">1</span></span><br><span class=\"line\">                hi -= <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"1508-Range-Sum-of-Sorted-Subarray-Sums\"><a href=\"#1508-Range-Sum-of-Sorted-Subarray-Sums\" class=\"headerlink\" title=\"1508. Range Sum of Sorted Subarray Sums\"></a>1508. Range Sum of Sorted Subarray Sums</h3><h4 id=\"数组的累加和排序，取区间中的数字和。原题\"><a href=\"#数组的累加和排序，取区间中的数字和。原题\" class=\"headerlink\" title=\"数组的累加和排序，取区间中的数字和。原题\"></a>数组的累加和排序，取区间中的数字和。<a href=\"https://leetcode.com/problems/range-sum-of-sorted-subarray-sums/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [1,2,3,4], n &#x3D; 4, left &#x3D; 1, right &#x3D; 5</span><br><span class=\"line\">Output: 13 </span><br><span class=\"line\">Explanation: All subarray sums are 1, 3, 6, 10, 2, 5, 9, 3, 7, 4. After sorting them in non-decreasing order we have the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from index le &#x3D; 1 to ri &#x3D; 5 is 1 + 2 + 3 + 3 + 4 &#x3D; 13.</span><br></pre></td></tr></table></figure>\n<p>方法一：O(n^2)的方法。比赛的时候还用了accumulate， 但是其实没必要。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rangeSum</span><span class=\"params\">(self, nums: List[int], n: int, left: int, right: int)</span> -&gt; int:</span></span><br><span class=\"line\">    mod = <span class=\"number\">10</span>**<span class=\"number\">9</span> + <span class=\"number\">7</span></span><br><span class=\"line\">    n = len(nums)</span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">        cur = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i, n):</span><br><span class=\"line\">            cur += nums[j]</span><br><span class=\"line\">            ans.append(cur)</span><br><span class=\"line\">    ans.sort()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(ans[left<span class=\"number\">-1</span>: right]) % mod</span><br></pre></td></tr></table></figure>\n<h3 id=\"1509-Minimum-Difference-Between-Largest-and-Smallest-Value-in-Three-Moves\"><a href=\"#1509-Minimum-Difference-Between-Largest-and-Smallest-Value-in-Three-Moves\" class=\"headerlink\" title=\"1509. Minimum Difference Between Largest and Smallest Value in Three Moves\"></a>1509. Minimum Difference Between Largest and Smallest Value in Three Moves</h3><h4 id=\"删除3个数，数组的最大值最小值差最小是多少。原题\"><a href=\"#删除3个数，数组的最大值最小值差最小是多少。原题\" class=\"headerlink\" title=\"删除3个数，数组的最大值最小值差最小是多少。原题\"></a>删除3个数，数组的最大值最小值差最小是多少。<a href=\"https://leetcode.com/problems/minimum-difference-between-largest-and-smallest-value-in-three-moves/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：首次ac的方法。思路很直观，但是写法却有点复杂。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minDifference</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    nums.sort()</span><br><span class=\"line\">    n = len(nums)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n &lt;= <span class=\"number\">3</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\"># print(nums)</span></span><br><span class=\"line\">    ans = float(<span class=\"string\">'inf'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>):</span><br><span class=\"line\">        tmp = nums[i:n<span class=\"number\">-3</span>+i]</span><br><span class=\"line\">        ans = min(ans, max(tmp) - min(tmp))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：2行就可以搞定。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minDifference</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    nums.sort()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min(b-a <span class=\"keyword\">for</span> a, b <span class=\"keyword\">in</span> zip(nums[:<span class=\"number\">4</span>], nums[<span class=\"number\">-4</span>:]))</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：堆求也可以。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minDifference</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    nums.sort()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min(a - b <span class=\"keyword\">for</span> a,b <span class=\"keyword\">in</span> zip(heapq.nlargest(<span class=\"number\">4</span>, nums), heapq.nsmallest(<span class=\"number\">4</span>, nums)[::<span class=\"number\">-1</span>]))</span><br></pre></td></tr></table></figure>\n<h3 id=\"1529-Bulb-Switcher-IV\"><a href=\"#1529-Bulb-Switcher-IV\" class=\"headerlink\" title=\"1529. Bulb Switcher IV\"></a>1529. Bulb Switcher IV</h3><h4 id=\"灯泡开关，每次只能开关从后开始的连续的n个，问变成目标状态，最少需要几次操作。原题\"><a href=\"#灯泡开关，每次只能开关从后开始的连续的n个，问变成目标状态，最少需要几次操作。原题\" class=\"headerlink\" title=\"灯泡开关，每次只能开关从后开始的连续的n个，问变成目标状态，最少需要几次操作。原题\"></a>灯泡开关，每次只能开关从后开始的连续的n个，问变成目标状态，最少需要几次操作。<a href=\"https://leetcode.com/problems/bulb-switcher-iv/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: target &#x3D; &quot;10111&quot;</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: Initial configuration &quot;00000&quot;.</span><br><span class=\"line\">flip from the third bulb:  &quot;00000&quot; -&gt; &quot;00111&quot;</span><br><span class=\"line\">flip from the first bulb:  &quot;00111&quot; -&gt; &quot;11000&quot;</span><br><span class=\"line\">flip from the second bulb:  &quot;11000&quot; -&gt; &quot;10111&quot;</span><br><span class=\"line\">We need at least 3 flip operations to form target.</span><br></pre></td></tr></table></figure>\n<p>方法一：竞赛时的方法。 分组。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minFlips</span><span class=\"params\">(self, target: str)</span> -&gt; int:</span></span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    first = <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> l, g <span class=\"keyword\">in</span> itertools.groupby(target):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> l == <span class=\"string\">'0'</span> <span class=\"keyword\">and</span> first:</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            ans += <span class=\"number\">1</span></span><br><span class=\"line\">        first = <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：上诉方法补0 优化。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minFlips</span><span class=\"params\">(self, target: str)</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> len(list(itertools.groupby(<span class=\"string\">'0'</span> + target))) - <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：不分组，一次遍历。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minFlips</span><span class=\"params\">(self, target: str)</span> -&gt; int:</span></span><br><span class=\"line\">    ans, b = <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> target:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> int(c) == b:</span><br><span class=\"line\">            ans += <span class=\"number\">1</span></span><br><span class=\"line\">            b = <span class=\"number\">1</span> - b</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"442-Find-All-Duplicates-in-an-Array\"><a href=\"#442-Find-All-Duplicates-in-an-Array\" class=\"headerlink\" title=\"442. Find All Duplicates in an Array\"></a>442. Find All Duplicates in an Array</h3><h4 id=\"找到所有重复的元素，数组中的元素都在1-n之间，n为数组的长度。原题\"><a href=\"#找到所有重复的元素，数组中的元素都在1-n之间，n为数组的长度。原题\" class=\"headerlink\" title=\"找到所有重复的元素，数组中的元素都在1~n之间，n为数组的长度。原题\"></a>找到所有重复的元素，数组中的元素都在1~n之间，n为数组的长度。<a href=\"https://leetcode.com/problems/find-all-duplicates-in-an-array/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：要求在O(n)时间，O(1)空间实现，那么就考虑修改原数组来节省空间。以负值来记录是否出现过。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findDuplicates</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    res = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[abs(x)<span class=\"number\">-1</span>] &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            res.append(abs(x))</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            nums[abs(x)<span class=\"number\">-1</span>] *= <span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"713-Subarray-Product-Less-Than-K\"><a href=\"#713-Subarray-Product-Less-Than-K\" class=\"headerlink\" title=\"713. Subarray Product Less Than K\"></a>713. Subarray Product Less Than K</h3><h4 id=\"连续子数组乘积小于k的个数，元素为正数。原题\"><a href=\"#连续子数组乘积小于k的个数，元素为正数。原题\" class=\"headerlink\" title=\"连续子数组乘积小于k的个数，元素为正数。原题\"></a>连续子数组乘积小于k的个数，元素为正数。<a href=\"https://leetcode.com/problems/subarray-product-less-than-k/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [10, 5, 2, 6], k &#x3D; 100</span><br><span class=\"line\">Output: 8</span><br><span class=\"line\">Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].</span><br><span class=\"line\">Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.</span><br></pre></td></tr></table></figure>\n<p>方法一：一开始想到了双端队列，但是累加时end-start+1数量没想到。此题用双指针即可</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numSubarrayProductLessThanK</span><span class=\"params\">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> k == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    start = ans = <span class=\"number\">0</span></span><br><span class=\"line\">    prod = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> end, num <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">        <span class=\"keyword\">while</span> start&lt;=end <span class=\"keyword\">and</span> prod*num&gt;=k:</span><br><span class=\"line\">            prod //= nums[start]</span><br><span class=\"line\">            start += <span class=\"number\">1</span></span><br><span class=\"line\">        prod = <span class=\"number\">1</span> <span class=\"keyword\">if</span> start&gt;end <span class=\"keyword\">else</span> prod*num</span><br><span class=\"line\">        ans += (end-start+<span class=\"number\">1</span>) * (start&lt;=end)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"915-Partition-Array-into-Disjoint-Intervals\"><a href=\"#915-Partition-Array-into-Disjoint-Intervals\" class=\"headerlink\" title=\"915. Partition Array into Disjoint Intervals\"></a>915. Partition Array into Disjoint Intervals</h3><h4 id=\"将数组拆成两个非空数组，要求左侧的每个元素都小于等于右侧的每个元素，求左侧最小的长度，假设答案一定存在。原题\"><a href=\"#将数组拆成两个非空数组，要求左侧的每个元素都小于等于右侧的每个元素，求左侧最小的长度，假设答案一定存在。原题\" class=\"headerlink\" title=\"将数组拆成两个非空数组，要求左侧的每个元素都小于等于右侧的每个元素，求左侧最小的长度，假设答案一定存在。原题\"></a>将数组拆成两个非空数组，要求左侧的每个元素都小于等于右侧的每个元素，求左侧最小的长度，假设答案一定存在。<a href=\"https://leetcode.com/problems/partition-array-into-disjoint-intervals/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [5,0,3,8,6]</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: left &#x3D; [5,0,3], right &#x3D; [8,6]</span><br></pre></td></tr></table></figure>\n<p>方法一：蛮简单的，two-pass的方法，这个累加函数的生成器不能直接reversed，要将其转换成数组，这里产生了一次遍历。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">partitionDisjoint</span><span class=\"params\">(self, A: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    left = itertools.accumulate(A, max)</span><br><span class=\"line\">    right = reversed(list(itertools.accumulate(reversed(A), min)))</span><br><span class=\"line\">    next(right, <span class=\"literal\">None</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, (a, b) <span class=\"keyword\">in</span> enumerate(zip(left, right)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> a &lt;= b:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> i + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：one-pass. 这个方法不是很好想，思路是这样的，当当前数小于之前的最大值，那么久将其算入左侧的数组中。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">partitionDisjoint</span><span class=\"params\">(self, A: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    p = <span class=\"number\">0</span></span><br><span class=\"line\">    cur_max = left_max = A[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, a <span class=\"keyword\">in</span> enumerate(A):</span><br><span class=\"line\">        cur_max = max(cur_max, a)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> a &lt; left_max:</span><br><span class=\"line\">            left_max = cur_max</span><br><span class=\"line\">            p = i</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1562-Find-Latest-Group-of-Size-M\"><a href=\"#1562-Find-Latest-Group-of-Size-M\" class=\"headerlink\" title=\"1562. Find Latest Group of Size M\"></a>1562. Find Latest Group of Size M</h3><h4 id=\"将一个全是0的字符串按照arr的索引顺序变为1，整体被0分割成若干段，问最后有m个长度的”1”的段时是第几步、原题\"><a href=\"#将一个全是0的字符串按照arr的索引顺序变为1，整体被0分割成若干段，问最后有m个长度的”1”的段时是第几步、原题\" class=\"headerlink\" title=\"将一个全是0的字符串按照arr的索引顺序变为1，整体被0分割成若干段，问最后有m个长度的”1”的段时是第几步、原题\"></a>将一个全是0的字符串按照arr的索引顺序变为1，整体被0分割成若干段，问最后有m个长度的”1”的段时是第几步、<a href=\"https://leetcode.com/problems/find-latest-group-of-size-m/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: arr &#x3D; [3,5,1,2,4], m &#x3D; 1</span><br><span class=\"line\">Output: 4</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">Step 1: &quot;00100&quot;, groups: [&quot;1&quot;]</span><br><span class=\"line\">Step 2: &quot;00101&quot;, groups: [&quot;1&quot;, &quot;1&quot;]</span><br><span class=\"line\">Step 3: &quot;10101&quot;, groups: [&quot;1&quot;, &quot;1&quot;, &quot;1&quot;]</span><br><span class=\"line\">Step 4: &quot;11101&quot;, groups: [&quot;111&quot;, &quot;1&quot;]</span><br><span class=\"line\">Step 5: &quot;11111&quot;, groups: [&quot;11111&quot;]</span><br><span class=\"line\">The latest step at which there exists a group of size 1 is step 4.</span><br></pre></td></tr></table></figure>\n<p>方法一：比赛时没做出来，Lee的方法。length表示第i个bit的长度，count表示这么长的group有多少个。严格来说<code>length[a-left]</code>和<code>lenght[a+right]</code>区间内都应该变成left+right+1。但是由于中间的后续用不到，所以不必赋值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findLatestStep</span><span class=\"params\">(self, arr: List[int], m: int)</span> -&gt; int:</span></span><br><span class=\"line\">    length = [<span class=\"number\">0</span>] * (len(arr)+<span class=\"number\">2</span>)</span><br><span class=\"line\">    count = [<span class=\"number\">0</span>] * (len(arr)+<span class=\"number\">1</span>)</span><br><span class=\"line\">    ans = <span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, a <span class=\"keyword\">in</span> enumerate(arr):</span><br><span class=\"line\">        left, right = length[a<span class=\"number\">-1</span>], length[a+<span class=\"number\">1</span>]</span><br><span class=\"line\">        length[a] = length[a-left] = length[a+right] = left + right + <span class=\"number\">1</span></span><br><span class=\"line\">        count[left] -= <span class=\"number\">1</span></span><br><span class=\"line\">        count[right] -= <span class=\"number\">1</span></span><br><span class=\"line\">        count[length[a]] += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"comment\"># print(length, count)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> count[m]:</span><br><span class=\"line\">            ans = i + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"334-Increasing-Triplet-Subsequence\"><a href=\"#334-Increasing-Triplet-Subsequence\" class=\"headerlink\" title=\"334. Increasing Triplet Subsequence\"></a>334. Increasing Triplet Subsequence</h3><h4 id=\"数组中是否有三个元素递增。原题\"><a href=\"#数组中是否有三个元素递增。原题\" class=\"headerlink\" title=\"数组中是否有三个元素递增。原题\"></a>数组中是否有三个元素递增。<a href=\"https://leetcode.com/problems/increasing-triplet-subsequence/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [1,2,3,4,5]</span><br><span class=\"line\">Output: true</span><br><span class=\"line\">Input: [1,5,3,4,2]</span><br><span class=\"line\">Output: true</span><br></pre></td></tr></table></figure>\n<p>方法一：首次ac的方法，看了要求在O(n)时间O(1)空间实现。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">increasingTriplet</span><span class=\"params\">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class=\"line\">    a = b = float(<span class=\"string\">'inf'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> num &gt; b: <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        a = min(a, num)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> a&lt;num&lt;b: b=num</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：这个stefan的方法，具有泛化性，如果求4，5个元素递增可以直接修改变量。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">inc = [float(<span class=\"string\">'inf'</span>)] * <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        i = bisect.bisect_left(inc, x)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i &gt;= <span class=\"number\">2</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        inc[i] = x</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"926-Flip-String-to-Monotone-Increasing\"><a href=\"#926-Flip-String-to-Monotone-Increasing\" class=\"headerlink\" title=\"926. Flip String to Monotone Increasing\"></a>926. Flip String to Monotone Increasing</h3><h4 id=\"将一个二进制字符串翻转成单调递增最少要几步。原题\"><a href=\"#将一个二进制字符串翻转成单调递增最少要几步。原题\" class=\"headerlink\" title=\"将一个二进制字符串翻转成单调递增最少要几步。原题\"></a>将一个二进制字符串翻转成单调递增最少要几步。<a href=\"https://leetcode.com/problems/flip-string-to-monotone-increasing/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: &quot;010110&quot;</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: We flip to get 011111, or alternatively 000111.</span><br></pre></td></tr></table></figure>\n<p>方法一：看了一眼讨论区，就明白了，遍历时找到递增的点，也就是第一个1，记录后边的0和前边的1。这里我是在后面补1，也可以将ans初始化为len(S)-suffix_0。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minFlipsMonoIncr</span><span class=\"params\">(self, S: str)</span> -&gt; int:</span></span><br><span class=\"line\">    S += <span class=\"string\">'1'</span></span><br><span class=\"line\">    suffix_0, prefix_1 = S.count(<span class=\"string\">'0'</span>), <span class=\"number\">0</span></span><br><span class=\"line\">    ans = float(<span class=\"string\">'inf'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> S:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> c == <span class=\"string\">'0'</span>:</span><br><span class=\"line\">            suffix_0 -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            ans = min(ans, suffix_0+prefix_1)</span><br><span class=\"line\">            prefix_1 += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"424-Longest-Repeating-Character-Replacement\"><a href=\"#424-Longest-Repeating-Character-Replacement\" class=\"headerlink\" title=\"424. Longest Repeating Character Replacement\"></a>424. Longest Repeating Character Replacement</h3><h4 id=\"由26个大写字母组成的字符串，在k次替换范围内，产生的最长的重复字符串是多少。原题\"><a href=\"#由26个大写字母组成的字符串，在k次替换范围内，产生的最长的重复字符串是多少。原题\" class=\"headerlink\" title=\"由26个大写字母组成的字符串，在k次替换范围内，产生的最长的重复字符串是多少。原题\"></a>由26个大写字母组成的字符串，在k次替换范围内，产生的最长的重复字符串是多少。<a href=\"https://leetcode.com/problems/longest-repeating-character-replacement/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">s &#x3D; &quot;ABAB&quot;, k &#x3D; 2</span><br><span class=\"line\"></span><br><span class=\"line\">Output:</span><br><span class=\"line\">4</span><br><span class=\"line\"></span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">Replace the two &#39;A&#39;s with two &#39;B&#39;s or vice versa.</span><br></pre></td></tr></table></figure>\n<p>方法一：滑动窗口加数组计数。time- O(26N)。while是没有必要的，left+1后 左边等号就会刚好=k, 不过这里的left, right表示的区间意义变了，表示的是最大的滑动窗口，窗口内的字符串不一定是可以满足条件的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">characterReplacement</span><span class=\"params\">(self, s: str, k: int)</span> -&gt; int:</span></span><br><span class=\"line\">    cnt = [<span class=\"number\">0</span>] * <span class=\"number\">26</span></span><br><span class=\"line\">    left = ans = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> right, d <span class=\"keyword\">in</span> enumerate(s):</span><br><span class=\"line\">        cnt[ord(d)-ord(<span class=\"string\">'A'</span>)] += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"comment\"># while right-left+1-max(cnt) &gt; k:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> right-left+<span class=\"number\">1</span>-max(cnt) &gt; k:</span><br><span class=\"line\">            cnt[ord(s[left])-ord(<span class=\"string\">'A'</span>)] -= <span class=\"number\">1</span></span><br><span class=\"line\">            left += <span class=\"number\">1</span></span><br><span class=\"line\">        ans = max(ans, right-left+<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法二：研究了很久也没弄明白，为什么maxf曾经最大的值，可以替代max(cnt)。理论上时间确实比上述快了。Time-O(N)。我试了一个特殊的例子，”BBBCADEF”1，在某些情况maxf &gt; max(cnt)的，但即便这样也没有影响if判断，猜测可能为right-left+1区间为最大区间。不过又将if改成while循环，依然没有影响。此解法还是有些疑惑。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">characterReplacement</span><span class=\"params\">(self, s: str, k: int)</span> -&gt; int:</span></span><br><span class=\"line\">    cnt = [<span class=\"number\">0</span>] * <span class=\"number\">26</span></span><br><span class=\"line\">    left = ans = maxf = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> right, d <span class=\"keyword\">in</span> enumerate(s):</span><br><span class=\"line\">        cnt[ord(d)-ord(<span class=\"string\">'A'</span>)] += <span class=\"number\">1</span></span><br><span class=\"line\">        maxf = max(maxf, cnt[ord(d)-ord(<span class=\"string\">'A'</span>)])</span><br><span class=\"line\">        <span class=\"comment\"># while right-left+1-max(cnt) &gt; k:</span></span><br><span class=\"line\">        <span class=\"comment\"># print(maxf, max(cnt), left, right, ans)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> right-left+<span class=\"number\">1</span>-maxf &gt; k:</span><br><span class=\"line\">            cnt[ord(s[left])-ord(<span class=\"string\">'A'</span>)] -= <span class=\"number\">1</span></span><br><span class=\"line\">            left += <span class=\"number\">1</span></span><br><span class=\"line\">        ans = max(ans, right-left+<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"398-Random-Pick-Index\"><a href=\"#398-Random-Pick-Index\" class=\"headerlink\" title=\"398. Random Pick Index\"></a>398. Random Pick Index</h3><h4 id=\"有这样一个数组，我想随机的去一个目标的元素，找到和目标相等的这些元素随机返回一个索引。原题\"><a href=\"#有这样一个数组，我想随机的去一个目标的元素，找到和目标相等的这些元素随机返回一个索引。原题\" class=\"headerlink\" title=\"有这样一个数组，我想随机的去一个目标的元素，找到和目标相等的这些元素随机返回一个索引。原题\"></a>有这样一个数组，我想随机的去一个目标的元素，找到和目标相等的这些元素随机返回一个索引。<a href=\"https://leetcode.com/problems/random-pick-index/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">int[] nums &#x3D; new int[] &#123;1,2,3,3,3&#125;;</span><br><span class=\"line\">Solution solution &#x3D; new Solution(nums);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; pick(3) should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.</span><br><span class=\"line\">solution.pick(3);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; pick(1) should return 0. Since in the array only nums[0] is equal to 1.</span><br><span class=\"line\">solution.pick(1);</span><br></pre></td></tr></table></figure>\n<p>方法一：直接放到defaultdict中也没有超过空间限制。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, nums: List[int])</span>:</span></span><br><span class=\"line\">        self.p = collections.defaultdict(list)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, d <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">            self.p[d].append(i)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pick</span><span class=\"params\">(self, target: int)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> random.choice(self.p[target])</span><br></pre></td></tr></table></figure>\n<p>方法二：一个新的方法叫作蓄水池取样，当遇见了一个目标数，就将它放到池子中，然后随机一个数。并在随到当前数时更新索引。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, nums: List[int])</span>:</span></span><br><span class=\"line\">        self.nums = nums</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pick</span><span class=\"params\">(self, target: int)</span> -&gt; int:</span></span><br><span class=\"line\">        ans = <span class=\"literal\">None</span></span><br><span class=\"line\">        count = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, num <span class=\"keyword\">in</span> enumerate(self.nums):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> num == target:</span><br><span class=\"line\">                count += <span class=\"number\">1</span></span><br><span class=\"line\">                chance = random.randint(<span class=\"number\">1</span>, count)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> chance == count:</span><br><span class=\"line\">                    ans = i</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"382-Linked-List-Random-Node\"><a href=\"#382-Linked-List-Random-Node\" class=\"headerlink\" title=\"382. Linked List Random Node\"></a>382. Linked List Random Node</h3><h4 id=\"在一个链表上随机取一个节点值。原题\"><a href=\"#在一个链表上随机取一个节点值。原题\" class=\"headerlink\" title=\"在一个链表上随机取一个节点值。原题\"></a>在一个链表上随机取一个节点值。<a href=\"https://leetcode.com/problems/linked-list-random-node/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：和398一样。假设链表无限大，不能够获取它的长度。这是非常经典的一个题。一个很大的数据流，对数据流的内容只能访问一次，随机算法使数据流中所有的被选中的概率相等。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, nums: List[int])</span>:</span></span><br><span class=\"line\">        self.nums = nums</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pick</span><span class=\"params\">(self, target: int)</span> -&gt; int:</span></span><br><span class=\"line\">        ans = <span class=\"literal\">None</span></span><br><span class=\"line\">        count = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, num <span class=\"keyword\">in</span> enumerate(self.nums):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> num == target:</span><br><span class=\"line\">                count += <span class=\"number\">1</span></span><br><span class=\"line\">                chance = random.randint(<span class=\"number\">1</span>, count)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> chance == count:</span><br><span class=\"line\">                    ans = i</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"209-Minimum-Size-Subarray-Sum\"><a href=\"#209-Minimum-Size-Subarray-Sum\" class=\"headerlink\" title=\"209. Minimum Size Subarray Sum\"></a>209. Minimum Size Subarray Sum</h3><h4 id=\"累加和大于s的最短的子数组长度。原题\"><a href=\"#累加和大于s的最短的子数组长度。原题\" class=\"headerlink\" title=\"累加和大于s的最短的子数组长度。原题\"></a>累加和大于s的最短的子数组长度。<a href=\"https://leetcode.com/problems/minimum-size-subarray-sum/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: the subarray [4,3] has the minimal length under the problem constraint.</span><br></pre></td></tr></table></figure>\n<p>方法一：滑动窗口。注意A为空的情况。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minSubArrayLen</span><span class=\"params\">(self, s: int, A: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    i, ans = <span class=\"number\">0</span>, len(A)+<span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(A)):</span><br><span class=\"line\">        s -= A[j]</span><br><span class=\"line\">        <span class=\"keyword\">while</span> s &lt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">            ans = min(ans, j-i+<span class=\"number\">1</span>)</span><br><span class=\"line\">            s += A[i]</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans % (len(A)+<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"930-Binary-Subarrays-With-Sum\"><a href=\"#930-Binary-Subarrays-With-Sum\" class=\"headerlink\" title=\"930. Binary Subarrays With Sum\"></a>930. Binary Subarrays With Sum</h3><h4 id=\"求和我S的子数组个数，数组元素只包含0，1。原题\"><a href=\"#求和我S的子数组个数，数组元素只包含0，1。原题\" class=\"headerlink\" title=\"求和我S的子数组个数，数组元素只包含0，1。原题\"></a>求和我S的子数组个数，数组元素只包含0，1。<a href=\"https://leetcode.com/problems/binary-subarrays-with-sum/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: A &#x3D; [1,0,1,0,1], S &#x3D; 2</span><br><span class=\"line\">Output: 4</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">The 4 subarrays are bolded below:</span><br><span class=\"line\">[1,0,1,0,1]</span><br><span class=\"line\">[1,0,1,0,1]</span><br><span class=\"line\">[1,0,1,0,1]</span><br><span class=\"line\">[1,0,1,0,1]</span><br></pre></td></tr></table></figure>\n<p>方法一：这种题要求at_most. 滑动窗口，用和小于等于S的子数组个数减去小于等于S-1的子数组个数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numSubarraysWithSum</span><span class=\"params\">(self, A: List[int], S: int)</span> -&gt; int:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">at_most</span><span class=\"params\">(S)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> S &lt; <span class=\"number\">0</span>: <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        res = i = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(A)):</span><br><span class=\"line\">            S -= A[j]</span><br><span class=\"line\">            <span class=\"keyword\">while</span> S &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                S += A[i]</span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">            res += j-i+<span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> at_most(S) - at_most(S<span class=\"number\">-1</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"969-Pancake-Sorting\"><a href=\"#969-Pancake-Sorting\" class=\"headerlink\" title=\"969. Pancake Sorting\"></a>969. Pancake Sorting</h3><h4 id=\"煎饼排序。由1-n组成，没次只能reverse前k个，求k的数组，答案不唯一。原题\"><a href=\"#煎饼排序。由1-n组成，没次只能reverse前k个，求k的数组，答案不唯一。原题\" class=\"headerlink\" title=\"煎饼排序。由1~n组成，没次只能reverse前k个，求k的数组，答案不唯一。原题\"></a>煎饼排序。由1~n组成，没次只能reverse前k个，求k的数组，答案不唯一。<a href=\"https://leetcode.com/problems/pancake-sorting/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: A &#x3D; [3,2,4,1]</span><br><span class=\"line\">Output: [4,2,4,3]</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">We perform 4 pancake flips, with k values 4, 2, 4, and 3.</span><br><span class=\"line\">Starting state: A &#x3D; [3, 2, 4, 1]</span><br><span class=\"line\">After 1st flip (k &#x3D; 4): A &#x3D; [1, 4, 2, 3]</span><br><span class=\"line\">After 2nd flip (k &#x3D; 2): A &#x3D; [4, 1, 2, 3]</span><br><span class=\"line\">After 3rd flip (k &#x3D; 4): A &#x3D; [3, 2, 1, 4]</span><br><span class=\"line\">After 4th flip (k &#x3D; 3): A &#x3D; [1, 2, 3, 4], which is sorted.</span><br><span class=\"line\">Notice that we return an array of the chosen k values of the pancake flips.</span><br></pre></td></tr></table></figure>\n<p>方法一：例子中的做法不是很好，只需要每次找最大的，然后翻到首位，然后再全翻转使其到达末尾。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pancakeSort</span><span class=\"params\">(self, A: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    ans, n = [], len(A)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> A[i] != i+<span class=\"number\">1</span>:</span><br><span class=\"line\">            j = A.index(i+<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> j:</span><br><span class=\"line\">                ans.append(j+<span class=\"number\">1</span>)</span><br><span class=\"line\">                A = A[:j+<span class=\"number\">1</span>][::<span class=\"number\">-1</span>] + A[j+<span class=\"number\">1</span>:]</span><br><span class=\"line\">            ans.append(i+<span class=\"number\">1</span>)</span><br><span class=\"line\">            A = A[:i+<span class=\"number\">1</span>][::<span class=\"number\">-1</span>] + A[i+<span class=\"number\">1</span>:]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：Lee的方法，这种方法把1也放进去了。其实是无所谓的。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pancakeSort</span><span class=\"params\">(self, A: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    ans, n = [], len(A)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(n, <span class=\"number\">1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">        i = A.index(x)</span><br><span class=\"line\">        ans.extend((i+<span class=\"number\">1</span>, x))</span><br><span class=\"line\">        A = A[:i:<span class=\"number\">-1</span>] + A[:i]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"1566-Detect-Pattern-of-Length-M-Repeated-K-or-More-Times\"><a href=\"#1566-Detect-Pattern-of-Length-M-Repeated-K-or-More-Times\" class=\"headerlink\" title=\"1566. Detect Pattern of Length M Repeated K or More Times\"></a>1566. Detect Pattern of Length M Repeated K or More Times</h3><h4 id=\"判断数组中是否有k次以上个重复的M大小的组。原题\"><a href=\"#判断数组中是否有k次以上个重复的M大小的组。原题\" class=\"headerlink\" title=\"判断数组中是否有k次以上个重复的M大小的组。原题\"></a>判断数组中是否有k次以上个重复的M大小的组。<a href=\"https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: arr &#x3D; [1,2,4,4,4,4], m &#x3D; 1, k &#x3D; 3</span><br><span class=\"line\">Output: true</span><br><span class=\"line\">Explanation: The pattern (4) of length 1 is repeated 4 consecutive times. Notice that pattern can be repeated k or more times but not less.</span><br></pre></td></tr></table></figure>\n<p>方法一：暴力。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">containsPattern</span><span class=\"params\">(self, arr: List[int], m: int, k: int)</span> -&gt; bool:</span></span><br><span class=\"line\">    n = len(arr)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">        end = i + m*k</span><br><span class=\"line\">        <span class=\"keyword\">if</span> end &gt; n: <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        tmp = arr[i:i+m]</span><br><span class=\"line\">        <span class=\"comment\"># if all(arr[i+m*j:i+m*j+m] == tmp for j in range(1, k)):</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> arr[i:i+m*k] == tmp*k:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：这个方法挺难想，为什么是<code>(k-1)*m</code>因为第一个用来比较，不算在内，如果在达到之前有一个不相等，则归零。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">containsPattern</span><span class=\"params\">(self, arr: List[int], m: int, k: int)</span> -&gt; bool:</span></span><br><span class=\"line\">    streak = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(arr)-m):</span><br><span class=\"line\">        streak = streak + <span class=\"number\">1</span> <span class=\"keyword\">if</span> arr[i] == arr[i+m] <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> streak == (k<span class=\"number\">-1</span>)*m: <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"228-Summary-Ranges\"><a href=\"#228-Summary-Ranges\" class=\"headerlink\" title=\"228. Summary Ranges\"></a>228. Summary Ranges</h3><h4 id=\"格式化一段range。原题\"><a href=\"#格式化一段range。原题\" class=\"headerlink\" title=\"格式化一段range。原题\"></a>格式化一段range。<a href=\"https://leetcode.com/problems/summary-ranges/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input:  [0,1,2,4,5,7]</span><br><span class=\"line\">Output: [&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]</span><br><span class=\"line\">Explanation: 0,1,2 form a continuous range; 4,5 form a continuous range.</span><br></pre></td></tr></table></figure>\n<p>方法一：很简单，记录这题主要是学到了一个新的写法。先贴自己的解法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">summaryRanges</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[str]:</span></span><br><span class=\"line\">    stack = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> stack <span class=\"keyword\">or</span> stack[<span class=\"number\">-1</span>][<span class=\"number\">-1</span>]+<span class=\"number\">1</span>&lt;d:</span><br><span class=\"line\">            stack.append([d])</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(stack[<span class=\"number\">-1</span>]) == <span class=\"number\">2</span>:</span><br><span class=\"line\">                stack[<span class=\"number\">-1</span>].pop()</span><br><span class=\"line\">            stack[<span class=\"number\">-1</span>].append(d)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"string\">'-&gt;'</span>.join(map(str, p)) <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> stack]</span><br></pre></td></tr></table></figure>\n<p>方法二：stefan的写法。<code>[][1:] = 1,</code>数组会变成[1]。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">summaryRanges</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[str]:</span></span><br><span class=\"line\">    stack = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> stack <span class=\"keyword\">or</span> stack[<span class=\"number\">-1</span>][<span class=\"number\">-1</span>]+<span class=\"number\">1</span>&lt;d:</span><br><span class=\"line\">            stack.append([])</span><br><span class=\"line\">        stack[<span class=\"number\">-1</span>][<span class=\"number\">1</span>:] = d, </span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"string\">'-&gt;'</span>.join(map(str, p)) <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> stack]</span><br></pre></td></tr></table></figure>\n<h3 id=\"769-Max-Chunks-To-Make-Sorted\"><a href=\"#769-Max-Chunks-To-Make-Sorted\" class=\"headerlink\" title=\"769. Max Chunks To Make Sorted\"></a>769. Max Chunks To Make Sorted</h3><h4 id=\"可以将一个数组分成几块小数组，然后使每个小数组排序后连接起来，整个大数组有序，问最多可以分成多少块。原题\"><a href=\"#可以将一个数组分成几块小数组，然后使每个小数组排序后连接起来，整个大数组有序，问最多可以分成多少块。原题\" class=\"headerlink\" title=\"可以将一个数组分成几块小数组，然后使每个小数组排序后连接起来，整个大数组有序，问最多可以分成多少块。原题\"></a>可以将一个数组分成几块小数组，然后使每个小数组排序后连接起来，整个大数组有序，问最多可以分成多少块。<a href=\"https://leetcode.com/problems/max-chunks-to-make-sorted/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: arr &#x3D; [1,0,2,3,4]</span><br><span class=\"line\">Output: 4</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">We can split into two chunks, such as [1, 0], [2, 3, 4].</span><br><span class=\"line\">However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible.</span><br></pre></td></tr></table></figure>\n<p>方法一：直白来看，如果某一段包含了排序后应该有的所有的数，那么久将其分成一段。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxChunksToSorted</span><span class=\"params\">(self, arr: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    ans, n = <span class=\"number\">0</span>, len(arr)</span><br><span class=\"line\">    start = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> end <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n+<span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> sorted(arr[start:end]) == list(range(start, end)):</span><br><span class=\"line\">            ans += <span class=\"number\">1</span></span><br><span class=\"line\">            start = end</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：Lee的方法。当max(A[0]~A[i])==i时分割，其中包含了一个原理，如果更大的数参入到之前的段中，最大值就会更新，想要在某点和索引相等，就必须将比它小的数全找到。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxChunksToSorted</span><span class=\"params\">(self, arr: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    cur_max, ans = <span class=\"number\">-1</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, num <span class=\"keyword\">in</span> enumerate(arr):</span><br><span class=\"line\">        cur_max = max(num, cur_max)</span><br><span class=\"line\">        ans += cur_max==i</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"390-Elimination-Game\"><a href=\"#390-Elimination-Game\" class=\"headerlink\" title=\"390. Elimination Game\"></a>390. Elimination Game</h3><h4 id=\"消除游戏，从1-n的数组，每次从左到右隔一个删除，然后从右到左隔一个删除。最后剩下一个数字是哪个。原题\"><a href=\"#消除游戏，从1-n的数组，每次从左到右隔一个删除，然后从右到左隔一个删除。最后剩下一个数字是哪个。原题\" class=\"headerlink\" title=\"消除游戏，从1~n的数组，每次从左到右隔一个删除，然后从右到左隔一个删除。最后剩下一个数字是哪个。原题\"></a>消除游戏，从1~n的数组，每次从左到右隔一个删除，然后从右到左隔一个删除。最后剩下一个数字是哪个。<a href=\"https://leetcode.com/problems/elimination-game/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input:</span><br><span class=\"line\">n &#x3D; 9,</span><br><span class=\"line\">1 2 3 4 5 6 7 8 9</span><br><span class=\"line\">2 4 6 8</span><br><span class=\"line\">2 6</span><br><span class=\"line\">6</span><br><span class=\"line\"></span><br><span class=\"line\">Output:</span><br><span class=\"line\">6</span><br></pre></td></tr></table></figure>\n<p>方法一：在用切片方法发现n能到1亿时，超时了；然后想到其实只需要控制一个范围即可。每次操作后，数组中的等差变为原来的2倍。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lastRemaining</span><span class=\"params\">(self, n: int)</span> -&gt; int:</span></span><br><span class=\"line\">    start, end, d = <span class=\"number\">1</span>, n, <span class=\"number\">1</span></span><br><span class=\"line\">    op = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> start &lt; end:</span><br><span class=\"line\">        <span class=\"comment\"># print(start, end, d, op)</span></span><br><span class=\"line\">        num = (end-start)//d + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> op:</span><br><span class=\"line\">            start += d</span><br><span class=\"line\">            end -= (num&amp;<span class=\"number\">1</span>) * d</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            start += (num&amp;<span class=\"number\">1</span>) * d</span><br><span class=\"line\">            end -= d</span><br><span class=\"line\">        op ^= <span class=\"number\">1</span></span><br><span class=\"line\">        d *= <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> start</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：整理代码。end其实无用，用一个num表示剩余的数字个数。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lastRemaining</span><span class=\"params\">(self, n: int)</span> -&gt; int:</span></span><br><span class=\"line\">    start = d = left = <span class=\"number\">1</span></span><br><span class=\"line\">    num = n</span><br><span class=\"line\">    <span class=\"keyword\">while</span> num &gt; <span class=\"number\">1</span>:</span><br><span class=\"line\">        start += (left <span class=\"keyword\">or</span> (num&amp;<span class=\"number\">1</span>)) * d</span><br><span class=\"line\">        left ^= <span class=\"number\">1</span></span><br><span class=\"line\">        d *= <span class=\"number\">2</span></span><br><span class=\"line\">        num //= <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> start</span><br></pre></td></tr></table></figure>\n<h3 id=\"853-Car-Fleet\"><a href=\"#853-Car-Fleet\" class=\"headerlink\" title=\"853. Car Fleet\"></a>853. Car Fleet</h3><h4 id=\"超车车队，说有这么一些车向同一个目的地出发，起始位置和速度不同，当快车遇见慢车时不能超过，而是跟在后面变成一个车队。问最后到达终点时有几个车队，1辆车也算一个车队。原题\"><a href=\"#超车车队，说有这么一些车向同一个目的地出发，起始位置和速度不同，当快车遇见慢车时不能超过，而是跟在后面变成一个车队。问最后到达终点时有几个车队，1辆车也算一个车队。原题\" class=\"headerlink\" title=\"超车车队，说有这么一些车向同一个目的地出发，起始位置和速度不同，当快车遇见慢车时不能超过，而是跟在后面变成一个车队。问最后到达终点时有几个车队，1辆车也算一个车队。原题\"></a>超车车队，说有这么一些车向同一个目的地出发，起始位置和速度不同，当快车遇见慢车时不能超过，而是跟在后面变成一个车队。问最后到达终点时有几个车队，1辆车也算一个车队。<a href=\"https://leetcode.com/problems/car-fleet/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: target &#x3D; 12, position &#x3D; [10,8,0,5,3], speed &#x3D; [2,4,1,1,3]</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">The cars starting at 10 and 8 become a fleet, meeting each other at 12.</span><br><span class=\"line\">The car starting at 0 doesn&#39;t catch up to any other car, so it is a fleet by itself.</span><br><span class=\"line\">The cars starting at 5 and 3 become a fleet, meeting each other at 6.</span><br><span class=\"line\">Note that no other cars meet these fleets before the destination, so the answer is 3.</span><br></pre></td></tr></table></figure>\n<p>方法一：思路很快想出来了，就是排序，但是根据什么排序，怎么比较想了半天。问题出在这个例子上：<code>10, [0,4,2],[2,1,3]</code>这个排序后时<code>[(4, 6), (2, 2.6), (0, 5)]</code>，以起始点位置排序，当一个时间小于等于之前的时间时，那么这辆车就能追上之前的，变成一个车队；反之，则形成一个单独的车队。这个“之前的时间”指的不是挨着的前面的一个时间，而是之前最慢的一个车。也就是时间最大的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">carFleet</span><span class=\"params\">(self, target: int, position: List[int], speed: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    cars = ((target-p)/s <span class=\"keyword\">for</span> p, s <span class=\"keyword\">in</span> sorted(zip(position, speed), reverse=<span class=\"literal\">True</span>))</span><br><span class=\"line\">    ans = cur_t = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> cars:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> t &gt; cur_t:</span><br><span class=\"line\">            cur_t = t</span><br><span class=\"line\">            ans += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"1574-Shortest-Subarray-to-be-Removed-to-Make-Array-Sorted\"><a href=\"#1574-Shortest-Subarray-to-be-Removed-to-Make-Array-Sorted\" class=\"headerlink\" title=\"1574. Shortest Subarray to be Removed to Make Array Sorted\"></a>1574. Shortest Subarray to be Removed to Make Array Sorted</h3><h4 id=\"删除一个最短的子数组使整个数组有序。问最短数组长度为多少。原题\"><a href=\"#删除一个最短的子数组使整个数组有序。问最短数组长度为多少。原题\" class=\"headerlink\" title=\"删除一个最短的子数组使整个数组有序。问最短数组长度为多少。原题\"></a>删除一个最短的子数组使整个数组有序。问最短数组长度为多少。<a href=\"https://leetcode.com/problems/shortest-subarray-to-be-removed-to-make-array-sorted/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: arr &#x3D; [1,2,3,10,4,2,3,5]</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: The shortest subarray we can remove is [10,4,2] of length 3. The remaining elements after that will be [1,2,3,3,5] which are sorted.</span><br><span class=\"line\">Another correct solution is to remove the subarray [3,10,4].</span><br></pre></td></tr></table></figure>\n<p>方法一：这个题竞赛时没做出来，只想到从左到右找坏的点，没想到从右到左也需要找一次。而且找完之后，要控制两个指针，从0和j出发遍历，自己想的是从中间往两边遍历。边界条件非常多。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findLengthOfShortestSubarray</span><span class=\"params\">(self, arr: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    n = len(arr)</span><br><span class=\"line\">    i = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> i+<span class=\"number\">1</span>&lt;n <span class=\"keyword\">and</span> arr[i]&lt;=arr[i+<span class=\"number\">1</span>]: i += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> i == n<span class=\"number\">-1</span>: <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    j = n<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> j &gt; i <span class=\"keyword\">and</span> arr[j<span class=\"number\">-1</span>] &lt;= arr[j]: j -= <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> j == <span class=\"number\">0</span>: <span class=\"keyword\">return</span> n<span class=\"number\">-1</span></span><br><span class=\"line\">    ans = min(n-i<span class=\"number\">-1</span>, j)</span><br><span class=\"line\">    left = <span class=\"number\">0</span></span><br><span class=\"line\">    right = j</span><br><span class=\"line\">    <span class=\"keyword\">while</span> left &lt;= i <span class=\"keyword\">and</span> right &lt; n:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> arr[right] &gt;= arr[left]:</span><br><span class=\"line\">            ans = min(ans, right-left<span class=\"number\">-1</span>)</span><br><span class=\"line\">            left += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            right += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"835-Image-Overlap\"><a href=\"#835-Image-Overlap\" class=\"headerlink\" title=\"835. Image Overlap\"></a>835. Image Overlap</h3><h4 id=\"图片覆盖。两个二维矩阵，A可以向一个方向滑动N个单位，然后放到B上，如果都为1，则表示某个像素是覆盖的。求最多有多少个像素覆盖。原题\"><a href=\"#图片覆盖。两个二维矩阵，A可以向一个方向滑动N个单位，然后放到B上，如果都为1，则表示某个像素是覆盖的。求最多有多少个像素覆盖。原题\" class=\"headerlink\" title=\"图片覆盖。两个二维矩阵，A可以向一个方向滑动N个单位，然后放到B上，如果都为1，则表示某个像素是覆盖的。求最多有多少个像素覆盖。原题\"></a>图片覆盖。两个二维矩阵，A可以向一个方向滑动N个单位，然后放到B上，如果都为1，则表示某个像素是覆盖的。求最多有多少个像素覆盖。<a href=\"https://leetcode.com/problems/image-overlap/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: A &#x3D; [[1,1,0],</span><br><span class=\"line\">            [0,1,0],</span><br><span class=\"line\">            [0,1,0]]</span><br><span class=\"line\">       B &#x3D; [[0,0,0],</span><br><span class=\"line\">            [0,1,1],</span><br><span class=\"line\">            [0,0,1]]</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: We slide A to right by 1 unit and down by 1 unit.</span><br></pre></td></tr></table></figure>\n<p>方法一：逆向思维，将1的点都求出来，然后每两个做比较。相同偏移量的算到一起。</p>\n<pre><code>def largestOverlap(self, A: List[List[int]], B: List[List[int]]) -&gt; int:\n    A = [(x, y) for x, row in enumerate(A) for y, d in enumerate(row) if d]\n    B = [(x, y) for x, row in enumerate(B) for y, d in enumerate(row) if d]\n    c = Counter((xa-xb, ya-yb) for xa, ya in A for xb, yb in B)\n    return max(c.values() or [0])\n</code></pre><p>方法二：数学的降维打击。卷积。其中涉及到了一些数学知识还没有完全参透。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">from</span> scipy.signal <span class=\"keyword\">import</span> convolve2d</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">largestOverlap</span><span class=\"params\">(self, A: List[List[int]], B: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> np.max(convolve2d(A, np.rot90(B, <span class=\"number\">2</span>)))</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> scipy.signal <span class=\"keyword\">import</span> correlate2d</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">largestOverlap</span><span class=\"params\">(self, A: List[List[int]], B: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> correlate2d(A, B).max()</span><br></pre></td></tr></table></figure>\n<h3 id=\"42-Trapping-Rain-Water\"><a href=\"#42-Trapping-Rain-Water\" class=\"headerlink\" title=\"42. Trapping Rain Water\"></a>42. Trapping Rain Water</h3><h4 id=\"接雨水。给定一些柱状图的高度，问能接多少雨水。原题\"><a href=\"#接雨水。给定一些柱状图的高度，问能接多少雨水。原题\" class=\"headerlink\" title=\"接雨水。给定一些柱状图的高度，问能接多少雨水。原题\"></a>接雨水。给定一些柱状图的高度，问能接多少雨水。<a href=\"https://leetcode.com/problems/trapping-rain-water/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><img src=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%95%B0%E7%BB%84%E7%AF%87%EF%BC%89Array/rainwatertrap.png\" class>\n<p>方法一：用了逆向思维，通过总面积-损失的水-柱体面积求的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">trap</span><span class=\"params\">(self, height: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> height: <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    h_max, n = max(height), len(height)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_lost</span><span class=\"params\">(heights, target)</span>:</span></span><br><span class=\"line\">        cur_h = lost = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, h <span class=\"keyword\">in</span> enumerate(heights):</span><br><span class=\"line\">            lost += max(h-cur_h, <span class=\"number\">0</span>) * i   </span><br><span class=\"line\">            cur_h = max(cur_h, h)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> h == target:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> lost</span><br><span class=\"line\">    </span><br><span class=\"line\">    lost = get_lost(height, h_max) + get_lost(height[::<span class=\"number\">-1</span>], h_max)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n*h_max - lost - sum(height)</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：遍历一次，其实思路是一样的，从两边到中间，当遇见一次下降时，计算差值面积，就是蓄水面积。left_max, right_max可以看做是两面墙。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">trap</span><span class=\"params\">(self, height: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    left, right = <span class=\"number\">0</span>, len(height)<span class=\"number\">-1</span></span><br><span class=\"line\">    ans = left_max = right_max = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> left &lt; right:</span><br><span class=\"line\">        left_max = max(left_max, height[left])</span><br><span class=\"line\">        right_max = max(right_max, height[right])</span><br><span class=\"line\">        <span class=\"keyword\">if</span> left_max &lt; right_max:</span><br><span class=\"line\">            ans += left_max - height[left]</span><br><span class=\"line\">            left += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            ans += right_max - height[right]</span><br><span class=\"line\">            right -= <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"36-Valid-Sudoku\"><a href=\"#36-Valid-Sudoku\" class=\"headerlink\" title=\"36. Valid Sudoku\"></a>36. Valid Sudoku</h3><h4 id=\"验证一个数独的正确性，只需要考虑填入数字的格子。原题\"><a href=\"#验证一个数独的正确性，只需要考虑填入数字的格子。原题\" class=\"headerlink\" title=\"验证一个数独的正确性，只需要考虑填入数字的格子。原题\"></a>验证一个数独的正确性，只需要考虑填入数字的格子。<a href=\"https://leetcode.com/problems/valid-sudoku/\" target=\"_blank\" rel=\"noopener\">原题</a></h4><p>方法一：比较直观的写法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isValidSudoku</span><span class=\"params\">(self, board: List[List[str]])</span> -&gt; bool:</span></span><br><span class=\"line\">    row = [[<span class=\"literal\">True</span>]*<span class=\"number\">9</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">9</span>)]        </span><br><span class=\"line\">    col = [[<span class=\"literal\">True</span>]*<span class=\"number\">9</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">9</span>)]</span><br><span class=\"line\">    sub = [[<span class=\"literal\">True</span>]*<span class=\"number\">9</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">9</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">9</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">9</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> board[i][j] != <span class=\"string\">'.'</span>:</span><br><span class=\"line\">                d = int(board[i][j]) - <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> (row[i][d] <span class=\"keyword\">and</span> col[j][d] <span class=\"keyword\">and</span> sub[i//<span class=\"number\">3</span>*<span class=\"number\">3</span>+j//<span class=\"number\">3</span>][d]):</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">                row[i][d] = col[j][d] = sub[i//<span class=\"number\">3</span>*<span class=\"number\">3</span>+j//<span class=\"number\">3</span>][d] = <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：Counter, by Stefan. 记录3种元素，如果有重复的 就说明不行。这里和python2有个区别，原来是用的+，python3中字典的values()方法返回的是一个<code>dict_values</code>的对象。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isValidSudoku</span><span class=\"params\">(self, board: List[List[str]])</span> -&gt; bool:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span> == max(collections.Counter(</span><br><span class=\"line\">        x <span class=\"keyword\">for</span> i, row <span class=\"keyword\">in</span> enumerate(board)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j, c <span class=\"keyword\">in</span> enumerate(row)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> c != <span class=\"string\">'.'</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> ((c, i), (j, c), (i//<span class=\"number\">3</span>, j//<span class=\"number\">3</span>, c))</span><br><span class=\"line\">    ).values() <span class=\"keyword\">or</span> [<span class=\"number\">1</span>])</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：同样来自Stefan，这个方法很有趣，将判断放到了生成器中。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isValidSudoku</span><span class=\"params\">(self, board: List[List[str]])</span> -&gt; bool:</span></span><br><span class=\"line\">    seen = set()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">not</span> any(x <span class=\"keyword\">in</span> seen <span class=\"keyword\">or</span> seen.add(x)</span><br><span class=\"line\">                   <span class=\"keyword\">for</span> i, row <span class=\"keyword\">in</span> enumerate(board)</span><br><span class=\"line\">                   <span class=\"keyword\">for</span> j, c <span class=\"keyword\">in</span> enumerate(row)</span><br><span class=\"line\">                   <span class=\"keyword\">if</span> c != <span class=\"string\">'.'</span></span><br><span class=\"line\">                   <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> ((c, i), (j, c), (i//<span class=\"number\">3</span>, j//<span class=\"number\">3</span>, c)))</span><br></pre></td></tr></table></figure>\n<h3 id=\"1054-Distant-Barcodes\"><a href=\"#1054-Distant-Barcodes\" class=\"headerlink\" title=\"1054. Distant Barcodes\"></a><a href=\"https://leetcode.com/problems/distant-barcodes/\" target=\"_blank\" rel=\"noopener\">1054. Distant Barcodes</a></h3><h4 id=\"分散的条形码，就是将一个数组中的元素重新排序，让其没有两个一样的相邻。原题\"><a href=\"#分散的条形码，就是将一个数组中的元素重新排序，让其没有两个一样的相邻。原题\" class=\"headerlink\" title=\"分散的条形码，就是将一个数组中的元素重新排序，让其没有两个一样的相邻。原题\"></a>分散的条形码，就是将一个数组中的元素重新排序，让其没有两个一样的相邻。<a href=\"ps://leetcode.com/problems/distant-barcodes/\">原题</a></h4><p>方法一：我首次AC的方法就是用堆，取出一个或者2个数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rearrangeBarcodes</span><span class=\"params\">(self, barcodes: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    c = Counter(barcodes)</span><br><span class=\"line\">    heap = []</span><br><span class=\"line\">    ans = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> k, v <span class=\"keyword\">in</span> c.items():</span><br><span class=\"line\">        heapq.heappush(heap, (-v, k))</span><br><span class=\"line\">    <span class=\"keyword\">while</span> heap:</span><br><span class=\"line\">        most, d1 = heapq.heappop(heap)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ans <span class=\"keyword\">and</span> ans[<span class=\"number\">-1</span>]==d1:</span><br><span class=\"line\">            more, d2 = heapq.heappop(heap)</span><br><span class=\"line\">            ans.append(d2)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> more &lt; <span class=\"number\">-1</span>:</span><br><span class=\"line\">                heapq.heappush(heap, (more+<span class=\"number\">1</span>, d2))</span><br><span class=\"line\">            heapq.heappush(heap, (most, d1))</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        ans.append(d1)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> most &lt; <span class=\"number\">-1</span>:</span><br><span class=\"line\">            heapq.heappush(heap, (most+<span class=\"number\">1</span>, d1))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：by Lee, 将最多的数字，按索引分割依次插入。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rearrangeBarcodes</span><span class=\"params\">(self, barcodes: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    i, n = <span class=\"number\">0</span>, len(barcodes)</span><br><span class=\"line\">    ans = [<span class=\"number\">0</span>] * n</span><br><span class=\"line\">    <span class=\"keyword\">for</span> k, v <span class=\"keyword\">in</span> collections.Counter(barcodes).most_common():</span><br><span class=\"line\">        <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(v):</span><br><span class=\"line\">            ans[i] = k</span><br><span class=\"line\">            i += <span class=\"number\">2</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> i &gt;= n: i = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法三：by Lee，看到方法二时就想到了，这里需要注意一下，排序时要用一个元组，将一样的元素放到一起。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rearrangeBarcodes</span><span class=\"params\">(self, a: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    count = collections.Counter(a)</span><br><span class=\"line\">    a.sort(key=<span class=\"keyword\">lambda</span> x: (count[x], x))</span><br><span class=\"line\">    a[<span class=\"number\">1</span>::<span class=\"number\">2</span>], a[::<span class=\"number\">2</span>] = a[:len(a)//<span class=\"number\">2</span>], a[len(a)//<span class=\"number\">2</span>:]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a</span><br></pre></td></tr></table></figure>\n<h3 id=\"1588-Sum-of-All-Odd-Length-Subarrays\"><a href=\"#1588-Sum-of-All-Odd-Length-Subarrays\" class=\"headerlink\" title=\"1588. Sum of All Odd Length Subarrays\"></a><a href=\"https://leetcode.com/problems/sum-of-all-odd-length-subarrays/\" target=\"_blank\" rel=\"noopener\">1588. Sum of All Odd Length Subarrays</a></h3><h4 id=\"求所有奇数长度的子数组的和。\"><a href=\"#求所有奇数长度的子数组的和。\" class=\"headerlink\" title=\"求所有奇数长度的子数组的和。\"></a>求所有奇数长度的子数组的和。</h4><p>方法一：这题给的范围比较小，竞赛时用O(n^2)暴力就解了，不过实际有O(n)的方法。通过前缀和的方式，累加，再通过减法算和。比如<code>[1,4,2,5,3]</code>。<code>j-i</code>表示的是子数组的长度。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sumOddLengthSubarrays</span><span class=\"params\">(self, arr: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    n, sum_odd = len(arr), <span class=\"number\">0</span></span><br><span class=\"line\">    p_sum = [<span class=\"number\">0</span>] + list(itertools.accumulate(arr))</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, p <span class=\"keyword\">in</span> enumerate(p_sum):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i + <span class=\"number\">1</span>, n + <span class=\"number\">1</span>, <span class=\"number\">2</span>):</span><br><span class=\"line\">            <span class=\"comment\"># print(i, j, p_sum[j], p_sum[i])</span></span><br><span class=\"line\">            sum_odd += p_sum[j] - p_sum[i] </span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum_odd</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">0 1 1 0</span><br><span class=\"line\">0 3 7 0</span><br><span class=\"line\">0 5 15 0</span><br><span class=\"line\">1 2 5 1</span><br><span class=\"line\">1 4 12 1</span><br><span class=\"line\">2 3 7 5</span><br><span class=\"line\">2 5 15 5</span><br><span class=\"line\">3 4 12 7</span><br><span class=\"line\">4 5 15 12</span><br></pre></td></tr></table></figure>\n<p>方法二：通过观察可以找到规律，每个数字出现的个数是有规律的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">1 2 3 4 5 subarray length 1</span><br><span class=\"line\">1 2 X X X subarray length 2</span><br><span class=\"line\">X 2 3 X X subarray length 2</span><br><span class=\"line\">X X 3 4 X subarray length 2</span><br><span class=\"line\">X X X 4 5 subarray length 2</span><br><span class=\"line\">1 2 3 X X subarray length 3</span><br><span class=\"line\">X 2 3 4 X subarray length 3</span><br><span class=\"line\">X X 3 4 5 subarray length 3</span><br><span class=\"line\">1 2 3 4 X subarray length 4</span><br><span class=\"line\">X 2 3 4 5 subarray length 4</span><br><span class=\"line\">1 2 3 4 5 subarray length 5</span><br><span class=\"line\"></span><br><span class=\"line\">5 8 9 8 5 total times each index was added.</span><br><span class=\"line\">3 4 5 4 3 total times in odd length array with (x + 1) &#x2F; 2</span><br><span class=\"line\">2 4 4 4 2 total times in even length array with x &#x2F; 2</span><br></pre></td></tr></table></figure>\n<font color=\"#32CD32\" size=\"3\">方法二：在所有子数组中，不管奇偶总共有多少，比如包含2的子数组，左边有2个子数组，右边4个子数组，一共有2<em>4，也就是说<br><br>对于第i个元素，包含第i个元素的子数组=`(i+1) </em> (n-i)<code>奇数数组</code>(x+1)//2`, x表示总数。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sumOddLengthSubarrays</span><span class=\"params\">(self, arr: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    ans, n = <span class=\"number\">0</span>, len(arr)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, a <span class=\"keyword\">in</span> enumerate(arr):</span><br><span class=\"line\">        ans += (((i+<span class=\"number\">1</span>)*(n-i) + <span class=\"number\">1</span>) // <span class=\"number\">2</span>) * a</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"面试题-16-22-兰顿蚂蚁\"><a href=\"#面试题-16-22-兰顿蚂蚁\" class=\"headerlink\" title=\"面试题 16.22. 兰顿蚂蚁\"></a><a href=\"https://leetcode-cn.com/problems/langtons-ant-lcci/\" target=\"_blank\" rel=\"noopener\">面试题 16.22. 兰顿蚂蚁</a></h3><blockquote>\n<p><strong>兰顿蚂蚁</strong>（英语：Langton’s ant）是<a href=\"https://zh.wikipedia.org/wiki/細胞自動機\" target=\"_blank\" rel=\"noopener\">细胞自动机</a>的例子。它由<a href=\"https://zh.wikipedia.org/w/index.php?title=克里斯托夫·兰顿&amp;action=edit&amp;redlink=1\" target=\"_blank\" rel=\"noopener\">克里斯托夫·兰顿</a>在1986年提出，它由黑白格子和一只“蚂蚁”构成<a href=\"https://zh.wikipedia.org/wiki/兰顿蚂蚁#cite_note-1\" target=\"_blank\" rel=\"noopener\">[1]</a>，是一个二维<a href=\"https://zh.wikipedia.org/wiki/图灵机\" target=\"_blank\" rel=\"noopener\">图灵机</a>。兰顿蚂蚁拥有非常简单的逻辑和复杂的表现。在2000年兰顿蚂蚁的<a href=\"https://zh.wikipedia.org/wiki/圖靈完備性\" target=\"_blank\" rel=\"noopener\">图灵完备性</a>被证明。兰顿蚂蚁的想法后来被推广，比如使用多种颜色。</p>\n<p>若从全白的背景开始，在一开始的数百步，蚂蚁留下的路线会出现许多对称或重复的形状，然后会出现类似混沌的假随机，至约一万步后会出现以104步为周期无限重复的“高速公路”朝固定方向移动<a href=\"https://zh.wikipedia.org/wiki/兰顿蚂蚁#cite_note-2\" target=\"_blank\" rel=\"noopener\">[2]</a>。在目前试过的所有起始状态，蚂蚁的路线最终都会变成高速公路，但尚无法证明这是无论任何起始状态都会导致的必然结果<a href=\"https://zh.wikipedia.org/wiki/兰顿蚂蚁#cite_note-3\" target=\"_blank\" rel=\"noopener\">[3]</a>。</p>\n</blockquote>\n<p>这道题非常有意思。一只蚂蚁坐在由白色和黑色方格构成的无限网格上。开始时，网格全白，蚂蚁面向右侧。每行走一步，蚂蚁执行以下操作。返回能够包含蚂蚁走过的所有方格的最小矩形。</p>\n<p>(1) 如果在白色方格上，则翻转方格的颜色，向右(顺时针)转 90 度，并向前移动一个单位。<br>(2) 如果在黑色方格上，则翻转方格的颜色，向左(逆时针方向)转 90 度，并向前移动一个单位</p>\n<font color=\"#32CD32\" size=\"3\">方法一：刚看到此题时草率了，还想找到规律，后来一搜，原来在一万步之后才会出现某种规律，打扰了。此方法用了一个二维的双端队列模拟的。700ms, 40。</font>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">printKMoves</span><span class=\"params\">(self, K: int)</span> -&gt; List[str]:</span></span><br><span class=\"line\">    ax, ay = <span class=\"number\">0</span>, <span class=\"number\">0</span>  <span class=\"comment\"># 蚂蚁🐜</span></span><br><span class=\"line\">    di, dj, m, n = <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>  <span class=\"comment\"># 方向和矩阵高，长</span></span><br><span class=\"line\">    g = deque([deque([<span class=\"number\">0</span>])])  <span class=\"comment\"># 0 表示白色</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(K):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> g[ax][ay]==<span class=\"number\">0</span>:</span><br><span class=\"line\">            di, dj = dj, -di  <span class=\"comment\"># 顺时针</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            di, dj = -dj, di  <span class=\"comment\"># 逆时针</span></span><br><span class=\"line\">        g[ax][ay] ^= <span class=\"number\">1</span>        <span class=\"comment\"># 翻转</span></span><br><span class=\"line\">        ax, ay = ax+di, ay+dj   <span class=\"comment\"># 移动</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ax <span class=\"keyword\">in</span> (<span class=\"number\">-1</span>, m):       <span class=\"comment\"># 上下越界</span></span><br><span class=\"line\">            g.append(deque([<span class=\"number\">0</span>]*n))</span><br><span class=\"line\">            g.rotate(ax&lt;<span class=\"number\">0</span>)       <span class=\"comment\"># 上越界，直接appendleft也可以，这里写到了一起</span></span><br><span class=\"line\">            m += <span class=\"number\">1</span></span><br><span class=\"line\">            ax = max(ax, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> ay &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> g:</span><br><span class=\"line\">                row.appendleft(<span class=\"number\">0</span>)            </span><br><span class=\"line\">            n += <span class=\"number\">1</span></span><br><span class=\"line\">            ay += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> ay &gt;= n:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> g:</span><br><span class=\"line\">                row.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">            n += <span class=\"number\">1</span></span><br><span class=\"line\">    g[ax][ay] = <span class=\"number\">-1</span></span><br><span class=\"line\">    d = ((<span class=\"string\">'LR'</span>, <span class=\"string\">'UD'</span>)[di][(dj&gt;=<span class=\"number\">0</span>)&amp;(di&gt;=<span class=\"number\">0</span>)])  <span class=\"comment\"># 阴间写法</span></span><br><span class=\"line\">    <span class=\"comment\"># d = &#123;(0, -1): 'L', (-1, 0): 'U', (1, 0): 'D', (0, 1): 'R'&#125;[di, dj] # 阳间写法</span></span><br><span class=\"line\">    ans = [<span class=\"string\">''</span>.join((<span class=\"string\">'_X'</span>+d)[c] <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> row) <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> g]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>方法二：受评论区大神启发，使用<code>defaultdict</code>来避免每次都移动数组。写法是不错，但是时间和空间上都比方法一差太多，时间是3，4倍，空间是10倍。所以我改了一下改成两个defaultdict，时间上虽然还是不如方法一，但是时间空间都好了一半。最后是1500ms, 240M。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">printKMoves</span><span class=\"params\">(self, K: int)</span> -&gt; List[str]:</span></span><br><span class=\"line\">    ax, ay = <span class=\"number\">0</span>, <span class=\"number\">0</span>  <span class=\"comment\"># 蚂蚁🐜</span></span><br><span class=\"line\">    di, dj, m, n = <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>  <span class=\"comment\"># 初始方向和矩阵高，长</span></span><br><span class=\"line\">    g = defaultdict(<span class=\"keyword\">lambda</span>: defaultdict(int))</span><br><span class=\"line\">    r1 = r2 = c1 = c2 = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">spread</span><span class=\"params\">(x, y)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">nonlocal</span> r1, r2, c1, c2</span><br><span class=\"line\">        r1, r2, c1, c2 = min(r1, x), max(r2, x), min(c1, y), max(c2, y)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(K):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> g[ax][ay]==<span class=\"number\">0</span>:</span><br><span class=\"line\">            di, dj = dj, -di  <span class=\"comment\"># 顺时针</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            di, dj = -dj, di  <span class=\"comment\"># 逆时针</span></span><br><span class=\"line\">        g[ax][ay] ^= <span class=\"number\">1</span>        <span class=\"comment\"># 翻转</span></span><br><span class=\"line\">        ax, ay = ax+di, ay+dj   <span class=\"comment\"># 移动</span></span><br><span class=\"line\">        spread(ax, ay)</span><br><span class=\"line\">    g[ax][ay] = <span class=\"number\">-1</span></span><br><span class=\"line\">    d = ((<span class=\"string\">'LR'</span>, <span class=\"string\">'UD'</span>)[di][(dj&gt;=<span class=\"number\">0</span>)&amp;(di&gt;=<span class=\"number\">0</span>)])  <span class=\"comment\"># 阴间写法</span></span><br><span class=\"line\">    <span class=\"comment\"># d = &#123;(0, -1): 'L', (-1, 0): 'U', (1, 0): 'D', (0, 1): 'R'&#125;[di, dj] # 阳间写法</span></span><br><span class=\"line\">    ans = [<span class=\"string\">''</span>.join((<span class=\"string\">'_X'</span>+d)[g[i][j]] </span><br><span class=\"line\">           <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(c1, c2+<span class=\"number\">1</span>)) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(r1, r2+<span class=\"number\">1</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"41-First-Missing-Positive\"><a href=\"#41-First-Missing-Positive\" class=\"headerlink\" title=\"41. First Missing Positive\"></a><a href=\"https://leetcode.com/problems/first-missing-positive/\" target=\"_blank\" rel=\"noopener\">41. First Missing Positive</a></h3><h4 id=\"找到数组中最小的缺失的正数。数组中可能包含负数。要求在O-N-时间，常数空间实现。\"><a href=\"#找到数组中最小的缺失的正数。数组中可能包含负数。要求在O-N-时间，常数空间实现。\" class=\"headerlink\" title=\"找到数组中最小的缺失的正数。数组中可能包含负数。要求在O(N)时间，常数空间实现。\"></a>找到数组中最小的缺失的正数。数组中可能包含负数。要求在O(N)时间，常数空间实现。</h4><p>方法一：难点在于复杂度的要求。这个方法没想到，但是感觉之前用过，忘记是哪道题了。就是将元素放在它对应的索引上。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">firstMissingPositive</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(nums)):</span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"number\">0</span> &lt;= nums[i]<span class=\"number\">-1</span> &lt; len(nums) <span class=\"keyword\">and</span> nums[nums[i]<span class=\"number\">-1</span>] != nums[i]:</span><br><span class=\"line\">            j = nums[i] - <span class=\"number\">1</span></span><br><span class=\"line\">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(nums)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[i] != i+<span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> i + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> len(nums) + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"面试题-17-18-最短超串\"><a href=\"#面试题-17-18-最短超串\" class=\"headerlink\" title=\"面试题 17.18. 最短超串\"></a><a href=\"https://leetcode-cn.com/problems/shortest-supersequence-lcci/\" target=\"_blank\" rel=\"noopener\">面试题 17.18. 最短超串</a></h4><h4 id=\"找到包含small所有元素最短子数组的最小索引。\"><a href=\"#找到包含small所有元素最短子数组的最小索引。\" class=\"headerlink\" title=\"找到包含small所有元素最短子数组的最小索引。\"></a>找到包含small所有元素最短子数组的最小索引。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">big &#x3D; [7,5,9,0,2,1,3,5,7,9,1,1,5,8,8,9,7]</span><br><span class=\"line\">small &#x3D; [1,5,9]</span><br><span class=\"line\">输出: [7,10]</span><br></pre></td></tr></table></figure>\n<p>方法一：滑动窗口。挺简单的一次就AC了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">shortestSeq</span><span class=\"params\">(self, big: List[int], small: List[int])</span> -&gt; List[int]:</span></span><br><span class=\"line\">    ans, c, s = [], defaultdict(int), set(small)</span><br><span class=\"line\">    i, min_len = <span class=\"number\">0</span>, float(<span class=\"string\">'inf'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> end, d <span class=\"keyword\">in</span> enumerate(big):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> d <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">            c[d] += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> len(c) == len(s):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> end-i+<span class=\"number\">1</span> &lt; min_len:</span><br><span class=\"line\">                min_len = end - i + <span class=\"number\">1</span></span><br><span class=\"line\">                ans = [i, end]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> big[i] <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">                c[big[i]] -= <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> c[big[i]] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    c.pop(big[i])</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"289-Game-of-Life\"><a href=\"#289-Game-of-Life\" class=\"headerlink\" title=\"289. Game of Life\"></a><a href=\"https://leetcode.com/problems/game-of-life/\" target=\"_blank\" rel=\"noopener\">289. Game of Life</a></h3><blockquote>\n<h4 id=\"生命游戏，简称为生命，是英国数学家约翰·何顿·康威在-1970-年发明的细胞自动机。\"><a href=\"#生命游戏，简称为生命，是英国数学家约翰·何顿·康威在-1970-年发明的细胞自动机。\" class=\"headerlink\" title=\"生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。\"></a>生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。</h4><p>给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：</p>\n<p>如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；<br>如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；<br>如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；<br>如果死细胞周围正好有三个活细胞，则该位置死细胞复活；<br>根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。</p>\n</blockquote>\n<p>你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。<br>本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？</p>\n<p>方法一：首次AC的方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">gameOfLife</span><span class=\"params\">(self, board: List[List[int]])</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">    m, n = len(board), len(board[<span class=\"number\">0</span>])</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">count_live</span><span class=\"params\">(i, j)</span>:</span></span><br><span class=\"line\">        neighbors = ((<span class=\"number\">1</span>, <span class=\"number\">0</span>), (<span class=\"number\">-1</span>, <span class=\"number\">0</span>), (<span class=\"number\">0</span>, <span class=\"number\">1</span>), (<span class=\"number\">0</span>, <span class=\"number\">-1</span>), </span><br><span class=\"line\">                     (<span class=\"number\">-1</span>, <span class=\"number\">-1</span>), (<span class=\"number\">1</span>, <span class=\"number\">1</span>), (<span class=\"number\">1</span>, <span class=\"number\">-1</span>), (<span class=\"number\">-1</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum(board[i+di][j+dj] <span class=\"keyword\">for</span> di, dj <span class=\"keyword\">in</span> neighbors </span><br><span class=\"line\">                   <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=i+di&lt;m <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=j+dj&lt;n)</span><br><span class=\"line\">    </span><br><span class=\"line\">    g = [[<span class=\"number\">0</span>] * n <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(m)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            c = count_live(i, j)</span><br><span class=\"line\">            g[i][j] = int(c==<span class=\"number\">3</span> <span class=\"keyword\">or</span> (c==<span class=\"number\">2</span> <span class=\"keyword\">and</span> board[i][j]))</span><br><span class=\"line\"></span><br><span class=\"line\">    board[:] = g</span><br></pre></td></tr></table></figure>\n<p>方法二：如果面板是无限的，如何考虑呢？Stefan这样写，一个辅助函数来根据所有当前活着的细胞计算下一个状态的活细胞集。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">gameOfLife</span><span class=\"params\">(self, board: List[List[int]])</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">gameOfLifeInfinite</span><span class=\"params\">(live)</span>:</span></span><br><span class=\"line\">        ctr = collections.Counter((I, J)</span><br><span class=\"line\">                                  <span class=\"keyword\">for</span> i, j <span class=\"keyword\">in</span> live</span><br><span class=\"line\">                                  <span class=\"keyword\">for</span> I <span class=\"keyword\">in</span> range(i<span class=\"number\">-1</span>, i+<span class=\"number\">2</span>)</span><br><span class=\"line\">                                  <span class=\"keyword\">for</span> J <span class=\"keyword\">in</span> range(j<span class=\"number\">-1</span>, j+<span class=\"number\">2</span>)</span><br><span class=\"line\">                                  <span class=\"keyword\">if</span> I != i <span class=\"keyword\">or</span> J != j)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;ij</span><br><span class=\"line\">                <span class=\"keyword\">for</span> ij <span class=\"keyword\">in</span> ctr</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ctr[ij] == <span class=\"number\">3</span> <span class=\"keyword\">or</span> ctr[ij] == <span class=\"number\">2</span> <span class=\"keyword\">and</span> ij <span class=\"keyword\">in</span> live&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    live = &#123;(i, j) <span class=\"keyword\">for</span> i, row <span class=\"keyword\">in</span> enumerate(board) <span class=\"keyword\">for</span> j, live <span class=\"keyword\">in</span> enumerate(row) <span class=\"keyword\">if</span> live&#125;</span><br><span class=\"line\">    live = gameOfLifeInfinite(live)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, row <span class=\"keyword\">in</span> enumerate(board):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(row)):</span><br><span class=\"line\">            row[j] = int((i, j) <span class=\"keyword\">in</span> live)</span><br></pre></td></tr></table></figure>\n<p>方法三：此题可以使用生成器来建模，在《effictive python》中有一个非常经典的例子，《Fluent Python》中作者也提到了这个例子。我在次基础上修改了一点，主要是针对边界处理。每一个细胞都表示为一个协程，并令这些协程步调一致地向前推进。<code>step_cell</code>是一个协程，会生成·<code>Transition</code>对象用来表示细胞的状态迁移。每个细胞都可以通过运行<code>step_cell</code>来迁移到下一个状态。待所有细胞都迁移好之后，游戏的始终就会向前走一步。只要<code>simulate</code>协程在推进，这个过程就会一直持续下去。协程的优势就在于此。它令开发者所用的实现代码相互解耦。这使得程序好像能够平行地运行多个协程，也使得开发者能够在不修改协程的前提下，逐渐改进发布指令时所用的代码。不过书中说的一点没有明白”如果传入的坐标越界，那就自动折回，这使得网格看上去好像是一种无限循环的空间”，书中使用了取余的方式，但是本题中越界应该返回0。这套模板代码演示了如何用协程分离程序中的各个关注点，而关注点的分离，正是一条重要的设计原则。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">Query = namedtuple(<span class=\"string\">'Query'</span>, <span class=\"string\">'y x'</span>)   <span class=\"comment\"># 用于查询细胞的状态，这里实现很巧妙可以使协程通过此对象向外围环境查询信息</span></span><br><span class=\"line\">Transition = namedtuple(<span class=\"string\">'Transition'</span>, <span class=\"string\">'y x state'</span>)  <span class=\"comment\"># 表示细胞的状态迁移</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">gameOfLife</span><span class=\"params\">(self, board: List[List[int]])</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        Do not return anything, modify board in-place instead.</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        self.board = board</span><br><span class=\"line\">        self.TICK = object()\t<span class=\"comment\"># 停止标识，标志着一轮模拟结束</span></span><br><span class=\"line\">        sim = self.simulate(len(board), len(board[<span class=\"number\">0</span>]))</span><br><span class=\"line\">        ans = self.live_a_generation(sim)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(board)):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(board[<span class=\"number\">0</span>])):</span><br><span class=\"line\">                board[i][j] = ans[i,j]</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">count_neighbors</span><span class=\"params\">(self, y, x)</span>:</span>\t\t<span class=\"comment\">#查询了细胞周围的8个细胞状态</span></span><br><span class=\"line\">        n_ = <span class=\"keyword\">yield</span> Query(y + <span class=\"number\">1</span>, x + <span class=\"number\">0</span>)  <span class=\"comment\"># North</span></span><br><span class=\"line\">        ne = <span class=\"keyword\">yield</span> Query(y + <span class=\"number\">1</span>, x + <span class=\"number\">1</span>)  <span class=\"comment\"># Northeast</span></span><br><span class=\"line\">        e_ = <span class=\"keyword\">yield</span> Query(y + <span class=\"number\">0</span>, x + <span class=\"number\">1</span>)  <span class=\"comment\"># East</span></span><br><span class=\"line\">        se = <span class=\"keyword\">yield</span> Query(y - <span class=\"number\">1</span>, x + <span class=\"number\">1</span>)  <span class=\"comment\"># Southeast</span></span><br><span class=\"line\">        s_ = <span class=\"keyword\">yield</span> Query(y - <span class=\"number\">1</span>, x + <span class=\"number\">0</span>)  <span class=\"comment\"># South</span></span><br><span class=\"line\">        sw = <span class=\"keyword\">yield</span> Query(y - <span class=\"number\">1</span>, x - <span class=\"number\">1</span>)  <span class=\"comment\"># Southwest</span></span><br><span class=\"line\">        w_ = <span class=\"keyword\">yield</span> Query(y + <span class=\"number\">0</span>, x - <span class=\"number\">1</span>)  <span class=\"comment\"># West</span></span><br><span class=\"line\">        nw = <span class=\"keyword\">yield</span> Query(y + <span class=\"number\">1</span>, x - <span class=\"number\">1</span>)  <span class=\"comment\"># Northwest</span></span><br><span class=\"line\">        neighbor_states = [n_, ne, e_, se, s_, sw, w_, nw]</span><br><span class=\"line\">        count = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> state <span class=\"keyword\">in</span> neighbor_states:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> state == <span class=\"number\">1</span>:</span><br><span class=\"line\">                count += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> count</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">game_logic</span><span class=\"params\">(self, state, neighbors)</span>:</span>   <span class=\"comment\"># 游戏逻辑</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> state == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> neighbors &lt; <span class=\"number\">2</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>     <span class=\"comment\"># Die: Too few</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> neighbors &gt; <span class=\"number\">3</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>     <span class=\"comment\"># Die: Too many</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> neighbors == <span class=\"number\">3</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">1</span>     <span class=\"comment\"># Regenerate</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> state</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">step_cell</span><span class=\"params\">(self, y, x)</span>:</span>\t\t</span><br><span class=\"line\">        state = <span class=\"keyword\">yield</span> Query(y, x)\t\t<span class=\"comment\"># 查询当前细胞状态</span></span><br><span class=\"line\">        neighbors = <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> self.count_neighbors(y, x)  <span class=\"comment\"># 查询周围细胞状态，`count_neighbors`协程</span></span><br><span class=\"line\">        next_state = self.game_logic(state, neighbors)\t\t<span class=\"comment\"># 细胞的下一次状态</span></span><br><span class=\"line\">        <span class=\"keyword\">yield</span> Transition(y, x, next_state)\t\t<span class=\"comment\"># 生成迁移对象，将细胞在下一轮的状态告诉外部代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">simulate</span><span class=\"params\">(self, height, width)</span>:</span>    <span class=\"comment\">#  模拟协程</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> y <span class=\"keyword\">in</span> range(height):</span><br><span class=\"line\">                <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(width):</span><br><span class=\"line\">                    <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> self.step_cell(y, x)</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> self.TICK</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">live_a_generation</span><span class=\"params\">(self, sim)</span>:</span>\t\t\t<span class=\"comment\"># 主函数</span></span><br><span class=\"line\">        M, N = len(self.board), len(self.board[<span class=\"number\">0</span>])</span><br><span class=\"line\">        progeny = Grid(M, N)</span><br><span class=\"line\">        item = next(sim)</span><br><span class=\"line\">        <span class=\"keyword\">while</span> item <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> self.TICK:\t\t<span class=\"comment\"># 对所有的细胞向前推进一步</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> isinstance(item, Query):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=item.y&lt;M <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=item.x&lt;N:</span><br><span class=\"line\">                    state = self.board[item.y][item.x]</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    state = <span class=\"number\">0</span></span><br><span class=\"line\">                item = sim.send(state)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                progeny[item.y, item.x] = item.state</span><br><span class=\"line\">                item = next(sim)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> progeny</span><br><span class=\"line\">                </span><br><span class=\"line\">                </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Grid</span><span class=\"params\">(object)</span>:</span>\t\t<span class=\"comment\"># 用于表示细胞网格</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, height, width)</span>:</span></span><br><span class=\"line\">        self.height = height</span><br><span class=\"line\">        self.width = width</span><br><span class=\"line\">        self.rows = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(self.height):</span><br><span class=\"line\">            self.rows.append([<span class=\"number\">0</span>] * self.width)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        output = <span class=\"string\">''</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> self.rows:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> cell <span class=\"keyword\">in</span> row:</span><br><span class=\"line\">                output += str(cell)</span><br><span class=\"line\">            output += <span class=\"string\">'\\n'</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> output</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__getitem__</span><span class=\"params\">(self, index)</span>:</span></span><br><span class=\"line\">        y, x = index</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=y&lt;self.height <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=x&lt;self.width:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.rows[y][x]</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__setitem__</span><span class=\"params\">(self, index, state)</span>:</span></span><br><span class=\"line\">        y, x = index</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;=y&lt;self.height <span class=\"keyword\">and</span> <span class=\"number\">0</span>&lt;=x&lt;self.width:</span><br><span class=\"line\">            self.rows[y % self.height][x % self.width] = state</span><br></pre></td></tr></table></figure>\n<h3 id=\"164-Maximum-Gap\"><a href=\"#164-Maximum-Gap\" class=\"headerlink\" title=\"164. Maximum Gap\"></a><a href=\"https://leetcode.com/problems/maximum-gap/\" target=\"_blank\" rel=\"noopener\">164. Maximum Gap</a></h3><h4 id=\"在线性时间空间复杂度找到数组中两个排好序后的相邻元素的最大差。\"><a href=\"#在线性时间空间复杂度找到数组中两个排好序后的相邻元素的最大差。\" class=\"headerlink\" title=\"在线性时间空间复杂度找到数组中两个排好序后的相邻元素的最大差。\"></a>在线性时间空间复杂度找到数组中两个排好序后的相邻元素的最大差。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [3,6,9,1]</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: The sorted form of the array is [1,3,6,9], either</span><br><span class=\"line\">             (3,6) or (6,9) has the maximum difference 3.</span><br></pre></td></tr></table></figure>\n<p>方法一：桶排序。 如果将这些数平分，差最小也是size，所以最大值会出现在两个相邻的桶之间，而不会在一个桶内。这里同时记录了最小值和最大值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maximumGap</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    N = len(nums)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> N &lt; <span class=\"number\">2</span> <span class=\"keyword\">or</span> min(nums)==max(nums):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    small, big = min(nums), max(nums)</span><br><span class=\"line\">    size = (big-small) // (N<span class=\"number\">-1</span>) <span class=\"keyword\">or</span> <span class=\"number\">1</span></span><br><span class=\"line\">    buckets = [[<span class=\"literal\">None</span>, <span class=\"literal\">None</span>] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range((big-small)//size+<span class=\"number\">1</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        b = buckets[(n-small)//size]</span><br><span class=\"line\">        b[<span class=\"number\">0</span>] = n <span class=\"keyword\">if</span> b[<span class=\"number\">0</span>] <span class=\"keyword\">is</span> <span class=\"literal\">None</span> <span class=\"keyword\">else</span> min(b[<span class=\"number\">0</span>], n)</span><br><span class=\"line\">        b[<span class=\"number\">1</span>] = n <span class=\"keyword\">if</span> b[<span class=\"number\">1</span>] <span class=\"keyword\">is</span> <span class=\"literal\">None</span> <span class=\"keyword\">else</span> max(b[<span class=\"number\">1</span>], n)</span><br><span class=\"line\">    buckets = [b <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> buckets <span class=\"keyword\">if</span> b[<span class=\"number\">0</span>] <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(buckets[i][<span class=\"number\">0</span>]-buckets[i<span class=\"number\">-1</span>][<span class=\"number\">1</span>] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(buckets)))</span><br></pre></td></tr></table></figure>\n<h3 id=\"1755-Closest-Subsequence-Sum\"><a href=\"#1755-Closest-Subsequence-Sum\" class=\"headerlink\" title=\"1755. Closest Subsequence Sum\"></a><a href=\"https://leetcode.com/problems/closest-subsequence-sum/\" target=\"_blank\" rel=\"noopener\">1755. Closest Subsequence Sum</a></h3><h4 id=\"找到最接近目标值的子序列。\"><a href=\"#找到最接近目标值的子序列。\" class=\"headerlink\" title=\"找到最接近目标值的子序列。\"></a>找到最接近目标值的子序列。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [5,-7,3,5], goal &#x3D; 6</span><br><span class=\"line\">Output: 0</span><br><span class=\"line\">Explanation: Choose the whole array as a subsequence, with a sum of 6.</span><br><span class=\"line\">This is equal to the goal, so the absolute difference is 0.</span><br></pre></td></tr></table></figure>\n<p>方法一：分治+dfs。这题主要先想到分治，然后才能做，因为数组长度是40.直接做会超时。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minAbsDifference</span><span class=\"params\">(self, nums: List[int], goal: int)</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"comment\"># function that generates all possible sums of sebsequences</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(i, cur, arr, sums)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == len(arr):</span><br><span class=\"line\">            sums.add(cur)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        dfs(i+<span class=\"number\">1</span>, cur, arr, sums)</span><br><span class=\"line\">        dfs(i+<span class=\"number\">1</span>, cur+arr[i], arr, sums)</span><br><span class=\"line\"></span><br><span class=\"line\">    sums1, sums2 = set(), set()</span><br><span class=\"line\">    <span class=\"comment\"># generate all possible sums of the 1st and 2nd half </span></span><br><span class=\"line\">    dfs(<span class=\"number\">0</span>, <span class=\"number\">0</span>, nums[:len(nums)//<span class=\"number\">2</span>], sums1)</span><br><span class=\"line\">    dfs(<span class=\"number\">0</span>, <span class=\"number\">0</span>, nums[len(nums)//<span class=\"number\">2</span>:], sums2)</span><br><span class=\"line\">    res = inf</span><br><span class=\"line\">    sums2 = sorted(sums2)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> sums1:</span><br><span class=\"line\">        t = goal - num</span><br><span class=\"line\">        i = bisect_left(sums2, t)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i &lt; len(sums2):</span><br><span class=\"line\">            res = min(res, abs(t-sums2[i]))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            res = min(res, abs(t-sums2[i<span class=\"number\">-1</span>]))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"992-Subarrays-with-K-Different-Integers\"><a href=\"#992-Subarrays-with-K-Different-Integers\" class=\"headerlink\" title=\"992. Subarrays with K Different Integers\"></a><a href=\"https://leetcode.com/problems/subarrays-with-k-different-integers/\" target=\"_blank\" rel=\"noopener\">992. Subarrays with K Different Integers</a></h3><h4 id=\"k个不同数字的连续子数组的个数。\"><a href=\"#k个不同数字的连续子数组的个数。\" class=\"headerlink\" title=\"k个不同数字的连续子数组的个数。\"></a>k个不同数字的连续子数组的个数。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: A &#x3D; [1,2,1,2,3], K &#x3D; 2</span><br><span class=\"line\">Output: 7</span><br><span class=\"line\">Explanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].</span><br></pre></td></tr></table></figure>\n<p>方法一：刚好K个等于最少k个-最少k-1个。滑动窗口。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">subarraysWithKDistinct</span><span class=\"params\">(self, A: List[int], K: int)</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">most_k</span><span class=\"params\">(k)</span>:</span></span><br><span class=\"line\">        left, res, c = <span class=\"number\">0</span>, <span class=\"number\">0</span>, defaultdict(int)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> right, d <span class=\"keyword\">in</span> enumerate(A):</span><br><span class=\"line\">            c[d] += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> len(c) &gt; k:</span><br><span class=\"line\">                c[A[left]] -= <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> c[A[left]] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">del</span> c[A[left]]</span><br><span class=\"line\">                left += <span class=\"number\">1</span></span><br><span class=\"line\">            res += right-left+<span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br><span class=\"line\">    <span class=\"keyword\">return</span> most_k(K) - most_k(K<span class=\"number\">-1</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"995-Minimum-Number-of-K-Consecutive-Bit-Flips\"><a href=\"#995-Minimum-Number-of-K-Consecutive-Bit-Flips\" class=\"headerlink\" title=\"995. Minimum Number of K Consecutive Bit Flips\"></a><a href=\"https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/\" target=\"_blank\" rel=\"noopener\">995. Minimum Number of K Consecutive Bit Flips</a></h3><h4 id=\"每次翻转连续k个数字，能否全部翻转成1-需要多少次。\"><a href=\"#每次翻转连续k个数字，能否全部翻转成1-需要多少次。\" class=\"headerlink\" title=\"每次翻转连续k个数字，能否全部翻转成1.需要多少次。\"></a>每次翻转连续k个数字，能否全部翻转成1.需要多少次。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: A &#x3D; [0,0,0,1,0,1,1,0], K &#x3D; 3</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">Flip A[0],A[1],A[2]: A becomes [1,1,1,1,0,1,1,0]</span><br><span class=\"line\">Flip A[4],A[5],A[6]: A becomes [1,1,1,1,1,0,0,0]</span><br><span class=\"line\">Flip A[5],A[6],A[7]: A becomes [1,1,1,1,1,1,1,1]</span><br></pre></td></tr></table></figure>\n<p>方法一：贪心+滑动窗口。如果模拟30000的长度会超时。使用滑动窗口来做，看前k个队列中翻转的奇偶性，判断当前数是否翻转。如果翻转长度超过数组长度，则无法完成翻转。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minKBitFlips</span><span class=\"params\">(self, A: List[int], K: int)</span> -&gt; int:</span></span><br><span class=\"line\">    q, res = deque(), <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, a <span class=\"keyword\">in</span> enumerate(A):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> q <span class=\"keyword\">and</span> q[<span class=\"number\">0</span>]+K &lt;= i:</span><br><span class=\"line\">            q.popleft()</span><br><span class=\"line\">        flip = len(q)%<span class=\"number\">2</span>==a</span><br><span class=\"line\">        <span class=\"keyword\">if</span> flip:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i + K &gt; len(A): <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">            q.append(i)</span><br><span class=\"line\">            res += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<h3 id=\"395-Longest-Substring-with-At-Least-K-Repeating-Characters\"><a href=\"#395-Longest-Substring-with-At-Least-K-Repeating-Characters\" class=\"headerlink\" title=\"395. Longest Substring with At Least K Repeating Characters\"></a>395. Longest Substring with At Least K Repeating Characters</h3><h4 id=\"找到字符串中最长子串，要求每个字符频率不少于K，返回最长的子串长度。\"><a href=\"#找到字符串中最长子串，要求每个字符频率不少于K，返回最长的子串长度。\" class=\"headerlink\" title=\"找到字符串中最长子串，要求每个字符频率不少于K，返回最长的子串长度。\"></a>找到字符串中最长子串，要求每个字符频率不少于K，返回最长的子串长度。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：s &#x3D; &quot;aaabb&quot;, k &#x3D; 3</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：最长子串为 &quot;aaa&quot; ，其中 &#39;a&#39; 重复了 3 次。</span><br></pre></td></tr></table></figure>\n<p>方法一：这题，滑动窗口不好滑，递归思想简单。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestSubstring</span><span class=\"params\">(self, s: str, k: int)</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(s) &lt; k:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> set(s):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> s.count(c) &lt; k:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> max(self.longestSubstring(t, k) <span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> s.split(c))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> len(s)</span><br></pre></td></tr></table></figure>\n<h3 id=\"1838-Frequency-of-the-Most-Frequent-Element\"><a href=\"#1838-Frequency-of-the-Most-Frequent-Element\" class=\"headerlink\" title=\"1838. Frequency of the Most Frequent Element\"></a><a href=\"https://leetcode.com/problems/frequency-of-the-most-frequent-element/\" target=\"_blank\" rel=\"noopener\">1838. Frequency of the Most Frequent Element</a></h3><h4 id=\"有k次机会可以将数组中的元素加1，问能得到数组中最大的频数是多少。\"><a href=\"#有k次机会可以将数组中的元素加1，问能得到数组中最大的频数是多少。\" class=\"headerlink\" title=\"有k次机会可以将数组中的元素加1，问能得到数组中最大的频数是多少。\"></a>有k次机会可以将数组中的元素加1，问能得到数组中最大的频数是多少。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums &#x3D; [1,2,4], k &#x3D; 5</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: Increment the first element three times and the second element two times to make nums &#x3D; [4,4,4].</span><br><span class=\"line\">4 has a frequency of 3.</span><br></pre></td></tr></table></figure>\n<p>方法一：比赛的时候，滑动窗口想了一下，没找到条件。遗憾没做出来。因为每次都是+1, 所以条件是<code>k+sum &gt;= size * max</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxFrequency</span><span class=\"params\">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class=\"line\">    i = <span class=\"number\">0</span></span><br><span class=\"line\">    nums.sort()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(nums)):</span><br><span class=\"line\">        k += nums[j]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> k &lt; (j - i + <span class=\"number\">1</span>) * nums[j]:</span><br><span class=\"line\">            k -= nums[i]</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> j - i + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2106-Maximum-Fruits-Harvested-After-at-Most-K-Steps\"><a href=\"#2106-Maximum-Fruits-Harvested-After-at-Most-K-Steps\" class=\"headerlink\" title=\"2106. Maximum Fruits Harvested After at Most K Steps\"></a><a href=\"https://leetcode.com/problems/maximum-fruits-harvested-after-at-most-k-steps/\" target=\"_blank\" rel=\"noopener\">2106. Maximum Fruits Harvested After at Most K Steps</a></h3><h4 id=\"最多走k步，可以向左或向右走，最多能收集多少个草莓。\"><a href=\"#最多走k步，可以向左或向右走，最多能收集多少个草莓。\" class=\"headerlink\" title=\"最多走k步，可以向左或向右走，最多能收集多少个草莓。\"></a>最多走k步，可以向左或向右走，最多能收集多少个草莓。</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: fruits &#x3D; [[2,8],[6,3],[8,6]], startPos &#x3D; 5, k &#x3D; 4</span><br><span class=\"line\">Output: 9</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">The optimal way is to:</span><br><span class=\"line\">- Move right to position 6 and harvest 3 fruits</span><br><span class=\"line\">- Move right to position 8 and harvest 6 fruits</span><br><span class=\"line\">You moved 3 steps and harvested 3 + 6 &#x3D; 9 fruits in total.</span><br></pre></td></tr></table></figure>\n<p>方法一：比赛过后写出来的，比赛的方法写得过于复杂。其实简单的前缀和就好。需要注意的是往返需要2倍的步数，可以向左或向右往返。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxTotalFruits</span><span class=\"params\">(self, fruits: List[List[int]], startPos: int, k: int)</span> -&gt; int:</span></span><br><span class=\"line\">    d = Counter()</span><br><span class=\"line\">    r = <span class=\"number\">1</span></span><br><span class=\"line\">    left = Counter()</span><br><span class=\"line\">    right = Counter()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i,j <span class=\"keyword\">in</span> fruits:  </span><br><span class=\"line\">        d[i] = j</span><br><span class=\"line\">    ans = d[startPos]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(startPos+<span class=\"number\">1</span>,startPos+k+<span class=\"number\">1</span>):</span><br><span class=\"line\">        right[i-startPos] = right[i<span class=\"number\">-1</span>-startPos] + d[i]</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(startPos - <span class=\"number\">1</span>,startPos<span class=\"number\">-1</span>-k,<span class=\"number\">-1</span>):</span><br><span class=\"line\">        left[r] = left[r<span class=\"number\">-1</span>] + d[i]</span><br><span class=\"line\">        r += <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,k+<span class=\"number\">1</span>):</span><br><span class=\"line\">        ans = max(ans, max(right[i] + left[k - <span class=\"number\">2</span>*i], left[i] + right[k - <span class=\"number\">2</span>*i]) + d[startPos])</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"862-Shortest-Subarray-with-Sum-at-Least-K\"><a href=\"#862-Shortest-Subarray-with-Sum-at-Least-K\" class=\"headerlink\" title=\"862. Shortest Subarray with Sum at Least K\"></a><a href=\"https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/\" target=\"_blank\" rel=\"noopener\">862. Shortest Subarray with Sum at Least K</a></h3><p>给你一个整数数组 nums 和一个整数 k ，找出 nums 中和至少为 k 的 最短非空子数组 ，并返回该子数组的长度。如果不存在这样的 子数组 ，返回 -1 。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [2,-1,2], k &#x3D; 3</span><br><span class=\"line\">输出：3</span><br></pre></td></tr></table></figure>\n<p>方法一：前缀和很容易想到。之后需要维护一个队列，左侧删除也比较容易想到。右侧删除有点难想。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">shortestSubarray</span><span class=\"params\">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class=\"line\">    ans = inf</span><br><span class=\"line\">    s = list(accumulate(nums, initial=<span class=\"number\">0</span>))  <span class=\"comment\"># 计算前缀和</span></span><br><span class=\"line\">    q = deque()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, cur_s <span class=\"keyword\">in</span> enumerate(s):</span><br><span class=\"line\">        <span class=\"keyword\">while</span> q <span class=\"keyword\">and</span> cur_s-s[q[<span class=\"number\">0</span>]]&gt;=k:  </span><br><span class=\"line\">            ans = min(ans, i-q.popleft())</span><br><span class=\"line\">        <span class=\"keyword\">while</span> q <span class=\"keyword\">and</span> s[q[<span class=\"number\">-1</span>]]&gt;=cur_s:  <span class=\"comment\"># nxt_s - cur_s的值更大，并且长度更短</span></span><br><span class=\"line\">            q.pop()</span><br><span class=\"line\">        q.append(i)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans <span class=\"keyword\">if</span> ans != inf <span class=\"keyword\">else</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2448-Minimum-Cost-to-Make-Array-Equal\"><a href=\"#2448-Minimum-Cost-to-Make-Array-Equal\" class=\"headerlink\" title=\"2448. Minimum Cost to Make Array Equal\"></a><a href=\"https://leetcode.com/problems/minimum-cost-to-make-array-equal/\" target=\"_blank\" rel=\"noopener\">2448. Minimum Cost to Make Array Equal</a></h3><p>给你两个下标从 0 开始的数组 nums 和 cost ，分别包含 n 个 正 整数。</p>\n<p>你可以执行下面操作 任意 次：</p>\n<p>将 nums 中 任意 元素增加或者减小 1 。<br>对第 i 个元素执行一次操作的开销是 cost[i] 。</p>\n<p>请你返回使 nums 中所有元素 相等 的 最少 总开销。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums &#x3D; [1,3,5,2], cost &#x3D; [2,3,1,14]</span><br><span class=\"line\">输出：8</span><br><span class=\"line\">解释：我们可以执行以下操作使所有元素变为 2 ：</span><br><span class=\"line\">- 增加第 0 个元素 1 次，开销为 2 。</span><br><span class=\"line\">- 减小第 1 个元素 1 次，开销为 3 。</span><br><span class=\"line\">- 减小第 2 个元素 3 次，开销为 1 + 1 + 1 &#x3D; 3 。</span><br><span class=\"line\">总开销为 2 + 3 + 3 &#x3D; 8 。</span><br><span class=\"line\">这是最小开销。</span><br></pre></td></tr></table></figure>\n<p>方法一：这题竞赛没有过，题解也是看了很久，题目本身并不难。将nums和cost一起排序。首先计算所有等于<code>nums[0]</code>的开销，以及所有的cost。然后考虑所有的数变成<code>nums[1]</code>。这样要增加<code>(nums[1]-nums[0]) * cost[0]</code>，要减少<code>(nums[1]-nums[0])*(sum_cost-cost[0])</code>。之后考虑所有的数变成<code>nums[2]</code>，要增加<code>(nums[2]-nums[1])*(cost[0]+cost[1])</code>，减少<code>(nums[2]-nums[1])*(sum_cost-cost[0]-cost[1])</code>。总共减少<code>(nums[i+1]-nums[i]) * (sum_cost-cost[0]*2-cost[1]*2...-cost[i]*2)</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minCost</span><span class=\"params\">(self, nums: List[int], cost: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    a = sorted(zip(nums, cost))</span><br><span class=\"line\">    ans = total = sum((x - a[<span class=\"number\">0</span>][<span class=\"number\">0</span>]) * c <span class=\"keyword\">for</span> x, c <span class=\"keyword\">in</span> a)</span><br><span class=\"line\">    sum_cost = sum(cost)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (x0, c), (x1, _) <span class=\"keyword\">in</span> pairwise(a):</span><br><span class=\"line\">        sum_cost -= c * <span class=\"number\">2</span></span><br><span class=\"line\">        total -= sum_cost * (x1 - x0)</span><br><span class=\"line\">        ans = min(ans, total)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"805-Split-Array-With-Same-Average\"><a href=\"#805-Split-Array-With-Same-Average\" class=\"headerlink\" title=\"805. Split Array With Same Average\"></a><a href=\"https://leetcode.com/problems/split-array-with-same-average/\" target=\"_blank\" rel=\"noopener\">805. Split Array With Same Average</a></h3><p>给定你一个整数数组 <code>nums</code></p>\n<p>我们要将 <code>nums</code> 数组中的每个元素移动到 <code>A</code> 数组 或者 <code>B</code> 数组中，使得 <code>A</code> 数组和 <code>B</code> 数组不为空，并且 <code>average(A) == average(B)</code> 。</p>\n<p>如果可以完成则返回<code>true</code> ， 否则返回 <code>false</code> 。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: nums &#x3D; [1,2,3,4,5,6,7,8]</span><br><span class=\"line\">输出: true</span><br><span class=\"line\">解释: 我们可以将数组分割为 [1,4,5,8] 和 [2,3,6,7], 他们的平均值都是4.5。</span><br></pre></td></tr></table></figure>\n<p>方法一：看了题解才明白，首先要明白转化问题，目标是找到一个子数组，平均数为总数组的平均数。题中数组长度为30，如果遍历将会为2**30，超时，所以可以将问题折半，变为两个数组。分为三种情况：子数组在数组左侧，子数组在数组右侧，子数组左右都有。由于平均数浮点有精度问题，所以我们将所有数乘以N，然后减去sum(nums),这样问题变为，找到一个子数组和为0.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">splitArraySameAverage</span><span class=\"params\">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class=\"line\">    N = len(nums)</span><br><span class=\"line\">    s = sum(nums)</span><br><span class=\"line\">    mid = sum(nums) / N</span><br><span class=\"line\">    arr = [num*N-s <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums]</span><br><span class=\"line\">    left, right = arr[:N//<span class=\"number\">2</span>], arr[N//<span class=\"number\">2</span>:]</span><br><span class=\"line\">    t = set()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, N//<span class=\"number\">2</span>+<span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> inner <span class=\"keyword\">in</span> combinations(left, i):</span><br><span class=\"line\">            ss = sum(inner)</span><br><span class=\"line\">            <span class=\"comment\"># print(inner, ss)</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ss == <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                t.add(ss)</span><br><span class=\"line\">    <span class=\"comment\"># print(t)</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, N-len(left)):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> inner <span class=\"keyword\">in</span> combinations(right, i):</span><br><span class=\"line\">            ss = sum(inner)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ss == <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> -ss <span class=\"keyword\">in</span> t:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n","categories":["算法"],"tags":["LeetCode","Python","Algorithm","Array"]},{"title":"Google kickstart Round A 2020","url":"/Google-kickstart-Round-A-2020/","content":"<h5 id=\"经过了上次G轮的比赛，发现kickstart很好，题目质量也很高，大数据的测试用例能够帮助我发现一些效率上的问题。所以打算将2020年过往轮次补一下。\"><a href=\"#经过了上次G轮的比赛，发现kickstart很好，题目质量也很高，大数据的测试用例能够帮助我发现一些效率上的问题。所以打算将2020年过往轮次补一下。\" class=\"headerlink\" title=\"经过了上次G轮的比赛，发现kickstart很好，题目质量也很高，大数据的测试用例能够帮助我发现一些效率上的问题。所以打算将2020年过往轮次补一下。\"></a>经过了上次G轮的比赛，发现kickstart很好，题目质量也很高，大数据的测试用例能够帮助我发现一些效率上的问题。所以打算将2020年过往轮次补一下。</h5><a id=\"more\"></a>\n<h3 id=\"ALLOCATION\"><a href=\"#ALLOCATION\" class=\"headerlink\" title=\"ALLOCATION\"></a><a href=\"https://codingcompetitions.withgoogle.com/kickstart/round/000000000019ffc7/00000000001d3f56\" target=\"_blank\" rel=\"noopener\">ALLOCATION</a></h3><h4 id=\"有N个房子在卖，手里有一些资金，问最多可以买多少个房子。\"><a href=\"#有N个房子在卖，手里有一些资金，问最多可以买多少个房子。\" class=\"headerlink\" title=\"有N个房子在卖，手里有一些资金，问最多可以买多少个房子。\"></a>有N个房子在卖，手里有一些资金，问最多可以买多少个房子。</h4><p>第一题比较简单，贪心的思路做一个排序。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">T &#x3D; int(input())</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">for case in range(1, T+1):</span><br><span class=\"line\">    N, B &#x3D; map(int, input().split())</span><br><span class=\"line\">    prices &#x3D; map(int, input().split())</span><br><span class=\"line\">    ans, left &#x3D; 0, B</span><br><span class=\"line\">    for p in sorted(prices):</span><br><span class=\"line\">        if p &lt;&#x3D; left:</span><br><span class=\"line\">            left -&#x3D; p</span><br><span class=\"line\">            ans +&#x3D; 1</span><br><span class=\"line\">    print(&#39;Case #&#123;&#125;: &#123;&#125;&#39;.format(case, ans))</span><br></pre></td></tr></table></figure>\n<h3 id=\"Plates\"><a href=\"#Plates\" class=\"headerlink\" title=\"Plates\"></a><a href=\"https://codingcompetitions.withgoogle.com/kickstart/round/000000000019ffc7/00000000001d40bb\" target=\"_blank\" rel=\"noopener\">Plates</a></h3><h4 id=\"有N堆盘子，每堆盘都有K个盘子，每个盘子有不同的价格。拿取盘子时只能拿上面的一叠。我想取出P个盘子，问能取的最大值是多少。\"><a href=\"#有N堆盘子，每堆盘都有K个盘子，每个盘子有不同的价格。拿取盘子时只能拿上面的一叠。我想取出P个盘子，问能取的最大值是多少。\" class=\"headerlink\" title=\"有N堆盘子，每堆盘都有K个盘子，每个盘子有不同的价格。拿取盘子时只能拿上面的一叠。我想取出P个盘子，问能取的最大值是多少。\"></a>有N堆盘子，每堆盘都有K个盘子，每个盘子有不同的价格。拿取盘子时只能拿上面的一叠。我想取出P个盘子，问能取的最大值是多少。</h4><p>这道题是个dp，思路上很快想出来了，但是写法上卡了很久。</p>\n<p>一开始的写法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">T = int(input())</span><br><span class=\"line\"><span class=\"keyword\">for</span> case <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, T+<span class=\"number\">1</span>):</span><br><span class=\"line\">    N, K, P = map(int, input().split())</span><br><span class=\"line\">    stack = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(N):</span><br><span class=\"line\">        stack.append(list(map(int, input().split())))</span><br><span class=\"line\">    dp = [[<span class=\"number\">0</span>] * (P+<span class=\"number\">1</span>) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(N+<span class=\"number\">1</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, N+<span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, P+<span class=\"number\">1</span>):</span><br><span class=\"line\">            cur = <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(j+<span class=\"number\">1</span>):</span><br><span class=\"line\">                dp[i][j] = max(dp[i][j], dp[i<span class=\"number\">-1</span>][j-k]+cur)</span><br><span class=\"line\">                cur += stack[i<span class=\"number\">-1</span>][k] <span class=\"keyword\">if</span> k &lt; K <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br><span class=\"line\">    print(<span class=\"string\">'Case #&#123;&#125;: &#123;&#125;'</span>.format(case, dp[<span class=\"number\">-1</span>][<span class=\"number\">-1</span>]))</span><br></pre></td></tr></table></figure>\n<p>T2没有跑过TLE了，是的，没有考虑每堆拿完的情况，于是修改如下。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">T = int(input())</span><br><span class=\"line\"><span class=\"keyword\">for</span> case <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, T+<span class=\"number\">1</span>):</span><br><span class=\"line\">    N, K, P = map(int, input().split())</span><br><span class=\"line\">    stack = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(N):</span><br><span class=\"line\">        stack.append(list(map(int, input().split())))</span><br><span class=\"line\">    dp = [[<span class=\"number\">0</span>] * (P+<span class=\"number\">1</span>) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(N+<span class=\"number\">1</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, N+<span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, P+<span class=\"number\">1</span>):</span><br><span class=\"line\">            cur = <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(min(j, K)+<span class=\"number\">1</span>):</span><br><span class=\"line\">                dp[i][j] = max(dp[i][j], dp[i<span class=\"number\">-1</span>][j-k]+cur)</span><br><span class=\"line\">                cur += stack[i<span class=\"number\">-1</span>][k] <span class=\"keyword\">if</span> k &lt; K <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br><span class=\"line\">    print(<span class=\"string\">'Case #&#123;&#125;: &#123;&#125;'</span>.format(case, dp[<span class=\"number\">-1</span>][<span class=\"number\">-1</span>]))</span><br></pre></td></tr></table></figure>\n<p>结果还是超时，于是我自己试了一些大的数据集，用Pycharm的profile分析了一下，也没有找到性能的瓶颈。并且看起来和题解中给的时间复杂度完全符合<code>O(N*P*K)</code>。又进行了一些微调</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, P+<span class=\"number\">1</span>):</span><br><span class=\"line\">    cur = <span class=\"number\">0</span></span><br><span class=\"line\">    dp[i][j] = dp[i<span class=\"number\">-1</span>][j]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, min(j, K)+<span class=\"number\">1</span>):</span><br><span class=\"line\">        cur += stack[i<span class=\"number\">-1</span>][k<span class=\"number\">-1</span>]</span><br><span class=\"line\">        dp[i][j] = max(dp[i][j], dp[i<span class=\"number\">-1</span>][j-k]+cur)</span><br></pre></td></tr></table></figure>\n<p>依然超时。。最后试了一下这样写，居然通过了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">T = int(input())</span><br><span class=\"line\"><span class=\"keyword\">for</span> case <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, T+<span class=\"number\">1</span>):</span><br><span class=\"line\">    N, K, P = map(int, input().split())</span><br><span class=\"line\">    stack = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(N):</span><br><span class=\"line\">        stack.append(list(map(int, input().split())))</span><br><span class=\"line\">    dp = [[<span class=\"number\">0</span>] * (P+<span class=\"number\">1</span>) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(N+<span class=\"number\">1</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, N+<span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, P+<span class=\"number\">1</span>):</span><br><span class=\"line\">            cur = <span class=\"number\">0</span></span><br><span class=\"line\">            it = iter(stack[i<span class=\"number\">-1</span>])</span><br><span class=\"line\">            dp[i][j] = dp[i<span class=\"number\">-1</span>][j]</span><br><span class=\"line\">            <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, min(j, K)+<span class=\"number\">1</span>):</span><br><span class=\"line\">                cur += next(it)</span><br><span class=\"line\">                dp[i][j] = max(dp[i][j], dp[i<span class=\"number\">-1</span>][j-k]+cur)</span><br><span class=\"line\">    print(<span class=\"string\">'Case #&#123;&#125;: &#123;&#125;'</span>.format(case, dp[<span class=\"number\">-1</span>][<span class=\"number\">-1</span>]))</span><br></pre></td></tr></table></figure>\n<p>然后，经过几次不断的试验和对比，我发现了同样的代码得到了通过和超时两种不同的结果。想必是代码的运行时间卡在了超时的临界值导致的。</p>\n<img src=\"/Google-kickstart-Round-A-2020/b_atmp_15.png\" class>\n<img src=\"/Google-kickstart-Round-A-2020/b_atmp_16.png\" class>\n<p>不过第一版的版本经过多次提交还是TLE，个人认为<code>iter</code>的迭代并没有提升性能，结果存在偶然性。</p>\n<p>最后通过的代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> random</span><br><span class=\"line\">T = int(input())</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> case <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, T+<span class=\"number\">1</span>):</span><br><span class=\"line\">    N, K, P = map(int, input().split())</span><br><span class=\"line\">    stack = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(N):</span><br><span class=\"line\">        stack.append(list(map(int, input().split())))</span><br><span class=\"line\">    dp = [[<span class=\"number\">0</span>] * (P+<span class=\"number\">1</span>) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(N+<span class=\"number\">1</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, N+<span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, P+<span class=\"number\">1</span>):</span><br><span class=\"line\">            cur = <span class=\"number\">0</span></span><br><span class=\"line\">            it = iter(stack[i<span class=\"number\">-1</span>])</span><br><span class=\"line\">            dp[i][j] = dp[i<span class=\"number\">-1</span>][j]</span><br><span class=\"line\">            <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, min(j, K)+<span class=\"number\">1</span>):</span><br><span class=\"line\">                cur += next(it)</span><br><span class=\"line\">                dp[i][j] = max(dp[i][j], dp[i<span class=\"number\">-1</span>][j-k]+cur)</span><br><span class=\"line\">    print(<span class=\"string\">'Case #&#123;&#125;: &#123;&#125;'</span>.format(case, dp[<span class=\"number\">-1</span>][<span class=\"number\">-1</span>]))</span><br></pre></td></tr></table></figure>\n<p>更好的写法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">T = int(input())</span><br><span class=\"line\"><span class=\"keyword\">for</span> case <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, T+<span class=\"number\">1</span>):</span><br><span class=\"line\">    N, K, P = map(int, input().split())</span><br><span class=\"line\">    dp = [<span class=\"number\">0</span>] * (P + <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(N):</span><br><span class=\"line\">        a = map(int, input().split())</span><br><span class=\"line\">        new_dp = dp[:]</span><br><span class=\"line\">        s = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j, x <span class=\"keyword\">in</span> enumerate(a):</span><br><span class=\"line\">            s += x</span><br><span class=\"line\">            <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(P-j<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">                new_dp[k+j+<span class=\"number\">1</span>] = max(new_dp[k+j+<span class=\"number\">1</span>], dp[k]+s)</span><br><span class=\"line\">        dp = new_dp</span><br><span class=\"line\">    print(<span class=\"string\">'Case #&#123;&#125;: &#123;&#125;'</span>.format(case, dp[<span class=\"number\">-1</span>]))</span><br></pre></td></tr></table></figure>\n<p>今天闲来无事，将第二次没过的代码改了一下，用python2来写的，主要是为了能用PyPy解释器。结果。居然过掉了，难道以后因为这个要写python2了吗、</p>\n<h3 id=\"WorkOut\"><a href=\"#WorkOut\" class=\"headerlink\" title=\"WorkOut\"></a><a href=\"https://codingcompetitions.withgoogle.com/kickstart/round/000000000019ffc7/00000000001d3f5b#analysis\" target=\"_blank\" rel=\"noopener\">WorkOut</a></h3><h4 id=\"有个人指定了一系列的健身计划，健身计划的组数是递增的，一组健身计划的难度是最大的组间差。可以向原有计划中添加K次训练，使得难度变小。给你这样一组计划和K，问最小可以使难度降到多少？\"><a href=\"#有个人指定了一系列的健身计划，健身计划的组数是递增的，一组健身计划的难度是最大的组间差。可以向原有计划中添加K次训练，使得难度变小。给你这样一组计划和K，问最小可以使难度降到多少？\" class=\"headerlink\" title=\"有个人指定了一系列的健身计划，健身计划的组数是递增的，一组健身计划的难度是最大的组间差。可以向原有计划中添加K次训练，使得难度变小。给你这样一组计划和K，问最小可以使难度降到多少？\"></a>有个人指定了一系列的健身计划，健身计划的组数是递增的，一组健身计划的难度是最大的组间差。可以向原有计划中添加K次训练，使得难度变小。给你这样一组计划和K，问最小可以使难度降到多少？</h4><p>方法一：我一开始想错了，用的贪心的思路和堆来做。其实是不对的，比如2,12之间，<code>[2, 5, 8, 12]</code>是小于<code>[2, 4, 7, 12]</code>的。此题用二分法。通过最小最大的难度，找到一个合适的，使得，所有组件差满足改难度后，需要添加的组数刚好小于等于K。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check</span><span class=\"params\">(d, K)</span>:</span></span><br><span class=\"line\">    need = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, N):</span><br><span class=\"line\">        need += (sessions[i]-sessions[i<span class=\"number\">-1</span>]<span class=\"number\">-1</span>) // d</span><br><span class=\"line\">        <span class=\"keyword\">if</span> need &gt; K:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> need &lt;= K</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> case <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, int(input())+<span class=\"number\">1</span>):</span><br><span class=\"line\">    N, K = map(int, input().split())</span><br><span class=\"line\">    sessions = list(map(int, input().split()))</span><br><span class=\"line\">    lo, hi = <span class=\"number\">1</span>, sessions[<span class=\"number\">-1</span>]-sessions[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> lo &lt; hi:</span><br><span class=\"line\">        mid = (lo + hi) &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> check(mid, K):</span><br><span class=\"line\">            hi = mid</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            lo = mid + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    print_ans(case, lo)</span><br></pre></td></tr></table></figure>\n","categories":["算法"],"tags":["kickstart"]},{"title":"LeetCode算法题整理（线段树篇）SegmentTree","url":"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%AF%87%EF%BC%89SegmentTree/","content":"<h3 id=\"1649-Create-Sorted-Array-through-Instructions\"><a href=\"#1649-Create-Sorted-Array-through-Instructions\" class=\"headerlink\" title=\"1649. Create Sorted Array through Instructions\"></a><a href=\"https://leetcode.com/problems/create-sorted-array-through-instructions/\" target=\"_blank\" rel=\"noopener\">1649. Create Sorted Array through Instructions</a></h3><h4 id=\"根据指令数组创建一个有序的数组。每次新增数时的花费为，min-小于此数的个数，大于此数的个数-。\"><a href=\"#根据指令数组创建一个有序的数组。每次新增数时的花费为，min-小于此数的个数，大于此数的个数-。\" class=\"headerlink\" title=\"根据指令数组创建一个有序的数组。每次新增数时的花费为，min(小于此数的个数，大于此数的个数)。\"></a>根据指令数组创建一个有序的数组。每次新增数时的花费为，min(小于此数的个数，大于此数的个数)。</h4><a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: instructions &#x3D; [1,5,6,2]</span><br><span class=\"line\">Output: 1</span><br><span class=\"line\">Explanation: Begin with nums &#x3D; [].</span><br><span class=\"line\">Insert 1 with cost min(0, 0) &#x3D; 0, now nums &#x3D; [1].</span><br><span class=\"line\">Insert 5 with cost min(1, 0) &#x3D; 0, now nums &#x3D; [1,5].</span><br><span class=\"line\">Insert 6 with cost min(2, 0) &#x3D; 0, now nums &#x3D; [1,5,6].</span><br><span class=\"line\">Insert 2 with cost min(1, 2) &#x3D; 1, now nums &#x3D; [1,2,5,6].</span><br><span class=\"line\">The total cost is 0 + 0 + 0 + 1 &#x3D; 1.</span><br></pre></td></tr></table></figure>\n<p>方法一：凭借此题达成了AK，卡着超时线过的，用了8s多。以为过不了呢，因为分析出来时间复杂度为O(n^2)。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">createSortedArray</span><span class=\"params\">(self, instructions: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    ans, mod =<span class=\"number\">0</span>, <span class=\"number\">10</span>**<span class=\"number\">9</span> + <span class=\"number\">7</span></span><br><span class=\"line\">    nums = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> instructions:</span><br><span class=\"line\">        left = bisect.bisect_left(nums, d)</span><br><span class=\"line\">        right = bisect.bisect(nums, d)</span><br><span class=\"line\">        ans += min(left, len(nums)-right)</span><br><span class=\"line\">        bisect.insort(nums, d)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans % mod</span><br></pre></td></tr></table></figure>\n<p>方法二：使用<code>SortedList</code>，这个添加一个值的时间复杂度为<code>O(logn)</code>而不像<code>bisect.insort</code>是<code>O(n)</code>。5s多。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">createSortedArray</span><span class=\"params\">(self, instructions: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> sortedcontainers <span class=\"keyword\">import</span> SortedList</span><br><span class=\"line\">    ans, mod =<span class=\"number\">0</span>, <span class=\"number\">10</span>**<span class=\"number\">9</span> + <span class=\"number\">7</span></span><br><span class=\"line\">    nums = SortedList()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> instructions:</span><br><span class=\"line\">        cost = min(nums.bisect_left(d), len(nums)-nums.bisect_right(d))</span><br><span class=\"line\">        ans = (ans+cost) % mod</span><br><span class=\"line\">        nums.add(d)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n","categories":["Segment Tree"],"tags":["LeetCode","SegmentTree"]},{"title":"Google kickstart Round H 2020","url":"/Google-kickstart-Round-H-2020/","content":"<h5 id=\"尴尬，比赛看错了时间，把结束时间当成了开始时间了。\"><a href=\"#尴尬，比赛看错了时间，把结束时间当成了开始时间了。\" class=\"headerlink\" title=\"尴尬，比赛看错了时间，把结束时间当成了开始时间了。\"></a>尴尬，比赛看错了时间，把结束时间当成了开始时间了。</h5><a id=\"more\"></a>\n<h3 id=\"Retype\"><a href=\"#Retype\" class=\"headerlink\" title=\"Retype\"></a><a href=\"https://codingcompetitions.withgoogle.com/kickstart/round/000000000019ff49/000000000043adc7\" target=\"_blank\" rel=\"noopener\">Retype</a></h3><h4 id=\"闯关游戏，一共有N关，当前在K关，需要回到S关，或者重新开始。\"><a href=\"#闯关游戏，一共有N关，当前在K关，需要回到S关，或者重新开始。\" class=\"headerlink\" title=\"闯关游戏，一共有N关，当前在K关，需要回到S关，或者重新开始。\"></a>闯关游戏，一共有N关，当前在K关，需要回到S关，或者重新开始。</h4><p>方法一：两个case取最小。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> case <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, int(input())+<span class=\"number\">1</span>):</span><br><span class=\"line\">    N, K, S = map(int, input().split())</span><br><span class=\"line\">    ans = K + min(N, N-K+(K-S)*<span class=\"number\">2</span>)</span><br><span class=\"line\">    print_ans(case, ans)</span><br></pre></td></tr></table></figure>\n<h3 id=\"Boring-Numbers\"><a href=\"#Boring-Numbers\" class=\"headerlink\" title=\"Boring Numbers\"></a><a href=\"https://codingcompetitions.withgoogle.com/kickstart/round/000000000019ff49/000000000043b0c6#problem\" target=\"_blank\" rel=\"noopener\">Boring Numbers</a></h3><h4 id=\"12345，101010这样以奇数开头，并且奇偶交错的数叫无聊数。给你一个区间，求所有这种数的个数。\"><a href=\"#12345，101010这样以奇数开头，并且奇偶交错的数叫无聊数。给你一个区间，求所有这种数的个数。\" class=\"headerlink\" title=\"12345，101010这样以奇数开头，并且奇偶交错的数叫无聊数。给你一个区间，求所有这种数的个数。\"></a>12345，101010这样以奇数开头，并且奇偶交错的数叫无聊数。给你一个区间，求所有这种数的个数。</h4><p>方法一：Lee215的方法。以<code>N=3422</code>为例，在7~9行循环中，分别加上了<code>5**3</code>表示<code>1xxx</code>；<code>2*5**2</code>表示<code>3[0|2]xx</code>；<code>1*5**1</code>表示<code>341x</code>，最后因为<code>i%2==v%2</code>打破奇偶交替，退出循环，因为<code>342x</code>不符合要求。随后11~12行循环用来计算<code>[1, 9], [10, 99], [100, 999]</code>的个数。由于每一位计算的时候没有算当前的，比如计算百位时，只算了0和2，这里相当于一个滞后的计算，所以末尾需要+1，也就是<code>hi+1</code>。最后相减即为结果。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">count</span><span class=\"params\">(N)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    返回1~N的所有的无聊数，不包括N。</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    res = <span class=\"number\">0</span></span><br><span class=\"line\">    n = len(str(N))</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, v <span class=\"keyword\">in</span> enumerate(map(int, str(N))):</span><br><span class=\"line\">        res += (v + i%<span class=\"number\">2</span>) // <span class=\"number\">2</span> * <span class=\"number\">5</span> ** (n-i<span class=\"number\">-1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i % <span class=\"number\">2</span> == v % <span class=\"number\">2</span>:</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n):</span><br><span class=\"line\">        res += <span class=\"number\">5</span> ** i</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> case <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, int(input())+<span class=\"number\">1</span>):</span><br><span class=\"line\">    lo, hi = map(int, input().split())</span><br><span class=\"line\"></span><br><span class=\"line\">    a, b = map(count, (lo, hi+<span class=\"number\">1</span>))</span><br><span class=\"line\">    print_ans(case, b-a)</span><br></pre></td></tr></table></figure>\n","categories":["算法"],"tags":["kickstart"]},{"title":"LeetCode算法题整理（并查集篇）UnionFind","url":"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AF%87%EF%BC%89UnionFind/","content":"<h3 id=\"1697-Checking-Existence-of-Edge-Length-Limited-Paths\"><a href=\"#1697-Checking-Existence-of-Edge-Length-Limited-Paths\" class=\"headerlink\" title=\"1697. Checking Existence of Edge Length Limited Paths\"></a><a href=\"https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/\" target=\"_blank\" rel=\"noopener\">1697. Checking Existence of Edge Length Limited Paths</a></h3><h4 id=\"给你一个-n-个点组成的无向图边集-edgeList-，其中-edgeList-i-ui-vi-disi-表示点-ui-和点-vi-之间有一条长度为-disi-的边。请注意，两个点之间可能有-超过一条边-。给你一个查询数组queries-，其中-queries-j-pj-qj-limitj-，你的任务是对于每个查询-queries-j-，判断是否存在从-pj-到-qj-的路径，且这条路径上的每一条边都-严格小于-limitj-。请你返回一个-布尔数组-answer-，其中-answer-length-queries-length-，当-queries-j-的查询结果为-true-时，-answer-第-j-个值为-true-，否则为-false-。\"><a href=\"#给你一个-n-个点组成的无向图边集-edgeList-，其中-edgeList-i-ui-vi-disi-表示点-ui-和点-vi-之间有一条长度为-disi-的边。请注意，两个点之间可能有-超过一条边-。给你一个查询数组queries-，其中-queries-j-pj-qj-limitj-，你的任务是对于每个查询-queries-j-，判断是否存在从-pj-到-qj-的路径，且这条路径上的每一条边都-严格小于-limitj-。请你返回一个-布尔数组-answer-，其中-answer-length-queries-length-，当-queries-j-的查询结果为-true-时，-answer-第-j-个值为-true-，否则为-false-。\" class=\"headerlink\" title=\"给你一个 n 个点组成的无向图边集 edgeList ，其中 edgeList[i] = [ui, vi, disi] 表示点 ui 和点 vi 之间有一条长度为 disi 的边。请注意，两个点之间可能有 超过一条边 。给你一个查询数组queries ，其中 queries[j] = [pj, qj, limitj] ，你的任务是对于每个查询 queries[j] ，判断是否存在从 pj 到 qj 的路径，且这条路径上的每一条边都 严格小于 limitj 。请你返回一个 布尔数组 answer ，其中 answer.length == queries.length ，当 queries[j] 的查询结果为 true 时， answer 第 j 个值为 true ，否则为 false 。\"></a>给你一个 n 个点组成的无向图边集 edgeList ，其中 edgeList[i] = [ui, vi, disi] 表示点 ui 和点 vi 之间有一条长度为 disi 的边。请注意，两个点之间可能有 超过一条边 。给你一个查询数组queries ，其中 queries[j] = [pj, qj, limitj] ，你的任务是对于每个查询 queries[j] ，判断是否存在从 pj 到 qj 的路径，且这条路径上的每一条边都 严格小于 limitj 。请你返回一个 布尔数组 answer ，其中 answer.length == queries.length ，当 queries[j] 的查询结果为 true 时， answer 第 j 个值为 true ，否则为 false 。</h4><a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：n &#x3D; 3, edgeList &#x3D; [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries &#x3D; [[0,1,2],[0,2,5]]</span><br><span class=\"line\">输出：[false,true]</span><br><span class=\"line\">解释：上图为给定的输入数据。注意到 0 和 1 之间有两条重边，分别为 2 和 16 。</span><br><span class=\"line\">对于第一个查询，0 和 1 之间没有小于 2 的边，所以我们返回 false 。</span><br><span class=\"line\">对于第二个查询，有一条路径（0 -&gt; 1 -&gt; 2）两条边都小于 5 ，所以这个查询我们返回 true 。</span><br></pre></td></tr></table></figure>\n<p>方法一：离线算法+并查集。比赛中没时间做，此题要用并查集。</p>\n<blockquote>\n<p>在线算法，可以用来处理数据流。算法不需要一次性地把所有的 query 都收集到再处理。大家也可以想象成：把这个算法直接部署到线上，尽管在线上可能又产生了很多新的 query，也不影响，算法照常运行。</p>\n<p>离线算法则不同。离线算法需要把所有的信息都收集到，才能运行。处理当前 query 的计算过程，可能需要使用之后 query 的信息。</p>\n<p>以排序算法为例，插入排序算法是一种在线算法。因为可以把插入排序算法的待排序数组看做是一个数据流。插入排序算法顺次把每一个数据插入到当前排好序数组部分的正确位置。在排序过程中，即使后面源源不断来新的数据也不怕，整个算法照常进行。</p>\n<p>选择排序算法则是一种离线算法。因为选择排序算法一上来要找到整个数组中最小的元素；然后找第二小元素；以此类推。这就要求不能再有新的数据了。因为刚找到最小元素，再来的新数据中有更小的元素，之前的计算就不正确了。</p>\n</blockquote>\n<p>按照<em>queries</em>的<em>limit</em>排序，这样我们只需要查看当前的边是否联通来知道是否这条路径上的每条边都小于<em>limit</em>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">distanceLimitedPathsExist</span><span class=\"params\">(self, n: int, edgeList: List[List[int]], queries: List[List[int]])</span> -&gt; List[bool]:</span></span><br><span class=\"line\">    edgeList.sort(key=itemgetter(<span class=\"number\">2</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">union</span><span class=\"params\">(x, y)</span>:</span></span><br><span class=\"line\">        uf[find(x)] = find(y)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">find</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">        uf.setdefault(x, x)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> x != uf[x]:</span><br><span class=\"line\">            uf[x] = find(uf[x])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> uf[x]</span><br><span class=\"line\"></span><br><span class=\"line\">    uf = &#123;&#125;</span><br><span class=\"line\">    Q = len(queries)</span><br><span class=\"line\">    E = len(edgeList)</span><br><span class=\"line\"></span><br><span class=\"line\">    ans = [<span class=\"literal\">None</span>] * Q</span><br><span class=\"line\">    j = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> l, i, a, b <span class=\"keyword\">in</span> sorted(((l, i, a, b) <span class=\"keyword\">for</span> i, (a, b, l) <span class=\"keyword\">in</span> enumerate(queries))):</span><br><span class=\"line\">        <span class=\"keyword\">while</span> j &lt; E <span class=\"keyword\">and</span> edgeList[j][<span class=\"number\">2</span>] &lt; l:</span><br><span class=\"line\">            x, y, _ = edgeList[j]</span><br><span class=\"line\">            union(x, y)</span><br><span class=\"line\">            j += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        ans[i] = find(a)==find(b)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<h3 id=\"1319-Number-of-Operations-to-Make-Network-Connected\"><a href=\"#1319-Number-of-Operations-to-Make-Network-Connected\" class=\"headerlink\" title=\"1319. Number of Operations to Make Network Connected\"></a><a href=\"https://leetcode.com/problems/number-of-operations-to-make-network-connected/\" target=\"_blank\" rel=\"noopener\">1319. Number of Operations to Make Network Connected</a></h3><h4 id=\"最少需要多少步可以将所有的服务器相连。\"><a href=\"#最少需要多少步可以将所有的服务器相连。\" class=\"headerlink\" title=\"最少需要多少步可以将所有的服务器相连。\"></a>最少需要多少步可以将所有的服务器相连。</h4><img src=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AF%87%EF%BC%89UnionFind/1319q.png\" class>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 4, connections &#x3D; [[0,1],[0,2],[1,2]]</span><br><span class=\"line\">Output: 1</span><br><span class=\"line\">Explanation: Remove cable between computer 1 and 2 and place between computers 1 and 3.</span><br></pre></td></tr></table></figure>\n<p>方法一：dfs. 如果线够，就可以将所有的服务器相连，找到连通器的个数然后-1，就是需要的操作数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">makeConnected</span><span class=\"params\">(self, n: int, connections: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(connections) &lt; n<span class=\"number\">-1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    g = defaultdict(list)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> u, v <span class=\"keyword\">in</span> connections:</span><br><span class=\"line\">        g[u].append(v)</span><br><span class=\"line\">        g[v].append(u)</span><br><span class=\"line\"></span><br><span class=\"line\">    seen = set()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(i)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i <span class=\"keyword\">in</span> seen:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        seen.add(i)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> g[i]:</span><br><span class=\"line\">            dfs(j)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(dfs(i) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n)) - <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>方法二：并查集。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">makeConnected</span><span class=\"params\">(self, n: int, connections: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(connections) &lt; n<span class=\"number\">-1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>        </span><br><span class=\"line\"></span><br><span class=\"line\">    uf = list(range(n))</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">union</span><span class=\"params\">(x, y)</span>:</span></span><br><span class=\"line\">        uf[find(x)] = find(y)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">find</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> uf[x] != x:</span><br><span class=\"line\">            uf[x] = find(uf[x])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> uf[x]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> u, v <span class=\"keyword\">in</span> connections:</span><br><span class=\"line\">        union(u, v)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> len(&#123;find(i) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n)&#125;) - <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1489-Find-Critical-and-Pseudo-Critical-Edges-in-Minimum-Spanning-Tree\"><a href=\"#1489-Find-Critical-and-Pseudo-Critical-Edges-in-Minimum-Spanning-Tree\" class=\"headerlink\" title=\"1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree\"></a><a href=\"https://leetcode.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/\" target=\"_blank\" rel=\"noopener\">1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree</a></h3><h4 id=\"找到最小生成树的关建边和伪关建边。关建边指去掉这条边以后，路径和会增加。伪关建边，因为生成树图不唯一，指有的生成树图中有这条边，有的没有。还有一种是冗余边，指的是必须要去掉的边。分别返回关建边和伪关建边的索引。\"><a href=\"#找到最小生成树的关建边和伪关建边。关建边指去掉这条边以后，路径和会增加。伪关建边，因为生成树图不唯一，指有的生成树图中有这条边，有的没有。还有一种是冗余边，指的是必须要去掉的边。分别返回关建边和伪关建边的索引。\" class=\"headerlink\" title=\"找到最小生成树的关建边和伪关建边。关建边指去掉这条边以后，路径和会增加。伪关建边，因为生成树图不唯一，指有的生成树图中有这条边，有的没有。还有一种是冗余边，指的是必须要去掉的边。分别返回关建边和伪关建边的索引。\"></a>找到最小生成树的关建边和伪关建边。关建边指去掉这条边以后，路径和会增加。伪关建边，因为生成树图不唯一，指有的生成树图中有这条边，有的没有。还有一种是冗余边，指的是必须要去掉的边。分别返回关建边和伪关建边的索引。</h4><img src=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AF%87%EF%BC%89UnionFind/1489q.png\" class>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 5, edges &#x3D; [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]</span><br><span class=\"line\">Output: [[0,1],[2,3,4,5]]</span><br><span class=\"line\">Explanation: The figure above describes the graph.</span><br><span class=\"line\">The following figure shows all the possible MSTs:</span><br></pre></td></tr></table></figure>\n<p>方法一：Union-Find &amp; Kruskal’s 算法。按照Kruskal算法，我们先将所有的边按权重排列。先将所有点边传入得到一个最小生成树的路径和S。再将每条边去掉剩下的边求路径和S1，如果大于S，则说明这是一条关建边；否则它可能是一条伪关建边或者冗余边。然后我们将这条边加到图中，生成一个路径和S2。如果S2和S1相等，则说明是伪关建边。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findCriticalAndPseudoCriticalEdges</span><span class=\"params\">(self, n: int, edges: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">min_spanning_tree</span><span class=\"params\">(edges, m_edge=None)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">        uf = list(range(n))</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">union</span><span class=\"params\">(x, y)</span>:</span></span><br><span class=\"line\">            uf[find(x)] = find(y)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">find</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> uf[x] != x:</span><br><span class=\"line\">                uf[x] = find(uf[x])</span><br><span class=\"line\">            <span class=\"keyword\">return</span> uf[x]</span><br><span class=\"line\"></span><br><span class=\"line\">        edges = [(w, u, v) <span class=\"keyword\">for</span> u, v, w <span class=\"keyword\">in</span> edges]</span><br><span class=\"line\">        heapq.heapify(edges)</span><br><span class=\"line\">        cnt, ans = <span class=\"number\">1</span>, <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> m_edge:</span><br><span class=\"line\">            uu, vv, ww = m_edge</span><br><span class=\"line\">            cnt += <span class=\"number\">1</span></span><br><span class=\"line\">            ans += ww</span><br><span class=\"line\">            union(uu, vv)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            uu, vv, ww = <span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> cnt &lt; n:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> edges:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> inf</span><br><span class=\"line\">            d, u, v = heapq.heappop(edges)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> u==uu <span class=\"keyword\">and</span> v == vv:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> find(u) != find(v):</span><br><span class=\"line\">                ans += d</span><br><span class=\"line\">                cnt += <span class=\"number\">1</span></span><br><span class=\"line\">                union(u, v)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\"></span><br><span class=\"line\">    res = [[], []]</span><br><span class=\"line\">    mm = min_spanning_tree(edges)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(edges)):</span><br><span class=\"line\">        cur = min_spanning_tree(edges[:i]+edges[i+<span class=\"number\">1</span>:])</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cur == mm:</span><br><span class=\"line\">            <span class=\"comment\"># 伪关键边或冗余边</span></span><br><span class=\"line\">            include = min_spanning_tree(edges, edges[i])</span><br><span class=\"line\">            <span class=\"keyword\">if</span> include == mm:</span><br><span class=\"line\">                res[<span class=\"number\">1</span>].append(i)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            res[<span class=\"number\">0</span>].append(i)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<p>方法二：待定</p>\n<h3 id=\"1579-Remove-Max-Number-of-Edges-to-Keep-Graph-Fully-Traversable\"><a href=\"#1579-Remove-Max-Number-of-Edges-to-Keep-Graph-Fully-Traversable\" class=\"headerlink\" title=\"1579. Remove Max Number of Edges to Keep Graph Fully Traversable\"></a><a href=\"https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/\" target=\"_blank\" rel=\"noopener\">1579. Remove Max Number of Edges to Keep Graph Fully Traversable</a></h3><h4 id=\"找到能使Alice，Bob任意节点都能遍历完整图的最多删除的边的条数。\"><a href=\"#找到能使Alice，Bob任意节点都能遍历完整图的最多删除的边的条数。\" class=\"headerlink\" title=\"找到能使Alice，Bob任意节点都能遍历完整图的最多删除的边的条数。\"></a>找到能使Alice，Bob任意节点都能遍历完整图的最多删除的边的条数。</h4><img src=\"/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AF%87%EF%BC%89UnionFind/1579q.png\" class>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 4, edges &#x3D; [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: If we remove the 2 edges [1,1,2] and [1,1,3]. The graph will still be fully traversable by Alice and Bob. Removing any additional edge will not make it so. So the maximum number of edges we can remove is 2.</span><br></pre></td></tr></table></figure>\n<p>方法一：贪心+并查集。优先保留类型3的边。注意类型3的边也可能增加结果。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UF</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">        self.uf = list(range(n+<span class=\"number\">1</span>))</span><br><span class=\"line\">        self.n = n</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">union</span><span class=\"params\">(self, x, y)</span>:</span></span><br><span class=\"line\">            self.uf[self.find(x)] = self.find(y)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">find</span><span class=\"params\">(self, x)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.uf[x] != x:</span><br><span class=\"line\">            self.uf[x] = self.find(self.uf[x])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.uf[x]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">all_connected</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> len(&#123;self.find(i) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, self.n+<span class=\"number\">1</span>)&#125;) == <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxNumEdgesToRemove</span><span class=\"params\">(self, n: int, edges: List[List[int]])</span> -&gt; int:</span></span><br><span class=\"line\">        self.res = <span class=\"number\">0</span></span><br><span class=\"line\">        edges_3 = ([t, u, v] <span class=\"keyword\">for</span> t, u, v <span class=\"keyword\">in</span> edges <span class=\"keyword\">if</span> t==<span class=\"number\">3</span>)</span><br><span class=\"line\">        edges_2 = ([t, u, v] <span class=\"keyword\">for</span> t, u, v <span class=\"keyword\">in</span> edges <span class=\"keyword\">if</span> t==<span class=\"number\">2</span>)</span><br><span class=\"line\">        edges_1 = ([t, u, v] <span class=\"keyword\">for</span> t, u, v <span class=\"keyword\">in</span> edges <span class=\"keyword\">if</span> t==<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        uf = UF(n)</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">connect</span><span class=\"params\">(uf, edges)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> _, u, v <span class=\"keyword\">in</span> edges:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> uf.find(u) == uf.find(v):</span><br><span class=\"line\">                    self.res += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    uf.union(u, v)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> uf, uf.all_connected()</span><br><span class=\"line\"></span><br><span class=\"line\">        cp_uf, _ = connect(uf, edges_3)</span><br><span class=\"line\">        cp_uf = copy.deepcopy(uf)</span><br><span class=\"line\">        _, connected = connect(uf, edges_2)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> connected: <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        _, connected = connect(cp_uf, edges_1)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> connected: <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.res</span><br></pre></td></tr></table></figure>\n","categories":["UnionFind"],"tags":["LeetCode","UnionFind"]}]