<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="LeetCode,Python,Algorithm,Graph," />








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.2" />






<meta name="description" content="990. Satisfiability of Equality Equations满足所有方程式，判断是否存在变量的值满足所有的等式与不等式。原题解析：所有的相等的点，在图中是联通的。">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode算法题整理（图篇）Graph">
<meta property="og:url" content="http://darktiantian.github.io.git/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%9B%BE%E7%AF%87%EF%BC%89Graph/index.html">
<meta property="og:site_name" content="Xiaoliji&#39;s Blog">
<meta property="og:description" content="990. Satisfiability of Equality Equations满足所有方程式，判断是否存在变量的值满足所有的等式与不等式。原题解析：所有的相等的点，在图中是联通的。">
<meta property="og:image" content="http://darktiantian.github.io.git/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%9B%BE%E7%AF%87%EF%BC%89Graph/113_sample.png">
<meta property="og:image" content="http://darktiantian.github.io.git/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%9B%BE%E7%AF%87%EF%BC%89Graph/1334.png">
<meta property="og:image" content="http://darktiantian.github.io.git/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%9B%BE%E7%AF%87%EF%BC%89Graph/oranges.png">
<meta property="article:published_time" content="2019-02-10T05:32:48.000Z">
<meta property="article:modified_time" content="2020-10-21T11:00:58.440Z">
<meta property="article:author" content="xiaoliji">
<meta property="article:tag" content="LeetCode">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="Algorithm">
<meta property="article:tag" content="Graph">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://darktiantian.github.io.git/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%9B%BE%E7%AF%87%EF%BC%89Graph/113_sample.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://darktiantian.github.io.git/LeetCode算法题整理（图篇）Graph/"/>





  <title>LeetCode算法题整理（图篇）Graph | Xiaoliji's Blog</title>
  














<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <a href="https://github.com/darkTianTian" target="_blank" rel="noopener" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Xiaoliji's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">小里脊的个人博客</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://darktiantian.github.io.git/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%9B%BE%E7%AF%87%EF%BC%89Graph/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaoliji">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xiaoliji's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">LeetCode算法题整理（图篇）Graph</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-10T13:32:48+08:00">
                2019-02-10
              </time>
            

            
              <span class="post-updated">
                &nbsp; | &nbsp; Updated on
                <time itemprop="dateUpdated" datetime="2020-10-21T19:00:58+08:00" content="2020-10-21">
                  2020-10-21
                </time>
              </span>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%9B%BE%E7%AF%87%EF%BC%89Graph/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="LeetCode算法题整理（图篇）Graph/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%9B%BE%E7%AF%87%EF%BC%89Graph/" class="leancloud_visitors" data-flag-title="LeetCode算法题整理（图篇）Graph">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="990-Satisfiability-of-Equality-Equations"><a href="#990-Satisfiability-of-Equality-Equations" class="headerlink" title="990. Satisfiability of Equality Equations"></a>990. Satisfiability of Equality Equations</h3><h4 id="满足所有方程式，判断是否存在变量的值满足所有的等式与不等式。原题"><a href="#满足所有方程式，判断是否存在变量的值满足所有的等式与不等式。原题" class="headerlink" title="满足所有方程式，判断是否存在变量的值满足所有的等式与不等式。原题"></a>满足所有方程式，判断是否存在变量的值满足所有的等式与不等式。<a href="https://leetcode.com/problems/satisfiability-of-equality-equations/" target="_blank" rel="noopener">原题</a></h4><p>解析：所有的相等的点，在图中是联通的。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;a&#x3D;&#x3D;b&quot;,&quot;b!&#x3D;a&quot;]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: If we assign say, a &#x3D; 1 and b &#x3D; 1, then the first equation is satisfied, but not the second.  There is no way to assign the variables to satisfy both equations.</span><br><span class="line"></span><br><span class="line">Input: [&quot;a&#x3D;&#x3D;b&quot;,&quot;b&#x3D;&#x3D;c&quot;,&quot;a&#x3D;&#x3D;c&quot;]</span><br><span class="line">Output: true</span><br><span class="line"></span><br><span class="line">Input: [&quot;a&#x3D;&#x3D;b&quot;,&quot;b!&#x3D;c&quot;,&quot;c&#x3D;&#x3D;a&quot;]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p>方法一：set.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">equationsPossible</span><span class="params">(self, equations: <span class="string">'List[str]'</span>)</span> -&gt; 'bool':</span></span><br><span class="line">    equals = []</span><br><span class="line">    equations.sort(key=operator.itemgetter(<span class="number">1</span>), reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># print(equations)</span></span><br><span class="line">    <span class="keyword">for</span> x, e, _, y  <span class="keyword">in</span> equations:</span><br><span class="line">        <span class="keyword">if</span> e == <span class="string">'='</span>:</span><br><span class="line">            <span class="keyword">for</span> i, eq <span class="keyword">in</span> enumerate(equals):</span><br><span class="line">                <span class="keyword">if</span> x <span class="keyword">in</span> eq <span class="keyword">or</span> y <span class="keyword">in</span> eq:</span><br><span class="line">                    equals[i].update(&#123;x, y&#125;)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                equals.append(&#123;x, y&#125;)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> x == y:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">for</span> eq <span class="keyword">in</span> equals:</span><br><span class="line">                <span class="keyword">if</span> x <span class="keyword">in</span> eq <span class="keyword">and</span> y <span class="keyword">in</span> eq:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># print(equals)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：union find. 并查集。find方法可以想象成一个链表，返回的是链表末尾key,val相等的元素。同时建立连接关系。如<code>a==b, b==c</code>时<code>fc={&#39;a&#39;: &#39;b&#39;, &#39;b&#39;: &#39;c&#39;, &#39;c&#39;: &#39;c&#39;}</code>比较<code>a!=c</code>时就会最终找到<code>fc[&#39;a&#39;] == &#39;c&#39;</code>；如<code>a==b, c==a时，fc={&#39;a&#39;: &#39;b&#39;, &#39;b&#39;: &#39;b&#39;, &#39;c&#39;: &#39;b&#39;}</code>。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">equationsPossible</span><span class="params">(self, equations: <span class="string">'List[str]'</span>)</span> -&gt; 'bool':</span></span><br><span class="line">    equations.sort(key=<span class="keyword">lambda</span> e: e[<span class="number">1</span>] == <span class="string">'!'</span>)</span><br><span class="line">    uf = &#123;a: a <span class="keyword">for</span> a <span class="keyword">in</span> string.ascii_lowercase&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x != uf[x]: </span><br><span class="line">            uf[x] = find(uf[x])</span><br><span class="line">        <span class="keyword">return</span> uf[x]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> a, e, _, b <span class="keyword">in</span> equations:</span><br><span class="line">        <span class="keyword">if</span> e == <span class="string">"="</span>:</span><br><span class="line">            uf[find(a)] = find(b)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> find(a) == find(b):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h3 id="997-Find-the-Town-Judge"><a href="#997-Find-the-Town-Judge" class="headerlink" title="997. Find the Town Judge"></a>997. Find the Town Judge</h3><h4 id="找到小镇审判长。审判长被除自己以外的所有人信任，并且不信任任何人。根据信任列表找出审判长。原题"><a href="#找到小镇审判长。审判长被除自己以外的所有人信任，并且不信任任何人。根据信任列表找出审判长。原题" class="headerlink" title="找到小镇审判长。审判长被除自己以外的所有人信任，并且不信任任何人。根据信任列表找出审判长。原题"></a>找到小镇审判长。审判长被除自己以外的所有人信任，并且不信任任何人。根据信任列表找出审判长。<a href="https://leetcode.com/problems/find-the-town-judge/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: N &#x3D; 4, trust &#x3D; [[1,3],[1,4],[2,3],[2,4],[4,3]]</span><br><span class="line">Output: 3</span><br><span class="line">Input: N &#x3D; 3, trust &#x3D; [[1,3],[2,3],[3,1]]</span><br><span class="line">Output: -1</span><br><span class="line">Input: N &#x3D; 3, trust &#x3D; [[1,3],[2,3]]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
<p>方法一：brute force.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findJudge</span><span class="params">(self, N: int, trust: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> trust:</span><br><span class="line">        <span class="keyword">return</span> N</span><br><span class="line">    a, b = zip(*trust)           </span><br><span class="line">    candidates = collections.Counter(b)</span><br><span class="line">    villages = set(a)</span><br><span class="line">    <span class="keyword">for</span> c, votes <span class="keyword">in</span> candidates.most_common():</span><br><span class="line">        <span class="keyword">if</span> votes &lt; N - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> villages:</span><br><span class="line">            <span class="keyword">return</span> c</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：定向图。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findJudge</span><span class="params">(self, N: int, trust: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    count = [<span class="number">0</span>] * (N + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> trust:</span><br><span class="line">        count[i] -= <span class="number">1</span></span><br><span class="line">        count[j] += <span class="number">1</span></span><br><span class="line">        print(count)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> count[i] == N - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="133-Clone-Graph"><a href="#133-Clone-Graph" class="headerlink" title="133. Clone Graph"></a>133. Clone Graph</h3><h4 id="深拷贝一个简单环。原题"><a href="#深拷贝一个简单环。原题" class="headerlink" title="深拷贝一个简单环。原题"></a>深拷贝一个简单环。<a href="https://leetcode.com/problems/clone-graph/" target="_blank" rel="noopener">原题</a></h4><img src="/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%9B%BE%E7%AF%87%EF%BC%89Graph/113_sample.png" class>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cloneGraph</span><span class="params">(self, node: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">    cp = collections.defaultdict(<span class="keyword">lambda</span>: Node(<span class="number">0</span>, []))</span><br><span class="line">    nodes = [node]</span><br><span class="line">    seen = set()</span><br><span class="line">    <span class="keyword">while</span> nodes:</span><br><span class="line">        n = nodes.pop()</span><br><span class="line">        cp[n].val = n.val</span><br><span class="line">        cp[n].neighbors = [cp[x] <span class="keyword">for</span> x <span class="keyword">in</span> n.neighbors]</span><br><span class="line">        nodes.extend(x <span class="keyword">for</span> x <span class="keyword">in</span> n.neighbors <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> seen)</span><br><span class="line">        seen.add(n)</span><br><span class="line">    <span class="keyword">return</span> cp[node]</span><br></pre></td></tr></table></figure>
<h3 id="1334-Find-the-City-With-the-Smallest-Number-of-Neighbors-at-a-Threshold-Distance"><a href="#1334-Find-the-City-With-the-Smallest-Number-of-Neighbors-at-a-Threshold-Distance" class="headerlink" title="1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance"></a>1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance</h3><h4 id="找到距离范围内邻居最少的城市。原题"><a href="#找到距离范围内邻居最少的城市。原题" class="headerlink" title="找到距离范围内邻居最少的城市。原题"></a>找到距离范围内邻居最少的城市。<a href="https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/" target="_blank" rel="noopener">原题</a></h4><img src="/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%9B%BE%E7%AF%87%EF%BC%89Graph/1334.png" class>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 4, edges &#x3D; [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold &#x3D; 4</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The figure above describes the graph. </span><br><span class="line">The neighboring cities at a distanceThreshold &#x3D; 4 for each city are:</span><br><span class="line">City 0 -&gt; [City 1, City 2] </span><br><span class="line">City 1 -&gt; [City 0, City 2, City 3] </span><br><span class="line">City 2 -&gt; [City 0, City 1, City 3] </span><br><span class="line">City 3 -&gt; [City 1, City 2] </span><br><span class="line">Cities 0 and 3 have 2 neighboring cities at a distanceThreshold &#x3D; 4, but we have to return city 3 since it has the greatest number.</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法一：狄克斯特拉算法。这里没想到用一个堆来维持最小的距离。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findTheCity</span><span class="params">(self, n: int, edges: List[List[int]], distanceThreshold: int)</span> -&gt; int:</span></span><br><span class="line">    g = collections.defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> u, v, w <span class="keyword">in</span> edges:</span><br><span class="line">        g[u].append((v, w))</span><br><span class="line">        g[v].append((u, w))</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count_neighbor</span><span class="params">(city)</span>:</span></span><br><span class="line">        heap = [(<span class="number">0</span>, city)]</span><br><span class="line">        dist = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> heap:</span><br><span class="line">            cur_w, u = heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">if</span> u <span class="keyword">in</span> dist:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> u != city:</span><br><span class="line">                dist[u] = cur_w</span><br><span class="line">            <span class="keyword">for</span> v, w <span class="keyword">in</span> g[u]:</span><br><span class="line">                <span class="keyword">if</span> v <span class="keyword">in</span> dist:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> cur_w + w &lt;= distanceThreshold:</span><br><span class="line">                    heapq.heappush(heap, (cur_w+w, v))</span><br><span class="line">        <span class="keyword">return</span> len(dist)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> min(range(n), key=<span class="keyword">lambda</span> x: (count_neighbor(x), -x))</span><br></pre></td></tr></table></figure>
<p>方法二：弗洛伊德算法，这个时间复杂度为O(N^3)，space: O(N^2)但是代码简单。把每个节点当成中转点k，如果<code>dis[i][j] &gt; dis[i][k] + dis[k][j]</code>说明从k走，i, j距离更短。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findTheCity</span><span class="params">(self, n: int, edges: List[List[int]], maxd: int)</span> -&gt; int:</span></span><br><span class="line">    dis = [[float(<span class="string">'inf'</span>)] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="keyword">for</span> i, j, w <span class="keyword">in</span> edges:</span><br><span class="line">        dis[i][j] = dis[j][i] = w</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        dis[i][i] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                dis[i][j] = min(dis[i][j], dis[i][k]+dis[k][j])</span><br><span class="line">    ans = &#123;sum(d&lt;=maxd <span class="keyword">for</span> d <span class="keyword">in</span> dis[i]): i <span class="keyword">for</span> i <span class="keyword">in</span> range(n)&#125;  <span class="comment"># 这里id大的会将小的覆盖</span></span><br><span class="line">    <span class="keyword">return</span> ans[min(ans)]</span><br></pre></td></tr></table></figure>
<h3 id="1267-Count-Servers-that-Communicate"><a href="#1267-Count-Servers-that-Communicate" class="headerlink" title="1267. Count Servers that Communicate"></a>1267. Count Servers that Communicate</h3><h4 id="找到2个以上的服务器连接个数，服务器可以在一行或是一列算是连接上。原题"><a href="#找到2个以上的服务器连接个数，服务器可以在一行或是一列算是连接上。原题" class="headerlink" title="找到2个以上的服务器连接个数，服务器可以在一行或是一列算是连接上。原题"></a>找到2个以上的服务器连接个数，服务器可以在一行或是一列算是连接上。<a href="https://leetcode.com/problems/count-servers-that-communicate/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [[1,1,0,0],[0,0,1,0],[0,0,1,0],[0,0,0,1]]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The two servers in the first row can communicate with each other. The two servers in the third column can communicate with each other. The server at right bottom corner can&#39;t communicate with any other server.</span><br></pre></td></tr></table></figure>
<p>方法一：和小岛问题不同，这个服务器可以隔空连接，AC时用的dfs方法，效率非常慢。实际上只需要记录横纵左边即可，遍历两次</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countServers</span><span class="params">(self, g: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    X, Y = [<span class="number">0</span>]*<span class="number">300</span>, [<span class="number">0</span>]*<span class="number">300</span></span><br><span class="line">    m, n = len(g), len(g[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            X[i] += g[i][j]</span><br><span class="line">            Y[j] += g[i][j]</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> g[i][j]==<span class="number">1</span> <span class="keyword">and</span> (X[i]&gt;<span class="number">1</span> <span class="keyword">or</span> Y[j]&gt;<span class="number">1</span>):</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：行列累计求和，但是只是用来判断而不是累加，然后遍历所有的元素。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countServers</span><span class="params">(self, g: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    X, Y = tuple(map(sum, g)), tuple(map(sum, zip(*g)))</span><br><span class="line">    <span class="keyword">return</span> sum(X[i]+Y[j]&gt;<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(g)) <span class="keyword">for</span> j <span class="keyword">in</span> range(len(g[<span class="number">0</span>])) <span class="keyword">if</span> g[i][j])</span><br></pre></td></tr></table></figure>
<h3 id="886-Possible-Bipartition"><a href="#886-Possible-Bipartition" class="headerlink" title="886. Possible Bipartition"></a>886. Possible Bipartition</h3><h4 id="将不喜欢的人放在两组中，根据关系是否能将其分为2组。原题"><a href="#将不喜欢的人放在两组中，根据关系是否能将其分为2组。原题" class="headerlink" title="将不喜欢的人放在两组中，根据关系是否能将其分为2组。原题"></a>将不喜欢的人放在两组中，根据关系是否能将其分为2组。<a href="https://leetcode.com/problems/possible-bipartition/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: N &#x3D; 4, dislikes &#x3D; [[1,2],[1,3],[2,4]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: group1 [1,4], group2 [2,3]</span><br><span class="line"></span><br><span class="line">Input: N &#x3D; 3, dislikes &#x3D; [[1,2],[1,3],[2,3]]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p>方法一：dfs。此题想了半个多点才想明白，等同于在一个无向图中，寻找一个奇数边的环。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">possibleBipartition</span><span class="params">(self, N: int, dislikes: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">    g = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(N+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> a, b <span class="keyword">in</span> dislikes:</span><br><span class="line">        g[a].append(b)</span><br><span class="line">        g[b].append(a)</span><br><span class="line"></span><br><span class="line">    seen = set()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, p, p_len)</span>:</span></span><br><span class="line">        seen.add(i)</span><br><span class="line">        p[i] = p_len</span><br><span class="line">        <span class="keyword">for</span> nxt <span class="keyword">in</span> g[i]:</span><br><span class="line">            <span class="keyword">if</span> nxt <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="keyword">if</span> dfs(nxt, p, p_len+<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> nxt <span class="keyword">in</span> p <span class="keyword">and</span> (p_len-p[nxt])&amp;<span class="number">1</span>==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        p.pop(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    p = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> seen <span class="keyword">and</span> dfs(i, p, <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>方法二：染色思想。0代表红色，1代表蓝色，每次将其不喜欢的人染成另一种颜色。这个代码比较简洁，不过稍微慢了一丢丢，50ms左右。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">possibleBipartition</span><span class="params">(self, N: int, dislikes: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">    g = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(N+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> a, b <span class="keyword">in</span> dislikes:</span><br><span class="line">        g[a].append(b)</span><br><span class="line">        g[b].append(a)</span><br><span class="line">    </span><br><span class="line">    color = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, c=<span class="number">0</span>)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> color:</span><br><span class="line">            <span class="keyword">return</span> color[i]==c</span><br><span class="line">        color[i] = c</span><br><span class="line">        <span class="keyword">return</span> all(dfs(j, c^<span class="number">1</span>) <span class="keyword">for</span> j <span class="keyword">in</span> g[i])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> all(dfs(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N+<span class="number">1</span>) </span><br><span class="line">               <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> color)</span><br></pre></td></tr></table></figure>
<h3 id="207-Course-Schedule"><a href="#207-Course-Schedule" class="headerlink" title="207. Course Schedule"></a>207. Course Schedule</h3><h4 id="课程调度，课程有依赖关系，问是否能完成所有的课程。原题"><a href="#课程调度，课程有依赖关系，问是否能完成所有的课程。原题" class="headerlink" title="课程调度，课程有依赖关系，问是否能完成所有的课程。原题"></a>课程调度，课程有依赖关系，问是否能完成所有的课程。<a href="https://leetcode.com/problems/course-schedule/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: numCourses &#x3D; 2, prerequisites &#x3D; [[1,0]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There are a total of 2 courses to take. </span><br><span class="line">             To take course 1 you should have finished course 0. So it is possible.</span><br></pre></td></tr></table></figure>
<p>方法一：dfs。注意这里状态要用3中，1表示遍历过，-1表示正在遍历，0表未遍历。这样可以避免重复的遍历。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canFinish</span><span class="params">(self, n: int, prerequisites: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">    g = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="keyword">for</span> a, b <span class="keyword">in</span> prerequisites:</span><br><span class="line">        g[a].append(b)</span><br><span class="line">        </span><br><span class="line">    seen = [<span class="number">0</span>] * n</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> seen[i] <span class="keyword">in</span> &#123;<span class="number">1</span>, <span class="number">-1</span>&#125;: <span class="keyword">return</span> seen[i]==<span class="number">1</span></span><br><span class="line">        seen[i] = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> any(<span class="keyword">not</span> dfs(j) <span class="keyword">for</span> j <span class="keyword">in</span> g[i]): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        seen[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：这个方法优雅一点，来自Lee215. BFS Topological Sorting.</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canFinish</span><span class="params">(self, n: int, prerequisites: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">    g = collections.defaultdict(list)</span><br><span class="line">    degree = [<span class="number">0</span>] * n</span><br><span class="line">    <span class="keyword">for</span> u, v <span class="keyword">in</span> prerequisites:</span><br><span class="line">        g[v].append(u)</span><br><span class="line">        degree[u] -= <span class="number">1</span></span><br><span class="line">    bfs = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(n) <span class="keyword">if</span> degree[i]==<span class="number">0</span>]    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> bfs:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> g[i]:</span><br><span class="line">            degree[j] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> degree[j] == <span class="number">0</span>:</span><br><span class="line">                bfs.append(j)</span><br><span class="line">    <span class="keyword">return</span> len(bfs)==n</span><br></pre></td></tr></table></figure>
<h3 id="1462-Course-Schedule-IV"><a href="#1462-Course-Schedule-IV" class="headerlink" title="1462. Course Schedule IV"></a>1462. Course Schedule IV</h3><h4 id="和上题差不多，问题不一样，问的是根据给定的依赖关系，判断两节课是否有依赖。原题"><a href="#和上题差不多，问题不一样，问的是根据给定的依赖关系，判断两节课是否有依赖。原题" class="headerlink" title="和上题差不多，问题不一样，问的是根据给定的依赖关系，判断两节课是否有依赖。原题"></a>和上题差不多，问题不一样，问的是根据给定的依赖关系，判断两节课是否有依赖。<a href="https://leetcode.com/problems/course-schedule-iv/" target="_blank" rel="noopener">原题</a></h4><font color="#32CD32" size="3">方法一：dfs. 这个方法想了超出比赛时间限制了。但是也没过多久就优化 出来了。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkIfPrerequisite</span><span class="params">(self, n: int, prerequisites: List[List[int]], queries: List[List[int]])</span> -&gt; List[bool]:</span></span><br><span class="line">    g = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    q = [set() <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]         </span><br><span class="line">    <span class="keyword">for</span> u, v <span class="keyword">in</span> prerequisites:</span><br><span class="line">        g[u].append(v)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> q[i]:</span><br><span class="line">            <span class="keyword">return</span> q[i]</span><br><span class="line">        q[i].update(g[i])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> g[i]:</span><br><span class="line">            q[i].update(dfs(j))</span><br><span class="line">        <span class="keyword">return</span> q[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        dfs(i)</span><br><span class="line">    <span class="keyword">return</span> [b <span class="keyword">in</span> q[a] <span class="keyword">for</span> a, b <span class="keyword">in</span> queries]</span><br></pre></td></tr></table></figure>
<p>方法二：弗洛伊德算法，和求城市最小距离一样。时间复杂度是O(n3)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkIfPrerequisite</span><span class="params">(self, n: int, prerequisites: List[List[int]], queries: List[List[int]])</span> -&gt; List[bool]:</span></span><br><span class="line">    g = [[<span class="literal">False</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="keyword">for</span> u, v <span class="keyword">in</span> prerequisites:</span><br><span class="line">        g[u][v] = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                g[i][j] = g[i][j] <span class="keyword">or</span> (g[i][k] <span class="keyword">and</span> g[k][j])</span><br><span class="line">    <span class="keyword">return</span> [g[i][j] <span class="keyword">for</span> i, j <span class="keyword">in</span> queries]</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法三：bfs. 拓扑排序。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkIfPrerequisite</span><span class="params">(self, n: int, prerequisites: List[List[int]], queries: List[List[int]])</span> -&gt; List[bool]:</span></span><br><span class="line">    g = collections.defaultdict(list)</span><br><span class="line">    degree = [<span class="number">0</span>] * n</span><br><span class="line">    pres = [set() <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="keyword">for</span> u, v <span class="keyword">in</span> prerequisites:</span><br><span class="line">        g[u].append(v)</span><br><span class="line">        degree[v] -= <span class="number">1</span></span><br><span class="line">        pres[v].add(u)</span><br><span class="line">    bfs = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(n) <span class="keyword">if</span> degree[i]==<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> bfs:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> g[i]:</span><br><span class="line">            degree[j] += <span class="number">1</span></span><br><span class="line">            pres[j] |= pres[i]</span><br><span class="line">            <span class="keyword">if</span> degree[j] == <span class="number">0</span>:</span><br><span class="line">                bfs.append(j)</span><br><span class="line">    <span class="keyword">return</span> [a <span class="keyword">in</span> pres[b] <span class="keyword">for</span> a, b <span class="keyword">in</span> queries]</span><br></pre></td></tr></table></figure>
<h3 id="1466-Reorder-Routes-to-Make-All-Paths-Lead-to-the-City-Zero"><a href="#1466-Reorder-Routes-to-Make-All-Paths-Lead-to-the-City-Zero" class="headerlink" title="1466. Reorder Routes to Make All Paths Lead to the City Zero"></a>1466. Reorder Routes to Make All Paths Lead to the City Zero</h3><h4 id="有一个有向图，两个节点之间只有一条边，要求所有的边指向0，需要改多少条边的方向。原题"><a href="#有一个有向图，两个节点之间只有一条边，要求所有的边指向0，需要改多少条边的方向。原题" class="headerlink" title="有一个有向图，两个节点之间只有一条边，要求所有的边指向0，需要改多少条边的方向。原题"></a>有一个有向图，两个节点之间只有一条边，要求所有的边指向0，需要改多少条边的方向。<a href="https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 6, connections &#x3D; [[0,1],[1,3],[2,3],[4,0],[4,5]]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Change the direction of edges show in red such that each node can reach the node 0 (capital).</span><br></pre></td></tr></table></figure>
<p>方法一：此题竞赛时未作出。一个效率不是很高的方法。用父节点去重。set记录原始顺序，遍历无向图。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minReorder</span><span class="params">(self, n: int, connections: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    self.ans = <span class="number">0</span></span><br><span class="line">    g = collections.defaultdict(list)</span><br><span class="line">    roads = set()</span><br><span class="line">    <span class="keyword">for</span> u, v <span class="keyword">in</span> connections:</span><br><span class="line">        g[u].append(v)</span><br><span class="line">        g[v].append(u)</span><br><span class="line">        roads.add((u, v))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, parent)</span>:</span></span><br><span class="line">        self.ans += (parent, i) <span class="keyword">in</span> roads</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> g[i]:</span><br><span class="line">            <span class="keyword">if</span> j == parent:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            dfs(j, i)</span><br><span class="line">    </span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure>
<p>方法二：比赛时想的思路，dfs内容未想出来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minReorder</span><span class="params">(self, n: int, connections: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    g1 = collections.defaultdict(list)</span><br><span class="line">    g2 = collections.defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> u, v <span class="keyword">in</span> connections:</span><br><span class="line">        g1[u].append(v)</span><br><span class="line">        g2[v].append(u)</span><br><span class="line">    </span><br><span class="line">    seen = set()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i)</span>:</span></span><br><span class="line">        seen.add(i)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> g1[i]:</span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                ans += <span class="number">1</span> + dfs(j)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> g2[i]:</span><br><span class="line">            <span class="keyword">if</span> k <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                ans += dfs(k)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="1210-Minimum-Moves-to-Reach-Target-with-Rotations"><a href="#1210-Minimum-Moves-to-Reach-Target-with-Rotations" class="headerlink" title="1210. Minimum Moves to Reach Target with Rotations"></a>1210. Minimum Moves to Reach Target with Rotations</h3><h4 id="一个占位2格的蛇，从左上走到右下需要最少的步数，可以旋转。原题"><a href="#一个占位2格的蛇，从左上走到右下需要最少的步数，可以旋转。原题" class="headerlink" title="一个占位2格的蛇，从左上走到右下需要最少的步数，可以旋转。原题"></a>一个占位2格的蛇，从左上走到右下需要最少的步数，可以旋转。<a href="https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [[0,0,0,0,0,1],</span><br><span class="line">               [1,1,0,0,1,0],</span><br><span class="line">               [0,0,0,0,1,1],</span><br><span class="line">               [0,0,1,0,1,0],</span><br><span class="line">               [0,1,1,0,0,0],</span><br><span class="line">               [0,1,1,0,0,0]]</span><br><span class="line">Output: 11</span><br><span class="line">Explanation:</span><br><span class="line">One possible solution is [right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise, right, down].</span><br></pre></td></tr></table></figure>
<p>方法一：这题没想到在写完还有10分钟，其实思路很简单，就是拿两个点当成一个点。一个点的bfs就很容易了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minimumMoves</span><span class="params">(self, g: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    n = len(g)</span><br><span class="line">    q = collections.deque([((<span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), <span class="number">0</span>)])</span><br><span class="line">    seen = set(((<span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>)))</span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        tail, head, step = q.popleft()</span><br><span class="line">        <span class="keyword">if</span> tail[<span class="number">0</span>] == head[<span class="number">0</span>] == head[<span class="number">1</span>] == n<span class="number">-1</span> <span class="keyword">and</span> tail[<span class="number">1</span>]==n<span class="number">-2</span>:</span><br><span class="line">            <span class="keyword">return</span> step</span><br><span class="line">        <span class="keyword">if</span> tail[<span class="number">0</span>] == head[<span class="number">0</span>] <span class="keyword">and</span> tail[<span class="number">0</span>]!=n<span class="number">-1</span>: <span class="comment"># horizontal</span></span><br><span class="line">            d_tail, d_head = (tail[<span class="number">0</span>]+<span class="number">1</span>, tail[<span class="number">1</span>]), (head[<span class="number">0</span>]+<span class="number">1</span>, head[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> g[d_tail[<span class="number">0</span>]][d_tail[<span class="number">1</span>]] == g[d_head[<span class="number">0</span>]][d_head[<span class="number">1</span>]] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> (tail, d_tail) <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                    q.append((tail, d_tail, step+<span class="number">1</span>))</span><br><span class="line">                    seen.add((tail, d_tail))</span><br><span class="line">        <span class="keyword">if</span> tail[<span class="number">1</span>] == head[<span class="number">1</span>] <span class="keyword">and</span> tail[<span class="number">1</span>]!=n<span class="number">-1</span>: <span class="comment"># vertical</span></span><br><span class="line">            r_tail, r_head = (tail[<span class="number">0</span>], tail[<span class="number">1</span>]+<span class="number">1</span>), (head[<span class="number">0</span>], head[<span class="number">1</span>]+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> g[r_tail[<span class="number">0</span>]][r_tail[<span class="number">1</span>]] == g[r_head[<span class="number">0</span>]][r_head[<span class="number">1</span>]] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> (tail, r_tail) <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                    q.append((tail, r_tail, step+<span class="number">1</span>))</span><br><span class="line">                    seen.add((tail, r_tail))</span><br><span class="line">        <span class="keyword">if</span> head[<span class="number">1</span>] != n<span class="number">-1</span>:</span><br><span class="line">            r_head = head[<span class="number">0</span>], head[<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">            r_tail = tail[<span class="number">0</span>], tail[<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> g[r_head[<span class="number">0</span>]][r_head[<span class="number">1</span>]] == g[r_tail[<span class="number">0</span>]][r_tail[<span class="number">1</span>]] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> (r_tail, r_head) <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                    q.append((r_tail, r_head, step+<span class="number">1</span>))                    </span><br><span class="line">                    seen.add((r_tail, r_head))</span><br><span class="line">        <span class="keyword">if</span> head[<span class="number">0</span>] != n<span class="number">-1</span>:</span><br><span class="line">            d_head = head[<span class="number">0</span>]+<span class="number">1</span>, head[<span class="number">1</span>]</span><br><span class="line">            d_tail = tail[<span class="number">0</span>]+<span class="number">1</span>, tail[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> g[d_head[<span class="number">0</span>]][d_head[<span class="number">1</span>]] == g[d_tail[<span class="number">0</span>]][d_tail[<span class="number">1</span>]] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> (d_tail, d_head) <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                    q.append((d_tail, d_head, step+<span class="number">1</span>))</span><br><span class="line">                    seen.add((d_tail, d_head))</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：另一种思路将蛇的横竖状态记录，这样一个点也能表示。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minimumMoves</span><span class="params">(self, g: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    n = len(g)</span><br><span class="line">    q, seen, target = [(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)], set(), (n<span class="number">-1</span>, n<span class="number">-2</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> r, c, dr, step <span class="keyword">in</span> q:</span><br><span class="line">        <span class="keyword">if</span> (r, c, dr) == target: <span class="keyword">return</span> step</span><br><span class="line">        <span class="keyword">if</span> (r, c, dr) <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">            seen.add((r, c, dr))</span><br><span class="line">            <span class="keyword">if</span> dr:</span><br><span class="line">                <span class="keyword">if</span> c+<span class="number">1</span>&lt;n <span class="keyword">and</span> g[r][c+<span class="number">1</span>]==g[r+<span class="number">1</span>][c+<span class="number">1</span>]==<span class="number">0</span>:</span><br><span class="line">                    q += [(r, c+<span class="number">1</span>, <span class="number">1</span>, step+<span class="number">1</span>), (r, c, <span class="number">0</span>, step+<span class="number">1</span>)]</span><br><span class="line">                <span class="keyword">if</span> r+<span class="number">2</span>&lt;n <span class="keyword">and</span> g[r+<span class="number">2</span>][c]==<span class="number">0</span>:</span><br><span class="line">                    q += [(r+<span class="number">1</span>, c, <span class="number">1</span>, step+<span class="number">1</span>)]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> r+<span class="number">1</span>&lt;n <span class="keyword">and</span> g[r+<span class="number">1</span>][c]==g[r+<span class="number">1</span>][c+<span class="number">1</span>]==<span class="number">0</span>:</span><br><span class="line">                    q += [(r+<span class="number">1</span>, c, <span class="number">0</span>, step+<span class="number">1</span>), (r, c, <span class="number">1</span>, step+<span class="number">1</span>)]</span><br><span class="line">                <span class="keyword">if</span> c+<span class="number">2</span>&lt;n <span class="keyword">and</span> g[r][c+<span class="number">2</span>]==<span class="number">0</span>:</span><br><span class="line">                    q += [(r, c+<span class="number">1</span>, <span class="number">0</span>, step+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="1202-Smallest-String-With-Swaps"><a href="#1202-Smallest-String-With-Swaps" class="headerlink" title="1202. Smallest String With Swaps"></a>1202. Smallest String With Swaps</h3><h4 id="给定一组pairs表明索引对可以互换，求这个字符串能换的最小值时多少，同一对可以进行多次互换。原题"><a href="#给定一组pairs表明索引对可以互换，求这个字符串能换的最小值时多少，同一对可以进行多次互换。原题" class="headerlink" title="给定一组pairs表明索引对可以互换，求这个字符串能换的最小值时多少，同一对可以进行多次互换。原题"></a>给定一组pairs表明索引对可以互换，求这个字符串能换的最小值时多少，同一对可以进行多次互换。<a href="https://leetcode.com/problems/smallest-string-with-swaps/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;dcab&quot;, pairs &#x3D; [[0,3],[1,2]]</span><br><span class="line">Output: &quot;bacd&quot;</span><br><span class="line">Explaination: </span><br><span class="line">Swap s[0] and s[3], s &#x3D; &quot;bcad&quot;</span><br><span class="line">Swap s[1] and s[2], s &#x3D; &quot;bacd&quot;</span><br></pre></td></tr></table></figure>
<p>方法一：看了几个例子想一想就明白了，实际上是一道连通器的题，将连通的索引单独排序就是最小的值。</p>
<p>竞赛时ac的方法用的是dfs. 内存用的有点多。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smallestStringWithSwaps</span><span class="params">(self, s: str, pairs: List[List[int]])</span> -&gt; str:</span></span><br><span class="line">    g = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(s))]</span><br><span class="line">    ans = [<span class="string">''</span>] * len(s)</span><br><span class="line">    <span class="keyword">for</span> a, b <span class="keyword">in</span> pairs:</span><br><span class="line">        g[a].append(b)</span><br><span class="line">        g[b].append(a)</span><br><span class="line">    </span><br><span class="line">    seen = [<span class="literal">False</span>] * len(s)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, p)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> seen[i]:</span><br><span class="line">            seen[i] = <span class="literal">True</span></span><br><span class="line">            p.append(i)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> g[i]:</span><br><span class="line">                dfs(j, p)</span><br><span class="line">            <span class="keyword">return</span> p</span><br><span class="line">    </span><br><span class="line">    groups = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        tmp = dfs(i, [])</span><br><span class="line">        <span class="keyword">if</span> tmp:</span><br><span class="line">            groups.append(tmp)</span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> groups:</span><br><span class="line">        letters = iter(sorted(s[i] <span class="keyword">for</span> i <span class="keyword">in</span> idx))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> sorted(idx):</span><br><span class="line">            ans[i] = next(letters)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(ans)</span><br></pre></td></tr></table></figure>
<p>方法二：做了一点优化。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smallestStringWithSwaps</span><span class="params">(self, s: str, pairs: List[List[int]])</span> -&gt; str:</span></span><br><span class="line">    g = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(s))]</span><br><span class="line">    ans = [<span class="string">''</span>] * len(s)</span><br><span class="line">    <span class="keyword">for</span> a, b <span class="keyword">in</span> pairs:</span><br><span class="line">        g[a].append(b)</span><br><span class="line">        g[b].append(a)</span><br><span class="line">    </span><br><span class="line">    seen = [<span class="literal">False</span>] * len(s)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i)</span>:</span></span><br><span class="line">        seen[i] = <span class="literal">True</span></span><br><span class="line">        p.append(i)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> g[i]:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> seen[j]:</span><br><span class="line">                dfs(j)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        p = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> seen[i]:</span><br><span class="line">            dfs(i)</span><br><span class="line">        letters = iter(sorted(s[i] <span class="keyword">for</span> i <span class="keyword">in</span> p))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> sorted(p):</span><br><span class="line">            ans[i] = next(letters)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(ans)</span><br></pre></td></tr></table></figure>
<p>方法三：union-find。这个评论区里看到的方法写得很标准。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smallestStringWithSwaps</span><span class="params">(self, s: str, pairs: List[List[int]])</span> -&gt; str:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UF</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">            self.p = list(range(n))</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">            self.p[self.find(x)] = self.find(y)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> x!=self.p[x]:</span><br><span class="line">                self.p[x] = self.find(self.p[x])</span><br><span class="line">            <span class="keyword">return</span> self.p[x]</span><br><span class="line">    uf, res, m = UF(len(s)), [], defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> pairs:</span><br><span class="line">        uf.union(x, y)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        m[uf.find(i)].append(s[i])</span><br><span class="line">    <span class="keyword">for</span> comp_id <span class="keyword">in</span> m.keys(): </span><br><span class="line">        m[comp_id].sort(reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)): </span><br><span class="line">        res.append(m[uf.find(i)].pop())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(res)</span><br></pre></td></tr></table></figure>
<h3 id="787-Cheapest-Flights-Within-K-Stops"><a href="#787-Cheapest-Flights-Within-K-Stops" class="headerlink" title="787. Cheapest Flights Within K Stops"></a>787. Cheapest Flights Within K Stops</h3><h4 id="经过K个站点的最便宜的航班。原题"><a href="#经过K个站点的最便宜的航班。原题" class="headerlink" title="经过K个站点的最便宜的航班。原题"></a>经过K个站点的最便宜的航班。<a href="https://leetcode.com/problems/cheapest-flights-within-k-stops/" target="_blank" rel="noopener">原题</a></h4><p>方法一：狄克斯特拉算法，只不过多了一个条件，经过K个站点。不需要用seen记录已经去过的点，因为该点可能有更少步数的到达方式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findCheapestPrice</span><span class="params">(self, n: int, flights: List[List[int]], src: int, dst: int, K: int)</span> -&gt; int:</span></span><br><span class="line">    g = collections.defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> u, v, w <span class="keyword">in</span> flights:</span><br><span class="line">        g[u].append((v, w))</span><br><span class="line">    </span><br><span class="line">    q = [(<span class="number">0</span>, src, <span class="number">0</span>)]</span><br><span class="line">    heapq.heapify(q)</span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        p, city, step = heapq.heappop(q)</span><br><span class="line">        <span class="keyword">if</span> city == dst:</span><br><span class="line">            <span class="keyword">return</span> p</span><br><span class="line">        <span class="keyword">for</span> v, w <span class="keyword">in</span> g[city]:</span><br><span class="line">            <span class="keyword">if</span> step &lt; K+<span class="number">1</span>:</span><br><span class="line">                heapq.heappush(q, (p+w, v, step+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="332-Reconstruct-Itinerary"><a href="#332-Reconstruct-Itinerary" class="headerlink" title="332. Reconstruct Itinerary"></a>332. Reconstruct Itinerary</h3><h4 id="重建行程，根据火车票来寻找行程，答案不唯一。原题"><a href="#重建行程，根据火车票来寻找行程，答案不唯一。原题" class="headerlink" title="重建行程，根据火车票来寻找行程，答案不唯一。原题"></a>重建行程，根据火车票来寻找行程，答案不唯一。<a href="https://leetcode.com/problems/reconstruct-itinerary/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[&quot;MUC&quot;, &quot;LHR&quot;], [&quot;JFK&quot;, &quot;MUC&quot;], [&quot;SFO&quot;, &quot;SJC&quot;], [&quot;LHR&quot;, &quot;SFO&quot;]]</span><br><span class="line">Output: [&quot;JFK&quot;, &quot;MUC&quot;, &quot;LHR&quot;, &quot;SFO&quot;, &quot;SJC&quot;]</span><br></pre></td></tr></table></figure>
<p>方法一：首次ac的方法，直接修改g。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findItinerary</span><span class="params">(self, tickets: List[List[str]])</span> -&gt; List[str]:</span></span><br><span class="line">    g = collections.defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> u, v <span class="keyword">in</span> tickets:</span><br><span class="line">        g[u].append(v)</span><br><span class="line">    <span class="keyword">for</span> u <span class="keyword">in</span> g.keys():</span><br><span class="line">        g[u].sort()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(city, p)</span>:</span>  </span><br><span class="line">        <span class="comment"># print(city, p, g)</span></span><br><span class="line">        p.append(city)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> g:</span><br><span class="line">            <span class="keyword">return</span> p</span><br><span class="line">        org = g[city]</span><br><span class="line">        <span class="keyword">for</span> i, nxt <span class="keyword">in</span> enumerate(g[city]):</span><br><span class="line">            g[city] = g[city][:i] + g[city][i+<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> g[city]:</span><br><span class="line">                <span class="keyword">del</span> g[city]</span><br><span class="line">            <span class="keyword">if</span> dfs(nxt, p):</span><br><span class="line">                <span class="keyword">return</span> p</span><br><span class="line">            g[city] = org</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> org:</span><br><span class="line">            <span class="keyword">del</span> g[city]</span><br><span class="line">        p.pop()</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="string">'JFK'</span>, [])</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：用两个倒序可以解决</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findItinerary</span><span class="params">(self, tickets: List[List[str]])</span> -&gt; List[str]:</span></span><br><span class="line">    g = collections.defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> u, v <span class="keyword">in</span> sorted(tickets, reverse=<span class="literal">True</span>):</span><br><span class="line">        g[u].append(v)</span><br><span class="line">        </span><br><span class="line">    ans = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(city)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> g[city]:</span><br><span class="line">            dfs(g[city].pop())</span><br><span class="line">        ans.append(city)</span><br><span class="line">        </span><br><span class="line">    dfs(<span class="string">'JFK'</span>)</span><br><span class="line">    <span class="keyword">return</span> ans[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="1519-Number-of-Nodes-in-the-Sub-Tree-With-the-Same-Label"><a href="#1519-Number-of-Nodes-in-the-Sub-Tree-With-the-Same-Label" class="headerlink" title="1519. Number of Nodes in the Sub-Tree With the Same Label"></a>1519. Number of Nodes in the Sub-Tree With the Same Label</h3><h4 id="有一个数的图，每个节点有个字母，返回每个节点的子树中包含这个字母的总个数。原题"><a href="#有一个数的图，每个节点有个字母，返回每个节点的子树中包含这个字母的总个数。原题" class="headerlink" title="有一个数的图，每个节点有个字母，返回每个节点的子树中包含这个字母的总个数。原题"></a>有一个数的图，每个节点有个字母，返回每个节点的子树中包含这个字母的总个数。<a href="https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/" target="_blank" rel="noopener">原题</a></h4><p>方法一：这个题作为竞赛的第二题是在是太恶心了，结束后我想了很长时间才想出来。dfs + counter, 每个节点都有它独立的一个counter。 因为字母不同、</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countSubTrees</span><span class="params">(self, n: int, edges: List[List[int]], labels: str)</span> -&gt; List[int]:</span></span><br><span class="line">    g = collections.defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> u, v <span class="keyword">in</span> edges:</span><br><span class="line">        g[u].append(v)</span><br><span class="line">        g[v].append(u)</span><br><span class="line"></span><br><span class="line">    seen = [<span class="literal">False</span>] * n</span><br><span class="line">    c = Counter()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node)</span>:</span></span><br><span class="line">        cur = Counter()</span><br><span class="line">        seen[node] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> nxt <span class="keyword">in</span> g[node]:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> seen[nxt]:</span><br><span class="line">                cur += dfs(nxt)</span><br><span class="line">        label = labels[node]</span><br><span class="line">        cur[label] += <span class="number">1</span></span><br><span class="line">        ans[node] = cur[label]</span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line">        </span><br><span class="line">    ans = [<span class="number">0</span>] * n</span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：优化方法一</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countSubTrees</span><span class="params">(self, n: int, edges: List[List[int]], labels: str)</span> -&gt; List[int]:</span></span><br><span class="line">    g = collections.defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> u, v <span class="keyword">in</span> edges:</span><br><span class="line">        g[u].append(v)</span><br><span class="line">        g[v].append(u)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node, p)</span>:</span></span><br><span class="line">        cur = Counter(labels[node])</span><br><span class="line">        <span class="keyword">for</span> nxt <span class="keyword">in</span> g[node]:</span><br><span class="line">            <span class="keyword">if</span> nxt != p:</span><br><span class="line">                cur += dfs(nxt, node)</span><br><span class="line">        ans[node] = cur[labels[node]]</span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line">        </span><br><span class="line">    ans = [<span class="number">0</span>] * n</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="478-Generate-Random-Point-in-a-Circle"><a href="#478-Generate-Random-Point-in-a-Circle" class="headerlink" title="478. Generate Random Point in a Circle"></a>478. Generate Random Point in a Circle</h3><h4 id="在给定圆的范围内随机生成点。原题"><a href="#在给定圆的范围内随机生成点。原题" class="headerlink" title="在给定圆的范围内随机生成点。原题"></a>在给定圆的范围内随机生成点。<a href="https://leetcode.com/problems/generate-random-point-in-a-circle/" target="_blank" rel="noopener">原题</a></h4><p>方法一：严格来说 这是一道几何题，为什么要将其开方，因为如果没有开方，对于一个圆来说，半径越小的地方点就越密集，因为在该周长上所有的点分布是一样的。开方可以让半径小的点降低分布。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, radius: float, x_center: float, y_center: float)</span>:</span></span><br><span class="line">        self.r = radius</span><br><span class="line">        self.x = x_center</span><br><span class="line">        self.y = y_center</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">randPoint</span><span class="params">(self)</span> -&gt; List[float]:</span></span><br><span class="line">        <span class="keyword">import</span> random</span><br><span class="line">        edge = math.sqrt(random.random()) * self.r</span><br><span class="line">        deg = random.random()*<span class="number">2</span>*math.pi</span><br><span class="line">        x = self.x + edge*math.cos(deg)</span><br><span class="line">        y = self.y + edge*math.sin(deg)</span><br><span class="line">        <span class="keyword">return</span> x, y</span><br></pre></td></tr></table></figure>
<h3 id="1559-Detect-Cycles-in-2D-Grid"><a href="#1559-Detect-Cycles-in-2D-Grid" class="headerlink" title="1559. Detect Cycles in 2D Grid"></a>1559. Detect Cycles in 2D Grid</h3><h4 id="2D-矩阵中判断是否有环。原题"><a href="#2D-矩阵中判断是否有环。原题" class="headerlink" title="2D 矩阵中判断是否有环。原题"></a>2D 矩阵中判断是否有环。<a href="https://leetcode.com/problems/detect-cycles-in-2d-grid/" target="_blank" rel="noopener">原题</a></h4><p>方法一：这个题就差一点没想出来，就是怎么避免重复的路径，那就是需要和前一个点比对。看了这个提示后瞬间就完成了。时间空间待优化。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">containsCycle</span><span class="params">(self, g: List[List[str]])</span> -&gt; bool:</span></span><br><span class="line">    m, n = len(g), len(g[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    visited = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spread</span><span class="params">(x, y, c, a, b)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> visited[x][y]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        visited[x][y] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> ((x<span class="number">-1</span>, y), (x+<span class="number">1</span>, y), (x, y<span class="number">-1</span>), (x, y+<span class="number">1</span>)):</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span>&lt;=i&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=j&lt;n <span class="keyword">and</span> c==g[i][j] <span class="keyword">and</span> (i, j)!=(a, b):</span><br><span class="line">                <span class="keyword">if</span> spread(i, j, c, x, y):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> visited[i][j] <span class="keyword">and</span> spread(i, j, g[i][j], i, j):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="310-Minimum-Height-Trees"><a href="#310-Minimum-Height-Trees" class="headerlink" title="310. Minimum Height Trees"></a>310. Minimum Height Trees</h3><h4 id="有一个无向图，0-n-1这些节点，每两个节点只有一条边，找出这种节点，当以节点为根时，组成的树有最小的高度。原题"><a href="#有一个无向图，0-n-1这些节点，每两个节点只有一条边，找出这种节点，当以节点为根时，组成的树有最小的高度。原题" class="headerlink" title="有一个无向图，0~n-1这些节点，每两个节点只有一条边，找出这种节点，当以节点为根时，组成的树有最小的高度。原题"></a>有一个无向图，0~n-1这些节点，每两个节点只有一条边，找出这种节点，当以节点为根时，组成的树有最小的高度。<a href="https://leetcode.com/problems/minimum-height-trees/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 6, edges &#x3D; [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]</span><br><span class="line"></span><br><span class="line">     0  1  2</span><br><span class="line">      \ | &#x2F;</span><br><span class="line">        3</span><br><span class="line">        |</span><br><span class="line">        4</span><br><span class="line">        |</span><br><span class="line">        5 </span><br><span class="line"></span><br><span class="line">Output: [3, 4]</span><br></pre></td></tr></table></figure>
<p>方法一：这个解法很棒，评论区的解法，以前看这种题的时候，想到的是bfs，这个解法的核心思想是剪枝。每次将叶子节点剪去。最后剩下的 一个或者2个节点 就是最小高度的根节点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMinHeightTrees</span><span class="params">(self, n: int, edges: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> [<span class="number">0</span>]</span><br><span class="line">    g = collections.defaultdict(set)</span><br><span class="line">    <span class="keyword">for</span> u, v <span class="keyword">in</span> edges:</span><br><span class="line">        g[u].add(v)</span><br><span class="line">        g[v].add(u)</span><br><span class="line">        </span><br><span class="line">    leaves = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(n) <span class="keyword">if</span> len(g[i])==<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">2</span>:</span><br><span class="line">        n -= len(leaves)</span><br><span class="line">        new_leaves = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> leaves:</span><br><span class="line">            j = g[i].pop()</span><br><span class="line">            g[j].remove(i)</span><br><span class="line">            <span class="keyword">if</span> len(g[j])==<span class="number">1</span>: new_leaves.append(j)</span><br><span class="line">        leaves = new_leaves</span><br><span class="line">    <span class="keyword">return</span> leaves</span><br></pre></td></tr></table></figure>
<h3 id="127-Word-Ladder"><a href="#127-Word-Ladder" class="headerlink" title="127. Word Ladder"></a>127. Word Ladder</h3><h4 id="每次可以改变单词中的一个字母，但必须在wordList中，问最少需要多少次能达到目标单词。原题"><a href="#每次可以改变单词中的一个字母，但必须在wordList中，问最少需要多少次能达到目标单词。原题" class="headerlink" title="每次可以改变单词中的一个字母，但必须在wordList中，问最少需要多少次能达到目标单词。原题"></a>每次可以改变单词中的一个字母，但必须在wordList中，问最少需要多少次能达到目标单词。<a href="https://leetcode.com/problems/word-ladder/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord &#x3D; &quot;hit&quot;,</span><br><span class="line">endWord &#x3D; &quot;cog&quot;,</span><br><span class="line">wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">Output: 5</span><br><span class="line"></span><br><span class="line">Explanation: As one shortest transformation is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,</span><br><span class="line">return its length 5.</span><br></pre></td></tr></table></figure>
<p>方法一：BFS很好想，但是要想如何去重，wordList可能非常大，所以不能遍历，因为只有26个字母可以变，所以可以变换完比较。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ladderLength</span><span class="params">(self, beginWord: str, endWord: str, wordList: List[str])</span> -&gt; int:</span></span><br><span class="line">    q = [(beginWord, <span class="number">1</span>)]</span><br><span class="line">    words_set = set(wordList)</span><br><span class="line">    letters = string.ascii_lowercase</span><br><span class="line">    <span class="keyword">for</span> w, step <span class="keyword">in</span> q:</span><br><span class="line">        <span class="keyword">if</span> w == endWord: <span class="keyword">return</span> step</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(w)):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> letters:</span><br><span class="line">                nw = w[:i] + c + w[i+<span class="number">1</span>:]</span><br><span class="line">                <span class="keyword">if</span> nw <span class="keyword">in</span> words_set:</span><br><span class="line">                    q.append((nw, step+<span class="number">1</span>))</span><br><span class="line">                    words_set.remove(nw)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="547-Friend-Circles"><a href="#547-Friend-Circles" class="headerlink" title="547. Friend Circles"></a>547. Friend Circles</h3><h4 id="朋友圈，一堆人拉帮结伙，朋友关系可以传递。通过二维数组表示i-j两个人是否是朋友。问N个人有多少个帮派。原题"><a href="#朋友圈，一堆人拉帮结伙，朋友关系可以传递。通过二维数组表示i-j两个人是否是朋友。问N个人有多少个帮派。原题" class="headerlink" title="朋友圈，一堆人拉帮结伙，朋友关系可以传递。通过二维数组表示i, j两个人是否是朋友。问N个人有多少个帮派。原题"></a>朋友圈，一堆人拉帮结伙，朋友关系可以传递。通过二维数组表示i, j两个人是否是朋友。问N个人有多少个帮派。<a href="https://leetcode.com/problems/friend-circles/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[[1,1,0],</span><br><span class="line"> [1,1,0],</span><br><span class="line"> [0,0,1]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:The 0th and 1st students are direct friends, so they are in a friend circle. </span><br><span class="line">The 2nd student himself is in a friend circle. So return 2.</span><br></pre></td></tr></table></figure>
<p>方法一：典型的Union-Find。最后结果还要遍历一下，才是最终结果。<code>[[1,0,0,1],[0,1,1,0],[0,1,1,1],[1,0,1,1]]</code>这个case在union之后，是<code>[3,2,3,3]</code>因为2的朋友在1计算之后变成了3。最终点更新了。所以遍历之后是<code>[3,3,3,3]</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findCircleNum</span><span class="params">(self, M: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(x, y)</span>:</span></span><br><span class="line">        uf[find(x)] = find(y)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x != uf[x]:</span><br><span class="line">            uf[x] = find(uf[x])</span><br><span class="line">        <span class="keyword">return</span> uf[x] </span><br><span class="line">    </span><br><span class="line">    N = len(M)</span><br><span class="line">    uf = list(range(N))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">if</span> M[i][j]:</span><br><span class="line">                union(i, j)</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">return</span> len(&#123;find(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(N)&#125;)</span><br></pre></td></tr></table></figure>
<p>方法二：评论中有个dfs 也不错，行列循环分开了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findCircleNum</span><span class="params">(self, M: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    ans, N = <span class="number">0</span>, len(M)</span><br><span class="line">    seen = set()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> j, r <span class="keyword">in</span> enumerate(M[i]):</span><br><span class="line">            <span class="keyword">if</span> r <span class="keyword">and</span> j <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                seen.add(j)</span><br><span class="line">                dfs(j)</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">            dfs(i)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>方法三：stefan的科学库和numpy写法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scipy.sparse</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findCircleNum</span><span class="params">(self, M)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> scipy.sparse.csgraph.connected_components(M)[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findCircleNum</span><span class="params">(self, M)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(set(map(tuple, (np.matrix(M, dtype=<span class="string">'bool'</span>)**len(M)).A)))</span><br></pre></td></tr></table></figure>
<h3 id="1584-Min-Cost-to-Connect-All-Points"><a href="#1584-Min-Cost-to-Connect-All-Points" class="headerlink" title="1584. Min Cost to Connect All Points"></a>1584. Min Cost to Connect All Points</h3><h4 id="所有点最小的曼哈顿距离-xi-xj-yi-yj-和为多少。原题"><a href="#所有点最小的曼哈顿距离-xi-xj-yi-yj-和为多少。原题" class="headerlink" title="所有点最小的曼哈顿距离|xi - xj| + |yi - yj|和为多少。原题"></a>所有点最小的曼哈顿距离|xi - xj| + |yi - yj|和为多少。<a href="https://leetcode.com/problems/min-cost-to-connect-all-points/" target="_blank" rel="noopener">原题</a></h4><p>方法一：贪心法。这题有很多方法，然而比赛时一种也没写出来。首先贪心可以，由于是n^2的复杂度，所以没有敢写。</p>
<p>毕竟n=1000。评论区的做法，为什么贪心可行，想象一下，最后所有的点相连，每2点只有一条边，而且是最小的边。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minCostConnectPoints</span><span class="params">(self, points: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    n, ans = len(points), <span class="number">0</span></span><br><span class="line">    seen = set()</span><br><span class="line">    dis = [float(<span class="string">'inf'</span>)] * n</span><br><span class="line">    cur = <span class="number">0</span></span><br><span class="line">    <span class="comment"># n-1 edges</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">        x, y = points[cur]</span><br><span class="line">        seen.add(cur)</span><br><span class="line">        <span class="keyword">for</span> j, (nx, ny) <span class="keyword">in</span> enumerate(points):</span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">in</span> seen: <span class="keyword">continue</span></span><br><span class="line">            dis[j] = min(dis[j], abs(nx-x)+abs(ny-y))</span><br><span class="line">        s, cur = min((d, j) <span class="keyword">for</span> j, d <span class="keyword">in</span> enumerate(dis))</span><br><span class="line">        dis[cur] = float(<span class="string">'inf'</span>)</span><br><span class="line">        ans += s</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>方法二：最小生成树。这是经典的最小生成树问题，有两种实现的方式，一种是Prim算法。一种是Kruskal算法。比贪心法慢了400ms，花费1580ms，还以为是我实现的问题，结果看评论区中的要2s多。空间则是贪心的5倍多。因为此题需要找到各个边的权重，所以即使是Prim算法，时间复杂度也是O(n^2)。Prim算法是每次以新的顶点找到最小的权重边。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minCostConnectPoints</span><span class="params">(self, p: List[List[int]])</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">manhattan</span><span class="params">(x, y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> abs(x[<span class="number">0</span>]-y[<span class="number">0</span>]) + abs(x[<span class="number">1</span>]-y[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    ans, n = <span class="number">0</span>, len(p)</span><br><span class="line">    seen = set()</span><br><span class="line">    vertices = [(<span class="number">0</span>, (<span class="number">0</span>, <span class="number">0</span>))]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> len(seen) &lt; n:</span><br><span class="line">        <span class="comment"># print(vertices, seen)</span></span><br><span class="line">        w, (u, v) = heapq.heappop(vertices)            </span><br><span class="line">        <span class="keyword">if</span> v <span class="keyword">in</span> seen: <span class="keyword">continue</span></span><br><span class="line">        ans += w</span><br><span class="line">        seen.add(v)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> seen <span class="keyword">and</span> j!=v:</span><br><span class="line">                heapq.heappush(vertices, (manhattan(p[j], p[v]), (v, j)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>方法三：Kruskal，克鲁斯卡尔算法。原理是Union-Find。按照所有的权重看，每次产生一条边，但不一定和已有的边构成环。理论上来说比Prim算法要慢。实际运行却比prim快了1、200ms。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minCostConnectPoints</span><span class="params">(self, p: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    edges, n, cnt, ans = [], len(p), <span class="number">1</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">manhattan</span><span class="params">(x, y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> abs(p[x][<span class="number">0</span>]-p[y][<span class="number">0</span>]) + abs(p[x][<span class="number">1</span>]-p[y][<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    edges = [(manhattan(i, j), (i, j)) </span><br><span class="line">             <span class="keyword">for</span> i <span class="keyword">in</span> range(n) <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, n)]</span><br><span class="line">    heapq.heapify(edges)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(x, y)</span>:</span></span><br><span class="line">        uf[find(x)] = find(y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x != uf[x]:</span><br><span class="line">            uf[x] = find(uf[x])</span><br><span class="line">        <span class="keyword">return</span> uf[x]</span><br><span class="line"></span><br><span class="line">    uf = list(range(n))</span><br><span class="line">    <span class="keyword">while</span> cnt &lt; n:</span><br><span class="line">        d, (u, v) = heapq.heappop(edges)</span><br><span class="line">        <span class="keyword">if</span> find(u) != find(v):</span><br><span class="line">            ans += d</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            union(u, v)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="684-Redundant-Connection"><a href="#684-Redundant-Connection" class="headerlink" title="684. Redundant Connection"></a>684. Redundant Connection</h3><h4 id="多余的边，有一个无向图有N个节点，和N个边，对于一个连通器来说，刚好多了一条边。找到这条多余的边，所有的边给的-u-v-均满足u-lt-v。原题"><a href="#多余的边，有一个无向图有N个节点，和N个边，对于一个连通器来说，刚好多了一条边。找到这条多余的边，所有的边给的-u-v-均满足u-lt-v。原题" class="headerlink" title="多余的边，有一个无向图有N个节点，和N个边，对于一个连通器来说，刚好多了一条边。找到这条多余的边，所有的边给的[u, v]均满足u&lt;v。原题"></a>多余的边，有一个无向图有N个节点，和N个边，对于一个连通器来说，刚好多了一条边。找到这条多余的边，所有的边给的[u, v]均满足u&lt;v。<a href="https://leetcode.com/problems/redundant-connection/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2], [1,3], [2,3]]</span><br><span class="line">Output: [2,3]</span><br><span class="line">Explanation: The given undirected graph will be like this:</span><br><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2 - 3</span><br></pre></td></tr></table></figure>
<p>方法一：使用传统的Union-Find。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findRedundantConnection</span><span class="params">(self, edges: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(x, y)</span>:</span></span><br><span class="line">        uf[find(x)] = find(y)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x != uf[x]:</span><br><span class="line">            uf[x] = find(uf[x])</span><br><span class="line">        <span class="keyword">return</span> uf[x]</span><br><span class="line">    </span><br><span class="line">    n = len(edges)</span><br><span class="line">    uf = list(range(n+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> u, v <span class="keyword">in</span> edges:</span><br><span class="line">        <span class="keyword">if</span> find(u)==find(v):</span><br><span class="line">            <span class="keyword">return</span> u, v</span><br><span class="line">        union(u, v)</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：stefan. 考虑没用上的条件 <code>u&lt;v</code>。 可以利用字符串的replace。将所有出现的点，替换成最大的。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findRedundantConnection</span><span class="params">(self, edges: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">    tree = <span class="string">''</span>.join(map(chr, range(<span class="number">1001</span>)))</span><br><span class="line">    <span class="keyword">for</span> u, v <span class="keyword">in</span> edges:</span><br><span class="line">        <span class="keyword">if</span> tree[u] == tree[v]:</span><br><span class="line">            <span class="keyword">return</span> u, v</span><br><span class="line">        tree = tree.replace(tree[u], tree[v])</span><br></pre></td></tr></table></figure>
<h3 id="685-Redundant-Connection-II"><a href="#685-Redundant-Connection-II" class="headerlink" title="685. Redundant Connection II"></a><a href="https://leetcode.com/problems/redundant-connection-ii/" target="_blank" rel="noopener">685. Redundant Connection II</a></h3><h4 id="同684一样，区别在于有向图，也是多出一条边，但这条边是最后一条无用的边。也就是说。删除这条边后，还是一个N个节点的有向图。并且图中只能有一个根节点。"><a href="#同684一样，区别在于有向图，也是多出一条边，但这条边是最后一条无用的边。也就是说。删除这条边后，还是一个N个节点的有向图。并且图中只能有一个根节点。" class="headerlink" title="同684一样，区别在于有向图，也是多出一条边，但这条边是最后一条无用的边。也就是说。删除这条边后，还是一个N个节点的有向图。并且图中只能有一个根节点。"></a>同684一样，区别在于有向图，也是多出一条边，但这条边是最后一条无用的边。也就是说。删除这条边后，还是一个N个节点的有向图。并且图中只能有一个根节点。</h4><p>方法一：花了不到2小时做出来，感觉方法很笨。因为有这样的例子，<code>[[2,1],[3,1],[4,2],[1,4]]</code>这时不能删除<code>[1,4]</code>，而是要删除<code>[2,1]</code>因为4和3会成为2个根节点。如果我们找到了一个点有两个父节点，那么删除的一定是这两条边中的一条。所以此时我没有将其加入到联通图中；另一种情况，没有两个父节点的点时，就像684一样判断是否联通就好了，最后判断，如果所有节点都联通了，我删除第2次遇见的相同父节点的边就行了，如果没有，那么应该删除第一次的边，这里用了一个pare来记录关系。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findRedundantDirectedConnection</span><span class="params">(self, edges: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(x, y)</span>:</span></span><br><span class="line">        uf[find(x)] = find(y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x != uf[x]:</span><br><span class="line">            uf[x] = find(uf[x])</span><br><span class="line">        <span class="keyword">return</span> uf[x]</span><br><span class="line">      </span><br><span class="line">    ans, N, pare = <span class="literal">None</span>, len(edges), &#123;&#125;</span><br><span class="line">    uf = list(range(N+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> u, v <span class="keyword">in</span> edges:</span><br><span class="line">        <span class="keyword">if</span> v <span class="keyword">in</span> pare:</span><br><span class="line">            ans = (u, v)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> find(u)==find(v) <span class="keyword">and</span> <span class="keyword">not</span> ans:</span><br><span class="line">            ans = (u, v)</span><br><span class="line">        union(u, v)</span><br><span class="line">        pare[v] = u</span><br><span class="line">    <span class="keyword">return</span> ans <span class="keyword">if</span> len(set(map(find, range(<span class="number">1</span>, N+<span class="number">1</span>))))==<span class="number">1</span> <span class="keyword">else</span> (pare[ans[<span class="number">1</span>]], ans[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<h3 id="743-Network-Delay-Time"><a href="#743-Network-Delay-Time" class="headerlink" title="743. Network Delay Time"></a>743. Network Delay Time</h3><h4 id="网络延迟，有N个网络节点，给出一个加权有向图，问从K点出发，遍历所有点需要多少时间，如果不可能返回-1。原题"><a href="#网络延迟，有N个网络节点，给出一个加权有向图，问从K点出发，遍历所有点需要多少时间，如果不可能返回-1。原题" class="headerlink" title="网络延迟，有N个网络节点，给出一个加权有向图，问从K点出发，遍历所有点需要多少时间，如果不可能返回-1。原题"></a>网络延迟，有N个网络节点，给出一个加权有向图，问从K点出发，遍历所有点需要多少时间，如果不可能返回-1。<a href="https://leetcode.com/problems/network-delay-time/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: times &#x3D; [[2,1,1],[2,3,1],[3,4,1]], N &#x3D; 4, K &#x3D; 2</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<p>方法一：bfs。首次AC，960ms。效率不算很高吧，因为可能遍历到重复的节点更新值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">networkDelayTime</span><span class="params">(self, times, N, K)</span>:</span></span><br><span class="line">    seen, ans = &#123;&#125;, <span class="number">0</span></span><br><span class="line">    g = collections.defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> u, v , w <span class="keyword">in</span> times:</span><br><span class="line">        g[u].append((v, w))</span><br><span class="line">    q = collections.deque([(K, <span class="number">0</span>)])</span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        u, t = q.popleft()</span><br><span class="line">        seen[u] = min(seen.get(u, float(<span class="string">'inf'</span>)), t)</span><br><span class="line">        <span class="keyword">for</span> v, nt <span class="keyword">in</span> g[u]:</span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> seen <span class="keyword">or</span> seen[v]&gt;nt+t:</span><br><span class="line">                q.append((v, t+nt))</span><br><span class="line">    <span class="keyword">return</span> max(seen.values()) <span class="keyword">if</span> len(seen)==N <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：堆实现了一个优先级队列，500ms左右。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">networkDelayTime</span><span class="params">(self, times, N, K)</span>:</span></span><br><span class="line">    seen, t = set(), <span class="number">0</span></span><br><span class="line">    g = collections.defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> u, v , w <span class="keyword">in</span> times:</span><br><span class="line">        g[u].append((v, w))</span><br><span class="line">    heap = [(<span class="number">0</span>, K)]</span><br><span class="line">    <span class="keyword">while</span> heap:</span><br><span class="line">        t, u = heapq.heappop(heap)</span><br><span class="line">        <span class="keyword">if</span> u <span class="keyword">in</span> seen: <span class="keyword">continue</span></span><br><span class="line">        seen.add(u)</span><br><span class="line">        <span class="keyword">if</span> len(seen) == N: <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> v, nt <span class="keyword">in</span> g[u]:</span><br><span class="line">            heapq.heappush(heap, (t+nt, v))</span><br><span class="line">    <span class="keyword">return</span> t <span class="keyword">if</span> len(seen)==N <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="721-Accounts-Merge"><a href="#721-Accounts-Merge" class="headerlink" title="721. Accounts Merge"></a><a href="https://leetcode.com/problems/accounts-merge/" target="_blank" rel="noopener">721. Accounts Merge</a></h3><h4 id="账号合并，一个人可能有多个账号，将具有相同账号的人合并到一起，返回所有的用户的所有的账号"><a href="#账号合并，一个人可能有多个账号，将具有相同账号的人合并到一起，返回所有的用户的所有的账号" class="headerlink" title="账号合并，一个人可能有多个账号，将具有相同账号的人合并到一起，返回所有的用户的所有的账号"></a>账号合并，一个人可能有多个账号，将具有相同账号的人合并到一起，返回所有的用户的所有的账号</h4><p>方法一：做的时候想到了union-find，不过以开始的思路用集合暴力也解出来了。只要有一个账号相同，就是一个人。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accountsMerge</span><span class="params">(self, accounts: List[List[str]])</span> -&gt; List[List[str]]:</span></span><br><span class="line">    users = collections.defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> name, *mails <span class="keyword">in</span> accounts:</span><br><span class="line">        old_mails = users[name]</span><br><span class="line">        mails = set(mails)</span><br><span class="line">        to_rm = []</span><br><span class="line">        n = len(old_mails)</span><br><span class="line">        j = n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> old_mails[j] &amp; mails:</span><br><span class="line">                mails |= old_mails[j]</span><br><span class="line">                old_mails.pop(j)</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        old_mails.append(mails)</span><br><span class="line">    <span class="keyword">return</span> [[name] + sorted(act_lst) </span><br><span class="line">            <span class="keyword">for</span> name, acts <span class="keyword">in</span> users.items() <span class="keyword">for</span> act_lst <span class="keyword">in</span> acts]</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：dfs，需要遍历两次。先记录一下每个邮箱出现的索引，</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accountsMerge</span><span class="params">(self, accounts: List[List[str]])</span> -&gt; List[List[str]]:</span></span><br><span class="line">    mail_occurs = collections.defaultdict(list)</span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> i, (_, *mails) <span class="keyword">in</span> enumerate(accounts):</span><br><span class="line">        <span class="keyword">for</span> mail <span class="keyword">in</span> mails:</span><br><span class="line">            mail_occurs[mail].append(i)</span><br><span class="line">    visited = [<span class="literal">False</span>] * len(accounts)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, mails)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> visited[i]: <span class="keyword">return</span>             </span><br><span class="line">        visited[i] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> other <span class="keyword">in</span> accounts[i][<span class="number">1</span>:]:</span><br><span class="line">            mails.add(other)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> mail_occurs[other]:</span><br><span class="line">                dfs(j, mails)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i, (name, *mails) <span class="keyword">in</span> enumerate(accounts):</span><br><span class="line">        <span class="keyword">if</span> visited[i]: <span class="keyword">continue</span></span><br><span class="line">        acts = set()</span><br><span class="line">        dfs(i, acts)</span><br><span class="line">        ans.append([name] + sorted(acts))</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法三：Union-FInd，这里要选出一个标准，不如每个首个出现的账号，将其它账号连到这个账号上。第二步需要遍历一遍，把相同的账号放到一个列表中，遍历过程中记录账号对应的姓名，方便我们构建最终的答案。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accountsMerge</span><span class="params">(self, accounts: List[List[str]])</span> -&gt; List[List[str]]:</span></span><br><span class="line">    uf = &#123;&#125;</span><br><span class="line">    mail_to_name = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(x, y)</span>:</span></span><br><span class="line">        uf.setdefault(x, x)</span><br><span class="line">        uf.setdefault(y, y)</span><br><span class="line">        uf[find(x)] = find(y)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x != uf[x]:</span><br><span class="line">            uf[x] = find(uf[x])</span><br><span class="line">        <span class="keyword">return</span> uf[x]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> name, *mails <span class="keyword">in</span> accounts:</span><br><span class="line">        first = mails[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> mail <span class="keyword">in</span> mails:</span><br><span class="line">            union(mail, first)</span><br><span class="line">            mail_to_name[mail] = name</span><br><span class="line">        </span><br><span class="line">    g = collections.defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> mail <span class="keyword">in</span> uf.keys():</span><br><span class="line">        g[find(mail)].append(mail)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> [[mail_to_name[first]] + sorted(mails) <span class="keyword">for</span> first, mails <span class="keyword">in</span> g.items()]</span><br></pre></td></tr></table></figure>
<h4 id="面试题-17-07-婴儿名字"><a href="#面试题-17-07-婴儿名字" class="headerlink" title="面试题 17.07. 婴儿名字"></a><a href="https://leetcode-cn.com/problems/baby-names-lcci/" target="_blank" rel="noopener">面试题 17.07. 婴儿名字</a></h4><h4 id="找到相同名字的数量，和721一样，也是合并婴儿。names中可能包含synonyms中没有的，synonyms中也可能包含names没有的。"><a href="#找到相同名字的数量，和721一样，也是合并婴儿。names中可能包含synonyms中没有的，synonyms中也可能包含names没有的。" class="headerlink" title="找到相同名字的数量，和721一样，也是合并婴儿。names中可能包含synonyms中没有的，synonyms中也可能包含names没有的。"></a>找到相同名字的数量，和721一样，也是合并婴儿。names中可能包含synonyms中没有的，synonyms中也可能包含names没有的。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：names &#x3D; [&quot;John(15)&quot;,&quot;Jon(12)&quot;,&quot;Chris(13)&quot;,&quot;Kris(4)&quot;,&quot;Christopher(19)&quot;], synonyms &#x3D; [&quot;(Jon,John)&quot;,&quot;(John,Johnny)&quot;,&quot;(Chris,Kris)&quot;,&quot;(Chris,Christopher)&quot;]</span><br><span class="line">输出：[&quot;John(27)&quot;,&quot;Chris(36)&quot;]</span><br></pre></td></tr></table></figure>
<p>方法一：Union-Find。改进，这里修改了union方法，将较小的直接作为索引键。因为后续也不需要再使用了。360ms, 35M.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trulyMostPopular</span><span class="params">(self, names: List[str], synonyms: List[str])</span> -&gt; List[str]:</span></span><br><span class="line">    <span class="comment"># RE_NAME_CNT = re.compile(r'\w+|\d+')</span></span><br><span class="line">    <span class="comment"># RE_SAME_NAME = re.compile(r'\w+')</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(x, y)</span>:</span></span><br><span class="line">        uf.setdefault(x, x)</span><br><span class="line">        uf.setdefault(y, y)</span><br><span class="line">        ax, ay = find(x), find(y)</span><br><span class="line">        <span class="keyword">if</span> ax &lt; ay: ay, ax = ax, ay</span><br><span class="line">        uf[ax] = ay</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x != uf[x]:</span><br><span class="line">            uf[x] = find(uf[x])</span><br><span class="line">        <span class="keyword">return</span> uf[x]</span><br><span class="line"></span><br><span class="line">    uf, cnt = &#123;&#125;, &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> person <span class="keyword">in</span> names:</span><br><span class="line">        <span class="comment"># name, c = re.findall(RE_NAME_CNT, person)</span></span><br><span class="line">        <span class="comment"># name, c = re.match(r'(\w+)\((\d+)\)', person).groups()</span></span><br><span class="line">        name, c = person.strip(<span class="string">')'</span>).split(<span class="string">'('</span>)</span><br><span class="line">        uf.setdefault(name, name)</span><br><span class="line">        cnt[name] = int(c)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> con <span class="keyword">in</span> synonyms:</span><br><span class="line">        <span class="comment"># n1, n2 = re.findall(RE_SAME_NAME, con)</span></span><br><span class="line">        <span class="comment"># n1, n2 = re.match(r'\((\w+),(\w+)\)', con).groups()</span></span><br><span class="line">        n1, n2 = con.strip(<span class="string">'()'</span>).split(<span class="string">','</span>)</span><br><span class="line">        union(n1, n2)</span><br><span class="line"></span><br><span class="line">    total = collections.defaultdict(int)</span><br><span class="line">    <span class="keyword">for</span> name, c <span class="keyword">in</span> cnt.items():</span><br><span class="line">        total[find(name)] += c</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [<span class="string">f'<span class="subst">&#123;p&#125;</span>(<span class="subst">&#123;t&#125;</span>)'</span> <span class="keyword">for</span> p, t <span class="keyword">in</span> total.items()]</span><br></pre></td></tr></table></figure>
<p>方法二：dfs 方法。cnt 不能使用defaultdict，因为循环cnt的时候会发生改变报错。因为会存在cnt中没有的key，也就是说不在names中的名字。448ms, 40M.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trulyMostPopular</span><span class="params">(self, names: List[str], synonyms: List[str])</span> -&gt; List[str]:</span></span><br><span class="line">    cnt, seen, g = &#123;&#125;, defaultdict(int), defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> person <span class="keyword">in</span> names:</span><br><span class="line">        name, c = person.strip(<span class="string">')'</span>).split(<span class="string">'('</span>)</span><br><span class="line">        cnt[name] = int(c)</span><br><span class="line">    <span class="keyword">for</span> con <span class="keyword">in</span> synonyms:</span><br><span class="line">        n1, n2 = con.strip(<span class="string">'()'</span>).split(<span class="string">','</span>)</span><br><span class="line">        g[n1].append(n2)</span><br><span class="line">        g[n2].append(n1)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(n)</span>:</span></span><br><span class="line">        seen[n], min_name = <span class="number">1</span>, n</span><br><span class="line">        total = cnt.get(n, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> other <span class="keyword">in</span> g[n]:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> seen[other]:</span><br><span class="line">                p, s = dfs(other)</span><br><span class="line">                total += s</span><br><span class="line">                min_name = min(min_name, p)</span><br><span class="line">        <span class="keyword">return</span> min_name, total</span><br><span class="line"></span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> cnt:</span><br><span class="line">        <span class="keyword">if</span> seen[name]: <span class="keyword">continue</span></span><br><span class="line">        n, s = dfs(name)</span><br><span class="line">        ans.append(<span class="string">'&#123;&#125;(&#123;&#125;)'</span>.format(n, s))</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法三：评论区大神的写法。292ms, 17M，比我的快了好多。它这里的p比我的g要节省空间和时间，我试了更改方法二的这里平均快了40ms和10M的内存。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trulyMostPopular</span><span class="params">(self, names: List[str], synonyms: List[str])</span> -&gt; List[str]:</span></span><br><span class="line">    p, d, q = &#123;&#125;, &#123;&#125;, collections.defaultdict(int)</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> synonyms:</span><br><span class="line">        a, b = s.strip(<span class="string">'()'</span>).split(<span class="string">','</span>)</span><br><span class="line">        pa, pb = p.setdefault(a, [a]), p.setdefault(b, [b])</span><br><span class="line">        pa.extend(pb)</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> pb:</span><br><span class="line">            p[c] = pa</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> p:</span><br><span class="line">        d.setdefault(id(p[name]), min(p[name]))</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> names:</span><br><span class="line">        name, count = s.strip(<span class="string">')'</span>).split(<span class="string">'('</span>)</span><br><span class="line">        q[name <span class="keyword">in</span> p <span class="keyword">and</span> d[id(p[name])] <span class="keyword">or</span> name] += int(count)</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">f'<span class="subst">&#123;name&#125;</span>(<span class="subst">&#123;count&#125;</span>)'</span> <span class="keyword">for</span> name, count <span class="keyword">in</span> q.items()]</span><br></pre></td></tr></table></figure>
<h3 id="851-Loud-and-Rich"><a href="#851-Loud-and-Rich" class="headerlink" title="851. Loud and Rich"></a><a href="https://leetcode.com/problems/loud-and-rich/" target="_blank" rel="noopener">851. Loud and Rich</a></h3><h4 id="啰里啰嗦一大堆，就是找到比当前人有钱的所有人中最低调的一个，quiet值最小，quiet没有重复值。"><a href="#啰里啰嗦一大堆，就是找到比当前人有钱的所有人中最低调的一个，quiet值最小，quiet没有重复值。" class="headerlink" title="啰里啰嗦一大堆，就是找到比当前人有钱的所有人中最低调的一个，quiet值最小，quiet没有重复值。"></a>啰里啰嗦一大堆，就是找到比当前人有钱的所有人中最低调的一个，quiet值最小，quiet没有重复值。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: richer &#x3D; [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet &#x3D; [3,2,5,4,6,1,7,0]</span><br><span class="line">Output: [5,5,2,5,4,5,6,7]</span><br><span class="line">Explanation: </span><br><span class="line">answer[0] &#x3D; 5.</span><br><span class="line">Person 5 has more money than 3, which has more money than 1, which has more money than 0.</span><br><span class="line">The only person who is quieter (has lower quiet[x]) is person 7, but</span><br><span class="line">it isn&#39;t clear if they have more money than person 0.</span><br></pre></td></tr></table></figure>
<p>方法一：dfs. 首次AC，算比较简单。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loudAndRich</span><span class="params">(self, richer: List[List[int]], quiet: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    N = len(quiet)</span><br><span class="line">    rich = collections.defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> a, b <span class="keyword">in</span> richer:</span><br><span class="line">        rich[b].append(a)</span><br><span class="line">    q_to_p = &#123;q: i <span class="keyword">for</span> i, q <span class="keyword">in</span> enumerate(quiet)&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">    @lru_cache(None)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i)</span>:</span></span><br><span class="line">        q = quiet[i]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> rich[i]:</span><br><span class="line">            q = min(q, dfs(j))</span><br><span class="line">        <span class="keyword">return</span> q</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [q_to_p[dfs(i)] <span class="keyword">for</span> i <span class="keyword">in</span> range(N)]</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：Lee的方法，比方法一节省一些空间。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loudAndRich</span><span class="params">(self, richer: List[List[int]], quiet: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    N = len(quiet)</span><br><span class="line">    rich = collections.defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> a, b <span class="keyword">in</span> richer:</span><br><span class="line">        rich[b].append(a)</span><br><span class="line">    ans = [<span class="number">-1</span>] * N</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> ans[i] &gt;= <span class="number">0</span>: <span class="keyword">return</span> ans[i]</span><br><span class="line">        ans[i] = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> rich[i]:</span><br><span class="line">            <span class="keyword">if</span> quiet[dfs(j)] &lt; quiet[ans[i]]:</span><br><span class="line">                ans[i] = dfs(j)</span><br><span class="line">        <span class="keyword">return</span> ans[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        dfs(i) </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="399-Evaluate-Division"><a href="#399-Evaluate-Division" class="headerlink" title="399. Evaluate Division"></a><a href="https://leetcode.com/problems/evaluate-division/" target="_blank" rel="noopener">399. Evaluate Division</a></h3><h4 id="通过已知的除法，计算带有这些变量的除法。"><a href="#通过已知的除法，计算带有这些变量的除法。" class="headerlink" title="通过已知的除法，计算带有这些变量的除法。"></a>通过已知的除法，计算带有这些变量的除法。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: equations &#x3D; [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;]], values &#x3D; [2.0,3.0], queries &#x3D; [[&quot;a&quot;,&quot;c&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;e&quot;],[&quot;a&quot;,&quot;a&quot;],[&quot;x&quot;,&quot;x&quot;]]</span><br><span class="line">Output: [6.00000,0.50000,-1.00000,1.00000,-1.00000]</span><br><span class="line">Explanation: </span><br><span class="line">Given: a &#x2F; b &#x3D; 2.0, b &#x2F; c &#x3D; 3.0</span><br><span class="line">queries are: a &#x2F; c &#x3D; ?, b &#x2F; a &#x3D; ?, a &#x2F; e &#x3D; ?, a &#x2F; a &#x3D; ?, x &#x2F; x &#x3D; ?</span><br><span class="line">return: [6.0, 0.5, -1.0, 1.0, -1.0 ]</span><br></pre></td></tr></table></figure>
<p>方法一：DFS。这题一开始想的是Union-Find方法，但是实现起来发现有点麻烦。需要注意一个问题，在遍历后未找到目标值时，需要添加-1。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcEquation</span><span class="params">(self, equations: List[List[str]], values: List[float], queries: List[List[str]])</span> -&gt; List[float]:</span></span><br><span class="line">    g = defaultdict(list)  </span><br><span class="line">    <span class="keyword">for</span> (u, v), w <span class="keyword">in</span> zip(equations, values):</span><br><span class="line">        g[u].append((v, w))</span><br><span class="line">        g[v].append((u, <span class="number">1</span>/w))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, t, p=<span class="number">1</span>)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i == t:</span><br><span class="line">            ans.append(p)</span><br><span class="line">        seen.add(i)</span><br><span class="line">        <span class="keyword">for</span> j, w <span class="keyword">in</span> g[i]:</span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                dfs(j, t, p*w)</span><br><span class="line">    </span><br><span class="line">    ans, seen = [], set()</span><br><span class="line">    <span class="keyword">for</span> i, (a, b) <span class="keyword">in</span> enumerate(queries):</span><br><span class="line">        <span class="keyword">if</span> g[a] <span class="keyword">and</span> g[b]:</span><br><span class="line">            dfs(a, b)</span><br><span class="line">            <span class="keyword">if</span> i == len(ans):</span><br><span class="line">                ans.append(<span class="number">-1</span>)</span><br><span class="line">            seen.clear()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ans.append(<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>方法二：BFS方法也很优雅。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcEquation</span><span class="params">(self, equations: List[List[str]], values: List[float], queries: List[List[str]])</span> -&gt; List[float]:</span></span><br><span class="line">    g = defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> (u, v), w <span class="keyword">in</span> zip(equations, values):</span><br><span class="line">        g[u].append((v, w))</span><br><span class="line">        g[v].append((u, <span class="number">1</span>/w))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(s, e)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> g[s] <span class="keyword">or</span> <span class="keyword">not</span> g[e]: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        q, seen = [(s, <span class="number">1</span>)], set()</span><br><span class="line">        <span class="keyword">for</span> cur, p <span class="keyword">in</span> q:</span><br><span class="line">            <span class="keyword">if</span> cur == e: <span class="keyword">return</span> p</span><br><span class="line">            seen.add(cur)</span><br><span class="line">            <span class="keyword">for</span> nei, np <span class="keyword">in</span> g[cur]:</span><br><span class="line">                <span class="keyword">if</span> nei <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                    q.append((nei, p*np))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> (bfs(s, e) <span class="keyword">for</span> s, e <span class="keyword">in</span> queries)</span><br></pre></td></tr></table></figure>
<p>方法三：Union-Find，自己想了个七八，也是用tuple返回一个比率，最后写着写着给自己绕蒙了，实现起来还是没有另两个方法简单。union方法其实融合了两个功能。然后就是将<code>ratio</code>添加到模板方法中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcEquation</span><span class="params">(self, equations: List[List[str]], values: List[float], queries: List[List[str]])</span> -&gt; List[float]:</span></span><br><span class="line">    uf = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(x)</span>:</span></span><br><span class="line">        p, xr = uf.setdefault(x, (x, <span class="number">1.0</span>))</span><br><span class="line">        <span class="keyword">if</span> x != p:</span><br><span class="line">            r, pr = find(p)</span><br><span class="line">            uf[x] = (r, xr * pr)</span><br><span class="line">        <span class="keyword">return</span> uf[x]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(x, y, ratio)</span>:</span></span><br><span class="line">        px, xr, py, yr = *find(x), *find(y)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ratio:</span><br><span class="line">            <span class="keyword">return</span> xr / yr <span class="keyword">if</span> px == py <span class="keyword">else</span> <span class="number">-1.0</span></span><br><span class="line">        <span class="keyword">if</span> px != py:</span><br><span class="line">            uf[px] = (py, yr/xr*ratio)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (u, v), w <span class="keyword">in</span> zip(equations, values):</span><br><span class="line">        union(u, v, w)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> [union(x, y, <span class="number">0</span>) <span class="keyword">if</span> x <span class="keyword">in</span> root <span class="keyword">and</span> y <span class="keyword">in</span> root <span class="keyword">else</span> <span class="number">-1.0</span> <span class="keyword">for</span> x, y <span class="keyword">in</span> queries]</span><br></pre></td></tr></table></figure>
<p>方法四：Stefan的弗洛伊德算法。这个没有想到。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcEquation</span><span class="params">(self, equations: List[List[str]], values: List[float], queries: List[List[str]])</span> -&gt; List[float]:</span></span><br><span class="line">    quot = collections.defaultdict(dict)</span><br><span class="line">    <span class="keyword">for</span> (num, den), val <span class="keyword">in</span> zip(equations, values):</span><br><span class="line">        quot[num][num] = quot[den][den] = <span class="number">1</span></span><br><span class="line">        quot[num][den] = val</span><br><span class="line">        quot[den][num] = <span class="number">1</span> / val</span><br><span class="line">    <span class="keyword">for</span> k, i, j <span class="keyword">in</span> itertools.permutations(quot, <span class="number">3</span>):</span><br><span class="line">        <span class="keyword">if</span> k <span class="keyword">in</span> quot[i] <span class="keyword">and</span> j <span class="keyword">in</span> quot[k]:</span><br><span class="line">            quot[i][j] = quot[i][k] * quot[k][j]        </span><br><span class="line">    <span class="keyword">return</span> [quot[num].get(den, <span class="number">-1</span>) <span class="keyword">for</span> num, den <span class="keyword">in</span> queries]</span><br></pre></td></tr></table></figure>
<h3 id="1617-Count-Subtrees-With-Max-Distance-Between-Cities"><a href="#1617-Count-Subtrees-With-Max-Distance-Between-Cities" class="headerlink" title="1617. Count Subtrees With Max Distance Between Cities"></a><a href="https://leetcode.com/problems/count-subtrees-with-max-distance-between-cities/" target="_blank" rel="noopener">1617. Count Subtrees With Max Distance Between Cities</a></h3><h4 id="给你一颗树，求任意子树中节点最大距离1-n-1的分别有多少个。最多有15个节点。"><a href="#给你一颗树，求任意子树中节点最大距离1-n-1的分别有多少个。最多有15个节点。" class="headerlink" title="给你一颗树，求任意子树中节点最大距离1~n-1的分别有多少个。最多有15个节点。"></a>给你一颗树，求任意子树中节点最大距离1~n-1的分别有多少个。最多有15个节点。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 4, edges &#x3D; [[1,2],[2,3],[2,4]]</span><br><span class="line">输出：[3,4,0]</span><br><span class="line">解释：</span><br><span class="line">子树 &#123;1,2&#125;, &#123;2,3&#125; 和 &#123;2,4&#125; 最大距离都是 1 。</span><br><span class="line">子树 &#123;1,2,3&#125;, &#123;1,2,4&#125;, &#123;2,3,4&#125; 和 &#123;1,2,3,4&#125; 最大距离都为 2 。</span><br><span class="line">不存在城市间最大距离为 3 的子树</span><br></pre></td></tr></table></figure>
<p>方法一：比赛时没有时间做，虽然hard但是比较简单，看了题解后写上了。就是暴力的枚举所有的子树，然后再bfs求最大距离，同时判断一下是否构成了子树（这个组合所有节点都出现了）。这里根据Lee215的竞赛写法做了一些调整。时间复杂度为2**15。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countSubgraphsForEachDiameter</span><span class="params">(self, n: int, edges: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">    g = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="keyword">for</span> u, v <span class="keyword">in</span> edges:</span><br><span class="line">        u, v = u<span class="number">-1</span>, v<span class="number">-1</span></span><br><span class="line">        g[u].append(v)</span><br><span class="line">        g[v].append(u)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">max_d</span><span class="params">(comb)</span>:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            mask = comb</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span>&lt;&lt;i) &amp; comb:</span><br><span class="line">                bfs = deque([(i, <span class="number">0</span>)])</span><br><span class="line">                d = <span class="number">0</span></span><br><span class="line">                <span class="keyword">while</span> bfs:</span><br><span class="line">                    k, d = bfs.popleft()</span><br><span class="line">                    mask ^= (<span class="number">1</span>&lt;&lt;k)  <span class="comment"># 标记k被取出此时为0</span></span><br><span class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> g[k]:</span><br><span class="line">                        <span class="keyword">if</span> (<span class="number">1</span>&lt;&lt;j) &amp; mask:   <span class="comment"># 为1的是剩下的</span></span><br><span class="line">                            bfs.append((j, d+<span class="number">1</span>))</span><br><span class="line">                <span class="keyword">if</span> mask: <span class="keyword">return</span> <span class="number">0</span>       <span class="comment"># 不是0说明没有构成子树</span></span><br><span class="line">                ans = max(ans, d)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    res = [<span class="number">0</span>] * (n<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">for</span> comb <span class="keyword">in</span> range(<span class="number">1</span>&lt;&lt;n):</span><br><span class="line">        <span class="keyword">if</span> comb &amp; (comb<span class="number">-1</span>) == <span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">        d = max_d(comb)</span><br><span class="line">        res[d<span class="number">-1</span>] += d&gt;<span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="1284-Minimum-Number-of-Flips-to-Convert-Binary-Matrix-to-Zero-Matrix"><a href="#1284-Minimum-Number-of-Flips-to-Convert-Binary-Matrix-to-Zero-Matrix" class="headerlink" title="1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix"></a>1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix</h3><h4 id="二维矩阵中，-每次翻拍“十”字，最小步数翻成0-原题"><a href="#二维矩阵中，-每次翻拍“十”字，最小步数翻成0-原题" class="headerlink" title="二维矩阵中， 每次翻拍“十”字，最小步数翻成0.原题"></a>二维矩阵中， 每次翻拍“十”字，最小步数翻成0.<a href="https://leetcode.com/problems/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: mat &#x3D; [[0,0],[0,1]]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: One possible solution is to flip (1, 0) then (0, 1) and finally (1, 1) as shown.</span><br></pre></td></tr></table></figure>
<p>方法一：看了答案才做出来，看到提示bfs，但是没有想到可以将这个二维矩阵转成一个二进制是它的数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minFlips</span><span class="params">(self, mat: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    m, n = len(mat), len(mat[<span class="number">0</span>])</span><br><span class="line">    start = sum(cell&lt;&lt;(i*n+j) <span class="keyword">for</span> i, row <span class="keyword">in</span> enumerate(mat) <span class="keyword">for</span> j, cell <span class="keyword">in</span> enumerate(row))</span><br><span class="line">    q = collections.deque([(start, <span class="number">0</span>)])</span><br><span class="line">    seen = &#123;start&#125;</span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        cur, step = q.popleft()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">            <span class="keyword">return</span> step</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> range(n):</span><br><span class="line">                nxt = cur</span><br><span class="line">                <span class="keyword">for</span> i, j <span class="keyword">in</span> ((<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">-1</span>), (<span class="number">0</span>, <span class="number">0</span>)):</span><br><span class="line">                    <span class="keyword">if</span> m &gt; x+i &gt;= <span class="number">0</span> &lt;= y+j &lt; n:</span><br><span class="line">                        nxt ^= <span class="number">1</span> &lt;&lt; ((x+i)*n + y+j) <span class="comment"># 0 ^ 0 = 0, 1 ^ 0 = 1</span></span><br><span class="line">                <span class="keyword">if</span> nxt <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                    q.append((nxt, step+<span class="number">1</span>))</span><br><span class="line">                    seen.add(nxt)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="1293-Shortest-Path-in-a-Grid-with-Obstacles-Elimination"><a href="#1293-Shortest-Path-in-a-Grid-with-Obstacles-Elimination" class="headerlink" title="1293. Shortest Path in a Grid with Obstacles Elimination"></a>1293. Shortest Path in a Grid with Obstacles Elimination</h3><h4 id="最短路径，可以打通障碍k次。原题"><a href="#最短路径，可以打通障碍k次。原题" class="headerlink" title="最短路径，可以打通障碍k次。原题"></a>最短路径，可以打通障碍k次。<a href="https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">grid &#x3D; </span><br><span class="line">[[0,0,0],</span><br><span class="line"> [1,1,0],</span><br><span class="line"> [0,0,0],</span><br><span class="line"> [0,1,1],</span><br><span class="line"> [0,0,0]], </span><br><span class="line">k &#x3D; 1</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: </span><br><span class="line">The shortest path without eliminating any obstacle is 10. </span><br><span class="line">The shortest path with one obstacle elimination at position (3,2) is 6. Such path is (0,0) -&gt; (0,1) -&gt; (0,2) -&gt; (1,2) -&gt; (2,2) -&gt; (3,2) -&gt; (4,2).</span><br></pre></td></tr></table></figure>
<p>方法一：一开始想到了正确思路，但是想错了最小步骤怎么求，其实不用求，第一个到达的就是最小的步数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortestPath</span><span class="params">(self, g: List[List[int]], k: int)</span> -&gt; int:</span></span><br><span class="line">    m, n = len(g), len(g[<span class="number">0</span>])</span><br><span class="line">    q = collections.deque([(<span class="number">0</span>, <span class="number">0</span>, k, <span class="number">0</span>)])</span><br><span class="line">    seen = &#123;(<span class="number">0</span>, <span class="number">0</span>, k)&#125;</span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        x, y, r, s = q.popleft()</span><br><span class="line">        <span class="keyword">if</span> x==m<span class="number">-1</span> <span class="keyword">and</span> y==n<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="comment"># 如果可以直接直角边走到末尾，那么直接过去，优化快了700ms+.</span></span><br><span class="line">        <span class="keyword">if</span> r &gt;= m + n - <span class="number">3</span> - x - y:</span><br><span class="line">            <span class="keyword">return</span> s + m + n - <span class="number">2</span> - x - y</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> ((<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">-1</span>)):</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span>&lt;=x+i&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=y+j&lt;n:</span><br><span class="line">                nr = r-(g[x+i][y+j]==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> (x+i, y+j, nr) <span class="keyword">not</span> <span class="keyword">in</span> seen <span class="keyword">and</span> nr&gt;=<span class="number">0</span>:</span><br><span class="line">                    q.append((x+i, y+j, nr, s+<span class="number">1</span>))</span><br><span class="line">                    seen.add((x+i, y+j, nr))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="1298-Maximum-Candies-You-Can-Get-from-Boxes"><a href="#1298-Maximum-Candies-You-Can-Get-from-Boxes" class="headerlink" title="1298. Maximum Candies You Can Get from Boxes"></a>1298. Maximum Candies You Can Get from Boxes</h3><h4 id="最多从盒子中拿到的糖果。从初始的盒子中往外取，盒子能嵌套盒子，盒子如果上锁还需要钥匙打开。原题"><a href="#最多从盒子中拿到的糖果。从初始的盒子中往外取，盒子能嵌套盒子，盒子如果上锁还需要钥匙打开。原题" class="headerlink" title="最多从盒子中拿到的糖果。从初始的盒子中往外取，盒子能嵌套盒子，盒子如果上锁还需要钥匙打开。原题"></a>最多从盒子中拿到的糖果。从初始的盒子中往外取，盒子能嵌套盒子，盒子如果上锁还需要钥匙打开。<a href="https://leetcode.com/problems/maximum-candies-you-can-get-from-boxes/" target="_blank" rel="noopener">原题</a></h4><p>方法一：有一点没有想到，就是如果前面的盒子被拿出来，但是没有钥匙，知道后面的盒子才获取到钥匙。这种情况需要如何处理？这里参考了lee215的方式。q来表示所有已经打开的盒子，seen表示所有可见的盒子，这样当拿到钥匙时，其实需要做两个操作，如果这个盒子可见，将其放入q，如果盒子没见，将其锁打开（虽不符常理），这样在遇见盒子时可以直接将其添加到队列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxCandies</span><span class="params">(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int])</span> -&gt; int:</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    q = collections.deque(b <span class="keyword">for</span> b <span class="keyword">in</span> initialBoxes <span class="keyword">if</span> status[b])</span><br><span class="line">    seen = set(initialBoxes)</span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        b = q.popleft()</span><br><span class="line">        ans += candies[b]</span><br><span class="line">        <span class="keyword">for</span> new_box <span class="keyword">in</span> containedBoxes[b]:</span><br><span class="line">            seen.add(new_box)</span><br><span class="line">            <span class="keyword">if</span> status[new_box]:</span><br><span class="line">                q.append(new_box)</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> keys[b]:</span><br><span class="line">            <span class="keyword">if</span> status[key] == <span class="number">0</span> <span class="keyword">and</span> key <span class="keyword">in</span> seen:</span><br><span class="line">                q.append(key)</span><br><span class="line">            status[key] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="1345-Jump-Game-IV"><a href="#1345-Jump-Game-IV" class="headerlink" title="1345. Jump Game IV"></a>1345. Jump Game IV</h3><h4 id="跳到末尾最小步数，可以向前向后或者跳到一样的值。原题"><a href="#跳到末尾最小步数，可以向前向后或者跳到一样的值。原题" class="headerlink" title="跳到末尾最小步数，可以向前向后或者跳到一样的值。原题"></a>跳到末尾最小步数，可以向前向后或者跳到一样的值。<a href="https://leetcode.com/problems/jump-game-iv/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [100,-23,-23,404,100,23,23,23,3,404]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: You need three jumps from index 0 --&gt; 4 --&gt; 3 --&gt; 9. Note that index 9 is the last index of the array.</span><br></pre></td></tr></table></figure>
<p>方法一：bfs。需要注意num_seen记录所有的同值，否则会超时。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minJumps</span><span class="params">(self, arr: List[int])</span> -&gt; int:</span></span><br><span class="line">    equal = collections.defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> i, a <span class="keyword">in</span> enumerate(arr):</span><br><span class="line">        equal[a].append(i)</span><br><span class="line">        </span><br><span class="line">    q = collections.deque([(<span class="number">0</span>, <span class="number">0</span>)])</span><br><span class="line">    pos_seen, num_seen = set(), set()</span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        p, s = q.popleft()</span><br><span class="line">        pos_seen.add(p)</span><br><span class="line">        num = arr[p]</span><br><span class="line">        <span class="keyword">if</span> p == len(arr)<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">for</span> nxt <span class="keyword">in</span> [p<span class="number">-1</span>, p+<span class="number">1</span>] + equal[num] * (num <span class="keyword">not</span> <span class="keyword">in</span> num_seen):</span><br><span class="line">            <span class="keyword">if</span> nxt <span class="keyword">in</span> pos_seen <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">0</span>&lt;=nxt&lt;len(arr): <span class="keyword">continue</span></span><br><span class="line">            q.append((nxt, s+<span class="number">1</span>))</span><br><span class="line">        num_seen.add(num)</span><br></pre></td></tr></table></figure>
<h3 id="1391-Check-if-There-is-a-Valid-Path-in-a-Grid"><a href="#1391-Check-if-There-is-a-Valid-Path-in-a-Grid" class="headerlink" title="1391. Check if There is a Valid Path in a Grid"></a>1391. Check if There is a Valid Path in a Grid</h3><h4 id="判断是否能到达右下点。原题"><a href="#判断是否能到达右下点。原题" class="headerlink" title="判断是否能到达右下点。原题"></a>判断是否能到达右下点。<a href="https://leetcode.com/problems/check-if-there-is-a-valid-path-in-a-grid/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [[2,4,3],[6,5,2]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: As shown you can start at cell (0, 0) and visit all the cells of the grid to reach (m - 1, n - 1).</span><br></pre></td></tr></table></figure>
<p>方法一：dfs。需要注意的是<code>(-x, -y) in directions[grid[ni][nj]])</code>是用来判断该块和下一块是否是联通的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hasValidPath</span><span class="params">(self, grid: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">    directions = &#123;</span><br><span class="line">        <span class="number">1</span>: ((<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">-1</span>)),</span><br><span class="line">        <span class="number">2</span>: ((<span class="number">1</span>, <span class="number">0</span>), (<span class="number">-1</span>, <span class="number">0</span>)),</span><br><span class="line">        <span class="number">3</span>: ((<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">-1</span>)),</span><br><span class="line">        <span class="number">4</span>: ((<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>)),</span><br><span class="line">        <span class="number">5</span>: ((<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">-1</span>)),</span><br><span class="line">        <span class="number">6</span>: ((<span class="number">0</span>, <span class="number">1</span>), (<span class="number">-1</span>, <span class="number">0</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    m, n = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line">    seen = set()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j)</span>:</span></span><br><span class="line">        seen.add((i, j))</span><br><span class="line">        <span class="keyword">if</span> (i, j) == (m<span class="number">-1</span>, n<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        block = grid[i][j]</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> directions[block]:</span><br><span class="line">            ni, nj = i+x, j+y</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span>&lt;=ni&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=nj&lt;n <span class="keyword">and</span> (ni, nj) <span class="keyword">not</span> <span class="keyword">in</span> seen <span class="keyword">and</span> (</span><br><span class="line">                (-x, -y) <span class="keyword">in</span> directions[grid[ni][nj]]):</span><br><span class="line">                <span class="keyword">if</span> dfs(ni, nj):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="1162-As-Far-from-Land-as-Possible"><a href="#1162-As-Far-from-Land-as-Possible" class="headerlink" title="1162. As Far from Land as Possible"></a>1162. As Far from Land as Possible</h3><h4 id="离陆地最远的点的距离。原题"><a href="#离陆地最远的点的距离。原题" class="headerlink" title="离陆地最远的点的距离。原题"></a>离陆地最远的点的距离。<a href="https://leetcode.com/problems/as-far-from-land-as-possible/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,0,1],[0,0,0],[1,0,1]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line">The cell (1, 1) is as far as possible from all the land with distance 2.</span><br></pre></td></tr></table></figure>
<p>方法一：bfs. 此题竞赛时想到了解法，但是出发点有点问题，是从水找陆地，这样的话有很多重复的循环，导致超时。正确的思路是从陆地遍历水。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxDistance</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    </span><br><span class="line">    R, C = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line">    q = collections.deque([(i, j, <span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(R) <span class="keyword">for</span> j <span class="keyword">in</span> range(C)</span><br><span class="line">                           <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>])</span><br><span class="line">    d = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        x, y, d = q.popleft()</span><br><span class="line">        <span class="keyword">if</span> grid[x][y] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> d</span><br><span class="line">        surrounds = ((x<span class="number">-1</span>, y), (x+<span class="number">1</span>, y), (x, y<span class="number">-1</span>), (x, y+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> surrounds:</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span>&lt;=i&lt;R <span class="keyword">and</span> <span class="number">0</span>&lt;=j&lt;C <span class="keyword">and</span> grid[i][j]==<span class="number">0</span>:</span><br><span class="line">                q.append((i, j, d+<span class="number">1</span>))</span><br><span class="line">                grid[i][j] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> d <span class="keyword">or</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="1091-Shortest-Path-in-Binary-Matrix"><a href="#1091-Shortest-Path-in-Binary-Matrix" class="headerlink" title="1091. Shortest Path in Binary Matrix"></a>1091. Shortest Path in Binary Matrix</h3><h4 id="从左上到右下，只能走0，求最短路径长度，可以斜着走。原题"><a href="#从左上到右下，只能走0，求最短路径长度，可以斜着走。原题" class="headerlink" title="从左上到右下，只能走0，求最短路径长度，可以斜着走。原题"></a>从左上到右下，只能走0，求最短路径长度，可以斜着走。<a href="https://leetcode.com/problems/shortest-path-in-binary-matrix/" target="_blank" rel="noopener">原题</a></h4><p>方法一：核心思想为，BFS，到终点的深度，使用两个数组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortestPathBinaryMatrix</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    n = len(grid)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> grid[<span class="number">0</span>][<span class="number">0</span>] == grid[<span class="number">-1</span>][<span class="number">-1</span>] == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spread</span><span class="params">(i, j)</span>:</span></span><br><span class="line">        di = (<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line">        dj = (<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> di:</span><br><span class="line">            <span class="keyword">for</span> m <span class="keyword">in</span> dj:</span><br><span class="line">                x, y = i+k, j+m</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;=x&lt;n <span class="keyword">and</span> <span class="number">0</span>&lt;=y&lt;n <span class="keyword">and</span> grid[x][y]==<span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">yield</span> x, y</span><br><span class="line">    </span><br><span class="line">    d = <span class="number">0</span></span><br><span class="line">    bfs = [(<span class="number">0</span>, <span class="number">0</span>)]</span><br><span class="line">    seen = set()</span><br><span class="line">    <span class="keyword">while</span> bfs:</span><br><span class="line">        d += <span class="number">1</span></span><br><span class="line">        bfs2 = []</span><br><span class="line">        <span class="keyword">for</span> (x, y) <span class="keyword">in</span> bfs:</span><br><span class="line">            <span class="keyword">if</span> x==n<span class="number">-1</span> <span class="keyword">and</span> y==n<span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> d</span><br><span class="line">            <span class="keyword">if</span> (x, y) <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                bfs2.extend([(i, j) <span class="keyword">for</span> i, j <span class="keyword">in</span> spread(x, y)])</span><br><span class="line">                seen.add((x, y))</span><br><span class="line">        bfs = bfs2</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：使用双端队列。为了避免起点为1，所以从-1开始，深度为0.</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortestPathBinaryMatrix</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    n = len(grid)</span><br><span class="line">    q = collections.deque([(<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>)])</span><br><span class="line">    seen = set()</span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        x, y, d = q.popleft()</span><br><span class="line">        <span class="keyword">if</span> x==n<span class="number">-1</span> <span class="keyword">and</span> y==n<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> d</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> ((x<span class="number">-1</span>, y<span class="number">-1</span>), (x<span class="number">-1</span>, y), (x<span class="number">-1</span>, y+<span class="number">1</span>), (x, y<span class="number">-1</span>), (x, y+<span class="number">1</span>), (x+<span class="number">1</span>, y<span class="number">-1</span>), (x+<span class="number">1</span>, y), (x+<span class="number">1</span>, y+<span class="number">1</span>)):</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span>&lt;=i&lt;n <span class="keyword">and</span> <span class="number">0</span>&lt;=j&lt;n <span class="keyword">and</span> grid[i][j]==<span class="number">0</span> <span class="keyword">and</span> (i, j) <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                q.append((i, j, d+<span class="number">1</span>))</span><br><span class="line">                seen.add((i, j))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="1034-Coloring-A-Border"><a href="#1034-Coloring-A-Border" class="headerlink" title="1034. Coloring A Border"></a>1034. Coloring A Border</h3><h4 id="给边界染色，此题和733-flood-fill很像，区别在于，那个是将所有区域染色，这个是只将边界染色。原题"><a href="#给边界染色，此题和733-flood-fill很像，区别在于，那个是将所有区域染色，这个是只将边界染色。原题" class="headerlink" title="给边界染色，此题和733.flood fill很像，区别在于，那个是将所有区域染色，这个是只将边界染色。原题"></a>给边界染色，此题和733.flood fill很像，区别在于，那个是将所有区域染色，这个是只将边界染色。<a href="https://leetcode.com/problems/coloring-a-border/" target="_blank" rel="noopener">原题</a></h4><p>方法一：写法稍作修改，将判断移到前面。四个方向只要有一个返回False就说明是边界的点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">colorBorder</span><span class="params">(self, grid: List[List[int]], r0: int, c0: int, color: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(x, y)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> (x, y) <span class="keyword">in</span> seen:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0</span>&lt;=x&lt;R <span class="keyword">and</span> <span class="number">0</span>&lt;=y&lt;C <span class="keyword">and</span> grid[x][y]==grid[r0][c0]):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        seen.add((x, y))</span><br><span class="line">        <span class="keyword">if</span> dfs(x+<span class="number">1</span>, y) + dfs(x<span class="number">-1</span>, y) + dfs(x, y<span class="number">-1</span>) + dfs(x, y+<span class="number">1</span>) &lt; <span class="number">4</span>:</span><br><span class="line">            grid[x][y] = color</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">    seen, R, C = set(), len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line">    dfs(r0, c0)</span><br><span class="line">    <span class="keyword">return</span> grid</span><br></pre></td></tr></table></figure>
<h3 id="1031-Number-of-Enclaves"><a href="#1031-Number-of-Enclaves" class="headerlink" title="1031. Number of Enclaves"></a>1031. Number of Enclaves</h3><h4 id="求被困的地点个数。1表示陆地，不能够走到边界的陆地称为被困的陆地。原题"><a href="#求被困的地点个数。1表示陆地，不能够走到边界的陆地称为被困的陆地。原题" class="headerlink" title="求被困的地点个数。1表示陆地，不能够走到边界的陆地称为被困的陆地。原题"></a>求被困的地点个数。1表示陆地，不能够走到边界的陆地称为被困的陆地。<a href="https://leetcode.com/problems/number-of-enclaves/" target="_blank" rel="noopener">原题</a></h4><p>方法一：简单的DFS</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numEnclaves</span><span class="params">(self, A: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> A:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    R, C = len(A), len(A[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spread</span><span class="params">(i, j)</span>:</span></span><br><span class="line">        A[i][j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> ((i<span class="number">-1</span>, j), (i+<span class="number">1</span>, j), (i, j<span class="number">-1</span>), (i, j+<span class="number">1</span>)):</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span>&lt;=x&lt;R <span class="keyword">and</span> <span class="number">0</span>&lt;=y&lt;C <span class="keyword">and</span> A[x][y] == <span class="number">1</span>:</span><br><span class="line">                spread(x, y)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(R):</span><br><span class="line">        <span class="keyword">if</span> A[i][<span class="number">0</span>]==<span class="number">1</span>:</span><br><span class="line">            spread(i, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> A[i][C<span class="number">-1</span>] == <span class="number">1</span>:</span><br><span class="line">            spread(i, C<span class="number">-1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(C):</span><br><span class="line">        <span class="keyword">if</span> A[<span class="number">0</span>][j] == <span class="number">1</span>:</span><br><span class="line">            spread(<span class="number">0</span>, j)</span><br><span class="line">        <span class="keyword">if</span> A[R<span class="number">-1</span>][j] == <span class="number">1</span>:</span><br><span class="line">            spread(R<span class="number">-1</span>, j)</span><br><span class="line">    <span class="keyword">return</span> sum(sum(row) <span class="keyword">for</span> row <span class="keyword">in</span> A)</span><br></pre></td></tr></table></figure>
<h3 id="695-Max-Area-of-Island"><a href="#695-Max-Area-of-Island" class="headerlink" title="695. Max Area of Island"></a>695. Max Area of Island</h3><h4 id="最大的岛屿面积。原题"><a href="#最大的岛屿面积。原题" class="headerlink" title="最大的岛屿面积。原题"></a>最大的岛屿面积。<a href="https://leetcode.com/problems/max-area-of-island/" target="_blank" rel="noopener">原题</a></h4><p>方法一：dfs.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxAreaOfIsland</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    R, C = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line">    area, seen = <span class="number">0</span>, set()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spread</span><span class="params">(i, j)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0</span>&lt;=i&lt;R <span class="keyword">and</span> <span class="number">0</span>&lt;=j&lt;C <span class="keyword">and</span> (i, j) <span class="keyword">not</span> <span class="keyword">in</span> seen <span class="keyword">and</span></span><br><span class="line">                grid[i][j]):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        seen.add((i, j))</span><br><span class="line">        surrounds = ((i<span class="number">-1</span>, j), (i+<span class="number">1</span>, j), (i, j<span class="number">-1</span>), (i, j+<span class="number">1</span>))</span><br><span class="line">        <span class="comment"># return 1 + sum(map(lambda x: dfs(*x), surrounds))   </span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + sum(starmap(dfs, surrounds))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> max(spread(i, j) </span><br><span class="line">               <span class="keyword">for</span> i <span class="keyword">in</span> range(R) <span class="keyword">for</span> j <span class="keyword">in</span> range(C))</span><br></pre></td></tr></table></figure>
<h3 id="994-Rotting-Oranges"><a href="#994-Rotting-Oranges" class="headerlink" title="994. Rotting Oranges"></a>994. Rotting Oranges</h3><h4 id="腐烂的橘子，1表示新鲜，2表示腐烂，每分钟腐烂的会传染给四周上下左右的橘子，问所有的橘子腐烂最少需要几分钟。原题"><a href="#腐烂的橘子，1表示新鲜，2表示腐烂，每分钟腐烂的会传染给四周上下左右的橘子，问所有的橘子腐烂最少需要几分钟。原题" class="headerlink" title="腐烂的橘子，1表示新鲜，2表示腐烂，每分钟腐烂的会传染给四周上下左右的橘子，问所有的橘子腐烂最少需要几分钟。原题"></a>腐烂的橘子，1表示新鲜，2表示腐烂，每分钟腐烂的会传染给四周上下左右的橘子，问所有的橘子腐烂最少需要几分钟。<a href="https://leetcode.com/problems/rotting-oranges/" target="_blank" rel="noopener">原题</a></h4><img src="/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%9B%BE%E7%AF%87%EF%BC%89Graph/oranges.png" class>
<p>方法一：竞赛时虽然做出来了，但有些点没想出来，其实是BFS，这样一想退出条件就很清楚了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">orangesRotting</span><span class="params">(self, g: <span class="string">'List[List[int]]'</span>)</span> -&gt; 'int':</span></span><br><span class="line">    R, C = len(g), len(g[<span class="number">0</span>])</span><br><span class="line">    rotted = ((x, y, <span class="number">0</span>) <span class="keyword">for</span> x <span class="keyword">in</span> range(R) <span class="keyword">for</span> y <span class="keyword">in</span> range(C) <span class="keyword">if</span> g[x][y]==<span class="number">2</span>)</span><br><span class="line">    q = collections.deque(rotted)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_rot</span><span class="params">(x, y)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> ((x<span class="number">-1</span>, y), (x, y<span class="number">-1</span>), (x+<span class="number">1</span>, y), (x, y+<span class="number">1</span>)):</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span>&lt;=x&lt;R <span class="keyword">and</span> <span class="number">0</span>&lt;=y&lt;C <span class="keyword">and</span> g[x][y]==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">yield</span> x, y</span><br><span class="line">    d = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        r, c, d = q.popleft()</span><br><span class="line">        <span class="keyword">for</span> sr, sc <span class="keyword">in</span> to_rot(r, c):</span><br><span class="line">            g[sr][sc] = <span class="number">2</span></span><br><span class="line">            q.append((sr, sc, d+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="number">1</span> <span class="keyword">in</span> sum(g, []):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="733-Flood-Fill"><a href="#733-Flood-Fill" class="headerlink" title="733. Flood Fill"></a>733. Flood Fill</h3><h4 id="“洪水填充”，给定一个二维数组表示一张图片的像素，然后指定一个点和一个颜色，将这个点和上下左右四个点使用新的颜色填充，和这个点原来相同的颜色的点也受到影响，依次扩散，返回新的图片数组。原题"><a href="#“洪水填充”，给定一个二维数组表示一张图片的像素，然后指定一个点和一个颜色，将这个点和上下左右四个点使用新的颜色填充，和这个点原来相同的颜色的点也受到影响，依次扩散，返回新的图片数组。原题" class="headerlink" title="“洪水填充”，给定一个二维数组表示一张图片的像素，然后指定一个点和一个颜色，将这个点和上下左右四个点使用新的颜色填充，和这个点原来相同的颜色的点也受到影响，依次扩散，返回新的图片数组。原题"></a>“洪水填充”，给定一个二维数组表示一张图片的像素，然后指定一个点和一个颜色，将这个点和上下左右四个点使用新的颜色填充，和这个点原来相同的颜色的点也受到影响，依次扩散，返回新的图片数组。<a href="https://leetcode.com/problems/flood-fill/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">image &#x3D; [[1,1,1],[1,1,0],[1,0,1]]</span><br><span class="line">sr &#x3D; 1, sc &#x3D; 1, newColor &#x3D; 2</span><br><span class="line">Output: [[2,2,2],[2,2,0],[2,0,1]]</span><br><span class="line">Explanation: </span><br><span class="line">From the center of the image (with position (sr, sc) &#x3D; (1, 1)), all pixels connected </span><br><span class="line">by a path of the same color as the starting pixel are colored with the new color.</span><br><span class="line">Note the bottom corner is not colored 2, because it is not 4-directionally connected</span><br><span class="line">to the starting pixel.</span><br></pre></td></tr></table></figure>
<p>方法一：dfs. 需要注意的是，如果目标点与颜色相同，则原图不变。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">floodFill</span><span class="params">(self, image, sr, sc, newColor)</span>:</span></span><br><span class="line">    rows, cols = len(image), len(image[<span class="number">0</span>])</span><br><span class="line">    old_val = image[sr][sc]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spread</span><span class="params">(x, y)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> old_val == image[x][y]:</span><br><span class="line">            image[x][y] = newColor</span><br><span class="line">            <span class="keyword">if</span> x<span class="number">-1</span> &gt;= <span class="number">0</span>:</span><br><span class="line">                spread(x<span class="number">-1</span>, y)</span><br><span class="line">            <span class="keyword">if</span> x+<span class="number">1</span> &lt; rows:</span><br><span class="line">                spread(x+<span class="number">1</span>, y)</span><br><span class="line">            <span class="keyword">if</span> y<span class="number">-1</span> &gt;= <span class="number">0</span>:</span><br><span class="line">                spread(x, y<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span> y+<span class="number">1</span> &lt; cols:</span><br><span class="line">                spread(x, y+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> old_val != newColor:</span><br><span class="line">        spread(sr, sc)</span><br><span class="line">    <span class="keyword">return</span> image</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：上述方法的变形。看起来更优雅。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">floodFill</span><span class="params">(self, image, sr, sc, newColor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(x, y)</span>:</span></span><br><span class="line">        image[x][y] = newColor</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> ((x<span class="number">-1</span>, y), (x+<span class="number">1</span>, y), (x, y+<span class="number">1</span>), (x, y<span class="number">-1</span>)):</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span>&lt;=x&lt;rows <span class="keyword">and</span> <span class="number">0</span>&lt;=y&lt;cols <span class="keyword">and</span> image[x][y]==old_val:</span><br><span class="line">                dfs(x, y)</span><br><span class="line">        </span><br><span class="line">    old_val, rows, cols = image[sr][sc], len(image), len(image[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> old_val != newColor:</span><br><span class="line">        dfs(sr, sc)</span><br><span class="line">    <span class="keyword">return</span> image</span><br></pre></td></tr></table></figure>
<h3 id="1625-Lexicographically-Smallest-String-After-Applying-Operations"><a href="#1625-Lexicographically-Smallest-String-After-Applying-Operations" class="headerlink" title="1625. Lexicographically Smallest String After Applying Operations"></a><a href="https://leetcode.com/problems/lexicographically-smallest-string-after-applying-operations/" target="_blank" rel="noopener">1625. Lexicographically Smallest String After Applying Operations</a></h3><h4 id="给你一个字符串-s-以及两个整数-a-和-b-。其中，字符串-s-的长度为偶数，且仅由数字-0-到-9-组成。"><a href="#给你一个字符串-s-以及两个整数-a-和-b-。其中，字符串-s-的长度为偶数，且仅由数字-0-到-9-组成。" class="headerlink" title="给你一个字符串 s 以及两个整数 a 和 b 。其中，字符串 s 的长度为偶数，且仅由数字 0 到 9 组成。"></a>给你一个字符串 s 以及两个整数 a 和 b 。其中，字符串 s 的长度为偶数，且仅由数字 0 到 9 组成。</h4><p>你可以在 s 上按任意顺序多次执行下面两个操作之一：</p>
<p>累加：将  a 加到 s 中所有下标为奇数的元素上（下标从 0 开始）。数字一旦超过 9 就会变成 0，如此循环往复。例如，s = “3456” 且 a = 5，则执行此操作后 s 变成 “3951”。<br>轮转：将 s 向右轮转 b 位。例如，s = “3456” 且 b = 1，则执行此操作后 s 变成 “6345”。<br>请你返回在 s 上执行上述操作任意次后可以得到的 字典序最小 的字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;5525&quot;, a &#x3D; 9, b &#x3D; 2</span><br><span class="line">输出：&quot;2050&quot;</span><br><span class="line">解释：执行操作如下：</span><br><span class="line">初态：&quot;5525&quot;</span><br><span class="line">轮转：&quot;2555&quot;</span><br><span class="line">累加：&quot;2454&quot;</span><br><span class="line">累加：&quot;2353&quot;</span><br><span class="line">轮转：&quot;5323&quot;</span><br><span class="line">累加：&quot;5222&quot;</span><br><span class="line">累加：&quot;5121&quot;</span><br><span class="line">轮转：&quot;2151&quot;</span><br><span class="line">累加：&quot;2050&quot;​​​​​​​​​​​​</span><br><span class="line">无法获得字典序小于 &quot;2050&quot; 的字符串。</span><br></pre></td></tr></table></figure>
<p>方法一：这题比较难想，作为竞赛第二题一直卡住了，实际没有3题简单。BFS，暴力去做就行，但是比赛时写得有一点问题TLE了。</p>
<p>但是还是想到一些规律，如果b是偶数时，累加的位数只有奇数位；如果b是奇数，那么通过旋转每一位都可能累加，但是累加和旋转的顺序其实是不想关的，可以单独地操作。时间1700ms。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findLexSmallestString</span><span class="params">(self, s: str, a: int, b: int)</span> -&gt; str:</span></span><br><span class="line">    q, seen, ans = deque([s]), &#123;s&#125;, s</span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        cur = q.popleft()</span><br><span class="line">        ans = min(ans, cur)</span><br><span class="line">        nxt = <span class="string">''</span>.join(str(n <span class="keyword">if</span> i&amp;<span class="number">1</span>==<span class="number">0</span> <span class="keyword">else</span> (int(n)+a)%<span class="number">10</span>) <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(cur))</span><br><span class="line">        <span class="keyword">if</span> nxt <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">            seen.add(nxt)</span><br><span class="line">            q.append(nxt)</span><br><span class="line">        rot = nxt[-b:] + nxt[:-b]</span><br><span class="line">        <span class="keyword">if</span> rot <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">            seen.add(rot)</span><br><span class="line">            q.append(rot)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>方法二：dfs，也是可以，向BFS那样去重就行了。速度比方法一慢了一点2400ms。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findLexSmallestString</span><span class="params">(self, s: str, a: int, b: int)</span> -&gt; str:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">op_1</span><span class="params">(s)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(str((int(c)+a)%<span class="number">10</span>) <span class="keyword">if</span> i&amp;<span class="number">1</span> <span class="keyword">else</span> c <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(s))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">op_2</span><span class="params">(s)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> s[-b:] + s[:-b]</span><br><span class="line">    </span><br><span class="line">    seen = set()</span><br><span class="line">    stack = [s]</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        s = stack.pop()</span><br><span class="line">        seen.add(s)</span><br><span class="line">        <span class="keyword">if</span> (ss := op_1(s)) <span class="keyword">not</span> <span class="keyword">in</span> seen: stack.append(ss)</span><br><span class="line">        <span class="keyword">if</span> (ss := op_2(s)) <span class="keyword">not</span> <span class="keyword">in</span> seen: stack.append(ss)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> min(seen)</span><br></pre></td></tr></table></figure>
<h3 id="1627-Graph-Connectivity-With-Threshold"><a href="#1627-Graph-Connectivity-With-Threshold" class="headerlink" title="1627. Graph Connectivity With Threshold"></a><a href="https://leetcode-cn.com/problems/graph-connectivity-with-threshold/" target="_blank" rel="noopener">1627. Graph Connectivity With Threshold</a></h3><h4 id="给你1-n个点，如果两个点有一个约数大于Threshold，那么表明两点之间有边。问给你一些点对，判断这两个点是否相连。"><a href="#给你1-n个点，如果两个点有一个约数大于Threshold，那么表明两点之间有边。问给你一些点对，判断这两个点是否相连。" class="headerlink" title="给你1~n个点，如果两个点有一个约数大于Threshold，那么表明两点之间有边。问给你一些点对，判断这两个点是否相连。"></a>给你1~n个点，如果两个点有一个约数大于Threshold，那么表明两点之间有边。问给你一些点对，判断这两个点是否相连。</h4><p>方法一：简单的并查集问题，比赛可惜没时间做。这题的问题在于如何建图。枚举两个点一定会超时，所以从逆向考虑，枚举所有的约数，将这些点相连。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">areConnected</span><span class="params">(self, n: int, threshold: int, queries: List[List[int]])</span> -&gt; List[bool]:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(x, y)</span>:</span></span><br><span class="line">        uf[find(x)] = find(y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x != uf[x]:</span><br><span class="line">            uf[x] = find(uf[x])</span><br><span class="line">        <span class="keyword">return</span> uf[x]</span><br><span class="line"></span><br><span class="line">    uf = list(range(<span class="number">0</span>, n+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> range(threshold+<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(d, n+<span class="number">1</span>, d):</span><br><span class="line">            union(j, d)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [find(u)==find(v) <span class="keyword">for</span> u, v <span class="keyword">in</span> queries]</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    <div>
      
        
      
    </div>

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/LeetCode/" rel="tag">
            <i class="fa fa-tag"></i> LeetCode</a>
          
            <a href="/tags/Python/" rel="tag">
            <i class="fa fa-tag"></i> Python</a>
          
            <a href="/tags/Algorithm/" rel="tag">
            <i class="fa fa-tag"></i> Algorithm</a>
          
            <a href="/tags/Graph/" rel="tag">
            <i class="fa fa-tag"></i> Graph</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%93%88%E5%B8%8C%E7%AF%87%EF%BC%89hashtable/" rel="next" title="LeetCode算法题整理（哈希篇）hashtable">
                <i class="fa fa-chevron-left"></i> LeetCode算法题整理（哈希篇）hashtable
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/%E7%AE%97%E6%B3%95%E7%AF%87%E7%9B%AE%E5%BD%95%E6%B1%87%E6%80%BB/" rel="prev" title="算法篇目录汇总">
                算法篇目录汇总 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript" target="_blank" rel="noopener">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="xiaoliji" />
          <p class="site-author-name" itemprop="name">xiaoliji</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">35</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/darkTianTian" target="_blank" title="GitHub" rel="external nofollow">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.hackerrank.com/xiaoliji?hr_r=1" target="_blank" title="HackerRank" rel="external nofollow">
                  
                    <i class="fa fa-fw fa-hackerrank"></i>
                  
                    
                      HackerRank
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://leetcode.com/darktiantian/" target="_blank" title="LeetCode" rel="external nofollow">
                  
                    <i class="fa fa-fw fa-leetcode"></i>
                  
                    
                      LeetCode
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.jianshu.com/u/de42f74901fd" target="_blank" title="简书" rel="external nofollow">
                  
                    <i class="fa fa-fw fa-book"></i>
                  
                    
                      简书
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#990-Satisfiability-of-Equality-Equations"><span class="nav-number">1.</span> <span class="nav-text">990. Satisfiability of Equality Equations</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#满足所有方程式，判断是否存在变量的值满足所有的等式与不等式。原题"><span class="nav-number">1.1.</span> <span class="nav-text">满足所有方程式，判断是否存在变量的值满足所有的等式与不等式。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#997-Find-the-Town-Judge"><span class="nav-number">2.</span> <span class="nav-text">997. Find the Town Judge</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#找到小镇审判长。审判长被除自己以外的所有人信任，并且不信任任何人。根据信任列表找出审判长。原题"><span class="nav-number">2.1.</span> <span class="nav-text">找到小镇审判长。审判长被除自己以外的所有人信任，并且不信任任何人。根据信任列表找出审判长。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#133-Clone-Graph"><span class="nav-number">3.</span> <span class="nav-text">133. Clone Graph</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#深拷贝一个简单环。原题"><span class="nav-number">3.1.</span> <span class="nav-text">深拷贝一个简单环。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1334-Find-the-City-With-the-Smallest-Number-of-Neighbors-at-a-Threshold-Distance"><span class="nav-number">4.</span> <span class="nav-text">1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#找到距离范围内邻居最少的城市。原题"><span class="nav-number">4.1.</span> <span class="nav-text">找到距离范围内邻居最少的城市。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1267-Count-Servers-that-Communicate"><span class="nav-number">5.</span> <span class="nav-text">1267. Count Servers that Communicate</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#找到2个以上的服务器连接个数，服务器可以在一行或是一列算是连接上。原题"><span class="nav-number">5.1.</span> <span class="nav-text">找到2个以上的服务器连接个数，服务器可以在一行或是一列算是连接上。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#886-Possible-Bipartition"><span class="nav-number">6.</span> <span class="nav-text">886. Possible Bipartition</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#将不喜欢的人放在两组中，根据关系是否能将其分为2组。原题"><span class="nav-number">6.1.</span> <span class="nav-text">将不喜欢的人放在两组中，根据关系是否能将其分为2组。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#207-Course-Schedule"><span class="nav-number">7.</span> <span class="nav-text">207. Course Schedule</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#课程调度，课程有依赖关系，问是否能完成所有的课程。原题"><span class="nav-number">7.1.</span> <span class="nav-text">课程调度，课程有依赖关系，问是否能完成所有的课程。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1462-Course-Schedule-IV"><span class="nav-number">8.</span> <span class="nav-text">1462. Course Schedule IV</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#和上题差不多，问题不一样，问的是根据给定的依赖关系，判断两节课是否有依赖。原题"><span class="nav-number">8.1.</span> <span class="nav-text">和上题差不多，问题不一样，问的是根据给定的依赖关系，判断两节课是否有依赖。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1466-Reorder-Routes-to-Make-All-Paths-Lead-to-the-City-Zero"><span class="nav-number">9.</span> <span class="nav-text">1466. Reorder Routes to Make All Paths Lead to the City Zero</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#有一个有向图，两个节点之间只有一条边，要求所有的边指向0，需要改多少条边的方向。原题"><span class="nav-number">9.1.</span> <span class="nav-text">有一个有向图，两个节点之间只有一条边，要求所有的边指向0，需要改多少条边的方向。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1210-Minimum-Moves-to-Reach-Target-with-Rotations"><span class="nav-number">10.</span> <span class="nav-text">1210. Minimum Moves to Reach Target with Rotations</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一个占位2格的蛇，从左上走到右下需要最少的步数，可以旋转。原题"><span class="nav-number">10.1.</span> <span class="nav-text">一个占位2格的蛇，从左上走到右下需要最少的步数，可以旋转。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1202-Smallest-String-With-Swaps"><span class="nav-number">11.</span> <span class="nav-text">1202. Smallest String With Swaps</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#给定一组pairs表明索引对可以互换，求这个字符串能换的最小值时多少，同一对可以进行多次互换。原题"><span class="nav-number">11.1.</span> <span class="nav-text">给定一组pairs表明索引对可以互换，求这个字符串能换的最小值时多少，同一对可以进行多次互换。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#787-Cheapest-Flights-Within-K-Stops"><span class="nav-number">12.</span> <span class="nav-text">787. Cheapest Flights Within K Stops</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#经过K个站点的最便宜的航班。原题"><span class="nav-number">12.1.</span> <span class="nav-text">经过K个站点的最便宜的航班。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#332-Reconstruct-Itinerary"><span class="nav-number">13.</span> <span class="nav-text">332. Reconstruct Itinerary</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#重建行程，根据火车票来寻找行程，答案不唯一。原题"><span class="nav-number">13.1.</span> <span class="nav-text">重建行程，根据火车票来寻找行程，答案不唯一。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1519-Number-of-Nodes-in-the-Sub-Tree-With-the-Same-Label"><span class="nav-number">14.</span> <span class="nav-text">1519. Number of Nodes in the Sub-Tree With the Same Label</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#有一个数的图，每个节点有个字母，返回每个节点的子树中包含这个字母的总个数。原题"><span class="nav-number">14.1.</span> <span class="nav-text">有一个数的图，每个节点有个字母，返回每个节点的子树中包含这个字母的总个数。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#478-Generate-Random-Point-in-a-Circle"><span class="nav-number">15.</span> <span class="nav-text">478. Generate Random Point in a Circle</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#在给定圆的范围内随机生成点。原题"><span class="nav-number">15.1.</span> <span class="nav-text">在给定圆的范围内随机生成点。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1559-Detect-Cycles-in-2D-Grid"><span class="nav-number">16.</span> <span class="nav-text">1559. Detect Cycles in 2D Grid</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2D-矩阵中判断是否有环。原题"><span class="nav-number">16.1.</span> <span class="nav-text">2D 矩阵中判断是否有环。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#310-Minimum-Height-Trees"><span class="nav-number">17.</span> <span class="nav-text">310. Minimum Height Trees</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#有一个无向图，0-n-1这些节点，每两个节点只有一条边，找出这种节点，当以节点为根时，组成的树有最小的高度。原题"><span class="nav-number">17.1.</span> <span class="nav-text">有一个无向图，0~n-1这些节点，每两个节点只有一条边，找出这种节点，当以节点为根时，组成的树有最小的高度。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#127-Word-Ladder"><span class="nav-number">18.</span> <span class="nav-text">127. Word Ladder</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#每次可以改变单词中的一个字母，但必须在wordList中，问最少需要多少次能达到目标单词。原题"><span class="nav-number">18.1.</span> <span class="nav-text">每次可以改变单词中的一个字母，但必须在wordList中，问最少需要多少次能达到目标单词。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#547-Friend-Circles"><span class="nav-number">19.</span> <span class="nav-text">547. Friend Circles</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#朋友圈，一堆人拉帮结伙，朋友关系可以传递。通过二维数组表示i-j两个人是否是朋友。问N个人有多少个帮派。原题"><span class="nav-number">19.1.</span> <span class="nav-text">朋友圈，一堆人拉帮结伙，朋友关系可以传递。通过二维数组表示i, j两个人是否是朋友。问N个人有多少个帮派。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1584-Min-Cost-to-Connect-All-Points"><span class="nav-number">20.</span> <span class="nav-text">1584. Min Cost to Connect All Points</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#所有点最小的曼哈顿距离-xi-xj-yi-yj-和为多少。原题"><span class="nav-number">20.1.</span> <span class="nav-text">所有点最小的曼哈顿距离|xi - xj| + |yi - yj|和为多少。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#684-Redundant-Connection"><span class="nav-number">21.</span> <span class="nav-text">684. Redundant Connection</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#多余的边，有一个无向图有N个节点，和N个边，对于一个连通器来说，刚好多了一条边。找到这条多余的边，所有的边给的-u-v-均满足u-lt-v。原题"><span class="nav-number">21.1.</span> <span class="nav-text">多余的边，有一个无向图有N个节点，和N个边，对于一个连通器来说，刚好多了一条边。找到这条多余的边，所有的边给的[u, v]均满足u&lt;v。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#685-Redundant-Connection-II"><span class="nav-number">22.</span> <span class="nav-text">685. Redundant Connection II</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#同684一样，区别在于有向图，也是多出一条边，但这条边是最后一条无用的边。也就是说。删除这条边后，还是一个N个节点的有向图。并且图中只能有一个根节点。"><span class="nav-number">22.1.</span> <span class="nav-text">同684一样，区别在于有向图，也是多出一条边，但这条边是最后一条无用的边。也就是说。删除这条边后，还是一个N个节点的有向图。并且图中只能有一个根节点。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#743-Network-Delay-Time"><span class="nav-number">23.</span> <span class="nav-text">743. Network Delay Time</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#网络延迟，有N个网络节点，给出一个加权有向图，问从K点出发，遍历所有点需要多少时间，如果不可能返回-1。原题"><span class="nav-number">23.1.</span> <span class="nav-text">网络延迟，有N个网络节点，给出一个加权有向图，问从K点出发，遍历所有点需要多少时间，如果不可能返回-1。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#721-Accounts-Merge"><span class="nav-number">24.</span> <span class="nav-text">721. Accounts Merge</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#账号合并，一个人可能有多个账号，将具有相同账号的人合并到一起，返回所有的用户的所有的账号"><span class="nav-number">24.1.</span> <span class="nav-text">账号合并，一个人可能有多个账号，将具有相同账号的人合并到一起，返回所有的用户的所有的账号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#面试题-17-07-婴儿名字"><span class="nav-number">24.2.</span> <span class="nav-text">面试题 17.07. 婴儿名字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#找到相同名字的数量，和721一样，也是合并婴儿。names中可能包含synonyms中没有的，synonyms中也可能包含names没有的。"><span class="nav-number">24.3.</span> <span class="nav-text">找到相同名字的数量，和721一样，也是合并婴儿。names中可能包含synonyms中没有的，synonyms中也可能包含names没有的。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#851-Loud-and-Rich"><span class="nav-number">25.</span> <span class="nav-text">851. Loud and Rich</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#啰里啰嗦一大堆，就是找到比当前人有钱的所有人中最低调的一个，quiet值最小，quiet没有重复值。"><span class="nav-number">25.1.</span> <span class="nav-text">啰里啰嗦一大堆，就是找到比当前人有钱的所有人中最低调的一个，quiet值最小，quiet没有重复值。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#399-Evaluate-Division"><span class="nav-number">26.</span> <span class="nav-text">399. Evaluate Division</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#通过已知的除法，计算带有这些变量的除法。"><span class="nav-number">26.1.</span> <span class="nav-text">通过已知的除法，计算带有这些变量的除法。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1617-Count-Subtrees-With-Max-Distance-Between-Cities"><span class="nav-number">27.</span> <span class="nav-text">1617. Count Subtrees With Max Distance Between Cities</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#给你一颗树，求任意子树中节点最大距离1-n-1的分别有多少个。最多有15个节点。"><span class="nav-number">27.1.</span> <span class="nav-text">给你一颗树，求任意子树中节点最大距离1~n-1的分别有多少个。最多有15个节点。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1284-Minimum-Number-of-Flips-to-Convert-Binary-Matrix-to-Zero-Matrix"><span class="nav-number">28.</span> <span class="nav-text">1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#二维矩阵中，-每次翻拍“十”字，最小步数翻成0-原题"><span class="nav-number">28.1.</span> <span class="nav-text">二维矩阵中， 每次翻拍“十”字，最小步数翻成0.原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1293-Shortest-Path-in-a-Grid-with-Obstacles-Elimination"><span class="nav-number">29.</span> <span class="nav-text">1293. Shortest Path in a Grid with Obstacles Elimination</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#最短路径，可以打通障碍k次。原题"><span class="nav-number">29.1.</span> <span class="nav-text">最短路径，可以打通障碍k次。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1298-Maximum-Candies-You-Can-Get-from-Boxes"><span class="nav-number">30.</span> <span class="nav-text">1298. Maximum Candies You Can Get from Boxes</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#最多从盒子中拿到的糖果。从初始的盒子中往外取，盒子能嵌套盒子，盒子如果上锁还需要钥匙打开。原题"><span class="nav-number">30.1.</span> <span class="nav-text">最多从盒子中拿到的糖果。从初始的盒子中往外取，盒子能嵌套盒子，盒子如果上锁还需要钥匙打开。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1345-Jump-Game-IV"><span class="nav-number">31.</span> <span class="nav-text">1345. Jump Game IV</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#跳到末尾最小步数，可以向前向后或者跳到一样的值。原题"><span class="nav-number">31.1.</span> <span class="nav-text">跳到末尾最小步数，可以向前向后或者跳到一样的值。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1391-Check-if-There-is-a-Valid-Path-in-a-Grid"><span class="nav-number">32.</span> <span class="nav-text">1391. Check if There is a Valid Path in a Grid</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#判断是否能到达右下点。原题"><span class="nav-number">32.1.</span> <span class="nav-text">判断是否能到达右下点。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1162-As-Far-from-Land-as-Possible"><span class="nav-number">33.</span> <span class="nav-text">1162. As Far from Land as Possible</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#离陆地最远的点的距离。原题"><span class="nav-number">33.1.</span> <span class="nav-text">离陆地最远的点的距离。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1091-Shortest-Path-in-Binary-Matrix"><span class="nav-number">34.</span> <span class="nav-text">1091. Shortest Path in Binary Matrix</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#从左上到右下，只能走0，求最短路径长度，可以斜着走。原题"><span class="nav-number">34.1.</span> <span class="nav-text">从左上到右下，只能走0，求最短路径长度，可以斜着走。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1034-Coloring-A-Border"><span class="nav-number">35.</span> <span class="nav-text">1034. Coloring A Border</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#给边界染色，此题和733-flood-fill很像，区别在于，那个是将所有区域染色，这个是只将边界染色。原题"><span class="nav-number">35.1.</span> <span class="nav-text">给边界染色，此题和733.flood fill很像，区别在于，那个是将所有区域染色，这个是只将边界染色。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1031-Number-of-Enclaves"><span class="nav-number">36.</span> <span class="nav-text">1031. Number of Enclaves</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#求被困的地点个数。1表示陆地，不能够走到边界的陆地称为被困的陆地。原题"><span class="nav-number">36.1.</span> <span class="nav-text">求被困的地点个数。1表示陆地，不能够走到边界的陆地称为被困的陆地。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#695-Max-Area-of-Island"><span class="nav-number">37.</span> <span class="nav-text">695. Max Area of Island</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#最大的岛屿面积。原题"><span class="nav-number">37.1.</span> <span class="nav-text">最大的岛屿面积。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#994-Rotting-Oranges"><span class="nav-number">38.</span> <span class="nav-text">994. Rotting Oranges</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#腐烂的橘子，1表示新鲜，2表示腐烂，每分钟腐烂的会传染给四周上下左右的橘子，问所有的橘子腐烂最少需要几分钟。原题"><span class="nav-number">38.1.</span> <span class="nav-text">腐烂的橘子，1表示新鲜，2表示腐烂，每分钟腐烂的会传染给四周上下左右的橘子，问所有的橘子腐烂最少需要几分钟。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#733-Flood-Fill"><span class="nav-number">39.</span> <span class="nav-text">733. Flood Fill</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#“洪水填充”，给定一个二维数组表示一张图片的像素，然后指定一个点和一个颜色，将这个点和上下左右四个点使用新的颜色填充，和这个点原来相同的颜色的点也受到影响，依次扩散，返回新的图片数组。原题"><span class="nav-number">39.1.</span> <span class="nav-text">“洪水填充”，给定一个二维数组表示一张图片的像素，然后指定一个点和一个颜色，将这个点和上下左右四个点使用新的颜色填充，和这个点原来相同的颜色的点也受到影响，依次扩散，返回新的图片数组。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1625-Lexicographically-Smallest-String-After-Applying-Operations"><span class="nav-number">40.</span> <span class="nav-text">1625. Lexicographically Smallest String After Applying Operations</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#给你一个字符串-s-以及两个整数-a-和-b-。其中，字符串-s-的长度为偶数，且仅由数字-0-到-9-组成。"><span class="nav-number">40.1.</span> <span class="nav-text">给你一个字符串 s 以及两个整数 a 和 b 。其中，字符串 s 的长度为偶数，且仅由数字 0 到 9 组成。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1627-Graph-Connectivity-With-Threshold"><span class="nav-number">41.</span> <span class="nav-text">1627. Graph Connectivity With Threshold</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#给你1-n个点，如果两个点有一个约数大于Threshold，那么表明两点之间有边。问给你一些点对，判断这两个点是否相连。"><span class="nav-number">41.1.</span> <span class="nav-text">给你1~n个点，如果两个点有一个约数大于Threshold，那么表明两点之间有边。问给你一些点对，判断这两个点是否相连。</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xiaoliji</span>
</div>
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_pv">
  本站访客数:<span id="busuanzi_value_site_pv"></span>
</span>
</div>
<div class="powered-by">

  Powered by <a class="theme-link" href="https://hexo.io" target="_blank" rel="texternal nofollow noopener">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="texternal nofollow noopener">
    NexT.Mist
  </a>
</div>


<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共197.3k字</span>
</div>
        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  

    
      <script id="dsq-count-scr" src="https://.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://darktiantian.github.io.git/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%9B%BE%E7%AF%87%EF%BC%89Graph/';
          this.page.identifier = 'LeetCode算法题整理（图篇）Graph/';
          this.page.title = 'LeetCode算法题整理（图篇）Graph';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.json";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("MuBXc6gVka7X95yN3qhh8Akg-gzGzoHsz", "flbiG5OQDhWpAaCRLDETaoPF");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  

</body>
</html>
