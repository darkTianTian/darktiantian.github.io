<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="LeetCode,Python,Algorithm,Graph," />








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.2" />






<meta name="description" content="990. Satisfiability of Equality Equations满足所有方程式，判断是否存在变量的值满足所有的等式与不等式。原题解析：所有的相等的点，在图中是联通的。">
<meta name="keywords" content="LeetCode,Python,Algorithm,Graph">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode算法题整理（图篇）Graph">
<meta property="og:url" content="http://darktiantian.github.io.git/LeetCode算法题整理（图篇）Graph/index.html">
<meta property="og:site_name" content="Xiaoliji&#39;s Blog">
<meta property="og:description" content="990. Satisfiability of Equality Equations满足所有方程式，判断是否存在变量的值满足所有的等式与不等式。原题解析：所有的相等的点，在图中是联通的。">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://darktiantian.github.io.git/LeetCode算法题整理（图篇）Graph/113_sample.png">
<meta property="og:image" content="http://darktiantian.github.io.git/LeetCode算法题整理（图篇）Graph/1334.png">
<meta property="og:updated_time" content="2020-09-14T15:25:54.733Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeetCode算法题整理（图篇）Graph">
<meta name="twitter:description" content="990. Satisfiability of Equality Equations满足所有方程式，判断是否存在变量的值满足所有的等式与不等式。原题解析：所有的相等的点，在图中是联通的。">
<meta name="twitter:image" content="http://darktiantian.github.io.git/LeetCode算法题整理（图篇）Graph/113_sample.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://darktiantian.github.io.git/LeetCode算法题整理（图篇）Graph/"/>





  <title>LeetCode算法题整理（图篇）Graph | Xiaoliji's Blog</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <a href="https://github.com/darkTianTian" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Xiaoliji's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">小里脊的个人博客</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://darktiantian.github.io.git/LeetCode算法题整理（图篇）Graph/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaoliji">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xiaoliji's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">LeetCode算法题整理（图篇）Graph</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-10T13:32:48+08:00">
                2019-02-10
              </time>
            

            
              <span class="post-updated">
                &nbsp; | &nbsp; Updated on
                <time itemprop="dateUpdated" datetime="2020-09-14T23:25:54+08:00" content="2020-09-14">
                  2020-09-14
                </time>
              </span>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/LeetCode算法题整理（图篇）Graph/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="LeetCode算法题整理（图篇）Graph/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/LeetCode算法题整理（图篇）Graph/" class="leancloud_visitors" data-flag-title="LeetCode算法题整理（图篇）Graph">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="990-Satisfiability-of-Equality-Equations"><a href="#990-Satisfiability-of-Equality-Equations" class="headerlink" title="990. Satisfiability of Equality Equations"></a>990. Satisfiability of Equality Equations</h3><h4 id="满足所有方程式，判断是否存在变量的值满足所有的等式与不等式。原题"><a href="#满足所有方程式，判断是否存在变量的值满足所有的等式与不等式。原题" class="headerlink" title="满足所有方程式，判断是否存在变量的值满足所有的等式与不等式。原题"></a>满足所有方程式，判断是否存在变量的值满足所有的等式与不等式。<a href="https://leetcode.com/problems/satisfiability-of-equality-equations/" target="_blank" rel="noopener">原题</a></h4><p>解析：所有的相等的点，在图中是联通的。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;a==b&quot;,&quot;b!=a&quot;]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second.  There is no way to assign the variables to satisfy both equations.</span><br><span class="line"></span><br><span class="line">Input: [&quot;a==b&quot;,&quot;b==c&quot;,&quot;a==c&quot;]</span><br><span class="line">Output: true</span><br><span class="line"></span><br><span class="line">Input: [&quot;a==b&quot;,&quot;b!=c&quot;,&quot;c==a&quot;]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p>方法一：set.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">equationsPossible</span><span class="params">(self, equations: <span class="string">'List[str]'</span>)</span> -&gt; 'bool':</span></span><br><span class="line">    equals = []</span><br><span class="line">    equations.sort(key=operator.itemgetter(<span class="number">1</span>), reverse=<span class="keyword">True</span>)</span><br><span class="line">    <span class="comment"># print(equations)</span></span><br><span class="line">    <span class="keyword">for</span> x, e, _, y  <span class="keyword">in</span> equations:</span><br><span class="line">        <span class="keyword">if</span> e == <span class="string">'='</span>:</span><br><span class="line">            <span class="keyword">for</span> i, eq <span class="keyword">in</span> enumerate(equals):</span><br><span class="line">                <span class="keyword">if</span> x <span class="keyword">in</span> eq <span class="keyword">or</span> y <span class="keyword">in</span> eq:</span><br><span class="line">                    equals[i].update(&#123;x, y&#125;)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                equals.append(&#123;x, y&#125;)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> x == y:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">for</span> eq <span class="keyword">in</span> equals:</span><br><span class="line">                <span class="keyword">if</span> x <span class="keyword">in</span> eq <span class="keyword">and</span> y <span class="keyword">in</span> eq:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="comment"># print(equals)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：union find. 并查集。find方法可以想象成一个链表，返回的是链表末尾key,val相等的元素。同时建立连接关系。如<code>a==b, b==c</code>时<code>fc={&#39;a&#39;: &#39;b&#39;, &#39;b&#39;: &#39;c&#39;, &#39;c&#39;: &#39;c&#39;}</code>比较<code>a!=c</code>时就会最终找到<code>fc[&#39;a&#39;] == &#39;c&#39;</code>；如<code>a==b, c==a时，fc={&#39;a&#39;: &#39;b&#39;, &#39;b&#39;: &#39;b&#39;, &#39;c&#39;: &#39;b&#39;}</code>。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">equationsPossible</span><span class="params">(self, equations: <span class="string">'List[str]'</span>)</span> -&gt; 'bool':</span></span><br><span class="line">    equations.sort(key=<span class="keyword">lambda</span> e: e[<span class="number">1</span>] == <span class="string">'!'</span>)</span><br><span class="line">    uf = &#123;a: a <span class="keyword">for</span> a <span class="keyword">in</span> string.ascii_lowercase&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x != uf[x]: </span><br><span class="line">            uf[x] = find(uf[x])</span><br><span class="line">        <span class="keyword">return</span> uf[x]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> a, e, _, b <span class="keyword">in</span> equations:</span><br><span class="line">        <span class="keyword">if</span> e == <span class="string">"="</span>:</span><br><span class="line">            uf[find(a)] = find(b)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> find(a) == find(b):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h3 id="997-Find-the-Town-Judge"><a href="#997-Find-the-Town-Judge" class="headerlink" title="997. Find the Town Judge"></a>997. Find the Town Judge</h3><h4 id="找到小镇审判长。审判长被除自己以外的所有人信任，并且不信任任何人。根据信任列表找出审判长。原题"><a href="#找到小镇审判长。审判长被除自己以外的所有人信任，并且不信任任何人。根据信任列表找出审判长。原题" class="headerlink" title="找到小镇审判长。审判长被除自己以外的所有人信任，并且不信任任何人。根据信任列表找出审判长。原题"></a>找到小镇审判长。审判长被除自己以外的所有人信任，并且不信任任何人。根据信任列表找出审判长。<a href="https://leetcode.com/problems/find-the-town-judge/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]]</span><br><span class="line">Output: 3</span><br><span class="line">Input: N = 3, trust = [[1,3],[2,3],[3,1]]</span><br><span class="line">Output: -1</span><br><span class="line">Input: N = 3, trust = [[1,3],[2,3]]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
<p>方法一：brute force.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findJudge</span><span class="params">(self, N: int, trust: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> trust:</span><br><span class="line">        <span class="keyword">return</span> N</span><br><span class="line">    a, b = zip(*trust)           </span><br><span class="line">    candidates = collections.Counter(b)</span><br><span class="line">    villages = set(a)</span><br><span class="line">    <span class="keyword">for</span> c, votes <span class="keyword">in</span> candidates.most_common():</span><br><span class="line">        <span class="keyword">if</span> votes &lt; N - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> villages:</span><br><span class="line">            <span class="keyword">return</span> c</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：定向图。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findJudge</span><span class="params">(self, N: int, trust: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    count = [<span class="number">0</span>] * (N + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> trust:</span><br><span class="line">        count[i] -= <span class="number">1</span></span><br><span class="line">        count[j] += <span class="number">1</span></span><br><span class="line">        print(count)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> count[i] == N - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="133-Clone-Graph"><a href="#133-Clone-Graph" class="headerlink" title="133. Clone Graph"></a>133. Clone Graph</h3><h4 id="深拷贝一个简单环。原题"><a href="#深拷贝一个简单环。原题" class="headerlink" title="深拷贝一个简单环。原题"></a>深拷贝一个简单环。<a href="https://leetcode.com/problems/clone-graph/" target="_blank" rel="noopener">原题</a></h4><img src="/LeetCode算法题整理（图篇）Graph/113_sample.png">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cloneGraph</span><span class="params">(self, node: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">    cp = collections.defaultdict(<span class="keyword">lambda</span>: Node(<span class="number">0</span>, []))</span><br><span class="line">    nodes = [node]</span><br><span class="line">    seen = set()</span><br><span class="line">    <span class="keyword">while</span> nodes:</span><br><span class="line">        n = nodes.pop()</span><br><span class="line">        cp[n].val = n.val</span><br><span class="line">        cp[n].neighbors = [cp[x] <span class="keyword">for</span> x <span class="keyword">in</span> n.neighbors]</span><br><span class="line">        nodes.extend(x <span class="keyword">for</span> x <span class="keyword">in</span> n.neighbors <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> seen)</span><br><span class="line">        seen.add(n)</span><br><span class="line">    <span class="keyword">return</span> cp[node]</span><br></pre></td></tr></table></figure>
<h3 id="1334-Find-the-City-With-the-Smallest-Number-of-Neighbors-at-a-Threshold-Distance"><a href="#1334-Find-the-City-With-the-Smallest-Number-of-Neighbors-at-a-Threshold-Distance" class="headerlink" title="1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance"></a>1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance</h3><h4 id="找到距离范围内邻居最少的城市。原题"><a href="#找到距离范围内邻居最少的城市。原题" class="headerlink" title="找到距离范围内邻居最少的城市。原题"></a>找到距离范围内邻居最少的城市。<a href="https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/" target="_blank" rel="noopener">原题</a></h4><img src="/LeetCode算法题整理（图篇）Graph/1334.png">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The figure above describes the graph. </span><br><span class="line">The neighboring cities at a distanceThreshold = 4 for each city are:</span><br><span class="line">City 0 -&gt; [City 1, City 2] </span><br><span class="line">City 1 -&gt; [City 0, City 2, City 3] </span><br><span class="line">City 2 -&gt; [City 0, City 1, City 3] </span><br><span class="line">City 3 -&gt; [City 1, City 2] </span><br><span class="line">Cities 0 and 3 have 2 neighboring cities at a distanceThreshold = 4, but we have to return city 3 since it has the greatest number.</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法一：狄克斯特拉算法。这里没想到用一个堆来维持最小的距离。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findTheCity</span><span class="params">(self, n: int, edges: List[List[int]], distanceThreshold: int)</span> -&gt; int:</span></span><br><span class="line">    g = collections.defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> u, v, w <span class="keyword">in</span> edges:</span><br><span class="line">        g[u].append((v, w))</span><br><span class="line">        g[v].append((u, w))</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count_neighbor</span><span class="params">(city)</span>:</span></span><br><span class="line">        heap = [(<span class="number">0</span>, city)]</span><br><span class="line">        dist = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> heap:</span><br><span class="line">            cur_w, u = heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">if</span> u <span class="keyword">in</span> dist:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> u != city:</span><br><span class="line">                dist[u] = cur_w</span><br><span class="line">            <span class="keyword">for</span> v, w <span class="keyword">in</span> g[u]:</span><br><span class="line">                <span class="keyword">if</span> v <span class="keyword">in</span> dist:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> cur_w + w &lt;= distanceThreshold:</span><br><span class="line">                    heapq.heappush(heap, (cur_w+w, v))</span><br><span class="line">        <span class="keyword">return</span> len(dist)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> min(range(n), key=<span class="keyword">lambda</span> x: (count_neighbor(x), -x))</span><br></pre></td></tr></table></figure>
<p>方法二：弗洛伊德算法，这个时间复杂度为O(N^3)，space: O(N^2)但是代码简单。把每个节点当成中转点k，如果<code>dis[i][j] &gt; dis[i][k] + dis[k][j]</code>说明从k走，i, j距离更短。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findTheCity</span><span class="params">(self, n: int, edges: List[List[int]], maxd: int)</span> -&gt; int:</span></span><br><span class="line">    dis = [[float(<span class="string">'inf'</span>)] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="keyword">for</span> i, j, w <span class="keyword">in</span> edges:</span><br><span class="line">        dis[i][j] = dis[j][i] = w</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        dis[i][i] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                dis[i][j] = min(dis[i][j], dis[i][k]+dis[k][j])</span><br><span class="line">    ans = &#123;sum(d&lt;=maxd <span class="keyword">for</span> d <span class="keyword">in</span> dis[i]): i <span class="keyword">for</span> i <span class="keyword">in</span> range(n)&#125;  <span class="comment"># 这里id大的会将小的覆盖</span></span><br><span class="line">    <span class="keyword">return</span> ans[min(ans)]</span><br></pre></td></tr></table></figure>
<h3 id="1267-Count-Servers-that-Communicate"><a href="#1267-Count-Servers-that-Communicate" class="headerlink" title="1267. Count Servers that Communicate"></a>1267. Count Servers that Communicate</h3><h4 id="找到2个以上的服务器连接个数，服务器可以在一行或是一列算是连接上。原题"><a href="#找到2个以上的服务器连接个数，服务器可以在一行或是一列算是连接上。原题" class="headerlink" title="找到2个以上的服务器连接个数，服务器可以在一行或是一列算是连接上。原题"></a>找到2个以上的服务器连接个数，服务器可以在一行或是一列算是连接上。<a href="https://leetcode.com/problems/count-servers-that-communicate/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[1,1,0,0],[0,0,1,0],[0,0,1,0],[0,0,0,1]]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The two servers in the first row can communicate with each other. The two servers in the third column can communicate with each other. The server at right bottom corner can&apos;t communicate with any other server.</span><br></pre></td></tr></table></figure>
<p>方法一：和小岛问题不同，这个服务器可以隔空连接，AC时用的dfs方法，效率非常慢。实际上只需要记录横纵左边即可，遍历两次</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countServers</span><span class="params">(self, g: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    X, Y = [<span class="number">0</span>]*<span class="number">300</span>, [<span class="number">0</span>]*<span class="number">300</span></span><br><span class="line">    m, n = len(g), len(g[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            X[i] += g[i][j]</span><br><span class="line">            Y[j] += g[i][j]</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> g[i][j]==<span class="number">1</span> <span class="keyword">and</span> (X[i]&gt;<span class="number">1</span> <span class="keyword">or</span> Y[j]&gt;<span class="number">1</span>):</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：行列累计求和，但是只是用来判断而不是累加，然后遍历所有的元素。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countServers</span><span class="params">(self, g: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    X, Y = tuple(map(sum, g)), tuple(map(sum, zip(*g)))</span><br><span class="line">    <span class="keyword">return</span> sum(X[i]+Y[j]&gt;<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(g)) <span class="keyword">for</span> j <span class="keyword">in</span> range(len(g[<span class="number">0</span>])) <span class="keyword">if</span> g[i][j])</span><br></pre></td></tr></table></figure>
<h3 id="886-Possible-Bipartition"><a href="#886-Possible-Bipartition" class="headerlink" title="886. Possible Bipartition"></a>886. Possible Bipartition</h3><h4 id="将不喜欢的人放在两组中，根据关系是否能将其分为2组。原题"><a href="#将不喜欢的人放在两组中，根据关系是否能将其分为2组。原题" class="headerlink" title="将不喜欢的人放在两组中，根据关系是否能将其分为2组。原题"></a>将不喜欢的人放在两组中，根据关系是否能将其分为2组。<a href="https://leetcode.com/problems/possible-bipartition/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 4, dislikes = [[1,2],[1,3],[2,4]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: group1 [1,4], group2 [2,3]</span><br><span class="line"></span><br><span class="line">Input: N = 3, dislikes = [[1,2],[1,3],[2,3]]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p>方法一：dfs。此题想了半个多点才想明白，等同于在一个无向图中，寻找一个奇数边的环。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">possibleBipartition</span><span class="params">(self, N: int, dislikes: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">    g = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(N+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> a, b <span class="keyword">in</span> dislikes:</span><br><span class="line">        g[a].append(b)</span><br><span class="line">        g[b].append(a)</span><br><span class="line"></span><br><span class="line">    seen = set()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, p, p_len)</span>:</span></span><br><span class="line">        seen.add(i)</span><br><span class="line">        p[i] = p_len</span><br><span class="line">        <span class="keyword">for</span> nxt <span class="keyword">in</span> g[i]:</span><br><span class="line">            <span class="keyword">if</span> nxt <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="keyword">if</span> dfs(nxt, p, p_len+<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">elif</span> nxt <span class="keyword">in</span> p <span class="keyword">and</span> (p_len-p[nxt])&amp;<span class="number">1</span>==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        p.pop(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    p = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> seen <span class="keyword">and</span> dfs(i, p, <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>方法二：染色思想。0代表红色，1代表蓝色，每次将其不喜欢的人染成另一种颜色。这个代码比较简洁，不过稍微慢了一丢丢，50ms左右。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">possibleBipartition</span><span class="params">(self, N: int, dislikes: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">    g = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(N+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> a, b <span class="keyword">in</span> dislikes:</span><br><span class="line">        g[a].append(b)</span><br><span class="line">        g[b].append(a)</span><br><span class="line">    </span><br><span class="line">    color = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, c=<span class="number">0</span>)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> color:</span><br><span class="line">            <span class="keyword">return</span> color[i]==c</span><br><span class="line">        color[i] = c</span><br><span class="line">        <span class="keyword">return</span> all(dfs(j, c^<span class="number">1</span>) <span class="keyword">for</span> j <span class="keyword">in</span> g[i])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> all(dfs(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N+<span class="number">1</span>) </span><br><span class="line">               <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> color)</span><br></pre></td></tr></table></figure>
<h3 id="207-Course-Schedule"><a href="#207-Course-Schedule" class="headerlink" title="207. Course Schedule"></a>207. Course Schedule</h3><h4 id="课程调度，课程有依赖关系，问是否能完成所有的课程。原题"><a href="#课程调度，课程有依赖关系，问是否能完成所有的课程。原题" class="headerlink" title="课程调度，课程有依赖关系，问是否能完成所有的课程。原题"></a>课程调度，课程有依赖关系，问是否能完成所有的课程。<a href="https://leetcode.com/problems/course-schedule/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: numCourses = 2, prerequisites = [[1,0]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There are a total of 2 courses to take. </span><br><span class="line">             To take course 1 you should have finished course 0. So it is possible.</span><br></pre></td></tr></table></figure>
<p>方法一：dfs。注意这里状态要用3中，1表示遍历过，-1表示正在遍历，0表未遍历。这样可以避免重复的遍历。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canFinish</span><span class="params">(self, n: int, prerequisites: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">    g = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="keyword">for</span> a, b <span class="keyword">in</span> prerequisites:</span><br><span class="line">        g[a].append(b)</span><br><span class="line">        </span><br><span class="line">    seen = [<span class="number">0</span>] * n</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> seen[i] <span class="keyword">in</span> &#123;<span class="number">1</span>, <span class="number">-1</span>&#125;: <span class="keyword">return</span> seen[i]==<span class="number">1</span></span><br><span class="line">        seen[i] = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> any(<span class="keyword">not</span> dfs(j) <span class="keyword">for</span> j <span class="keyword">in</span> g[i]): <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        seen[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：这个方法优雅一点，来自Lee215. BFS Topological Sorting.</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canFinish</span><span class="params">(self, n: int, prerequisites: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">    g = collections.defaultdict(list)</span><br><span class="line">    degree = [<span class="number">0</span>] * n</span><br><span class="line">    <span class="keyword">for</span> u, v <span class="keyword">in</span> prerequisites:</span><br><span class="line">        g[v].append(u)</span><br><span class="line">        degree[u] -= <span class="number">1</span></span><br><span class="line">    bfs = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(n) <span class="keyword">if</span> degree[i]==<span class="number">0</span>]    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> bfs:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> g[i]:</span><br><span class="line">            degree[j] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> degree[j] == <span class="number">0</span>:</span><br><span class="line">                bfs.append(j)</span><br><span class="line">    <span class="keyword">return</span> len(bfs)==n</span><br></pre></td></tr></table></figure>
<h3 id="1462-Course-Schedule-IV"><a href="#1462-Course-Schedule-IV" class="headerlink" title="1462. Course Schedule IV"></a>1462. Course Schedule IV</h3><h4 id="和上题差不多，问题不一样，问的是根据给定的依赖关系，判断两节课是否有依赖。原题"><a href="#和上题差不多，问题不一样，问的是根据给定的依赖关系，判断两节课是否有依赖。原题" class="headerlink" title="和上题差不多，问题不一样，问的是根据给定的依赖关系，判断两节课是否有依赖。原题"></a>和上题差不多，问题不一样，问的是根据给定的依赖关系，判断两节课是否有依赖。<a href="https://leetcode.com/problems/course-schedule-iv/" target="_blank" rel="noopener">原题</a></h4><font color="#32CD32" size="3">方法一：dfs. 这个方法想了超出比赛时间限制了。但是也没过多久就优化 出来了。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkIfPrerequisite</span><span class="params">(self, n: int, prerequisites: List[List[int]], queries: List[List[int]])</span> -&gt; List[bool]:</span></span><br><span class="line">    g = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    q = [set() <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]         </span><br><span class="line">    <span class="keyword">for</span> u, v <span class="keyword">in</span> prerequisites:</span><br><span class="line">        g[u].append(v)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> q[i]:</span><br><span class="line">            <span class="keyword">return</span> q[i]</span><br><span class="line">        q[i].update(g[i])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> g[i]:</span><br><span class="line">            q[i].update(dfs(j))</span><br><span class="line">        <span class="keyword">return</span> q[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        dfs(i)</span><br><span class="line">    <span class="keyword">return</span> [b <span class="keyword">in</span> q[a] <span class="keyword">for</span> a, b <span class="keyword">in</span> queries]</span><br></pre></td></tr></table></figure>
<p>方法二：弗洛伊德算法，和求城市最小距离一样。时间复杂度是O(n3)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkIfPrerequisite</span><span class="params">(self, n: int, prerequisites: List[List[int]], queries: List[List[int]])</span> -&gt; List[bool]:</span></span><br><span class="line">    g = [[<span class="keyword">False</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="keyword">for</span> u, v <span class="keyword">in</span> prerequisites:</span><br><span class="line">        g[u][v] = <span class="keyword">True</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                g[i][j] = g[i][j] <span class="keyword">or</span> (g[i][k] <span class="keyword">and</span> g[k][j])</span><br><span class="line">    <span class="keyword">return</span> [g[i][j] <span class="keyword">for</span> i, j <span class="keyword">in</span> queries]</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法三：bfs. 拓扑排序。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkIfPrerequisite</span><span class="params">(self, n: int, prerequisites: List[List[int]], queries: List[List[int]])</span> -&gt; List[bool]:</span></span><br><span class="line">    g = collections.defaultdict(list)</span><br><span class="line">    degree = [<span class="number">0</span>] * n</span><br><span class="line">    pres = [set() <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="keyword">for</span> u, v <span class="keyword">in</span> prerequisites:</span><br><span class="line">        g[u].append(v)</span><br><span class="line">        degree[v] -= <span class="number">1</span></span><br><span class="line">        pres[v].add(u)</span><br><span class="line">    bfs = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(n) <span class="keyword">if</span> degree[i]==<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> bfs:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> g[i]:</span><br><span class="line">            degree[j] += <span class="number">1</span></span><br><span class="line">            pres[j] |= pres[i]</span><br><span class="line">            <span class="keyword">if</span> degree[j] == <span class="number">0</span>:</span><br><span class="line">                bfs.append(j)</span><br><span class="line">    <span class="keyword">return</span> [a <span class="keyword">in</span> pres[b] <span class="keyword">for</span> a, b <span class="keyword">in</span> queries]</span><br></pre></td></tr></table></figure>
<h3 id="1466-Reorder-Routes-to-Make-All-Paths-Lead-to-the-City-Zero"><a href="#1466-Reorder-Routes-to-Make-All-Paths-Lead-to-the-City-Zero" class="headerlink" title="1466. Reorder Routes to Make All Paths Lead to the City Zero"></a>1466. Reorder Routes to Make All Paths Lead to the City Zero</h3><h4 id="有一个有向图，两个节点之间只有一条边，要求所有的边指向0，需要改多少条边的方向。原题"><a href="#有一个有向图，两个节点之间只有一条边，要求所有的边指向0，需要改多少条边的方向。原题" class="headerlink" title="有一个有向图，两个节点之间只有一条边，要求所有的边指向0，需要改多少条边的方向。原题"></a>有一个有向图，两个节点之间只有一条边，要求所有的边指向0，需要改多少条边的方向。<a href="https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 6, connections = [[0,1],[1,3],[2,3],[4,0],[4,5]]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Change the direction of edges show in red such that each node can reach the node 0 (capital).</span><br></pre></td></tr></table></figure>
<p>方法一：此题竞赛时未作出。一个效率不是很高的方法。用父节点去重。set记录原始顺序，遍历无向图。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minReorder</span><span class="params">(self, n: int, connections: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    self.ans = <span class="number">0</span></span><br><span class="line">    g = collections.defaultdict(list)</span><br><span class="line">    roads = set()</span><br><span class="line">    <span class="keyword">for</span> u, v <span class="keyword">in</span> connections:</span><br><span class="line">        g[u].append(v)</span><br><span class="line">        g[v].append(u)</span><br><span class="line">        roads.add((u, v))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, parent)</span>:</span></span><br><span class="line">        self.ans += (parent, i) <span class="keyword">in</span> roads</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> g[i]:</span><br><span class="line">            <span class="keyword">if</span> j == parent:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            dfs(j, i)</span><br><span class="line">    </span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure>
<p>方法二：比赛时想的思路，dfs内容未想出来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minReorder</span><span class="params">(self, n: int, connections: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    g1 = collections.defaultdict(list)</span><br><span class="line">    g2 = collections.defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> u, v <span class="keyword">in</span> connections:</span><br><span class="line">        g1[u].append(v)</span><br><span class="line">        g2[v].append(u)</span><br><span class="line">    </span><br><span class="line">    seen = set()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i)</span>:</span></span><br><span class="line">        seen.add(i)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> g1[i]:</span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                ans += <span class="number">1</span> + dfs(j)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> g2[i]:</span><br><span class="line">            <span class="keyword">if</span> k <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                ans += dfs(k)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="1210-Minimum-Moves-to-Reach-Target-with-Rotations"><a href="#1210-Minimum-Moves-to-Reach-Target-with-Rotations" class="headerlink" title="1210. Minimum Moves to Reach Target with Rotations"></a>1210. Minimum Moves to Reach Target with Rotations</h3><h4 id="一个占位2格的蛇，从左上走到右下需要最少的步数，可以旋转。原题"><a href="#一个占位2格的蛇，从左上走到右下需要最少的步数，可以旋转。原题" class="headerlink" title="一个占位2格的蛇，从左上走到右下需要最少的步数，可以旋转。原题"></a>一个占位2格的蛇，从左上走到右下需要最少的步数，可以旋转。<a href="https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[0,0,0,0,0,1],</span><br><span class="line">               [1,1,0,0,1,0],</span><br><span class="line">               [0,0,0,0,1,1],</span><br><span class="line">               [0,0,1,0,1,0],</span><br><span class="line">               [0,1,1,0,0,0],</span><br><span class="line">               [0,1,1,0,0,0]]</span><br><span class="line">Output: 11</span><br><span class="line">Explanation:</span><br><span class="line">One possible solution is [right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise, right, down].</span><br></pre></td></tr></table></figure>
<p>方法一：这题没想到在写完还有10分钟，其实思路很简单，就是拿两个点当成一个点。一个点的bfs就很容易了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minimumMoves</span><span class="params">(self, g: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    n = len(g)</span><br><span class="line">    q = collections.deque([((<span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), <span class="number">0</span>)])</span><br><span class="line">    seen = set(((<span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>)))</span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        tail, head, step = q.popleft()</span><br><span class="line">        <span class="keyword">if</span> tail[<span class="number">0</span>] == head[<span class="number">0</span>] == head[<span class="number">1</span>] == n<span class="number">-1</span> <span class="keyword">and</span> tail[<span class="number">1</span>]==n<span class="number">-2</span>:</span><br><span class="line">            <span class="keyword">return</span> step</span><br><span class="line">        <span class="keyword">if</span> tail[<span class="number">0</span>] == head[<span class="number">0</span>] <span class="keyword">and</span> tail[<span class="number">0</span>]!=n<span class="number">-1</span>: <span class="comment"># horizontal</span></span><br><span class="line">            d_tail, d_head = (tail[<span class="number">0</span>]+<span class="number">1</span>, tail[<span class="number">1</span>]), (head[<span class="number">0</span>]+<span class="number">1</span>, head[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> g[d_tail[<span class="number">0</span>]][d_tail[<span class="number">1</span>]] == g[d_head[<span class="number">0</span>]][d_head[<span class="number">1</span>]] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> (tail, d_tail) <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                    q.append((tail, d_tail, step+<span class="number">1</span>))</span><br><span class="line">                    seen.add((tail, d_tail))</span><br><span class="line">        <span class="keyword">if</span> tail[<span class="number">1</span>] == head[<span class="number">1</span>] <span class="keyword">and</span> tail[<span class="number">1</span>]!=n<span class="number">-1</span>: <span class="comment"># vertical</span></span><br><span class="line">            r_tail, r_head = (tail[<span class="number">0</span>], tail[<span class="number">1</span>]+<span class="number">1</span>), (head[<span class="number">0</span>], head[<span class="number">1</span>]+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> g[r_tail[<span class="number">0</span>]][r_tail[<span class="number">1</span>]] == g[r_head[<span class="number">0</span>]][r_head[<span class="number">1</span>]] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> (tail, r_tail) <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                    q.append((tail, r_tail, step+<span class="number">1</span>))</span><br><span class="line">                    seen.add((tail, r_tail))</span><br><span class="line">        <span class="keyword">if</span> head[<span class="number">1</span>] != n<span class="number">-1</span>:</span><br><span class="line">            r_head = head[<span class="number">0</span>], head[<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">            r_tail = tail[<span class="number">0</span>], tail[<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> g[r_head[<span class="number">0</span>]][r_head[<span class="number">1</span>]] == g[r_tail[<span class="number">0</span>]][r_tail[<span class="number">1</span>]] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> (r_tail, r_head) <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                    q.append((r_tail, r_head, step+<span class="number">1</span>))                    </span><br><span class="line">                    seen.add((r_tail, r_head))</span><br><span class="line">        <span class="keyword">if</span> head[<span class="number">0</span>] != n<span class="number">-1</span>:</span><br><span class="line">            d_head = head[<span class="number">0</span>]+<span class="number">1</span>, head[<span class="number">1</span>]</span><br><span class="line">            d_tail = tail[<span class="number">0</span>]+<span class="number">1</span>, tail[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> g[d_head[<span class="number">0</span>]][d_head[<span class="number">1</span>]] == g[d_tail[<span class="number">0</span>]][d_tail[<span class="number">1</span>]] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> (d_tail, d_head) <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                    q.append((d_tail, d_head, step+<span class="number">1</span>))</span><br><span class="line">                    seen.add((d_tail, d_head))</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：另一种思路将蛇的横竖状态记录，这样一个点也能表示。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minimumMoves</span><span class="params">(self, g: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    n = len(g)</span><br><span class="line">    q, seen, target = [(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)], set(), (n<span class="number">-1</span>, n<span class="number">-2</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> r, c, dr, step <span class="keyword">in</span> q:</span><br><span class="line">        <span class="keyword">if</span> (r, c, dr) == target: <span class="keyword">return</span> step</span><br><span class="line">        <span class="keyword">if</span> (r, c, dr) <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">            seen.add((r, c, dr))</span><br><span class="line">            <span class="keyword">if</span> dr:</span><br><span class="line">                <span class="keyword">if</span> c+<span class="number">1</span>&lt;n <span class="keyword">and</span> g[r][c+<span class="number">1</span>]==g[r+<span class="number">1</span>][c+<span class="number">1</span>]==<span class="number">0</span>:</span><br><span class="line">                    q += [(r, c+<span class="number">1</span>, <span class="number">1</span>, step+<span class="number">1</span>), (r, c, <span class="number">0</span>, step+<span class="number">1</span>)]</span><br><span class="line">                <span class="keyword">if</span> r+<span class="number">2</span>&lt;n <span class="keyword">and</span> g[r+<span class="number">2</span>][c]==<span class="number">0</span>:</span><br><span class="line">                    q += [(r+<span class="number">1</span>, c, <span class="number">1</span>, step+<span class="number">1</span>)]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> r+<span class="number">1</span>&lt;n <span class="keyword">and</span> g[r+<span class="number">1</span>][c]==g[r+<span class="number">1</span>][c+<span class="number">1</span>]==<span class="number">0</span>:</span><br><span class="line">                    q += [(r+<span class="number">1</span>, c, <span class="number">0</span>, step+<span class="number">1</span>), (r, c, <span class="number">1</span>, step+<span class="number">1</span>)]</span><br><span class="line">                <span class="keyword">if</span> c+<span class="number">2</span>&lt;n <span class="keyword">and</span> g[r][c+<span class="number">2</span>]==<span class="number">0</span>:</span><br><span class="line">                    q += [(r, c+<span class="number">1</span>, <span class="number">0</span>, step+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="1202-Smallest-String-With-Swaps"><a href="#1202-Smallest-String-With-Swaps" class="headerlink" title="1202. Smallest String With Swaps"></a>1202. Smallest String With Swaps</h3><h4 id="给定一组pairs表明索引对可以互换，求这个字符串能换的最小值时多少，同一对可以进行多次互换。原题"><a href="#给定一组pairs表明索引对可以互换，求这个字符串能换的最小值时多少，同一对可以进行多次互换。原题" class="headerlink" title="给定一组pairs表明索引对可以互换，求这个字符串能换的最小值时多少，同一对可以进行多次互换。原题"></a>给定一组pairs表明索引对可以互换，求这个字符串能换的最小值时多少，同一对可以进行多次互换。<a href="https://leetcode.com/problems/smallest-string-with-swaps/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;dcab&quot;, pairs = [[0,3],[1,2]]</span><br><span class="line">Output: &quot;bacd&quot;</span><br><span class="line">Explaination: </span><br><span class="line">Swap s[0] and s[3], s = &quot;bcad&quot;</span><br><span class="line">Swap s[1] and s[2], s = &quot;bacd&quot;</span><br></pre></td></tr></table></figure>
<p>方法一：看了几个例子想一想就明白了，实际上是一道连通器的题，将连通的索引单独排序就是最小的值。</p>
<p>竞赛时ac的方法用的是dfs. 内存用的有点多。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smallestStringWithSwaps</span><span class="params">(self, s: str, pairs: List[List[int]])</span> -&gt; str:</span></span><br><span class="line">    g = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(s))]</span><br><span class="line">    ans = [<span class="string">''</span>] * len(s)</span><br><span class="line">    <span class="keyword">for</span> a, b <span class="keyword">in</span> pairs:</span><br><span class="line">        g[a].append(b)</span><br><span class="line">        g[b].append(a)</span><br><span class="line">    </span><br><span class="line">    seen = [<span class="keyword">False</span>] * len(s)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, p)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> seen[i]:</span><br><span class="line">            seen[i] = <span class="keyword">True</span></span><br><span class="line">            p.append(i)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> g[i]:</span><br><span class="line">                dfs(j, p)</span><br><span class="line">            <span class="keyword">return</span> p</span><br><span class="line">    </span><br><span class="line">    groups = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        tmp = dfs(i, [])</span><br><span class="line">        <span class="keyword">if</span> tmp:</span><br><span class="line">            groups.append(tmp)</span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> groups:</span><br><span class="line">        letters = iter(sorted(s[i] <span class="keyword">for</span> i <span class="keyword">in</span> idx))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> sorted(idx):</span><br><span class="line">            ans[i] = next(letters)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(ans)</span><br></pre></td></tr></table></figure>
<p>方法二：做了一点优化。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smallestStringWithSwaps</span><span class="params">(self, s: str, pairs: List[List[int]])</span> -&gt; str:</span></span><br><span class="line">    g = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(s))]</span><br><span class="line">    ans = [<span class="string">''</span>] * len(s)</span><br><span class="line">    <span class="keyword">for</span> a, b <span class="keyword">in</span> pairs:</span><br><span class="line">        g[a].append(b)</span><br><span class="line">        g[b].append(a)</span><br><span class="line">    </span><br><span class="line">    seen = [<span class="keyword">False</span>] * len(s)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i)</span>:</span></span><br><span class="line">        seen[i] = <span class="keyword">True</span></span><br><span class="line">        p.append(i)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> g[i]:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> seen[j]:</span><br><span class="line">                dfs(j)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        p = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> seen[i]:</span><br><span class="line">            dfs(i)</span><br><span class="line">        letters = iter(sorted(s[i] <span class="keyword">for</span> i <span class="keyword">in</span> p))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> sorted(p):</span><br><span class="line">            ans[i] = next(letters)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(ans)</span><br></pre></td></tr></table></figure>
<p>方法三：union-find。这个评论区里看到的方法写得很标准。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smallestStringWithSwaps</span><span class="params">(self, s: str, pairs: List[List[int]])</span> -&gt; str:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UF</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">            self.p = list(range(n))</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">            self.p[self.find(x)] = self.find(y)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> x!=self.p[x]:</span><br><span class="line">                self.p[x] = self.find(self.p[x])</span><br><span class="line">            <span class="keyword">return</span> self.p[x]</span><br><span class="line">    uf, res, m = UF(len(s)), [], defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> pairs:</span><br><span class="line">        uf.union(x, y)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        m[uf.find(i)].append(s[i])</span><br><span class="line">    <span class="keyword">for</span> comp_id <span class="keyword">in</span> m.keys(): </span><br><span class="line">        m[comp_id].sort(reverse=<span class="keyword">True</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)): </span><br><span class="line">        res.append(m[uf.find(i)].pop())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(res)</span><br></pre></td></tr></table></figure>
<h3 id="787-Cheapest-Flights-Within-K-Stops"><a href="#787-Cheapest-Flights-Within-K-Stops" class="headerlink" title="787. Cheapest Flights Within K Stops"></a>787. Cheapest Flights Within K Stops</h3><h4 id="经过K个站点的最便宜的航班。原题"><a href="#经过K个站点的最便宜的航班。原题" class="headerlink" title="经过K个站点的最便宜的航班。原题"></a>经过K个站点的最便宜的航班。<a href="https://leetcode.com/problems/cheapest-flights-within-k-stops/" target="_blank" rel="noopener">原题</a></h4><p>方法一：狄克斯特拉算法，只不过多了一个条件，经过K个站点。不需要用seen记录已经去过的点，因为该点可能有更少步数的到达方式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findCheapestPrice</span><span class="params">(self, n: int, flights: List[List[int]], src: int, dst: int, K: int)</span> -&gt; int:</span></span><br><span class="line">    g = collections.defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> u, v, w <span class="keyword">in</span> flights:</span><br><span class="line">        g[u].append((v, w))</span><br><span class="line">    </span><br><span class="line">    q = [(<span class="number">0</span>, src, <span class="number">0</span>)]</span><br><span class="line">    heapq.heapify(q)</span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        p, city, step = heapq.heappop(q)</span><br><span class="line">        <span class="keyword">if</span> city == dst:</span><br><span class="line">            <span class="keyword">return</span> p</span><br><span class="line">        <span class="keyword">for</span> v, w <span class="keyword">in</span> g[city]:</span><br><span class="line">            <span class="keyword">if</span> step &lt; K+<span class="number">1</span>:</span><br><span class="line">                heapq.heappush(q, (p+w, v, step+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="332-Reconstruct-Itinerary"><a href="#332-Reconstruct-Itinerary" class="headerlink" title="332. Reconstruct Itinerary"></a>332. Reconstruct Itinerary</h3><h4 id="重建行程，根据火车票来寻找行程，答案不唯一。原题"><a href="#重建行程，根据火车票来寻找行程，答案不唯一。原题" class="headerlink" title="重建行程，根据火车票来寻找行程，答案不唯一。原题"></a>重建行程，根据火车票来寻找行程，答案不唯一。<a href="https://leetcode.com/problems/reconstruct-itinerary/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[&quot;MUC&quot;, &quot;LHR&quot;], [&quot;JFK&quot;, &quot;MUC&quot;], [&quot;SFO&quot;, &quot;SJC&quot;], [&quot;LHR&quot;, &quot;SFO&quot;]]</span><br><span class="line">Output: [&quot;JFK&quot;, &quot;MUC&quot;, &quot;LHR&quot;, &quot;SFO&quot;, &quot;SJC&quot;]</span><br></pre></td></tr></table></figure>
<p>方法一：首次ac的方法，直接修改g。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findItinerary</span><span class="params">(self, tickets: List[List[str]])</span> -&gt; List[str]:</span></span><br><span class="line">    g = collections.defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> u, v <span class="keyword">in</span> tickets:</span><br><span class="line">        g[u].append(v)</span><br><span class="line">    <span class="keyword">for</span> u <span class="keyword">in</span> g.keys():</span><br><span class="line">        g[u].sort()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(city, p)</span>:</span>  </span><br><span class="line">        <span class="comment"># print(city, p, g)</span></span><br><span class="line">        p.append(city)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> g:</span><br><span class="line">            <span class="keyword">return</span> p</span><br><span class="line">        org = g[city]</span><br><span class="line">        <span class="keyword">for</span> i, nxt <span class="keyword">in</span> enumerate(g[city]):</span><br><span class="line">            g[city] = g[city][:i] + g[city][i+<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> g[city]:</span><br><span class="line">                <span class="keyword">del</span> g[city]</span><br><span class="line">            <span class="keyword">if</span> dfs(nxt, p):</span><br><span class="line">                <span class="keyword">return</span> p</span><br><span class="line">            g[city] = org</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> org:</span><br><span class="line">            <span class="keyword">del</span> g[city]</span><br><span class="line">        p.pop()</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="string">'JFK'</span>, [])</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：用两个倒序可以解决</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findItinerary</span><span class="params">(self, tickets: List[List[str]])</span> -&gt; List[str]:</span></span><br><span class="line">    g = collections.defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> u, v <span class="keyword">in</span> sorted(tickets, reverse=<span class="keyword">True</span>):</span><br><span class="line">        g[u].append(v)</span><br><span class="line">        </span><br><span class="line">    ans = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(city)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> g[city]:</span><br><span class="line">            dfs(g[city].pop())</span><br><span class="line">        ans.append(city)</span><br><span class="line">        </span><br><span class="line">    dfs(<span class="string">'JFK'</span>)</span><br><span class="line">    <span class="keyword">return</span> ans[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="1519-Number-of-Nodes-in-the-Sub-Tree-With-the-Same-Label"><a href="#1519-Number-of-Nodes-in-the-Sub-Tree-With-the-Same-Label" class="headerlink" title="1519. Number of Nodes in the Sub-Tree With the Same Label"></a>1519. Number of Nodes in the Sub-Tree With the Same Label</h3><h4 id="有一个数的图，每个节点有个字母，返回每个节点的子树中包含这个字母的总个数。原题"><a href="#有一个数的图，每个节点有个字母，返回每个节点的子树中包含这个字母的总个数。原题" class="headerlink" title="有一个数的图，每个节点有个字母，返回每个节点的子树中包含这个字母的总个数。原题"></a>有一个数的图，每个节点有个字母，返回每个节点的子树中包含这个字母的总个数。<a href="https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/" target="_blank" rel="noopener">原题</a></h4><p>方法一：这个题作为竞赛的第二题是在是太恶心了，结束后我想了很长时间才想出来。dfs + counter, 每个节点都有它独立的一个counter。 因为字母不同、</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countSubTrees</span><span class="params">(self, n: int, edges: List[List[int]], labels: str)</span> -&gt; List[int]:</span></span><br><span class="line">    g = collections.defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> u, v <span class="keyword">in</span> edges:</span><br><span class="line">        g[u].append(v)</span><br><span class="line">        g[v].append(u)</span><br><span class="line"></span><br><span class="line">    seen = [<span class="keyword">False</span>] * n</span><br><span class="line">    c = Counter()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node)</span>:</span></span><br><span class="line">        cur = Counter()</span><br><span class="line">        seen[node] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> nxt <span class="keyword">in</span> g[node]:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> seen[nxt]:</span><br><span class="line">                cur += dfs(nxt)</span><br><span class="line">        label = labels[node]</span><br><span class="line">        cur[label] += <span class="number">1</span></span><br><span class="line">        ans[node] = cur[label]</span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line">        </span><br><span class="line">    ans = [<span class="number">0</span>] * n</span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：优化方法一</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countSubTrees</span><span class="params">(self, n: int, edges: List[List[int]], labels: str)</span> -&gt; List[int]:</span></span><br><span class="line">    g = collections.defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> u, v <span class="keyword">in</span> edges:</span><br><span class="line">        g[u].append(v)</span><br><span class="line">        g[v].append(u)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node, p)</span>:</span></span><br><span class="line">        cur = Counter(labels[node])</span><br><span class="line">        <span class="keyword">for</span> nxt <span class="keyword">in</span> g[node]:</span><br><span class="line">            <span class="keyword">if</span> nxt != p:</span><br><span class="line">                cur += dfs(nxt, node)</span><br><span class="line">        ans[node] = cur[labels[node]]</span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line">        </span><br><span class="line">    ans = [<span class="number">0</span>] * n</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="478-Generate-Random-Point-in-a-Circle"><a href="#478-Generate-Random-Point-in-a-Circle" class="headerlink" title="478. Generate Random Point in a Circle"></a>478. Generate Random Point in a Circle</h3><h4 id="在给定圆的范围内随机生成点。原题"><a href="#在给定圆的范围内随机生成点。原题" class="headerlink" title="在给定圆的范围内随机生成点。原题"></a>在给定圆的范围内随机生成点。<a href="https://leetcode.com/problems/generate-random-point-in-a-circle/" target="_blank" rel="noopener">原题</a></h4><p>方法一：严格来说 这是一道几何题，为什么要将其开方，因为如果没有开方，对于一个圆来说，半径越小的地方点就越密集，因为在该周长上所有的点分布是一样的。开方可以让半径小的点降低分布。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, radius: float, x_center: float, y_center: float)</span>:</span></span><br><span class="line">        self.r = radius</span><br><span class="line">        self.x = x_center</span><br><span class="line">        self.y = y_center</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">randPoint</span><span class="params">(self)</span> -&gt; List[float]:</span></span><br><span class="line">        <span class="keyword">import</span> random</span><br><span class="line">        edge = math.sqrt(random.random()) * self.r</span><br><span class="line">        deg = random.random()*<span class="number">2</span>*math.pi</span><br><span class="line">        x = self.x + edge*math.cos(deg)</span><br><span class="line">        y = self.y + edge*math.sin(deg)</span><br><span class="line">        <span class="keyword">return</span> x, y</span><br></pre></td></tr></table></figure>
<h3 id="1559-Detect-Cycles-in-2D-Grid"><a href="#1559-Detect-Cycles-in-2D-Grid" class="headerlink" title="1559. Detect Cycles in 2D Grid"></a>1559. Detect Cycles in 2D Grid</h3><h4 id="2D-矩阵中判断是否有环。原题"><a href="#2D-矩阵中判断是否有环。原题" class="headerlink" title="2D 矩阵中判断是否有环。原题"></a>2D 矩阵中判断是否有环。<a href="https://leetcode.com/problems/detect-cycles-in-2d-grid/" target="_blank" rel="noopener">原题</a></h4><p>方法一：这个题就差一点没想出来，就是怎么避免重复的路径，那就是需要和前一个点比对。看了这个提示后瞬间就完成了。时间空间待优化。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">containsCycle</span><span class="params">(self, g: List[List[str]])</span> -&gt; bool:</span></span><br><span class="line">    m, n = len(g), len(g[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    visited = [[<span class="keyword">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spread</span><span class="params">(x, y, c, a, b)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> visited[x][y]:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        visited[x][y] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> ((x<span class="number">-1</span>, y), (x+<span class="number">1</span>, y), (x, y<span class="number">-1</span>), (x, y+<span class="number">1</span>)):</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span>&lt;=i&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=j&lt;n <span class="keyword">and</span> c==g[i][j] <span class="keyword">and</span> (i, j)!=(a, b):</span><br><span class="line">                <span class="keyword">if</span> spread(i, j, c, x, y):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> visited[i][j] <span class="keyword">and</span> spread(i, j, g[i][j], i, j):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h3 id="310-Minimum-Height-Trees"><a href="#310-Minimum-Height-Trees" class="headerlink" title="310. Minimum Height Trees"></a>310. Minimum Height Trees</h3><h4 id="有一个无向图，0-n-1这些节点，每两个节点只有一条边，找出这种节点，当以节点为根时，组成的树有最小的高度。原题"><a href="#有一个无向图，0-n-1这些节点，每两个节点只有一条边，找出这种节点，当以节点为根时，组成的树有最小的高度。原题" class="headerlink" title="有一个无向图，0~n-1这些节点，每两个节点只有一条边，找出这种节点，当以节点为根时，组成的树有最小的高度。原题"></a>有一个无向图，0~n-1这些节点，每两个节点只有一条边，找出这种节点，当以节点为根时，组成的树有最小的高度。<a href="https://leetcode.com/problems/minimum-height-trees/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]</span><br><span class="line"></span><br><span class="line">     0  1  2</span><br><span class="line">      \ | /</span><br><span class="line">        3</span><br><span class="line">        |</span><br><span class="line">        4</span><br><span class="line">        |</span><br><span class="line">        5 </span><br><span class="line"></span><br><span class="line">Output: [3, 4]</span><br></pre></td></tr></table></figure>
<p>方法一：这个解法很棒，评论区的解法，以前看这种题的时候，想到的是bfs，这个解法的核心思想是剪枝。每次将叶子节点剪去。最后剩下的 一个或者2个节点 就是最小高度的根节点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMinHeightTrees</span><span class="params">(self, n: int, edges: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> [<span class="number">0</span>]</span><br><span class="line">    g = collections.defaultdict(set)</span><br><span class="line">    <span class="keyword">for</span> u, v <span class="keyword">in</span> edges:</span><br><span class="line">        g[u].add(v)</span><br><span class="line">        g[v].add(u)</span><br><span class="line">        </span><br><span class="line">    leaves = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(n) <span class="keyword">if</span> len(g[i])==<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">2</span>:</span><br><span class="line">        n -= len(leaves)</span><br><span class="line">        new_leaves = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> leaves:</span><br><span class="line">            j = g[i].pop()</span><br><span class="line">            g[j].remove(i)</span><br><span class="line">            <span class="keyword">if</span> len(g[j])==<span class="number">1</span>: new_leaves.append(j)</span><br><span class="line">        leaves = new_leaves</span><br><span class="line">    <span class="keyword">return</span> leaves</span><br></pre></td></tr></table></figure>
<h3 id="127-Word-Ladder"><a href="#127-Word-Ladder" class="headerlink" title="127. Word Ladder"></a>127. Word Ladder</h3><h4 id="每次可以改变单词中的一个字母，但必须在wordList中，问最少需要多少次能达到目标单词。原题"><a href="#每次可以改变单词中的一个字母，但必须在wordList中，问最少需要多少次能达到目标单词。原题" class="headerlink" title="每次可以改变单词中的一个字母，但必须在wordList中，问最少需要多少次能达到目标单词。原题"></a>每次可以改变单词中的一个字母，但必须在wordList中，问最少需要多少次能达到目标单词。<a href="https://leetcode.com/problems/word-ladder/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord = &quot;hit&quot;,</span><br><span class="line">endWord = &quot;cog&quot;,</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">Output: 5</span><br><span class="line"></span><br><span class="line">Explanation: As one shortest transformation is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,</span><br><span class="line">return its length 5.</span><br></pre></td></tr></table></figure>
<p>方法一：BFS很好想，但是要想如何去重，wordList可能非常大，所以不能遍历，因为只有26个字母可以变，所以可以变换完比较。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ladderLength</span><span class="params">(self, beginWord: str, endWord: str, wordList: List[str])</span> -&gt; int:</span></span><br><span class="line">    q = [(beginWord, <span class="number">1</span>)]</span><br><span class="line">    words_set = set(wordList)</span><br><span class="line">    letters = string.ascii_lowercase</span><br><span class="line">    <span class="keyword">for</span> w, step <span class="keyword">in</span> q:</span><br><span class="line">        <span class="keyword">if</span> w == endWord: <span class="keyword">return</span> step</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(w)):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> letters:</span><br><span class="line">                nw = w[:i] + c + w[i+<span class="number">1</span>:]</span><br><span class="line">                <span class="keyword">if</span> nw <span class="keyword">in</span> words_set:</span><br><span class="line">                    q.append((nw, step+<span class="number">1</span>))</span><br><span class="line">                    words_set.remove(nw)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="547-Friend-Circles"><a href="#547-Friend-Circles" class="headerlink" title="547. Friend Circles"></a>547. Friend Circles</h3><h4 id="朋友圈，一堆人拉帮结伙，朋友关系可以传递。通过二维数组表示i-j两个人是否是朋友。问N个人有多少个帮派。原题"><a href="#朋友圈，一堆人拉帮结伙，朋友关系可以传递。通过二维数组表示i-j两个人是否是朋友。问N个人有多少个帮派。原题" class="headerlink" title="朋友圈，一堆人拉帮结伙，朋友关系可以传递。通过二维数组表示i, j两个人是否是朋友。问N个人有多少个帮派。原题"></a>朋友圈，一堆人拉帮结伙，朋友关系可以传递。通过二维数组表示i, j两个人是否是朋友。问N个人有多少个帮派。<a href="https://leetcode.com/problems/friend-circles/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[[1,1,0],</span><br><span class="line"> [1,1,0],</span><br><span class="line"> [0,0,1]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:The 0th and 1st students are direct friends, so they are in a friend circle. </span><br><span class="line">The 2nd student himself is in a friend circle. So return 2.</span><br></pre></td></tr></table></figure>
<p>方法一：典型的Union-Find。最后结果还要遍历一下，才是最终结果。<code>[[1,0,0,1],[0,1,1,0],[0,1,1,1],[1,0,1,1]]</code>这个case在union之后，是<code>[3,2,3,3]</code>因为2的朋友在1计算之后变成了3。最终点更新了。所以遍历之后是<code>[3,3,3,3]</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findCircleNum</span><span class="params">(self, M: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(x, y)</span>:</span></span><br><span class="line">        uf[find(x)] = find(y)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x != uf[x]:</span><br><span class="line">            uf[x] = find(uf[x])</span><br><span class="line">        <span class="keyword">return</span> uf[x] </span><br><span class="line">    </span><br><span class="line">    N = len(M)</span><br><span class="line">    uf = list(range(N))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">if</span> M[i][j]:</span><br><span class="line">                union(i, j)</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">return</span> len(&#123;find(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(N)&#125;)</span><br></pre></td></tr></table></figure>
<p>方法二：评论中有个dfs 也不错，行列循环分开了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findCircleNum</span><span class="params">(self, M: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    ans, N = <span class="number">0</span>, len(M)</span><br><span class="line">    seen = set()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> j, r <span class="keyword">in</span> enumerate(M[i]):</span><br><span class="line">            <span class="keyword">if</span> r <span class="keyword">and</span> j <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                seen.add(j)</span><br><span class="line">                dfs(j)</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">            dfs(i)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>方法三：stefan的科学库和numpy写法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scipy.sparse</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findCircleNum</span><span class="params">(self, M)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> scipy.sparse.csgraph.connected_components(M)[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findCircleNum</span><span class="params">(self, M)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(set(map(tuple, (np.matrix(M, dtype=<span class="string">'bool'</span>)**len(M)).A)))</span><br></pre></td></tr></table></figure>
<h3 id="1584-Min-Cost-to-Connect-All-Points"><a href="#1584-Min-Cost-to-Connect-All-Points" class="headerlink" title="1584. Min Cost to Connect All Points"></a>1584. Min Cost to Connect All Points</h3><h4 id="所有点最小的曼哈顿距离-xi-xj-yi-yj-和为多少。原题"><a href="#所有点最小的曼哈顿距离-xi-xj-yi-yj-和为多少。原题" class="headerlink" title="所有点最小的曼哈顿距离|xi - xj| + |yi - yj|和为多少。原题"></a>所有点最小的曼哈顿距离|xi - xj| + |yi - yj|和为多少。<a href="https://leetcode.com/problems/min-cost-to-connect-all-points/" target="_blank" rel="noopener">原题</a></h4><p>方法一：贪心法。这题有很多方法，然而比赛时一种也没写出来。首先贪心可以，由于是n^2的复杂度，所以没有敢写。</p>
<p>毕竟n=1000。评论区的做法，为什么贪心可行，想象一下，最后所有的点相连，每2点只有一条边，而且是最小的边。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minCostConnectPoints</span><span class="params">(self, points: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    n, ans = len(points), <span class="number">0</span></span><br><span class="line">    seen = set()</span><br><span class="line">    dis = [float(<span class="string">'inf'</span>)] * n</span><br><span class="line">    cur = <span class="number">0</span></span><br><span class="line">    <span class="comment"># n-1 edges</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">        x, y = points[cur]</span><br><span class="line">        seen.add(cur)</span><br><span class="line">        <span class="keyword">for</span> j, (nx, ny) <span class="keyword">in</span> enumerate(points):</span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">in</span> seen: <span class="keyword">continue</span></span><br><span class="line">            dis[j] = min(dis[j], abs(nx-x)+abs(ny-y))</span><br><span class="line">        s, cur = min((d, j) <span class="keyword">for</span> j, d <span class="keyword">in</span> enumerate(dis))</span><br><span class="line">        dis[cur] = float(<span class="string">'inf'</span>)</span><br><span class="line">        ans += s</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>方法二：最小生成树。这是经典的最小生成树问题，有两种实现的方式，一种是Prim算法。一种是Kruskal算法。比贪心法慢了400ms，花费1580ms，还以为是我实现的问题，结果看评论区中的要2s多。空间则是贪心的5倍多。因为此题需要找到各个边的权重，所以即使是Prim算法，时间复杂度也是O(n^2)。Prim算法是每次以新的顶点找到最小的权重边。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minCostConnectPoints</span><span class="params">(self, p: List[List[int]])</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">manhattan</span><span class="params">(x, y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> abs(x[<span class="number">0</span>]-y[<span class="number">0</span>]) + abs(x[<span class="number">1</span>]-y[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    ans, n = <span class="number">0</span>, len(p)</span><br><span class="line">    seen = set()</span><br><span class="line">    vertices = [(<span class="number">0</span>, (<span class="number">0</span>, <span class="number">0</span>))]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> len(seen) &lt; n:</span><br><span class="line">        <span class="comment"># print(vertices, seen)</span></span><br><span class="line">        w, (u, v) = heapq.heappop(vertices)            </span><br><span class="line">        <span class="keyword">if</span> u <span class="keyword">in</span> seen <span class="keyword">and</span> v <span class="keyword">in</span> seen: <span class="keyword">continue</span></span><br><span class="line">        ans += w</span><br><span class="line">        seen.add(v)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> seen <span class="keyword">and</span> j!=v:</span><br><span class="line">                heapq.heappush(vertices, (manhattan(p[j], p[v]), (v, j)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>方法三：Kruskal，克鲁斯卡尔算法。原理是Union-Find。按照所有的权重看，每次产生一条边，但不一定和已有的边构成环。理论上来说比Prim算法要慢。实际运行却比prim快了1、200ms。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minCostConnectPoints</span><span class="params">(self, p: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    edges, n, cnt, ans = [], len(p), <span class="number">1</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">manhattan</span><span class="params">(x, y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> abs(p[x][<span class="number">0</span>]-p[y][<span class="number">0</span>]) + abs(p[x][<span class="number">1</span>]-p[y][<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    edges = [(manhattan(i, j), (i, j)) </span><br><span class="line">             <span class="keyword">for</span> i <span class="keyword">in</span> range(n) <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, n)]</span><br><span class="line">    heapq.heapify(edges)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(x, y)</span>:</span></span><br><span class="line">        uf[find(x)] = find(y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x != uf[x]:</span><br><span class="line">            uf[x] = find(uf[x])</span><br><span class="line">        <span class="keyword">return</span> uf[x]</span><br><span class="line"></span><br><span class="line">    uf = list(range(n))</span><br><span class="line">    <span class="keyword">while</span> cnt &lt; n:</span><br><span class="line">        d, (u, v) = heapq.heappop(edges)</span><br><span class="line">        <span class="keyword">if</span> find(u) != find(v):</span><br><span class="line">            ans += d</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            union(u, v)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="684-Redundant-Connection"><a href="#684-Redundant-Connection" class="headerlink" title="684. Redundant Connection"></a>684. Redundant Connection</h3><h4 id="多余的边，有一个无向图有N个节点，和N个边，对于一个连通器来说，刚好多了一条边。找到这条多余的边，所有的边给的-u-v-均满足u-lt-u。原题"><a href="#多余的边，有一个无向图有N个节点，和N个边，对于一个连通器来说，刚好多了一条边。找到这条多余的边，所有的边给的-u-v-均满足u-lt-u。原题" class="headerlink" title="多余的边，有一个无向图有N个节点，和N个边，对于一个连通器来说，刚好多了一条边。找到这条多余的边，所有的边给的[u, v]均满足u&lt;u。原题"></a>多余的边，有一个无向图有N个节点，和N个边，对于一个连通器来说，刚好多了一条边。找到这条多余的边，所有的边给的[u, v]均满足u&lt;u。<a href="https://leetcode.com/problems/redundant-connection/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2], [1,3], [2,3]]</span><br><span class="line">Output: [2,3]</span><br><span class="line">Explanation: The given undirected graph will be like this:</span><br><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2 - 3</span><br></pre></td></tr></table></figure>
<p>方法一：使用传统的Union-Find。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findRedundantConnection</span><span class="params">(self, edges: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(x, y)</span>:</span></span><br><span class="line">        uf[find(x)] = find(y)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x != uf[x]:</span><br><span class="line">            uf[x] = find(uf[x])</span><br><span class="line">        <span class="keyword">return</span> uf[x]</span><br><span class="line">    </span><br><span class="line">    n = len(edges)</span><br><span class="line">    uf = list(range(n+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> u, v <span class="keyword">in</span> edges:</span><br><span class="line">        <span class="keyword">if</span> find(u)==find(v):</span><br><span class="line">            <span class="keyword">return</span> u, v</span><br><span class="line">        union(u, v)</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：stefan. 考虑没用上的条件 <code>u&lt;v</code>。 可以利用字符串的replace。将所有出现的点，替换成最大的。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findRedundantConnection</span><span class="params">(self, edges: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">    tree = <span class="string">''</span>.join(map(chr, range(<span class="number">1001</span>)))</span><br><span class="line">    <span class="keyword">for</span> u, v <span class="keyword">in</span> edges:</span><br><span class="line">        <span class="keyword">if</span> tree[u] == tree[v]:</span><br><span class="line">            <span class="keyword">return</span> u, v</span><br><span class="line">        tree = tree.replace(tree[u], tree[v])</span><br></pre></td></tr></table></figure>
<h3 id="743-Network-Delay-Time"><a href="#743-Network-Delay-Time" class="headerlink" title="743. Network Delay Time"></a>743. Network Delay Time</h3><h4 id="网络延迟，有N个网络节点，给出一个加权有向图，问从K点出发，遍历所有点需要多少时间，如果不可能返回-1。原题"><a href="#网络延迟，有N个网络节点，给出一个加权有向图，问从K点出发，遍历所有点需要多少时间，如果不可能返回-1。原题" class="headerlink" title="网络延迟，有N个网络节点，给出一个加权有向图，问从K点出发，遍历所有点需要多少时间，如果不可能返回-1。原题"></a>网络延迟，有N个网络节点，给出一个加权有向图，问从K点出发，遍历所有点需要多少时间，如果不可能返回-1。<a href="https://leetcode.com/problems/network-delay-time/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: times = [[2,1,1],[2,3,1],[3,4,1]], N = 4, K = 2</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<p>方法一：bfs。首次AC，960ms。效率不算很高吧，因为可能遍历到重复的节点更新值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">networkDelayTime</span><span class="params">(self, times, N, K)</span>:</span></span><br><span class="line">    seen, ans = &#123;&#125;, <span class="number">0</span></span><br><span class="line">    g = collections.defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> u, v , w <span class="keyword">in</span> times:</span><br><span class="line">        g[u].append((v, w))</span><br><span class="line">    q = collections.deque([(K, <span class="number">0</span>)])</span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        u, t = q.popleft()</span><br><span class="line">        seen[u] = min(seen.get(u, float(<span class="string">'inf'</span>)), t)</span><br><span class="line">        <span class="keyword">for</span> v, nt <span class="keyword">in</span> g[u]:</span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> seen <span class="keyword">or</span> seen[v]&gt;nt+t:</span><br><span class="line">                q.append((v, t+nt))</span><br><span class="line">    <span class="keyword">return</span> max(seen.values()) <span class="keyword">if</span> len(seen)==N <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：堆实现了一个优先级队列，500ms左右。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">networkDelayTime</span><span class="params">(self, times, N, K)</span>:</span></span><br><span class="line">    seen, t = set(), <span class="number">0</span></span><br><span class="line">    g = collections.defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> u, v , w <span class="keyword">in</span> times:</span><br><span class="line">        g[u].append((v, w))</span><br><span class="line">    heap = [(<span class="number">0</span>, K)]</span><br><span class="line">    <span class="keyword">while</span> heap:</span><br><span class="line">        t, u = heapq.heappop(heap)</span><br><span class="line">        <span class="keyword">if</span> u <span class="keyword">in</span> seen: <span class="keyword">continue</span></span><br><span class="line">        seen.add(u)</span><br><span class="line">        <span class="keyword">if</span> len(seen) == N: <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> v, nt <span class="keyword">in</span> g[u]:</span><br><span class="line">            heapq.heappush(heap, (t+nt, v))</span><br><span class="line">    <span class="keyword">return</span> t <span class="keyword">if</span> len(seen)==N <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    <div>
      
        
      
    </div>

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/LeetCode/" rel="tag">
            <i class="fa fa-tag"></i> LeetCode</a>
          
            <a href="/tags/Python/" rel="tag">
            <i class="fa fa-tag"></i> Python</a>
          
            <a href="/tags/Algorithm/" rel="tag">
            <i class="fa fa-tag"></i> Algorithm</a>
          
            <a href="/tags/Graph/" rel="tag">
            <i class="fa fa-tag"></i> Graph</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/LeetCode算法题整理（哈希篇）hashtable/" rel="next" title="LeetCode算法题整理（哈希篇）hashtable">
                <i class="fa fa-chevron-left"></i> LeetCode算法题整理（哈希篇）hashtable
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/算法篇目录汇总/" rel="prev" title="算法篇目录汇总">
                算法篇目录汇总 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="xiaoliji" />
          <p class="site-author-name" itemprop="name">xiaoliji</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">28</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/darkTianTian" target="_blank" title="GitHub" rel="external nofollow">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.hackerrank.com/xiaoliji?hr_r=1" target="_blank" title="HackerRank" rel="external nofollow">
                  
                    <i class="fa fa-fw fa-hackerrank"></i>
                  
                    
                      HackerRank
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://leetcode.com/darktiantian/" target="_blank" title="LeetCode" rel="external nofollow">
                  
                    <i class="fa fa-fw fa-leetcode"></i>
                  
                    
                      LeetCode
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.jianshu.com/u/de42f74901fd" target="_blank" title="简书" rel="external nofollow">
                  
                    <i class="fa fa-fw fa-book"></i>
                  
                    
                      简书
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#990-Satisfiability-of-Equality-Equations"><span class="nav-number">1.</span> <span class="nav-text">990. Satisfiability of Equality Equations</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#满足所有方程式，判断是否存在变量的值满足所有的等式与不等式。原题"><span class="nav-number">1.1.</span> <span class="nav-text">满足所有方程式，判断是否存在变量的值满足所有的等式与不等式。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#997-Find-the-Town-Judge"><span class="nav-number">2.</span> <span class="nav-text">997. Find the Town Judge</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#找到小镇审判长。审判长被除自己以外的所有人信任，并且不信任任何人。根据信任列表找出审判长。原题"><span class="nav-number">2.1.</span> <span class="nav-text">找到小镇审判长。审判长被除自己以外的所有人信任，并且不信任任何人。根据信任列表找出审判长。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#133-Clone-Graph"><span class="nav-number">3.</span> <span class="nav-text">133. Clone Graph</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#深拷贝一个简单环。原题"><span class="nav-number">3.1.</span> <span class="nav-text">深拷贝一个简单环。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1334-Find-the-City-With-the-Smallest-Number-of-Neighbors-at-a-Threshold-Distance"><span class="nav-number">4.</span> <span class="nav-text">1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#找到距离范围内邻居最少的城市。原题"><span class="nav-number">4.1.</span> <span class="nav-text">找到距离范围内邻居最少的城市。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1267-Count-Servers-that-Communicate"><span class="nav-number">5.</span> <span class="nav-text">1267. Count Servers that Communicate</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#找到2个以上的服务器连接个数，服务器可以在一行或是一列算是连接上。原题"><span class="nav-number">5.1.</span> <span class="nav-text">找到2个以上的服务器连接个数，服务器可以在一行或是一列算是连接上。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#886-Possible-Bipartition"><span class="nav-number">6.</span> <span class="nav-text">886. Possible Bipartition</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#将不喜欢的人放在两组中，根据关系是否能将其分为2组。原题"><span class="nav-number">6.1.</span> <span class="nav-text">将不喜欢的人放在两组中，根据关系是否能将其分为2组。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#207-Course-Schedule"><span class="nav-number">7.</span> <span class="nav-text">207. Course Schedule</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#课程调度，课程有依赖关系，问是否能完成所有的课程。原题"><span class="nav-number">7.1.</span> <span class="nav-text">课程调度，课程有依赖关系，问是否能完成所有的课程。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1462-Course-Schedule-IV"><span class="nav-number">8.</span> <span class="nav-text">1462. Course Schedule IV</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#和上题差不多，问题不一样，问的是根据给定的依赖关系，判断两节课是否有依赖。原题"><span class="nav-number">8.1.</span> <span class="nav-text">和上题差不多，问题不一样，问的是根据给定的依赖关系，判断两节课是否有依赖。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1466-Reorder-Routes-to-Make-All-Paths-Lead-to-the-City-Zero"><span class="nav-number">9.</span> <span class="nav-text">1466. Reorder Routes to Make All Paths Lead to the City Zero</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#有一个有向图，两个节点之间只有一条边，要求所有的边指向0，需要改多少条边的方向。原题"><span class="nav-number">9.1.</span> <span class="nav-text">有一个有向图，两个节点之间只有一条边，要求所有的边指向0，需要改多少条边的方向。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1210-Minimum-Moves-to-Reach-Target-with-Rotations"><span class="nav-number">10.</span> <span class="nav-text">1210. Minimum Moves to Reach Target with Rotations</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一个占位2格的蛇，从左上走到右下需要最少的步数，可以旋转。原题"><span class="nav-number">10.1.</span> <span class="nav-text">一个占位2格的蛇，从左上走到右下需要最少的步数，可以旋转。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1202-Smallest-String-With-Swaps"><span class="nav-number">11.</span> <span class="nav-text">1202. Smallest String With Swaps</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#给定一组pairs表明索引对可以互换，求这个字符串能换的最小值时多少，同一对可以进行多次互换。原题"><span class="nav-number">11.1.</span> <span class="nav-text">给定一组pairs表明索引对可以互换，求这个字符串能换的最小值时多少，同一对可以进行多次互换。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#787-Cheapest-Flights-Within-K-Stops"><span class="nav-number">12.</span> <span class="nav-text">787. Cheapest Flights Within K Stops</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#经过K个站点的最便宜的航班。原题"><span class="nav-number">12.1.</span> <span class="nav-text">经过K个站点的最便宜的航班。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#332-Reconstruct-Itinerary"><span class="nav-number">13.</span> <span class="nav-text">332. Reconstruct Itinerary</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#重建行程，根据火车票来寻找行程，答案不唯一。原题"><span class="nav-number">13.1.</span> <span class="nav-text">重建行程，根据火车票来寻找行程，答案不唯一。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1519-Number-of-Nodes-in-the-Sub-Tree-With-the-Same-Label"><span class="nav-number">14.</span> <span class="nav-text">1519. Number of Nodes in the Sub-Tree With the Same Label</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#有一个数的图，每个节点有个字母，返回每个节点的子树中包含这个字母的总个数。原题"><span class="nav-number">14.1.</span> <span class="nav-text">有一个数的图，每个节点有个字母，返回每个节点的子树中包含这个字母的总个数。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#478-Generate-Random-Point-in-a-Circle"><span class="nav-number">15.</span> <span class="nav-text">478. Generate Random Point in a Circle</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#在给定圆的范围内随机生成点。原题"><span class="nav-number">15.1.</span> <span class="nav-text">在给定圆的范围内随机生成点。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1559-Detect-Cycles-in-2D-Grid"><span class="nav-number">16.</span> <span class="nav-text">1559. Detect Cycles in 2D Grid</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2D-矩阵中判断是否有环。原题"><span class="nav-number">16.1.</span> <span class="nav-text">2D 矩阵中判断是否有环。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#310-Minimum-Height-Trees"><span class="nav-number">17.</span> <span class="nav-text">310. Minimum Height Trees</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#有一个无向图，0-n-1这些节点，每两个节点只有一条边，找出这种节点，当以节点为根时，组成的树有最小的高度。原题"><span class="nav-number">17.1.</span> <span class="nav-text">有一个无向图，0~n-1这些节点，每两个节点只有一条边，找出这种节点，当以节点为根时，组成的树有最小的高度。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#127-Word-Ladder"><span class="nav-number">18.</span> <span class="nav-text">127. Word Ladder</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#每次可以改变单词中的一个字母，但必须在wordList中，问最少需要多少次能达到目标单词。原题"><span class="nav-number">18.1.</span> <span class="nav-text">每次可以改变单词中的一个字母，但必须在wordList中，问最少需要多少次能达到目标单词。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#547-Friend-Circles"><span class="nav-number">19.</span> <span class="nav-text">547. Friend Circles</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#朋友圈，一堆人拉帮结伙，朋友关系可以传递。通过二维数组表示i-j两个人是否是朋友。问N个人有多少个帮派。原题"><span class="nav-number">19.1.</span> <span class="nav-text">朋友圈，一堆人拉帮结伙，朋友关系可以传递。通过二维数组表示i, j两个人是否是朋友。问N个人有多少个帮派。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1584-Min-Cost-to-Connect-All-Points"><span class="nav-number">20.</span> <span class="nav-text">1584. Min Cost to Connect All Points</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#所有点最小的曼哈顿距离-xi-xj-yi-yj-和为多少。原题"><span class="nav-number">20.1.</span> <span class="nav-text">所有点最小的曼哈顿距离|xi - xj| + |yi - yj|和为多少。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#684-Redundant-Connection"><span class="nav-number">21.</span> <span class="nav-text">684. Redundant Connection</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#多余的边，有一个无向图有N个节点，和N个边，对于一个连通器来说，刚好多了一条边。找到这条多余的边，所有的边给的-u-v-均满足u-lt-u。原题"><span class="nav-number">21.1.</span> <span class="nav-text">多余的边，有一个无向图有N个节点，和N个边，对于一个连通器来说，刚好多了一条边。找到这条多余的边，所有的边给的[u, v]均满足u&lt;u。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#743-Network-Delay-Time"><span class="nav-number">22.</span> <span class="nav-text">743. Network Delay Time</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#网络延迟，有N个网络节点，给出一个加权有向图，问从K点出发，遍历所有点需要多少时间，如果不可能返回-1。原题"><span class="nav-number">22.1.</span> <span class="nav-text">网络延迟，有N个网络节点，给出一个加权有向图，问从K点出发，遍历所有点需要多少时间，如果不可能返回-1。原题</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xiaoliji</span>
</div>
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_pv">
  本站访客数:<span id="busuanzi_value_site_pv"></span>
</span>
</div>
<div class="powered-by">

  Powered by <a class="theme-link" href="https://hexo.io" rel="texternal nofollow">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next" rel="texternal nofollow">
    NexT.Mist
  </a>
</div>


<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共164.5k字</span>
</div>
        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  

    
      <script id="dsq-count-scr" src="https://.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://darktiantian.github.io.git/LeetCode算法题整理（图篇）Graph/';
          this.page.identifier = 'LeetCode算法题整理（图篇）Graph/';
          this.page.title = 'LeetCode算法题整理（图篇）Graph';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("MuBXc6gVka7X95yN3qhh8Akg-gzGzoHsz", "flbiG5OQDhWpAaCRLDETaoPF");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  

</body>
</html>
