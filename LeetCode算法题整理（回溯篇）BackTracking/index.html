<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="LeetCode,Python,Algorithm,BackTracking," />








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.2" />






<meta name="description" content="93. Restore IP Addresses恢复IP地址。原题12Input: &amp;quot;25525511135&amp;quot;Output: [&amp;quot;255.255.11.135&amp;quot;, &amp;quot;255.255.111.35&amp;quot;]">
<meta name="keywords" content="LeetCode,Python,Algorithm,BackTracking">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode算法题整理（回溯篇）BackTracking">
<meta property="og:url" content="http://darktiantian.github.io.git/LeetCode算法题整理（回溯篇）BackTracking/index.html">
<meta property="og:site_name" content="Xiaoliji&#39;s Blog">
<meta property="og:description" content="93. Restore IP Addresses恢复IP地址。原题12Input: &amp;quot;25525511135&amp;quot;Output: [&amp;quot;255.255.11.135&amp;quot;, &amp;quot;255.255.111.35&amp;quot;]">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2020-09-20T13:00:38.868Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeetCode算法题整理（回溯篇）BackTracking">
<meta name="twitter:description" content="93. Restore IP Addresses恢复IP地址。原题12Input: &amp;quot;25525511135&amp;quot;Output: [&amp;quot;255.255.11.135&amp;quot;, &amp;quot;255.255.111.35&amp;quot;]">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://darktiantian.github.io.git/LeetCode算法题整理（回溯篇）BackTracking/"/>





  <title>LeetCode算法题整理（回溯篇）BackTracking | Xiaoliji's Blog</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <a href="https://github.com/darkTianTian" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Xiaoliji's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">小里脊的个人博客</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://darktiantian.github.io.git/LeetCode算法题整理（回溯篇）BackTracking/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaoliji">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xiaoliji's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">LeetCode算法题整理（回溯篇）BackTracking</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-24T20:53:44+08:00">
                2019-03-24
              </time>
            

            
              <span class="post-updated">
                &nbsp; | &nbsp; Updated on
                <time itemprop="dateUpdated" datetime="2020-09-20T21:00:38+08:00" content="2020-09-20">
                  2020-09-20
                </time>
              </span>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/LeetCode算法题整理（回溯篇）BackTracking/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="LeetCode算法题整理（回溯篇）BackTracking/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/LeetCode算法题整理（回溯篇）BackTracking/" class="leancloud_visitors" data-flag-title="LeetCode算法题整理（回溯篇）BackTracking">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="93-Restore-IP-Addresses"><a href="#93-Restore-IP-Addresses" class="headerlink" title="93. Restore IP Addresses"></a>93. Restore IP Addresses</h3><h4 id="恢复IP地址。原题"><a href="#恢复IP地址。原题" class="headerlink" title="恢复IP地址。原题"></a>恢复IP地址。<a href="https://leetcode.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;25525511135&quot;</span><br><span class="line">Output: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>方法一：需要注意0的情况。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">restoreIpAddresses</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(ip, remain, part)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> part &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> remain <span class="keyword">and</span> part==<span class="number">0</span>:</span><br><span class="line">            ans.append(ip)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ip += <span class="string">'.'</span> * bool(ip)</span><br><span class="line">            n = len(remain)</span><br><span class="line">            <span class="keyword">if</span> n &gt;= <span class="number">1</span>:</span><br><span class="line">                backtrack(ip+remain[:<span class="number">1</span>], remain[<span class="number">1</span>:], part<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span> n &gt;= <span class="number">2</span> <span class="keyword">and</span> remain[<span class="number">0</span>]!=<span class="string">'0'</span>:</span><br><span class="line">                backtrack(ip+remain[:<span class="number">2</span>], remain[<span class="number">2</span>:], part<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span> n &gt;= <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="number">99</span> &lt; int(remain[:<span class="number">3</span>]) &lt; <span class="number">256</span>:</span><br><span class="line">                    backtrack(ip+remain[:<span class="number">3</span>], remain[<span class="number">3</span>:], part<span class="number">-1</span>)</span><br><span class="line">            </span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">if</span> s:</span><br><span class="line">        backtrack(<span class="string">''</span>, s, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">return</span> list(ans)</span><br></pre></td></tr></table></figure>
<h3 id="131-Palindrome-Partitioning"><a href="#131-Palindrome-Partitioning" class="headerlink" title="131. Palindrome Partitioning"></a>131. Palindrome Partitioning</h3><h4 id="回文串切分。原题"><a href="#回文串切分。原题" class="headerlink" title="回文串切分。原题"></a>回文串切分。<a href="https://leetcode.com/problems/palindrome-partitioning/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;aab&quot;</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [&quot;aa&quot;,&quot;b&quot;],</span><br><span class="line">  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>方法一：原始回溯。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, s: str)</span> -&gt; List[List[str]]:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(s, remain)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> remain:</span><br><span class="line">            ans.append(s)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(remain)+<span class="number">1</span>):      <span class="comment"># 这里是n+1，因为整个字符串也有可能。</span></span><br><span class="line">                <span class="keyword">if</span> remain[:i] == remain[:i][::<span class="number">-1</span>]:</span><br><span class="line">                    backtrack(s+[remain[:i]], remain[i:])</span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">if</span> s:</span><br><span class="line">        backtrack([], s)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：使用列表生成式。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, s: str)</span> -&gt; List[List[str]]:</span></span><br><span class="line">    <span class="keyword">return</span> s <span class="keyword">and</span> [[s[:i]] + suffix </span><br><span class="line">                  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s)+<span class="number">1</span>) <span class="keyword">if</span> s[:i]==s[i<span class="number">-1</span>::<span class="number">-1</span>]</span><br><span class="line">                  <span class="keyword">for</span> suffix <span class="keyword">in</span> self.partition(s[i:])] <span class="keyword">or</span> [[]]</span><br></pre></td></tr></table></figure>
<h3 id="77-Combinations"><a href="#77-Combinations" class="headerlink" title="77. Combinations"></a>77. Combinations</h3><h4 id="实现组合。原题"><a href="#实现组合。原题" class="headerlink" title="实现组合。原题"></a>实现组合。<a href="https://leetcode.com/problems/combinations/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 4, k = 2</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>方法一：回溯。700ms, 比Solution中的慢了100ms.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">(self, n: int, k: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(a, k, rest)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">            ans.extend(a+[num] <span class="keyword">for</span> num <span class="keyword">in</span> rest)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i, h <span class="keyword">in</span> enumerate(rest):</span><br><span class="line">                backtrack(a+[h], k<span class="number">-1</span>, rest[i+<span class="number">1</span>:])</span><br><span class="line">        </span><br><span class="line">    ans = []</span><br><span class="line">    backtrack([], k, list(range(<span class="number">1</span>, n+<span class="number">1</span>)))</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>方法二：Solution中的递归。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">(self, n: int, k: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(first=<span class="number">1</span>, cur=[])</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(cur) == k:</span><br><span class="line">            ans.append(cur[:])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(first, n+<span class="number">1</span>):</span><br><span class="line">                cur.append(i)</span><br><span class="line">                backtrack(i+<span class="number">1</span>, cur)</span><br><span class="line">                cur.pop()</span><br><span class="line">        </span><br><span class="line">    ans = []</span><br><span class="line">    backtrack()</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法三：列表生成式写法，递归。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">(self, n: int, k: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> [[]]</span><br><span class="line">    <span class="keyword">return</span> [pre+[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(k, n+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> pre <span class="keyword">in</span> self.combine(i<span class="number">-1</span>, k<span class="number">-1</span>)]</span><br></pre></td></tr></table></figure>
<h3 id="39-Combination-Sum"><a href="#39-Combination-Sum" class="headerlink" title="39. Combination Sum"></a>39. Combination Sum</h3><h4 id="和77类似，找出和为指定数值的组合，候选数字可以重复使用。原题"><a href="#和77类似，找出和为指定数值的组合，候选数字可以重复使用。原题" class="headerlink" title="和77类似，找出和为指定数值的组合，候选数字可以重复使用。原题"></a>和77类似，找出和为指定数值的组合，候选数字可以重复使用。<a href="https://leetcode.com/problems/combination-sum/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: candidates = [2,3,5], target = 8,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>方法一：将候选组排序，并记录当前的索引值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(g, i, target)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">            ans.append(g)</span><br><span class="line">        <span class="keyword">elif</span> target &lt; candidates[i]:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n):</span><br><span class="line">            backtrack(g+[candidates[j]], j, target-candidates[j])</span><br><span class="line">    </span><br><span class="line">    ans = []</span><br><span class="line">    n = len(candidates)</span><br><span class="line">    candidates.sort()</span><br><span class="line">    backtrack([], <span class="number">0</span>, target)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>方法二：时隔一年又重做一遍，感觉方法更加精炼了。sort感觉没啥必要。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, cn: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(i, t, p)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> t == <span class="number">0</span>:</span><br><span class="line">            ans.append(p[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> t &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(cn)):</span><br><span class="line">            c = cn[j]</span><br><span class="line">            p.append(c)</span><br><span class="line">            backtrack(j, t-c, p)</span><br><span class="line">            p.pop()</span><br><span class="line"></span><br><span class="line">    ans = []</span><br><span class="line">    backtrack(<span class="number">0</span>, target, [])</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="40-Combination-Sum-II"><a href="#40-Combination-Sum-II" class="headerlink" title="40. Combination Sum II"></a>40. Combination Sum II</h3><h4 id="组合求和，和39类似，区别在于候选数字中可能有重复数字，但每个数字只能使用一次。原题"><a href="#组合求和，和39类似，区别在于候选数字中可能有重复数字，但每个数字只能使用一次。原题" class="headerlink" title="组合求和，和39类似，区别在于候选数字中可能有重复数字，但每个数字只能使用一次。原题"></a>组合求和，和39类似，区别在于候选数字中可能有重复数字，但每个数字只能使用一次。<a href="https://leetcode.com/problems/combination-sum-ii/" target="_blank" rel="noopener">原题</a></h4><p>麻烦的地方在于如何保证结果是非重复的。当<code>j==i</code>时，<code>cn[j]==cn[j-1]</code>说明前面刚刚用了和这个一样的数字。可以继续使用。比如<code>[1,1,6]</code>。当<code>j!=i</code>，<code>cn[j]==cn[j-1]</code>时，说明想以j开头同样找数组，这样肯定会找出一个重复的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(g, i, target)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">            ans.append(g)</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n):</span><br><span class="line">            <span class="comment"># avoid duplicate result</span></span><br><span class="line">            <span class="keyword">if</span> j != i <span class="keyword">and</span> candidates[j]==candidates[j<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> candidates[j] &gt; target:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            backtrack(g+[candidates[j]], j+<span class="number">1</span>, target-candidates[j])</span><br><span class="line">    </span><br><span class="line">    ans = []</span><br><span class="line">    n = len(candidates)</span><br><span class="line">    candidates.sort()</span><br><span class="line">    backtrack([], <span class="number">0</span>, target)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="216-Combination-Sum-III"><a href="#216-Combination-Sum-III" class="headerlink" title="216. Combination Sum III"></a>216. Combination Sum III</h3><h4 id="组合求和，从1-9选出k个不重复的数，和为n。原题"><a href="#组合求和，从1-9选出k个不重复的数，和为n。原题" class="headerlink" title="组合求和，从1~9选出k个不重复的数，和为n。原题"></a>组合求和，从1~9选出k个不重复的数，和为n。<a href="https://leetcode.com/problems/combination-sum-iii/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: k = 3, n = 9</span><br><span class="line">Output: [[1,2,6], [1,3,5], [2,3,4]]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinationSum3</span><span class="params">(self, k: int, n: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(g, i, target, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> k==<span class="number">0</span> <span class="keyword">and</span> target==<span class="number">0</span>:</span><br><span class="line">            ans.append(g)</span><br><span class="line">        <span class="keyword">if</span> k &lt; <span class="number">0</span> <span class="keyword">or</span> target &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, <span class="number">10</span>):</span><br><span class="line">            backtrack(g+[j], j+<span class="number">1</span>, target-j, k<span class="number">-1</span>)</span><br><span class="line">    </span><br><span class="line">    ans = []</span><br><span class="line">    backtrack([], <span class="number">1</span>, n, k)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>方法二：递归，使用<code>last</code>作为上限。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinationSum3</span><span class="params">(self, k: int, n: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combs</span><span class="params">(k, n, cap)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> k:</span><br><span class="line">            <span class="keyword">return</span> [[]] * (<span class="keyword">not</span> n)</span><br><span class="line">        <span class="keyword">return</span> [comb + [last]</span><br><span class="line">                <span class="keyword">for</span> last <span class="keyword">in</span> range(<span class="number">1</span>, cap)</span><br><span class="line">                <span class="keyword">for</span> comb <span class="keyword">in</span> combs(k<span class="number">-1</span>, n-last, last)]</span><br><span class="line">    <span class="keyword">return</span> combs(k, n, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<h3 id="78-Subsets"><a href="#78-Subsets" class="headerlink" title="78. Subsets"></a>78. Subsets</h3><h4 id="输出给定无重复集合的子集组合。原题"><a href="#输出给定无重复集合的子集组合。原题" class="headerlink" title="输出给定无重复集合的子集组合。原题"></a>输出给定无重复集合的子集组合。<a href="https://leetcode.com/problems/subsets/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>方法一：常规写法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(g, i, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            ans.append(g)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(nums)):</span><br><span class="line">            backtrack(g+[nums[j]], j+<span class="number">1</span>, n<span class="number">-1</span>)</span><br><span class="line">    </span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> range(len(nums)+<span class="number">1</span>):</span><br><span class="line">        backtrack([], <span class="number">0</span>, n)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：做一个递增就好了。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    ans = [[]]</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        ans += [pre+[num] <span class="keyword">for</span> pre <span class="keyword">in</span> ans]</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>方法三：使用索引来做。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    self.ans = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, n, p)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            self.ans.append(p[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(nums)):</span><br><span class="line">            d = nums[j]</span><br><span class="line">            p.append(d)</span><br><span class="line">            dfs(j+<span class="number">1</span>, n<span class="number">-1</span>, p)</span><br><span class="line">            p.pop()</span><br><span class="line"></span><br><span class="line">    [dfs(<span class="number">0</span>, i, []) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(nums)+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure>
<h3 id="90-Subsets-II"><a href="#90-Subsets-II" class="headerlink" title="90. Subsets II"></a>90. Subsets II</h3><h4 id="和78类似，区别在于给定的数组有重复元素。原题"><a href="#和78类似，区别在于给定的数组有重复元素。原题" class="headerlink" title="和78类似，区别在于给定的数组有重复元素。原题"></a>和78类似，区别在于给定的数组有重复元素。<a href="https://leetcode.com/problems/subsets-ii/" target="_blank" rel="noopener">原题</a></h4><p>方法一：用到了40题中解法去重的代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subsetsWithDup</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(g, i, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            ans.append(g)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(nums)):</span><br><span class="line">            <span class="keyword">if</span> j!=i <span class="keyword">and</span> nums[j]==nums[j<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            backtrack(g+[nums[j]], j+<span class="number">1</span>, n<span class="number">-1</span>)</span><br><span class="line">    </span><br><span class="line">    ans = []</span><br><span class="line">    nums.sort()</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> range(len(nums)+<span class="number">1</span>):</span><br><span class="line">        backtrack([], <span class="number">0</span>, n)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="79-Word-Search"><a href="#79-Word-Search" class="headerlink" title="79. Word Search"></a>79. Word Search</h3><h4 id="矩阵中的路径。原题"><a href="#矩阵中的路径。原题" class="headerlink" title="矩阵中的路径。原题"></a>矩阵中的路径。<a href="https://leetcode.com/problems/word-search/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">board =</span><br><span class="line">[</span><br><span class="line">  [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;],</span><br><span class="line">  [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;],</span><br><span class="line">  [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Given word = &quot;ABCCED&quot;, return true.</span><br><span class="line">Given word = &quot;SEE&quot;, return true.</span><br><span class="line">Given word = &quot;ABCB&quot;, return false.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, g: List[List[str]], word: str)</span> -&gt; bool:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j, word)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> word:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        original, g[i][j] = g[i][j], <span class="string">'-'</span></span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> ((i+<span class="number">1</span>, j), (i, j+<span class="number">1</span>), (i, j<span class="number">-1</span>), (i<span class="number">-1</span>, j)):</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span>&lt;=x&lt;R <span class="keyword">and</span> <span class="number">0</span>&lt;=y&lt;C <span class="keyword">and</span> g[x][y] == word[<span class="number">0</span>]: </span><br><span class="line">                <span class="keyword">if</span> dfs(x, y, word[<span class="number">1</span>:]):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        g[i][j] = original</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    R, C = len(g), len(g[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(R):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(C):</span><br><span class="line">            <span class="keyword">if</span> g[i][j] == word[<span class="number">0</span>] <span class="keyword">and</span> dfs(i, j, word[<span class="number">1</span>:]):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h3 id="200-Number-of-Islands"><a href="#200-Number-of-Islands" class="headerlink" title="200. Number of Islands"></a>200. Number of Islands</h3><h4 id="小岛的个数。原题"><a href="#小岛的个数。原题" class="headerlink" title="小岛的个数。原题"></a>小岛的个数。<a href="https://leetcode.com/problems/number-of-islands/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line"></span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<p>方法一：常规写法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numIslands</span><span class="params">(self, grid: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> grid:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    R, C = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line">    seen = set()</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spread</span><span class="params">(i, j)</span>:</span></span><br><span class="line">        seen.add((i, j))</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> ((i<span class="number">-1</span>, j), (i+<span class="number">1</span>, j), (i, j<span class="number">-1</span>), (i, j+<span class="number">1</span>)):</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span>&lt;=x&lt;R <span class="keyword">and</span> <span class="number">0</span>&lt;=y&lt;C <span class="keyword">and</span> (x, y) <span class="keyword">not</span> <span class="keyword">in</span> seen</span><br><span class="line">                    <span class="keyword">and</span> grid[x][y]==<span class="string">'1'</span>):</span><br><span class="line">                spread(x, y)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(R):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(C):</span><br><span class="line">            <span class="keyword">if</span> (i, j) <span class="keyword">not</span> <span class="keyword">in</span> seen <span class="keyword">and</span> grid[i][j]==<span class="string">'1'</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                spread(i, j)</span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<p>方法二：当登录一座岛屿时，使这座岛屿下沉，变为’0’。不明白为什么比上个方法慢了20ms。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numIslands</span><span class="params">(self, grid: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sink</span><span class="params">(i, j)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span>&lt;=i&lt;len(grid) <span class="keyword">and</span> <span class="number">0</span>&lt;=j&lt;len(grid[i]) <span class="keyword">and</span> grid[i][j]==<span class="string">'1'</span>:</span><br><span class="line">            grid[i][j] = <span class="string">'0'</span></span><br><span class="line">            list(map(sink, (i<span class="number">-1</span>, i+<span class="number">1</span>, i, i), (j, j, j<span class="number">-1</span>, j+<span class="number">1</span>)))   <span class="comment"># important, return generator without list</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> sum(sink(i, j) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)) <span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[i])))</span><br></pre></td></tr></table></figure>
<h3 id="1254-Number-of-Closed-Islands"><a href="#1254-Number-of-Closed-Islands" class="headerlink" title="1254. Number of Closed Islands"></a>1254. Number of Closed Islands</h3><h4 id="和200类似，但是与边界相连的岛不能算了。原题"><a href="#和200类似，但是与边界相连的岛不能算了。原题" class="headerlink" title="和200类似，但是与边界相连的岛不能算了。原题"></a>和200类似，但是与边界相连的岛不能算了。<a href="https://leetcode.com/problems/number-of-closed-islands/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line">Islands in gray are closed because they are completely surrounded by water (group of 1s).</span><br></pre></td></tr></table></figure>
<p>方法一：下沉法。先把边界的岛屿处理，然后再累计。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">closedIsland</span><span class="params">(self, g: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    m, n = len(g), len(g[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sink</span><span class="params">(i, j)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> m&gt;i&gt;=<span class="number">0</span>&lt;=j&lt;n <span class="keyword">and</span> g[i][j]==<span class="number">0</span>:</span><br><span class="line">            g[i][j] = <span class="number">1</span></span><br><span class="line">            list(map(sink, (i<span class="number">-1</span>, i+<span class="number">1</span>, i, i), (j, j, j<span class="number">-1</span>, j+<span class="number">1</span>)))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    list(map(sink, [<span class="number">0</span>]*n, range(n)))</span><br><span class="line">    list(map(sink, [m<span class="number">-1</span>]*n, range(n)))</span><br><span class="line">    list(map(sink, range(m), [<span class="number">0</span>]*m))</span><br><span class="line">    list(map(sink, range(m), [n<span class="number">-1</span>]*m))</span><br><span class="line">    <span class="keyword">return</span> sum(sink(i, j) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m<span class="number">-1</span>) <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n<span class="number">-1</span>))</span><br></pre></td></tr></table></figure>
<h3 id="130-Surrounded-Regions"><a href="#130-Surrounded-Regions" class="headerlink" title="130. Surrounded Regions"></a>130. Surrounded Regions</h3><h4 id="将四周被包围的O翻转成X，边缘不算包围。原题"><a href="#将四周被包围的O翻转成X，边缘不算包围。原题" class="headerlink" title="将四周被包围的O翻转成X，边缘不算包围。原题"></a>将四周被包围的<code>O</code>翻转成<code>X</code>，边缘不算包围。<a href="https://leetcode.com/problems/surrounded-regions/" target="_blank" rel="noopener">原题</a></h4><p>方法一：传统的方法在延伸的时候判断不出是否到达边界。所以这里先得到边界的点，然后从边界往里延伸，将所有的<code>O</code>变为<code>S</code>，第二次遍历时，将<code>S</code>恢复成<code>O</code>，其他设为<code>X</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(self, board: List[List[str]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> board: <span class="keyword">return</span></span><br><span class="line">    R, C = len(board), len(board[<span class="number">0</span>])</span><br><span class="line">    bounds = [(i, j) <span class="keyword">for</span> k <span class="keyword">in</span> range(R+C) </span><br><span class="line">              <span class="keyword">for</span> i, j <span class="keyword">in</span> ((<span class="number">0</span>, k), (R<span class="number">-1</span>, k), (k, <span class="number">0</span>), (k, C<span class="number">-1</span>))</span><br><span class="line">              <span class="keyword">if</span> i &lt; R <span class="keyword">and</span> j &lt; C]</span><br><span class="line">    <span class="keyword">while</span> bounds:</span><br><span class="line">        x, y = bounds.pop()</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span>&lt;=x&lt;R <span class="keyword">and</span> <span class="number">0</span>&lt;=y&lt;C <span class="keyword">and</span> board[x][y]==<span class="string">'O'</span>:</span><br><span class="line">            board[x][y] = <span class="string">'S'</span></span><br><span class="line">            bounds += (x<span class="number">-1</span>, y), (x+<span class="number">1</span>, y), (x, y<span class="number">-1</span>), (x, y+<span class="number">1</span>)</span><br><span class="line">    board[:] = [[<span class="string">'XO'</span>[c==<span class="string">'S'</span>] <span class="keyword">for</span> c <span class="keyword">in</span> row] <span class="keyword">for</span> row <span class="keyword">in</span> board]</span><br></pre></td></tr></table></figure>
<h3 id="417-Pacific-Atlantic-Water-Flow"><a href="#417-Pacific-Atlantic-Water-Flow" class="headerlink" title="417. Pacific Atlantic Water Flow"></a>417. Pacific Atlantic Water Flow</h3><h4 id="太平洋大西洋水流向，假设陆地上可以沿着高度不高于的地方流淌，求能同时流入两个海洋的陆地坐标。原题"><a href="#太平洋大西洋水流向，假设陆地上可以沿着高度不高于的地方流淌，求能同时流入两个海洋的陆地坐标。原题" class="headerlink" title="太平洋大西洋水流向，假设陆地上可以沿着高度不高于的地方流淌，求能同时流入两个海洋的陆地坐标。原题"></a>太平洋大西洋水流向，假设陆地上可以沿着高度不高于的地方流淌，求能同时流入两个海洋的陆地坐标。<a href="https://leetcode.com/problems/pacific-atlantic-water-flow/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Given the following 5x5 matrix:</span><br><span class="line"></span><br><span class="line">  Pacific ~   ~   ~   ~   ~ </span><br><span class="line">       ~  1   2   2   3  (5) *</span><br><span class="line">       ~  3   2   3  (4) (4) *</span><br><span class="line">       ~  2   4  (5)  3   1  *</span><br><span class="line">       ~ (6) (7)  1   4   5  *</span><br><span class="line">       ~ (5)  1   1   2   4  *</span><br><span class="line">          *   *   *   *   * Atlantic</span><br><span class="line">Return:</span><br><span class="line">[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).</span><br><span class="line"> </span><br><span class="line"> Pacific  ~   ~   ~   </span><br><span class="line">       ~  1   2  (3)  *</span><br><span class="line">       ~ (8) (9) (4)  *</span><br><span class="line">       ~ (7) (6) (5)  *</span><br><span class="line">          *   *   *   * Atlantic</span><br></pre></td></tr></table></figure>
<p>方法一：一开始我以为从左上的点只能往右或下方向找陆地，事实上还是要寻找四个方向。这应该是最暴力的解法了。但是看了几个高票答案都没我这个快。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pacificAtlantic</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    p_land = set()</span><br><span class="line">    a_land = set()</span><br><span class="line">    R, C = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spread</span><span class="params">(i, j, land)</span>:</span></span><br><span class="line">        land.add((i, j))</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> ((i+<span class="number">1</span>, j), (i, j+<span class="number">1</span>), (i<span class="number">-1</span>, j), (i, j<span class="number">-1</span>)):</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span>&lt;=x&lt;R <span class="keyword">and</span> <span class="number">0</span>&lt;=y&lt;C <span class="keyword">and</span> matrix[x][y] &gt;= matrix[i][j]</span><br><span class="line">                    <span class="keyword">and</span> (x, y) <span class="keyword">not</span> <span class="keyword">in</span> land):</span><br><span class="line">                spread(x, y, land)</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(R):</span><br><span class="line">        spread(i, <span class="number">0</span>, p_land)</span><br><span class="line">        spread(i, C<span class="number">-1</span>, a_land)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(C):</span><br><span class="line">        spread(<span class="number">0</span>, j, p_land)</span><br><span class="line">        spread(R<span class="number">-1</span>, j, a_land)</span><br><span class="line">    <span class="keyword">return</span> list(p_land &amp; a_land)</span><br></pre></td></tr></table></figure>
<h3 id="526-Beautiful-Arrangement"><a href="#526-Beautiful-Arrangement" class="headerlink" title="526. Beautiful Arrangement"></a>526. Beautiful Arrangement</h3><h4 id="完美安排，给定1-N的数字，生成一种排列，是第i位的数字能被i整除，或者i能被第i位的数字整除，索引从1开始。原题"><a href="#完美安排，给定1-N的数字，生成一种排列，是第i位的数字能被i整除，或者i能被第i位的数字整除，索引从1开始。原题" class="headerlink" title="完美安排，给定1~N的数字，生成一种排列，是第i位的数字能被i整除，或者i能被第i位的数字整除，索引从1开始。原题"></a>完美安排，给定1~N的数字，生成一种排列，是第i位的数字能被i整除，或者i能被第i位的数字整除，索引从1开始。<a href="https://leetcode.com/problems/beautiful-arrangement/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line"></span><br><span class="line">The first beautiful arrangement is [1, 2]:</span><br><span class="line"></span><br><span class="line">Number at the 1st position (i=1) is 1, and 1 is divisible by i (i=1).</span><br><span class="line"></span><br><span class="line">Number at the 2nd position (i=2) is 2, and 2 is divisible by i (i=2).</span><br><span class="line"></span><br><span class="line">The second beautiful arrangement is [2, 1]:</span><br><span class="line"></span><br><span class="line">Number at the 1st position (i=1) is 2, and 2 is divisible by i (i=1).</span><br><span class="line"></span><br><span class="line">Number at the 2nd position (i=2) is 1, and i (i=2) is divisible by 1.</span><br></pre></td></tr></table></figure>
<p>方法一：常规写法，1300ms，beats50%.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countArrangement</span><span class="params">(self, N: int)</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(g, rest)</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> count</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> rest:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        index = len(g) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(rest):</span><br><span class="line">            <span class="keyword">if</span> num % index == <span class="number">0</span> <span class="keyword">or</span> index % num == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># print(g, i, num, index, rest)</span></span><br><span class="line">                g.append(num)</span><br><span class="line">                backtrack(g, rest[:i]+rest[i+<span class="number">1</span>:])</span><br><span class="line">                g.pop()</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    backtrack([], list(range(<span class="number">1</span>, N+<span class="number">1</span>)))</span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<p>方法二：去掉了方法一中一些无用的空间和操作。1000ms, beats 67%.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countArrangement</span><span class="params">(self, N: int)</span> -&gt; int:</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(g)</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> count</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> rest:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        index = len(g) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> rest:</span><br><span class="line">            <span class="keyword">if</span> num % index == <span class="number">0</span> <span class="keyword">or</span> index % num == <span class="number">0</span>:</span><br><span class="line">                g.append(num)</span><br><span class="line">                rest.remove(num)</span><br><span class="line">                backtrack(g)</span><br><span class="line">                g.pop()</span><br><span class="line">                rest.add(num)</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    rest = set(range(<span class="number">1</span>, N+<span class="number">1</span>))</span><br><span class="line">    backtrack([])</span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法三：这里从后往前构建，最后构造1，因为1的位置放任何数字都可以。152ms</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countArrangement</span><span class="params">(self, N: int)</span> -&gt; int:</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(i, rest)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> sum(backtrack(i<span class="number">-1</span>, rest-&#123;x&#125;)</span><br><span class="line">                   <span class="keyword">for</span> x <span class="keyword">in</span> rest</span><br><span class="line">                   <span class="keyword">if</span> x % i == <span class="number">0</span> <span class="keyword">or</span> i % x == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> backtrack(N, set(range(<span class="number">1</span>, N+<span class="number">1</span>)))</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法四：在3的基础上优化，每次调用方法时可以利用之前的结果。52ms</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cache = &#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countArrangement</span><span class="params">(self, N: int)</span> -&gt; int:</span></span><br><span class="line">            </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(i, rest)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            key = i, rest</span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">in</span> cache:</span><br><span class="line">                <span class="keyword">return</span> cache[key]</span><br><span class="line">            ans =  sum(backtrack(i<span class="number">-1</span>, rest[:j]+rest[j+<span class="number">1</span>:])</span><br><span class="line">                       <span class="keyword">for</span> j, x <span class="keyword">in</span> enumerate(rest)</span><br><span class="line">                       <span class="keyword">if</span> x % i == <span class="number">0</span> <span class="keyword">or</span> i % x == <span class="number">0</span>)</span><br><span class="line">            <span class="comment"># print(ans, i, rest)</span></span><br><span class="line">            cache[key] = ans</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        <span class="keyword">return</span> backtrack(N, tuple(range(<span class="number">1</span>, N+<span class="number">1</span>)))</span><br></pre></td></tr></table></figure>
<h3 id="22-Generate-Parentheses"><a href="#22-Generate-Parentheses" class="headerlink" title="22. Generate Parentheses"></a>22. Generate Parentheses</h3><h4 id="生成n对合法的括号。原题"><a href="#生成n对合法的括号。原题" class="headerlink" title="生成n对合法的括号。原题"></a>生成n对合法的括号。<a href="https://leetcode.com/problems/generate-parentheses/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &quot;((()))&quot;,</span><br><span class="line">  &quot;(()())&quot;,</span><br><span class="line">  &quot;(())()&quot;,</span><br><span class="line">  &quot;()(())&quot;,</span><br><span class="line">  &quot;()()()&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>方法一：常规写法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n: int)</span> -&gt; List[str]:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(p, l, r)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(p) == n*<span class="number">2</span>:</span><br><span class="line">            ans.append(p)</span><br><span class="line">        <span class="keyword">if</span> l &lt; n:</span><br><span class="line">            backtrack(p+<span class="string">'('</span>, l+<span class="number">1</span>, r) </span><br><span class="line">        <span class="keyword">if</span> r &lt; l:</span><br><span class="line">            backtrack(p+<span class="string">')'</span>, l, r+<span class="number">1</span>)</span><br><span class="line">    ans = []</span><br><span class="line">    backtrack(<span class="string">''</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：生成器写法。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n: int)</span> -&gt; List[str]:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gen_parens</span><span class="params">(p, l, r)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> r &gt;= l &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> r:</span><br><span class="line">                <span class="keyword">yield</span> p</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> gen_parens(p+<span class="string">'('</span>, l<span class="number">-1</span>, r)</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> gen_parens(p+<span class="string">')'</span>, l, r<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> list(gen_parens(<span class="string">''</span>, n, n))</span><br></pre></td></tr></table></figure>
<h3 id="89-Gray-Code"><a href="#89-Gray-Code" class="headerlink" title="89. Gray Code"></a>89. Gray Code</h3><h4 id="灰码问题。给定一个n表示n位。从0开始每次改变一个位的数字，产生所有的组合。原题"><a href="#灰码问题。给定一个n表示n位。从0开始每次改变一个位的数字，产生所有的组合。原题" class="headerlink" title="灰码问题。给定一个n表示n位。从0开始每次改变一个位的数字，产生所有的组合。原题"></a>灰码问题。给定一个n表示n位。从0开始每次改变一个位的数字，产生所有的组合。<a href="https://leetcode.com/problems/gray-code/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: [0,1,3,2]</span><br><span class="line">Explanation:</span><br><span class="line">00 - 0</span><br><span class="line">01 - 1</span><br><span class="line">11 - 3</span><br><span class="line">10 - 2</span><br><span class="line"></span><br><span class="line">For a given n, a gray code sequence may not be uniquely defined.</span><br><span class="line">For example, [0,2,3,1] is also a valid gray code sequence.</span><br><span class="line"></span><br><span class="line">00 - 0</span><br><span class="line">10 - 2</span><br><span class="line">11 - 3</span><br><span class="line">01 - 1</span><br></pre></td></tr></table></figure>
<p>方法一：回溯法。一定要有顺序，一开始我误以为n位的进制0或1的组合。但是不行，因为不能从<code>01</code>跨越到<code>10</code>。这个问题我想了很久没有想出来如何解决，看到discuss中一个java版本的受到了启发。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grayCode</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(p, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            ans.append(int(<span class="string">''</span>.join(p), <span class="number">2</span>))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">            p += binary[i]</span><br><span class="line">            <span class="keyword">if</span> p[<span class="number">-1</span>] == <span class="string">'0'</span>:</span><br><span class="line">                backtrack(p, n<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                binary[<span class="number">0</span>], binary[<span class="number">1</span>] = binary[<span class="number">1</span>], binary[<span class="number">0</span>]</span><br><span class="line">                backtrack(p, n<span class="number">-1</span>)</span><br><span class="line">                binary[<span class="number">0</span>], binary[<span class="number">1</span>] = binary[<span class="number">1</span>], binary[<span class="number">0</span>]</span><br><span class="line">            p = p[:<span class="number">-1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">0</span>]</span><br><span class="line">    ans = []</span><br><span class="line">    binary = list(<span class="string">'01'</span>)</span><br><span class="line">    backtrack(<span class="string">''</span>, n)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：此题有规律，这个规律讲不太好，有点像之字形那种感觉，倒序的时候在最高位补1。就能满足每个数只变化一位的要求。</font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0   1   11  110</span><br><span class="line">        10  111</span><br><span class="line">            101</span><br><span class="line">            100</span><br><span class="line"></span><br><span class="line">start:      [0]  # [0]</span><br><span class="line">i = 0:      [0, 1]  # [0, 1]</span><br><span class="line">i = 1:      [0, 1, 3, 2]  # [00, 01, 11, 10]</span><br><span class="line">i = 2:      [0, 1, 3, 2, 6, 7, 5, 4]  # [000, 001, 011, 010, 110, 111, 101, 100]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grayCode</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">    ans = [<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="comment"># ans += [x + pow(2, i) for x in reversed(ans)]</span></span><br><span class="line">        ans += (x | <span class="number">1</span>&lt;&lt;i <span class="keyword">for</span> x <span class="keyword">in</span> reversed(ans))</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="842-Split-Array-into-Fibonacci-Sequence"><a href="#842-Split-Array-into-Fibonacci-Sequence" class="headerlink" title="842. Split Array into Fibonacci Sequence"></a>842. Split Array into Fibonacci Sequence</h3><h4 id="一串数组组成的字符串拆成斐波那契数列。原题"><a href="#一串数组组成的字符串拆成斐波那契数列。原题" class="headerlink" title="一串数组组成的字符串拆成斐波那契数列。原题"></a>一串数组组成的字符串拆成斐波那契数列。<a href="https://leetcode.com/problems/split-array-into-fibonacci-sequence/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;123456579&quot;</span><br><span class="line">Output: [123,456,579]</span><br><span class="line"></span><br><span class="line">Input: &quot;112358130&quot;</span><br><span class="line">Output: []</span><br><span class="line">Explanation: The task is impossible.</span><br></pre></td></tr></table></figure>
<p>ps: 此题第一天做的时候想了很久，提交了n个错误答案，后来第二天做的时候，20分钟就做出来了。</p>
<p>方法一：第一次AC的答案。需要注意几个点。首先只有当元素结果大于2才算数列；主循环中<code>range(1, len(rest)+1)</code>否则会丢失最后元素；因为0的存在，所以要考虑0不能作为数字的开头；最后题中要求每个数字要在<code>int32</code>范围内。224ms.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">splitIntoFibonacci</span><span class="params">(self, S: str)</span> -&gt; List[int]:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(p, rest)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> rest <span class="keyword">and</span> len(p) &gt; <span class="number">2</span>:</span><br><span class="line">            ans.append(list(map(int, p)))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(rest)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> len(p) &lt; <span class="number">2</span> <span class="keyword">or</span> int(rest[:i])==int(p[<span class="number">-1</span>])+int(p[<span class="number">-2</span>]):</span><br><span class="line">                <span class="keyword">if</span> len(rest[:i]) &gt; <span class="number">1</span> <span class="keyword">and</span> rest[<span class="number">0</span>]==<span class="string">'0'</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> int(rest[:i]) &gt; <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                backtrack(p+[rest[:i]], rest[i:])</span><br><span class="line">    ans = []</span><br><span class="line">    backtrack([], S)</span><br><span class="line">    <span class="keyword">return</span> ans[<span class="number">0</span>] <span class="keyword">if</span> ans <span class="keyword">else</span> []</span><br></pre></td></tr></table></figure>
<p>优化二：添加一个flag，在找到结果后返回。188ms, beats 26%.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">splitIntoFibonacci</span><span class="params">(self, S: str)</span> -&gt; List[int]:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(p, rest)</span>:</span></span><br><span class="line">        <span class="comment"># print(p, rest)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> rest <span class="keyword">and</span> len(p) &gt; <span class="number">2</span>:</span><br><span class="line">            ans.append(list(map(int, p)))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(rest)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> len(p) &lt; <span class="number">2</span> <span class="keyword">or</span> int(rest[:i])==int(p[<span class="number">-1</span>])+int(p[<span class="number">-2</span>]):</span><br><span class="line">                <span class="keyword">if</span> len(rest[:i]) &gt; <span class="number">1</span> <span class="keyword">and</span> rest[<span class="number">0</span>]==<span class="string">'0'</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> int(rest[:i]) &gt; <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> backtrack(p+[rest[:i]], rest[i:]):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    ans = []</span><br><span class="line">    backtrack([], S)</span><br><span class="line">    <span class="keyword">return</span> ans[<span class="number">0</span>] <span class="keyword">if</span> ans <span class="keyword">else</span> []</span><br></pre></td></tr></table></figure>
<p>优化三：每个元素既然小于<code>2**31-1</code>那么，最长长度为10。在主循环中加入此条件可以提升到52ms。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">splitIntoFibonacci</span><span class="params">(self, S: str)</span> -&gt; List[int]:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(p, rest)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> rest <span class="keyword">and</span> len(p) &gt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> list(map(int, p))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, min(<span class="number">11</span>, len(rest)+<span class="number">1</span>)):</span><br><span class="line">            to_add = rest[:i]</span><br><span class="line">            <span class="keyword">if</span> len(p) &lt; <span class="number">2</span> <span class="keyword">or</span> int(to_add)==int(p[<span class="number">-1</span>])+int(p[<span class="number">-2</span>]):</span><br><span class="line">                <span class="keyword">if</span> len(to_add) &gt; <span class="number">1</span> <span class="keyword">and</span> rest.startswith(<span class="string">'0'</span>):</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> int(to_add) &gt; <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                seq = backtrack(p+[to_add], rest[i:])</span><br><span class="line">                <span class="keyword">if</span> seq:</span><br><span class="line">                    <span class="keyword">return</span> seq</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    ans = backtrack([], S)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">优化4：当前两个数和已经为3位数时，下一个数没必要从1开始了。44ms。无论怎么提交都达不到迭代的40ms。猜测可能是递归栈的瓶颈了吧。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">splitIntoFibonacci</span><span class="params">(self, S: str)</span> -&gt; List[int]:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(p, rest)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> rest <span class="keyword">and</span> len(p) &gt; <span class="number">2</span>:</span><br><span class="line">            p[:] = list(map(int, p))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> len(p) &gt;= <span class="number">2</span>:</span><br><span class="line">            next_num = int(p[<span class="number">-1</span>]) + int(p[<span class="number">-2</span>])</span><br><span class="line">            start = len(str(next_num))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            start = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start, min(<span class="number">11</span>, len(rest)+<span class="number">1</span>)):</span><br><span class="line">            to_add = rest[:i]</span><br><span class="line">            <span class="keyword">if</span> len(p) &lt; <span class="number">2</span> <span class="keyword">or</span> int(to_add)==next_num:</span><br><span class="line">                <span class="keyword">if</span> len(to_add) &gt; <span class="number">1</span> <span class="keyword">and</span> rest.startswith(<span class="string">'0'</span>):</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> int(to_add) &gt; <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                p.append(to_add)</span><br><span class="line">                <span class="keyword">if</span> backtrack(p, rest[i:]):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                p.pop()</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    ans = []</span><br><span class="line">    backtrack(ans, S)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：迭代。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">splitIntoFibonacci</span><span class="params">(self, S: str)</span> -&gt; List[int]:</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(min(<span class="number">10</span>, len(S))):</span><br><span class="line">        a = S[:i+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> a != <span class="string">'0'</span> <span class="keyword">and</span> a.startswith(<span class="string">'0'</span>): <span class="keyword">break</span></span><br><span class="line">        a = int(a)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, min(i+<span class="number">10</span>, len(S))):</span><br><span class="line">            b = S[i+<span class="number">1</span>:j+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> b != <span class="string">'0'</span> <span class="keyword">and</span> b.startswith(<span class="string">'0'</span>): <span class="keyword">break</span></span><br><span class="line">            b = int(b)</span><br><span class="line">            fib = [a, b]</span><br><span class="line">            k = j + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> k &lt; len(S):</span><br><span class="line">                nxt = fib[<span class="number">-2</span>] + fib[<span class="number">-1</span>]</span><br><span class="line">                nxt_str = str(nxt)</span><br><span class="line">                <span class="keyword">if</span> nxt &lt;= <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span> <span class="keyword">and</span> S[k:].startswith(nxt_str):</span><br><span class="line">                    fib.append(nxt)</span><br><span class="line">                    k += len(nxt_str)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> len(fib) &gt; <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">return</span> fib</span><br><span class="line">    <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
<h3 id="60-Permutation-Sequence"><a href="#60-Permutation-Sequence" class="headerlink" title="60. Permutation Sequence"></a>60. Permutation Sequence</h3><h4 id="全排列中的第k个。原题"><a href="#全排列中的第k个。原题" class="headerlink" title="全排列中的第k个。原题"></a>全排列中的第k个。<a href="https://leetcode.com/problems/permutation-sequence/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 3, k = 3</span><br><span class="line">Output: &quot;213&quot;</span><br></pre></td></tr></table></figure>
<p>方法一：其实一开始想到了数学跳过去前几个结果，不过想着暴力的解决一下，结果却超时了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPermutation</span><span class="params">(self, n: int, k: int)</span> -&gt; str:</span></span><br><span class="line">    self.k = k</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(s, rest)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> rest:</span><br><span class="line">            self.k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.k == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> s</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(rest)):</span><br><span class="line">            old = s</span><br><span class="line">            s += rest[i]</span><br><span class="line">            ans = backtrack(s, rest[:i]+rest[i+<span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">if</span> ans: <span class="keyword">return</span> ans</span><br><span class="line">            s = old</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    nums = list(map(str, range(<span class="number">1</span>, n+<span class="number">1</span>)))</span><br><span class="line">    <span class="keyword">return</span> backtrack(<span class="string">''</span>, nums)</span><br></pre></td></tr></table></figure>
<p>优化二：如果当前的k大于整个全排列的个数，那么跳过。比如<code>1234</code>从1开始，最多有<code>3!</code>个，如果k比它大，那么结果肯定不是1开头的数。40ms.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPermutation</span><span class="params">(self, n: int, k: int)</span> -&gt; str:</span></span><br><span class="line">    self.k = k</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(s, rest)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> rest:</span><br><span class="line">            self.k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.k == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> s</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(rest)):</span><br><span class="line">            <span class="keyword">if</span> self.k &gt; math.factorial(len(rest)<span class="number">-1</span>):</span><br><span class="line">                self.k -= math.factorial(len(rest)<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            old = s</span><br><span class="line">            s += rest[i]</span><br><span class="line">            ans = backtrack(s, rest[:i]+rest[i+<span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">if</span> ans: <span class="keyword">return</span> ans</span><br><span class="line">            s = old</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    nums = list(map(str, range(<span class="number">1</span>, n+<span class="number">1</span>)))</span><br><span class="line">    <span class="keyword">return</span> backtrack(<span class="string">''</span>, nums)</span><br></pre></td></tr></table></figure>
<p>方法二：改变一下思路，根据k的大小来确定每个位置的数。这道题想了不到个小时，最终原创出自己的写法。耗时36ms，beats 99%。果然数据规律才是致命的降维打击。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPermutation</span><span class="params">(self, n: int, k: int)</span> -&gt; str:</span></span><br><span class="line">    ans = <span class="string">''</span></span><br><span class="line">    nums = list(map(str, range(<span class="number">1</span>, n+<span class="number">1</span>)))</span><br><span class="line">    fact = math.factorial(len(nums)<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">while</span> k != <span class="number">1</span>:</span><br><span class="line">        i = (k - <span class="number">1</span>) // fact</span><br><span class="line">        k -= i * fact</span><br><span class="line">        ans += nums.pop(i)</span><br><span class="line">        fact //= len(nums)            </span><br><span class="line">    ans += <span class="string">''</span>.join(nums)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法三：根据solution中调整了一些点。关于k索引的问题可以在一开始就-1，然后循环中便可以使用<code>divmod</code>内置函数来求值。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPermutation</span><span class="params">(self, n: int, k: int)</span> -&gt; str:</span></span><br><span class="line">    ans = <span class="string">''</span></span><br><span class="line">    nums = list(map(str, range(<span class="number">1</span>, n+<span class="number">1</span>)))</span><br><span class="line">    fact = math.factorial(len(nums)<span class="number">-1</span>)</span><br><span class="line">    k -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k:</span><br><span class="line">        i, k = divmod(k, fact)</span><br><span class="line">        ans += nums.pop(i)</span><br><span class="line">        fact //= len(nums)            </span><br><span class="line">    ans += <span class="string">''</span>.join(nums)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="46-Permutations"><a href="#46-Permutations" class="headerlink" title="46. Permutations"></a>46. Permutations</h3><h4 id="数组全排列。原题"><a href="#数组全排列。原题" class="headerlink" title="数组全排列。原题"></a>数组全排列。<a href="https://leetcode.com/problems/permutations/description/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法一：recursively. 锁定头部法。思想为拿出一个数字作为头部，剩下的递归。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> [[n] + p</span><br><span class="line">            <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(nums)</span><br><span class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> self.permute(nums[:i]+nums[i+<span class="number">1</span>:])] <span class="keyword">or</span> [[]]</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：到处插入法。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums: <span class="string">'List[int]'</span>)</span> -&gt; 'List[List[int]]':</span></span><br><span class="line">    <span class="keyword">return</span> nums <span class="keyword">and</span> [p[:i] + [nums[<span class="number">0</span>]] + p[i:]</span><br><span class="line">                     <span class="keyword">for</span> p <span class="keyword">in</span> self.permute(nums[<span class="number">1</span>:])</span><br><span class="line">                     <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))] <span class="keyword">or</span> [[]]</span><br></pre></td></tr></table></figure>
<p>方法二：iteratively. 思想为拿出一个数字插入到现有排序中的各个位置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    ans = [[]]</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">        ans = [l[:i] + [n] + l[i:]</span><br><span class="line">               <span class="keyword">for</span> l <span class="keyword">in</span> ans</span><br><span class="line">               <span class="keyword">for</span> i <span class="keyword">in</span> range(len(l)+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="47-Permutations-II"><a href="#47-Permutations-II" class="headerlink" title="47. Permutations II"></a>47. Permutations II</h3><h4 id="全排列并去重。原题"><a href="#全排列并去重。原题" class="headerlink" title="全排列并去重。原题"></a>全排列并去重。<a href="https://leetcode.com/problems/permutations-ii/description/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,2]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,1,2],</span><br><span class="line">  [1,2,1],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>思路：当然可以使用<code>set</code>来去重，或者考虑一种迭代的方式。</p>
<p>展开。拿着每个数字向上一个结果中插入到每一个位置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    ans = [[]]</span><br><span class="line">    <span class="keyword">for</span> j, n <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">        new_ans = []</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> ans:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(l)+<span class="number">1</span>):</span><br><span class="line">                new_ans.append(l[:i]+[n]+l[i:])</span><br><span class="line">                print(<span class="string">'\t j &#123;0&#125; - &#123;3&#125; + [&#123;2&#125;] + &#123;4&#125;'</span>.format(j, i, n, l[:i], l[i:]))</span><br><span class="line">                <span class="comment"># if i&lt;len(l) and l[i]==n: break              #handles duplication</span></span><br><span class="line">                <span class="keyword">if</span> i&lt;len(l) <span class="keyword">and</span> l[i]==n: </span><br><span class="line">                    print(<span class="string">'\t \t l[&#123;&#125;] == &#123;&#125;'</span>.format(i, n))</span><br><span class="line">                    <span class="keyword">break</span>              <span class="comment">#handles duplication</span></span><br><span class="line">        ans = new_ans</span><br><span class="line">        print(<span class="string">'j &#123;&#125; afer inner ans &#123;&#125;'</span>.format(j, ans))</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>输入<code>nums=[1, 2, 3]</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">	 j 0 - [] + [1] + []</span><br><span class="line">j 0 afer inner ans [[1]]</span><br><span class="line">	 j 1 - [] + [2] + [1]</span><br><span class="line">	 j 1 - [1] + [2] + []</span><br><span class="line">j 1 afer inner ans [[2, 1], [1, 2]]</span><br><span class="line">	 j 2 - [] + [3] + [2, 1]</span><br><span class="line">	 j 2 - [2] + [3] + [1]</span><br><span class="line">	 j 2 - [2, 1] + [3] + []</span><br><span class="line">	 j 2 - [] + [3] + [1, 2]</span><br><span class="line">	 j 2 - [1] + [3] + [2]</span><br><span class="line">	 j 2 - [1, 2] + [3] + []</span><br><span class="line">j 2 afer inner ans [[3, 2, 1], [2, 3, 1], [2, 1, 3], [3, 1, 2], [1, 3, 2], [1, 2, 3]]</span><br></pre></td></tr></table></figure>
<p>理解一下是如何去重的，我们输入<code>nums=[1, 2, 1]</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">	 j 0 - [] + [1] + []</span><br><span class="line">j 0 afer inner ans [[1]]</span><br><span class="line">	 j 1 - [] + [2] + [1]</span><br><span class="line">	 j 1 - [1] + [2] + []</span><br><span class="line">j 1 afer inner ans [[2, 1], [1, 2]]</span><br><span class="line">	 j 2 - [] + [1] + [2, 1]</span><br><span class="line">	 j 2 - [2] + [1] + [1]</span><br><span class="line">	 	 l[1] == 1</span><br><span class="line">	 j 2 - [] + [1] + [1, 2]</span><br><span class="line">	 	 l[0] == 1</span><br><span class="line">j 2 afer inner ans [[1, 2, 1], [2, 1, 1], [1, 1, 2]]</span><br><span class="line">[[1, 2, 1], [2, 1, 1], [1, 1, 2]]</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">列表生成式整合。Stefan大神的写法。使用index来找非重复的临界值。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    ans = [[]]</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">        ans = [l[:i]+[n]+l[i:]</span><br><span class="line">               <span class="keyword">for</span> l <span class="keyword">in</span> ans</span><br><span class="line">               <span class="keyword">for</span> i <span class="keyword">in</span> range((l+[n]).index(n)+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">递归也可以</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    <span class="keyword">return</span> nums <span class="keyword">and</span> [p[:i] + [nums[<span class="number">0</span>]] + p[i:]</span><br><span class="line">                     <span class="keyword">for</span> p <span class="keyword">in</span> self.permuteUnique(nums[<span class="number">1</span>:])</span><br><span class="line">                     <span class="keyword">for</span> i <span class="keyword">in</span> range((p+[nums[<span class="number">0</span>]]).index(nums[<span class="number">0</span>])+<span class="number">1</span>)</span><br><span class="line">                     ] <span class="keyword">or</span> [[]]</span><br></pre></td></tr></table></figure>
<h3 id="1079-Letter-Tile-Possibilities"><a href="#1079-Letter-Tile-Possibilities" class="headerlink" title="1079. Letter Tile Possibilities"></a>1079. Letter Tile Possibilities</h3><h4 id="本来是一道回溯的题，结果测试用例过于简单，所以暴力法就解出来了。原题"><a href="#本来是一道回溯的题，结果测试用例过于简单，所以暴力法就解出来了。原题" class="headerlink" title="本来是一道回溯的题，结果测试用例过于简单，所以暴力法就解出来了。原题"></a>本来是一道回溯的题，结果测试用例过于简单，所以暴力法就解出来了。<a href="https://leetcode.com/problems/letter-tile-possibilities/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;AAB&quot;</span><br><span class="line">Output: 8</span><br><span class="line">Explanation: The possible sequences are &quot;A&quot;, &quot;B&quot;, &quot;AA&quot;, &quot;AB&quot;, &quot;BA&quot;, &quot;AAB&quot;, &quot;ABA&quot;, &quot;BAA&quot;.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numTilePossibilities</span><span class="params">(self, tiles: str)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">from</span> itertools <span class="keyword">import</span> permutations</span><br><span class="line">    n = len(tiles)</span><br><span class="line">    <span class="keyword">return</span> sum(len(set(permutations(tiles, i))) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<h3 id="1415-The-k-th-Lexicographical-String-of-All-Happy-Strings-of-Length-n"><a href="#1415-The-k-th-Lexicographical-String-of-All-Happy-Strings-of-Length-n" class="headerlink" title="1415. The k-th Lexicographical String of All Happy Strings of Length n"></a>1415. The k-th Lexicographical String of All Happy Strings of Length n</h3><h4 id="列出第k个快乐字符串（a-b-c）组成并没有连续相同的字母。原题"><a href="#列出第k个快乐字符串（a-b-c）组成并没有连续相同的字母。原题" class="headerlink" title="列出第k个快乐字符串（a,b,c）组成并没有连续相同的字母。原题"></a>列出第k个快乐字符串（a,b,c）组成并没有连续相同的字母。<a href="https://leetcode.com/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n/" target="_blank" rel="noopener">原题</a></h4><p>方法一：回溯法。列出所有的值，排序索引。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHappyString</span><span class="params">(self, n: int, k: int)</span> -&gt; str:</span></span><br><span class="line">    combine = []</span><br><span class="line">    s = <span class="string">'abc'</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(cur, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            combine.append(cur)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (cur <span class="keyword">and</span> cur[<span class="number">-1</span>]==c):</span><br><span class="line">                backtrack(cur+c, n<span class="number">-1</span>)</span><br><span class="line">    </span><br><span class="line">    backtrack(<span class="string">''</span>, n)</span><br><span class="line">    combine.sort()</span><br><span class="line">    <span class="keyword">return</span> combine[k<span class="number">-1</span>] <span class="keyword">if</span> k &lt;= len(combine) <span class="keyword">else</span> <span class="string">''</span></span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法二：开始想的就是这种方法，后来想偏了，想用数学的方式直接求目标字符串，最后没有写出来。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHappyString</span><span class="params">(self, n: int, k: int)</span> -&gt; str:</span></span><br><span class="line">    nxt = &#123;<span class="string">'a'</span>: <span class="string">'bc'</span>, <span class="string">'b'</span>: <span class="string">'ac'</span>, <span class="string">'c'</span>: <span class="string">'ab'</span>&#125; </span><br><span class="line">    q = collections.deque([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br><span class="line">    <span class="keyword">while</span> len(q[<span class="number">0</span>]) != n:</span><br><span class="line">        u = q.popleft()    </span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> nxt[u[<span class="number">-1</span>]]:</span><br><span class="line">            q.append(u + v)</span><br><span class="line">    <span class="keyword">return</span> q[k - <span class="number">1</span>] <span class="keyword">if</span> len(q) &gt;= k <span class="keyword">else</span> <span class="string">''</span></span><br></pre></td></tr></table></figure>
<h3 id="1255-Maximum-Score-Words-Formed-by-Letters"><a href="#1255-Maximum-Score-Words-Formed-by-Letters" class="headerlink" title="1255. Maximum Score Words Formed by Letters"></a>1255. Maximum Score Words Formed by Letters</h3><h4 id="给定一些单词，每个字母有得分，不过每个字母用多少是有限制的。问最大得分是多少，一个典型的背包问题。原题"><a href="#给定一些单词，每个字母有得分，不过每个字母用多少是有限制的。问最大得分是多少，一个典型的背包问题。原题" class="headerlink" title="给定一些单词，每个字母有得分，不过每个字母用多少是有限制的。问最大得分是多少，一个典型的背包问题。原题"></a>给定一些单词，每个字母有得分，不过每个字母用多少是有限制的。问最大得分是多少，一个典型的背包问题。<a href="https://leetcode.com/problems/maximum-score-words-formed-by-letters/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;dog&quot;,&quot;cat&quot;,&quot;dad&quot;,&quot;good&quot;], letters = [&quot;a&quot;,&quot;a&quot;,&quot;c&quot;,&quot;d&quot;,&quot;d&quot;,&quot;d&quot;,&quot;g&quot;,&quot;o&quot;,&quot;o&quot;], score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0]</span><br><span class="line">Output: 23</span><br><span class="line">Explanation:</span><br><span class="line">Score  a=1, c=9, d=5, g=3, o=2</span><br><span class="line">Given letters, we can form the words &quot;dad&quot; (5+1+5) and &quot;good&quot; (3+2+2+5) with a score of 23.</span><br><span class="line">Words &quot;dad&quot; and &quot;dog&quot; only get a score of 21.</span><br></pre></td></tr></table></figure>
<p>方法一：回溯。累加单词的分数可以提前退出递归。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxScoreWords</span><span class="params">(self, words: List[str], letters: List[str], score: List[int])</span> -&gt; int:</span></span><br><span class="line">    self.ans, n = <span class="number">0</span>, len(words)</span><br><span class="line">    wc = [Counter(w) <span class="keyword">for</span> w <span class="keyword">in</span> words]</span><br><span class="line">    ws = [sum(v*score[ord(k)-ord(<span class="string">'a'</span>)] <span class="keyword">for</span> k, v <span class="keyword">in</span> wc[i].items()) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, s, left)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> s + sum(ws[i:]) &lt;= self.ans:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.ans = max(self.ans, s)</span><br><span class="line">        <span class="keyword">for</span> j, wcnt <span class="keyword">in</span> enumerate(wc[i:], i):</span><br><span class="line">            <span class="keyword">if</span> all(n &lt;= left.get(c, <span class="number">0</span>) <span class="keyword">for</span> c, n <span class="keyword">in</span> wcnt.items()):</span><br><span class="line">                dfs(j+<span class="number">1</span>, s+ws[j], left-wcnt)</span><br><span class="line">                </span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>, Counter(letters))</span><br><span class="line">    <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure>
<p>方法二：这个和我一开始想的方法很像。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxScoreWords</span><span class="params">(self, words: List[str], letters: List[str], score: List[int])</span> -&gt; int:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(i, left)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i == len(words):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        wc = Counter(words[i])</span><br><span class="line">        <span class="keyword">if</span> all(n&lt;=left[c] <span class="keyword">for</span> c, n <span class="keyword">in</span> wc.items()):</span><br><span class="line">            cur_score = sum(v*score[ord(k)-ord(<span class="string">'a'</span>)] <span class="keyword">for</span> k, v <span class="keyword">in</span> wc.items())</span><br><span class="line">            ans = max(cur_score + backtrack(i+<span class="number">1</span>, left-wc), backtrack(i+<span class="number">1</span>, left))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ans = backtrack(i+<span class="number">1</span>, left)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="keyword">return</span> backtrack(<span class="number">0</span>, Counter(letters))</span><br></pre></td></tr></table></figure>
<h3 id="1239-Maximum-Length-of-a-Concatenated-String-with-Unique-Characters"><a href="#1239-Maximum-Length-of-a-Concatenated-String-with-Unique-Characters" class="headerlink" title="1239. Maximum Length of a Concatenated String with Unique Characters"></a>1239. Maximum Length of a Concatenated String with Unique Characters</h3><h4 id="最长的不重复的字符串组合。原题"><a href="#最长的不重复的字符串组合。原题" class="headerlink" title="最长的不重复的字符串组合。原题"></a>最长的不重复的字符串组合。<a href="https://leetcode.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/" target="_blank" rel="noopener">原题</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: All possible concatenations are &quot;&quot;,&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;,&quot;uniq&quot; and &quot;ique&quot;.</span><br><span class="line">Maximum length is 4.</span><br></pre></td></tr></table></figure>
<p>方法一：回溯法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxLength</span><span class="params">(self, arr: List[str])</span> -&gt; int:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, seen)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i == len(arr):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">        <span class="keyword">if</span> set(arr[i]) &amp; seen <span class="keyword">or</span> len(set(arr[i]))!=len(arr[i]):</span><br><span class="line">            ans = dfs(i+<span class="number">1</span>, seen)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ans = max(len(arr[i]) + dfs(i+<span class="number">1</span>, seen|set(arr[i])), dfs(i+<span class="number">1</span>, seen))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">0</span>, set())</span><br></pre></td></tr></table></figure>
<p>方法二：Lee215的解法。append的方式，会将每步累加的追加的ans中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxLength</span><span class="params">(self, arr: List[str])</span> -&gt; int:</span></span><br><span class="line">    ans = [set()]</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> arr:</span><br><span class="line">        <span class="keyword">if</span> len(set(a)) != len(a):<span class="keyword">continue</span></span><br><span class="line">        a = set(a)</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> ans[:]:</span><br><span class="line">            <span class="keyword">if</span> a &amp; c: <span class="keyword">continue</span></span><br><span class="line">            ans.append(a | c)</span><br><span class="line">    <span class="keyword">return</span> max(len(a) <span class="keyword">for</span> a <span class="keyword">in</span> ans)</span><br></pre></td></tr></table></figure>
<h3 id="51-N-Queens"><a href="#51-N-Queens" class="headerlink" title="51. N-Queens"></a>51. N-Queens</h3><h4 id="著名的N皇后问题，将N个皇后摆在N-N的棋盘中，直线，斜线不能同时存在2个皇后。问所有的摆放位置。原题"><a href="#著名的N皇后问题，将N个皇后摆在N-N的棋盘中，直线，斜线不能同时存在2个皇后。问所有的摆放位置。原题" class="headerlink" title="著名的N皇后问题，将N个皇后摆在N*N的棋盘中，直线，斜线不能同时存在2个皇后。问所有的摆放位置。原题"></a>著名的N皇后问题，将N个皇后摆在N*N的棋盘中，直线，斜线不能同时存在2个皇后。问所有的摆放位置。<a href="https://leetcode.com/problems/n-queens/" target="_blank" rel="noopener">原题</a></h4><p>方法一：调了一次就AC了。记录第一次AC的方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span><span class="params">(self, n: int)</span> -&gt; List[List[str]]:</span></span><br><span class="line"></span><br><span class="line">    l_dig = [<span class="keyword">False</span>] * (n*<span class="number">2</span><span class="number">-1</span>)</span><br><span class="line">    r_dig = [<span class="keyword">False</span>] * (n*<span class="number">2</span><span class="number">-1</span>)</span><br><span class="line">    row = [<span class="keyword">False</span>] * n</span><br><span class="line">    col = [<span class="keyword">False</span>] * n</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(i, j, k, g)</span>:</span></span><br><span class="line">        <span class="comment"># print(i, j, k, g)</span></span><br><span class="line">        row[i] = <span class="keyword">True</span></span><br><span class="line">        col[j] = <span class="keyword">True</span></span><br><span class="line">        l_dig[i+j] = <span class="keyword">True</span></span><br><span class="line">        r_dig[j-i+n<span class="number">-1</span>] = <span class="keyword">True</span></span><br><span class="line">        g[i][j] = <span class="string">'Q'</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> k<span class="number">-1</span>:</span><br><span class="line">            ans.append([<span class="string">''</span>.join(row) <span class="keyword">for</span> row <span class="keyword">in</span> g])</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(i+<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> row[x]:</span><br><span class="line">                <span class="keyword">for</span> y <span class="keyword">in</span> range(n):</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> col[y]:</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">not</span> l_dig[x+y] <span class="keyword">and</span> <span class="keyword">not</span> r_dig[y-x+n<span class="number">-1</span>]:</span><br><span class="line">                            backtrack(x, y, k<span class="number">-1</span>, g)</span><br><span class="line">        row[i] = <span class="keyword">False</span></span><br><span class="line">        col[j] = <span class="keyword">False</span></span><br><span class="line">        l_dig[i+j] = <span class="keyword">False</span></span><br><span class="line">        r_dig[j-i+n<span class="number">-1</span>] = <span class="keyword">False</span></span><br><span class="line">        g[i][j] = <span class="string">'.'</span></span><br><span class="line">                        </span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">        g = [[<span class="string">'.'</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        backtrack(<span class="number">0</span>, j, n, g)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>方法二：row是不必要的，因为遍历行是不会有重复的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span><span class="params">(self, n: int)</span> -&gt; List[List[str]]:</span></span><br><span class="line"></span><br><span class="line">    l_dig = [<span class="keyword">False</span>] * (n*<span class="number">2</span><span class="number">-1</span>)</span><br><span class="line">    r_dig = [<span class="keyword">False</span>] * (n*<span class="number">2</span><span class="number">-1</span>)</span><br><span class="line">    col = [<span class="keyword">False</span>] * n</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(i, j, k, g)</span>:</span></span><br><span class="line">        <span class="comment"># print(i, j, k, g)</span></span><br><span class="line">        col[j] = l_dig[i+j] = r_dig[j-i+n<span class="number">-1</span>] = <span class="keyword">True</span></span><br><span class="line">        g[i][j] = <span class="string">'Q'</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> k<span class="number">-1</span>:</span><br><span class="line">            ans.append([<span class="string">''</span>.join(row) <span class="keyword">for</span> row <span class="keyword">in</span> g])</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(i+<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> col[y]:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> l_dig[x+y] <span class="keyword">and</span> <span class="keyword">not</span> r_dig[y-x+n<span class="number">-1</span>]:</span><br><span class="line">                        backtrack(x, y, k<span class="number">-1</span>, g)</span><br><span class="line">        col[j] = l_dig[i+j] = r_dig[j-i+n<span class="number">-1</span>] = <span class="keyword">False</span></span><br><span class="line">        g[i][j] = <span class="string">'.'</span></span><br><span class="line">                        </span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">        g = [[<span class="string">'.'</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        backtrack(<span class="number">0</span>, j, n, g)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<font color="#32CD32" size="3">方法三：上述两种方法，用时800ms，此方法52ms，直接以行为单位进行回溯。</font>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span><span class="params">(self, n: int)</span> -&gt; List[List[str]]:</span></span><br><span class="line"></span><br><span class="line">    l_dig = [<span class="keyword">False</span>] * (n*<span class="number">2</span><span class="number">-1</span>)</span><br><span class="line">    r_dig = [<span class="keyword">False</span>] * (n*<span class="number">2</span><span class="number">-1</span>)</span><br><span class="line">    col = [<span class="keyword">False</span>] * n</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(i, g)</span>:</span></span><br><span class="line">        <span class="comment"># print(i, j, k, g)</span></span><br><span class="line">        <span class="keyword">if</span> i == n:</span><br><span class="line">            ans.append(list(g))</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> col[j] <span class="keyword">and</span> <span class="keyword">not</span> l_dig[i+j] <span class="keyword">and</span> <span class="keyword">not</span> r_dig[j-i+n<span class="number">-1</span>]:</span><br><span class="line">                row = <span class="string">'.'</span>*j + <span class="string">'Q'</span> + <span class="string">'.'</span>*(n-j<span class="number">-1</span>)</span><br><span class="line">                g.append(row)</span><br><span class="line">                col[j] = l_dig[i+j] = r_dig[j-i+n<span class="number">-1</span>] = <span class="keyword">True</span></span><br><span class="line">                backtrack(i+<span class="number">1</span>, g)</span><br><span class="line">                col[j] = l_dig[i+j] = r_dig[j-i+n<span class="number">-1</span>] = <span class="keyword">False</span></span><br><span class="line">                g.pop()</span><br><span class="line">                        </span><br><span class="line">    ans = []</span><br><span class="line">    backtrack(<span class="number">0</span>, [])</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="52-N-Queens-II"><a href="#52-N-Queens-II" class="headerlink" title="52. N-Queens II"></a>52. N-Queens II</h3><h4 id="和上边一样的N皇后问题，要求最后有多少种。原题"><a href="#和上边一样的N皇后问题，要求最后有多少种。原题" class="headerlink" title="和上边一样的N皇后问题，要求最后有多少种。原题"></a>和上边一样的N皇后问题，要求最后有多少种。<a href="https://leetcode.com/problems/n-queens-ii/" target="_blank" rel="noopener">原题</a></h4><p>方法一：不再需要一个数组来记录棋盘了，只需要计数就行。然后通过一个数组标记每行的棋子的纵坐标。而且无需重置，因为值会覆盖之前的。本质上还是回溯方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">totalNQueens</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">    rows = [<span class="number">-1</span>] * n</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">valid</span><span class="params">(k)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="keyword">if</span> rows[i]==rows[k] <span class="keyword">or</span> abs(rows[k]-rows[i]) == k-i:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i == n: </span><br><span class="line">            <span class="keyword">nonlocal</span> ans</span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            rows[i] = j</span><br><span class="line">            <span class="keyword">if</span> valid(i):</span><br><span class="line">                dfs(i+<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="37-Sudoku-Solver"><a href="#37-Sudoku-Solver" class="headerlink" title="37. Sudoku Solver"></a>37. Sudoku Solver</h3><h4 id="解9-9的数独。原题"><a href="#解9-9的数独。原题" class="headerlink" title="解9*9的数独。原题"></a>解9*9的数独。<a href="https://leetcode.com/problems/sudoku-solver/" target="_blank" rel="noopener">原题</a></h4><p>方法一：首次AC的方法，嗨呀，递归调用时忘记写return True了，调了半天。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solveSudoku</span><span class="params">(self, g: List[List[str]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    row = [[<span class="keyword">True</span>]*<span class="number">9</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>)]        </span><br><span class="line">    col = [[<span class="keyword">True</span>]*<span class="number">9</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>)]</span><br><span class="line">    sub = [[<span class="keyword">True</span>]*<span class="number">9</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>)]</span><br><span class="line">    to_add = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">if</span> g[i][j] != <span class="string">'.'</span>:</span><br><span class="line">                d = int(g[i][j]) - <span class="number">1</span></span><br><span class="line">                row[i][d] = col[j][d] = sub[i//<span class="number">3</span>*<span class="number">3</span>+j//<span class="number">3</span>][d] = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                to_add.append((i, j))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> to_add: </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        i, j = to_add.pop()</span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">if</span> row[i][d] <span class="keyword">and</span> col[j][d] <span class="keyword">and</span> sub[i//<span class="number">3</span>*<span class="number">3</span>+j//<span class="number">3</span>][d]:</span><br><span class="line">                g[i][j] = str(d+<span class="number">1</span>)</span><br><span class="line">                row[i][d] = col[j][d] = sub[i//<span class="number">3</span>*<span class="number">3</span>+j//<span class="number">3</span>][d] = <span class="keyword">False</span></span><br><span class="line">                <span class="keyword">if</span> backtrack():</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                g[i][j] = <span class="string">'.'</span></span><br><span class="line">                row[i][d] = col[j][d] = sub[i//<span class="number">3</span>*<span class="number">3</span>+j//<span class="number">3</span>][d] = <span class="keyword">True</span></span><br><span class="line">        to_add.append((i, j))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    backtrack()</span><br></pre></td></tr></table></figure>
<h3 id="980-Unique-Paths-III"><a href="#980-Unique-Paths-III" class="headerlink" title="980. Unique Paths III"></a><a href="https://leetcode.com/problems/unique-paths-iii/" target="_blank" rel="noopener">980. Unique Paths III</a></h3><h4 id="二维数组中有0，1，2，-1四种格子，要求从1开始走到2，经过所有的0，一共有多少种走法。"><a href="#二维数组中有0，1，2，-1四种格子，要求从1开始走到2，经过所有的0，一共有多少种走法。" class="headerlink" title="二维数组中有0，1，2，-1四种格子，要求从1开始走到2，经过所有的0，一共有多少种走法。"></a>二维数组中有0，1，2，-1四种格子，要求从1开始走到2，经过所有的0，一共有多少种走法。</h4><p>方法一：回溯法，思路很清晰，很快就写出来了，方向变量写错了调了半天。只需要关注0的个数就行。有优化的地方，因为1和2只有一个，所以可以先遍历一次找出0个个数和1的位置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniquePathsIII</span><span class="params">(self, g: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    M, N = len(g) , len(g[<span class="number">0</span>])</span><br><span class="line">    f = sum(g, [])</span><br><span class="line">    zero = f.count(<span class="number">0</span>)</span><br><span class="line">    self.ans = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bf</span><span class="params">(i, j, n)</span>:</span></span><br><span class="line">        ori = g[i][j]    </span><br><span class="line">        <span class="keyword">if</span> ori == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> n==zero+<span class="number">2</span>:</span><br><span class="line">                self.ans += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        g[i][j] = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> ((i+<span class="number">1</span>, j), (i, j+<span class="number">1</span>), (i<span class="number">-1</span>, j), (i, j<span class="number">-1</span>)):</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span>&lt;=x&lt;M <span class="keyword">and</span> <span class="number">0</span>&lt;=y&lt;N <span class="keyword">and</span> g[x][y] <span class="keyword">in</span> (<span class="number">0</span>, <span class="number">2</span>):</span><br><span class="line">                bf(x, y, n+<span class="number">1</span>)</span><br><span class="line">        g[i][j] = ori</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(M):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">if</span> g[i][j] == <span class="number">1</span>:</span><br><span class="line">                bf(i, j, <span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure>
      
    </div>
    
    
    

    <div>
      
        
      
    </div>

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/LeetCode/" rel="tag">
            <i class="fa fa-tag"></i> LeetCode</a>
          
            <a href="/tags/Python/" rel="tag">
            <i class="fa fa-tag"></i> Python</a>
          
            <a href="/tags/Algorithm/" rel="tag">
            <i class="fa fa-tag"></i> Algorithm</a>
          
            <a href="/tags/BackTracking/" rel="tag">
            <i class="fa fa-tag"></i> BackTracking</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/矩阵中单词的路径，很多人都错了/" rel="next" title="矩阵中单词的路径，很多人都错了">
                <i class="fa fa-chevron-left"></i> 矩阵中单词的路径，很多人都错了
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/LeetCode算法题整理（栈篇）Stack/" rel="prev" title="LeetCode算法题整理（栈篇）Stack">
                LeetCode算法题整理（栈篇）Stack <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="xiaoliji" />
          <p class="site-author-name" itemprop="name">xiaoliji</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">28</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/darkTianTian" target="_blank" title="GitHub" rel="external nofollow">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.hackerrank.com/xiaoliji?hr_r=1" target="_blank" title="HackerRank" rel="external nofollow">
                  
                    <i class="fa fa-fw fa-hackerrank"></i>
                  
                    
                      HackerRank
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://leetcode.com/darktiantian/" target="_blank" title="LeetCode" rel="external nofollow">
                  
                    <i class="fa fa-fw fa-leetcode"></i>
                  
                    
                      LeetCode
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.jianshu.com/u/de42f74901fd" target="_blank" title="简书" rel="external nofollow">
                  
                    <i class="fa fa-fw fa-book"></i>
                  
                    
                      简书
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#93-Restore-IP-Addresses"><span class="nav-number">1.</span> <span class="nav-text">93. Restore IP Addresses</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#恢复IP地址。原题"><span class="nav-number">1.1.</span> <span class="nav-text">恢复IP地址。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#131-Palindrome-Partitioning"><span class="nav-number">2.</span> <span class="nav-text">131. Palindrome Partitioning</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#回文串切分。原题"><span class="nav-number">2.1.</span> <span class="nav-text">回文串切分。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#77-Combinations"><span class="nav-number">3.</span> <span class="nav-text">77. Combinations</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实现组合。原题"><span class="nav-number">3.1.</span> <span class="nav-text">实现组合。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#39-Combination-Sum"><span class="nav-number">4.</span> <span class="nav-text">39. Combination Sum</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#和77类似，找出和为指定数值的组合，候选数字可以重复使用。原题"><span class="nav-number">4.1.</span> <span class="nav-text">和77类似，找出和为指定数值的组合，候选数字可以重复使用。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#40-Combination-Sum-II"><span class="nav-number">5.</span> <span class="nav-text">40. Combination Sum II</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#组合求和，和39类似，区别在于候选数字中可能有重复数字，但每个数字只能使用一次。原题"><span class="nav-number">5.1.</span> <span class="nav-text">组合求和，和39类似，区别在于候选数字中可能有重复数字，但每个数字只能使用一次。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#216-Combination-Sum-III"><span class="nav-number">6.</span> <span class="nav-text">216. Combination Sum III</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#组合求和，从1-9选出k个不重复的数，和为n。原题"><span class="nav-number">6.1.</span> <span class="nav-text">组合求和，从1~9选出k个不重复的数，和为n。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#78-Subsets"><span class="nav-number">7.</span> <span class="nav-text">78. Subsets</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#输出给定无重复集合的子集组合。原题"><span class="nav-number">7.1.</span> <span class="nav-text">输出给定无重复集合的子集组合。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#90-Subsets-II"><span class="nav-number">8.</span> <span class="nav-text">90. Subsets II</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#和78类似，区别在于给定的数组有重复元素。原题"><span class="nav-number">8.1.</span> <span class="nav-text">和78类似，区别在于给定的数组有重复元素。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#79-Word-Search"><span class="nav-number">9.</span> <span class="nav-text">79. Word Search</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#矩阵中的路径。原题"><span class="nav-number">9.1.</span> <span class="nav-text">矩阵中的路径。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#200-Number-of-Islands"><span class="nav-number">10.</span> <span class="nav-text">200. Number of Islands</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#小岛的个数。原题"><span class="nav-number">10.1.</span> <span class="nav-text">小岛的个数。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1254-Number-of-Closed-Islands"><span class="nav-number">11.</span> <span class="nav-text">1254. Number of Closed Islands</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#和200类似，但是与边界相连的岛不能算了。原题"><span class="nav-number">11.1.</span> <span class="nav-text">和200类似，但是与边界相连的岛不能算了。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#130-Surrounded-Regions"><span class="nav-number">12.</span> <span class="nav-text">130. Surrounded Regions</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#将四周被包围的O翻转成X，边缘不算包围。原题"><span class="nav-number">12.1.</span> <span class="nav-text">将四周被包围的O翻转成X，边缘不算包围。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#417-Pacific-Atlantic-Water-Flow"><span class="nav-number">13.</span> <span class="nav-text">417. Pacific Atlantic Water Flow</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#太平洋大西洋水流向，假设陆地上可以沿着高度不高于的地方流淌，求能同时流入两个海洋的陆地坐标。原题"><span class="nav-number">13.1.</span> <span class="nav-text">太平洋大西洋水流向，假设陆地上可以沿着高度不高于的地方流淌，求能同时流入两个海洋的陆地坐标。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#526-Beautiful-Arrangement"><span class="nav-number">14.</span> <span class="nav-text">526. Beautiful Arrangement</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#完美安排，给定1-N的数字，生成一种排列，是第i位的数字能被i整除，或者i能被第i位的数字整除，索引从1开始。原题"><span class="nav-number">14.1.</span> <span class="nav-text">完美安排，给定1~N的数字，生成一种排列，是第i位的数字能被i整除，或者i能被第i位的数字整除，索引从1开始。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-Generate-Parentheses"><span class="nav-number">15.</span> <span class="nav-text">22. Generate Parentheses</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#生成n对合法的括号。原题"><span class="nav-number">15.1.</span> <span class="nav-text">生成n对合法的括号。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#89-Gray-Code"><span class="nav-number">16.</span> <span class="nav-text">89. Gray Code</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#灰码问题。给定一个n表示n位。从0开始每次改变一个位的数字，产生所有的组合。原题"><span class="nav-number">16.1.</span> <span class="nav-text">灰码问题。给定一个n表示n位。从0开始每次改变一个位的数字，产生所有的组合。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#842-Split-Array-into-Fibonacci-Sequence"><span class="nav-number">17.</span> <span class="nav-text">842. Split Array into Fibonacci Sequence</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一串数组组成的字符串拆成斐波那契数列。原题"><span class="nav-number">17.1.</span> <span class="nav-text">一串数组组成的字符串拆成斐波那契数列。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#60-Permutation-Sequence"><span class="nav-number">18.</span> <span class="nav-text">60. Permutation Sequence</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#全排列中的第k个。原题"><span class="nav-number">18.1.</span> <span class="nav-text">全排列中的第k个。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#46-Permutations"><span class="nav-number">19.</span> <span class="nav-text">46. Permutations</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数组全排列。原题"><span class="nav-number">19.1.</span> <span class="nav-text">数组全排列。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#47-Permutations-II"><span class="nav-number">20.</span> <span class="nav-text">47. Permutations II</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#全排列并去重。原题"><span class="nav-number">20.1.</span> <span class="nav-text">全排列并去重。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1079-Letter-Tile-Possibilities"><span class="nav-number">21.</span> <span class="nav-text">1079. Letter Tile Possibilities</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#本来是一道回溯的题，结果测试用例过于简单，所以暴力法就解出来了。原题"><span class="nav-number">21.1.</span> <span class="nav-text">本来是一道回溯的题，结果测试用例过于简单，所以暴力法就解出来了。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1415-The-k-th-Lexicographical-String-of-All-Happy-Strings-of-Length-n"><span class="nav-number">22.</span> <span class="nav-text">1415. The k-th Lexicographical String of All Happy Strings of Length n</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#列出第k个快乐字符串（a-b-c）组成并没有连续相同的字母。原题"><span class="nav-number">22.1.</span> <span class="nav-text">列出第k个快乐字符串（a,b,c）组成并没有连续相同的字母。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1255-Maximum-Score-Words-Formed-by-Letters"><span class="nav-number">23.</span> <span class="nav-text">1255. Maximum Score Words Formed by Letters</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#给定一些单词，每个字母有得分，不过每个字母用多少是有限制的。问最大得分是多少，一个典型的背包问题。原题"><span class="nav-number">23.1.</span> <span class="nav-text">给定一些单词，每个字母有得分，不过每个字母用多少是有限制的。问最大得分是多少，一个典型的背包问题。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1239-Maximum-Length-of-a-Concatenated-String-with-Unique-Characters"><span class="nav-number">24.</span> <span class="nav-text">1239. Maximum Length of a Concatenated String with Unique Characters</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#最长的不重复的字符串组合。原题"><span class="nav-number">24.1.</span> <span class="nav-text">最长的不重复的字符串组合。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#51-N-Queens"><span class="nav-number">25.</span> <span class="nav-text">51. N-Queens</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#著名的N皇后问题，将N个皇后摆在N-N的棋盘中，直线，斜线不能同时存在2个皇后。问所有的摆放位置。原题"><span class="nav-number">25.1.</span> <span class="nav-text">著名的N皇后问题，将N个皇后摆在N*N的棋盘中，直线，斜线不能同时存在2个皇后。问所有的摆放位置。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#52-N-Queens-II"><span class="nav-number">26.</span> <span class="nav-text">52. N-Queens II</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#和上边一样的N皇后问题，要求最后有多少种。原题"><span class="nav-number">26.1.</span> <span class="nav-text">和上边一样的N皇后问题，要求最后有多少种。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#37-Sudoku-Solver"><span class="nav-number">27.</span> <span class="nav-text">37. Sudoku Solver</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解9-9的数独。原题"><span class="nav-number">27.1.</span> <span class="nav-text">解9*9的数独。原题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#980-Unique-Paths-III"><span class="nav-number">28.</span> <span class="nav-text">980. Unique Paths III</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#二维数组中有0，1，2，-1四种格子，要求从1开始走到2，经过所有的0，一共有多少种走法。"><span class="nav-number">28.1.</span> <span class="nav-text">二维数组中有0，1，2，-1四种格子，要求从1开始走到2，经过所有的0，一共有多少种走法。</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xiaoliji</span>
</div>
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_pv">
  本站访客数:<span id="busuanzi_value_site_pv"></span>
</span>
</div>
<div class="powered-by">

  Powered by <a class="theme-link" href="https://hexo.io" rel="texternal nofollow">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next" rel="texternal nofollow">
    NexT.Mist
  </a>
</div>


<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共171.6k字</span>
</div>
        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  

    
      <script id="dsq-count-scr" src="https://.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://darktiantian.github.io.git/LeetCode算法题整理（回溯篇）BackTracking/';
          this.page.identifier = 'LeetCode算法题整理（回溯篇）BackTracking/';
          this.page.title = 'LeetCode算法题整理（回溯篇）BackTracking';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("MuBXc6gVka7X95yN3qhh8Akg-gzGzoHsz", "flbiG5OQDhWpAaCRLDETaoPF");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  

</body>
</html>
